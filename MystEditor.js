var K$ = Object.defineProperty;
var e2 = (t, e, n) => e in t ? K$(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var lo = (t, e, n) => (e2(t, typeof e != "symbol" ? e + "" : e, n), n);
var Zl, Y, Rw, ii, mO, Zw, id, Iw, zo = {}, Lw = [], t2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Ah = Array.isArray;
function rr(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function Nw(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}
function dn(t, e, n) {
  var r, i, s, o = {};
  for (s in e)
    s == "key" ? r = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? Zl.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null)
    for (s in t.defaultProps)
      o[s] === void 0 && (o[s] = t.defaultProps[s]);
  return Eo(t, o, r, i, null);
}
function Eo(t, e, n, r, i) {
  var s = { type: t, props: e, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: i == null ? ++Rw : i, __i: -1, __u: 0 };
  return i == null && Y.vnode != null && Y.vnode(s), s;
}
function n2() {
  return { current: null };
}
function cr(t) {
  return t.children;
}
function Nn(t, e) {
  this.props = t, this.context = e;
}
function ms(t, e) {
  if (e == null)
    return t.__ ? ms(t.__, t.__i + 1) : null;
  for (var n; e < t.__k.length; e++)
    if ((n = t.__k[e]) != null && n.__e != null)
      return n.__e;
  return typeof t.type == "function" ? ms(t) : null;
}
function qw(t) {
  var e, n;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
      if ((n = t.__k[e]) != null && n.__e != null) {
        t.__e = t.__c.base = n.__e;
        break;
      }
    return qw(t);
  }
}
function sd(t) {
  (!t.__d && (t.__d = !0) && ii.push(t) && !Ac.__r++ || mO !== Y.debounceRendering) && ((mO = Y.debounceRendering) || Zw)(Ac);
}
function Ac() {
  var t, e, n, r, i, s, o, l, a;
  for (ii.sort(id); t = ii.shift(); )
    t.__d && (e = ii.length, r = void 0, s = (i = (n = t).__v).__e, l = [], a = [], (o = n.__P) && ((r = rr({}, i)).__v = i.__v + 1, Y.vnode && Y.vnode(r), ng(o, r, i, n.__n, o.ownerSVGElement !== void 0, 32 & i.__u ? [s] : null, l, s == null ? ms(i) : s, !!(32 & i.__u), a), r.__.__k[r.__i] = r, jw(l, r, a), r.__e != s && qw(r)), ii.length > e && ii.sort(id));
  Ac.__r = 0;
}
function Bw(t, e, n, r, i, s, o, l, a, c, h) {
  var u, f, d, p, g, m = r && r.__k || Lw, O = e.length;
  for (n.__d = a, r2(n, e, m), a = n.__d, u = 0; u < O; u++)
    (d = n.__k[u]) != null && typeof d != "boolean" && typeof d != "function" && (f = d.__i === -1 ? zo : m[d.__i] || zo, d.__i = u, ng(t, d, f, i, s, o, l, a, c, h), p = d.__e, d.ref && f.ref != d.ref && (f.ref && rg(f.ref, null, d), h.push(d.ref, d.__c || p, d)), g == null && p != null && (g = p), 65536 & d.__u || f.__k === d.__k ? a = Yw(d, a, t) : typeof d.type == "function" && d.__d !== void 0 ? a = d.__d : p && (a = p.nextSibling), d.__d = void 0, d.__u &= -196609);
  n.__d = a, n.__e = g;
}
function r2(t, e, n) {
  var r, i, s, o, l, a = e.length, c = n.length, h = c, u = 0;
  for (t.__k = [], r = 0; r < a; r++)
    (i = t.__k[r] = (i = e[r]) == null || typeof i == "boolean" || typeof i == "function" ? null : typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? Eo(null, i, null, null, i) : Ah(i) ? Eo(cr, { children: i }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? Eo(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) != null ? (i.__ = t, i.__b = t.__b + 1, l = i2(i, n, o = r + u, h), i.__i = l, s = null, l !== -1 && (h--, (s = n[l]) && (s.__u |= 131072)), s == null || s.__v === null ? (l == -1 && u--, typeof i.type != "function" && (i.__u |= 65536)) : l !== o && (l === o + 1 ? u++ : l > o ? h > a - o ? u += l - o : u-- : u = l < o && l == o - 1 ? l - o : 0, l !== r + u && (i.__u |= 65536))) : (s = n[r]) && s.key == null && s.__e && (s.__e == t.__d && (t.__d = ms(s)), od(s, s, !1), n[r] = null, h--);
  if (h)
    for (r = 0; r < c; r++)
      (s = n[r]) != null && (131072 & s.__u) == 0 && (s.__e == t.__d && (t.__d = ms(s)), od(s, s));
}
function Yw(t, e, n) {
  var r, i;
  if (typeof t.type == "function") {
    for (r = t.__k, i = 0; r && i < r.length; i++)
      r[i] && (r[i].__ = t, e = Yw(r[i], e, n));
    return e;
  }
  return t.__e != e && (n.insertBefore(t.__e, e || null), e = t.__e), e && e.nextSibling;
}
function ir(t, e) {
  return e = e || [], t == null || typeof t == "boolean" || (Ah(t) ? t.some(function(n) {
    ir(n, e);
  }) : e.push(t)), e;
}
function i2(t, e, n, r) {
  var i = t.key, s = t.type, o = n - 1, l = n + 1, a = e[n];
  if (a === null || a && i == a.key && s === a.type)
    return n;
  if (r > (a != null && (131072 & a.__u) == 0 ? 1 : 0))
    for (; o >= 0 || l < e.length; ) {
      if (o >= 0) {
        if ((a = e[o]) && (131072 & a.__u) == 0 && i == a.key && s === a.type)
          return o;
        o--;
      }
      if (l < e.length) {
        if ((a = e[l]) && (131072 & a.__u) == 0 && i == a.key && s === a.type)
          return l;
        l++;
      }
    }
  return -1;
}
function OO(t, e, n) {
  e[0] === "-" ? t.setProperty(e, n == null ? "" : n) : t[e] = n == null ? "" : typeof n != "number" || t2.test(e) ? n : n + "px";
}
function la(t, e, n, r, i) {
  var s;
  e:
    if (e === "style")
      if (typeof n == "string")
        t.style.cssText = n;
      else {
        if (typeof r == "string" && (t.style.cssText = r = ""), r)
          for (e in r)
            n && e in n || OO(t.style, e, "");
        if (n)
          for (e in n)
            r && n[e] === r[e] || OO(t.style, e, n[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      s = e !== (e = e.replace(/(PointerCapture)$|Capture$/, "$1")), e = e.toLowerCase() in t ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = n, n ? r ? n.u = r.u : (n.u = Date.now(), t.addEventListener(e, s ? yO : bO, s)) : t.removeEventListener(e, s ? yO : bO, s);
    else {
      if (i)
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e !== "width" && e !== "height" && e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e !== "rowSpan" && e !== "colSpan" && e !== "role" && e in t)
        try {
          t[e] = n == null ? "" : n;
          break e;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, n));
    }
}
function bO(t) {
  var e = this.l[t.type + !1];
  if (t.t) {
    if (t.t <= e.u)
      return;
  } else
    t.t = Date.now();
  return e(Y.event ? Y.event(t) : t);
}
function yO(t) {
  return this.l[t.type + !0](Y.event ? Y.event(t) : t);
}
function ng(t, e, n, r, i, s, o, l, a, c) {
  var h, u, f, d, p, g, m, O, b, y, w, S, x, v, P, D = e.type;
  if (e.constructor !== void 0)
    return null;
  128 & n.__u && (a = !!(32 & n.__u), s = [l = e.__e = n.__e]), (h = Y.__b) && h(e);
  e:
    if (typeof D == "function")
      try {
        if (O = e.props, b = (h = D.contextType) && r[h.__c], y = h ? b ? b.props.value : h.__ : r, n.__c ? m = (u = e.__c = n.__c).__ = u.__E : ("prototype" in D && D.prototype.render ? e.__c = u = new D(O, y) : (e.__c = u = new Nn(O, y), u.constructor = D, u.render = o2), b && b.sub(u), u.props = O, u.state || (u.state = {}), u.context = y, u.__n = r, f = u.__d = !0, u.__h = [], u._sb = []), u.__s == null && (u.__s = u.state), D.getDerivedStateFromProps != null && (u.__s == u.state && (u.__s = rr({}, u.__s)), rr(u.__s, D.getDerivedStateFromProps(O, u.__s))), d = u.props, p = u.state, u.__v = e, f)
          D.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), u.componentDidMount != null && u.__h.push(u.componentDidMount);
        else {
          if (D.getDerivedStateFromProps == null && O !== d && u.componentWillReceiveProps != null && u.componentWillReceiveProps(O, y), !u.__e && (u.shouldComponentUpdate != null && u.shouldComponentUpdate(O, u.__s, y) === !1 || e.__v === n.__v)) {
            for (e.__v !== n.__v && (u.props = O, u.state = u.__s, u.__d = !1), e.__e = n.__e, e.__k = n.__k, e.__k.forEach(function(Q) {
              Q && (Q.__ = e);
            }), w = 0; w < u._sb.length; w++)
              u.__h.push(u._sb[w]);
            u._sb = [], u.__h.length && o.push(u);
            break e;
          }
          u.componentWillUpdate != null && u.componentWillUpdate(O, u.__s, y), u.componentDidUpdate != null && u.__h.push(function() {
            u.componentDidUpdate(d, p, g);
          });
        }
        if (u.context = y, u.props = O, u.__P = t, u.__e = !1, S = Y.__r, x = 0, "prototype" in D && D.prototype.render) {
          for (u.state = u.__s, u.__d = !1, S && S(e), h = u.render(u.props, u.state, u.context), v = 0; v < u._sb.length; v++)
            u.__h.push(u._sb[v]);
          u._sb = [];
        } else
          do
            u.__d = !1, S && S(e), h = u.render(u.props, u.state, u.context), u.state = u.__s;
          while (u.__d && ++x < 25);
        u.state = u.__s, u.getChildContext != null && (r = rr(rr({}, r), u.getChildContext())), f || u.getSnapshotBeforeUpdate == null || (g = u.getSnapshotBeforeUpdate(d, p)), Bw(t, Ah(P = h != null && h.type === cr && h.key == null ? h.props.children : h) ? P : [P], e, n, r, i, s, o, l, a, c), u.base = e.__e, e.__u &= -161, u.__h.length && o.push(u), m && (u.__E = u.__ = null);
      } catch (Q) {
        e.__v = null, a || s != null ? (e.__e = l, e.__u |= a ? 160 : 32, s[s.indexOf(l)] = null) : (e.__e = n.__e, e.__k = n.__k), Y.__e(Q, e, n);
      }
    else
      s == null && e.__v === n.__v ? (e.__k = n.__k, e.__e = n.__e) : e.__e = s2(n.__e, e, n, r, i, s, o, a, c);
  (h = Y.diffed) && h(e);
}
function jw(t, e, n) {
  e.__d = void 0;
  for (var r = 0; r < n.length; r++)
    rg(n[r], n[++r], n[++r]);
  Y.__c && Y.__c(e, t), t.some(function(i) {
    try {
      t = i.__h, i.__h = [], t.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Y.__e(s, i.__v);
    }
  });
}
function s2(t, e, n, r, i, s, o, l, a) {
  var c, h, u, f, d, p, g, m = n.props, O = e.props, b = e.type;
  if (b === "svg" && (i = !0), s != null) {
    for (c = 0; c < s.length; c++)
      if ((d = s[c]) && "setAttribute" in d == !!b && (b ? d.localName === b : d.nodeType === 3)) {
        t = d, s[c] = null;
        break;
      }
  }
  if (t == null) {
    if (b === null)
      return document.createTextNode(O);
    t = i ? document.createElementNS("http://www.w3.org/2000/svg", b) : document.createElement(b, O.is && O), s = null, l = !1;
  }
  if (b === null)
    m === O || l && t.data === O || (t.data = O);
  else {
    if (s = s && Zl.call(t.childNodes), m = n.props || zo, !l && s != null)
      for (m = {}, c = 0; c < t.attributes.length; c++)
        m[(d = t.attributes[c]).name] = d.value;
    for (c in m)
      d = m[c], c == "children" || (c == "dangerouslySetInnerHTML" ? u = d : c === "key" || c in O || la(t, c, null, d, i));
    for (c in O)
      d = O[c], c == "children" ? f = d : c == "dangerouslySetInnerHTML" ? h = d : c == "value" ? p = d : c == "checked" ? g = d : c === "key" || l && typeof d != "function" || m[c] === d || la(t, c, d, m[c], i);
    if (h)
      l || u && (h.__html === u.__html || h.__html === t.innerHTML) || (t.innerHTML = h.__html), e.__k = [];
    else if (u && (t.innerHTML = ""), Bw(t, Ah(f) ? f : [f], e, n, r, i && b !== "foreignObject", s, o, s ? s[0] : n.__k && ms(n, 0), l, a), s != null)
      for (c = s.length; c--; )
        s[c] != null && Nw(s[c]);
    l || (c = "value", p !== void 0 && (p !== t[c] || b === "progress" && !p || b === "option" && p !== m[c]) && la(t, c, p, m[c], !1), c = "checked", g !== void 0 && g !== t[c] && la(t, c, g, m[c], !1));
  }
  return t;
}
function rg(t, e, n) {
  try {
    typeof t == "function" ? t(e) : t.current = e;
  } catch (r) {
    Y.__e(r, n);
  }
}
function od(t, e, n) {
  var r, i;
  if (Y.unmount && Y.unmount(t), (r = t.ref) && (r.current && r.current !== t.__e || rg(r, null, e)), (r = t.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (s) {
        Y.__e(s, e);
      }
    r.base = r.__P = null, t.__c = void 0;
  }
  if (r = t.__k)
    for (i = 0; i < r.length; i++)
      r[i] && od(r[i], e, n || typeof t.type != "function");
  n || t.__e == null || Nw(t.__e), t.__ = t.__e = t.__d = void 0;
}
function o2(t, e, n) {
  return this.constructor(t, n);
}
function Vo(t, e, n) {
  var r, i, s, o;
  Y.__ && Y.__(t, e), i = (r = typeof n == "function") ? null : n && n.__k || e.__k, s = [], o = [], ng(e, t = (!r && n || e).__k = dn(cr, null, [t]), i || zo, zo, e.ownerSVGElement !== void 0, !r && n ? [n] : i ? null : e.firstChild ? Zl.call(e.childNodes) : null, s, !r && n ? n : i ? i.__e : e.firstChild, r, o), jw(s, t, o);
}
function Xw(t, e) {
  Vo(t, e, Xw);
}
function l2(t, e, n) {
  var r, i, s, o, l = rr({}, t.props);
  for (s in t.type && t.type.defaultProps && (o = t.type.defaultProps), e)
    s == "key" ? r = e[s] : s == "ref" ? i = e[s] : l[s] = e[s] === void 0 && o !== void 0 ? o[s] : e[s];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? Zl.call(arguments, 2) : n), Eo(t.type, l, r || t.key, i || t.ref, null);
}
function a2(t, e) {
  var n = { __c: e = "__cC" + Iw++, __: t, Consumer: function(r, i) {
    return r.children(i);
  }, Provider: function(r) {
    var i, s;
    return this.getChildContext || (i = [], (s = {})[e] = this, this.getChildContext = function() {
      return s;
    }, this.shouldComponentUpdate = function(o) {
      this.props.value !== o.value && i.some(function(l) {
        l.__e = !0, sd(l);
      });
    }, this.sub = function(o) {
      i.push(o);
      var l = o.componentWillUnmount;
      o.componentWillUnmount = function() {
        i.splice(i.indexOf(o), 1), l && l.call(o);
      };
    }), r.children;
  } };
  return n.Provider.__ = n.Consumer.contextType = n;
}
Zl = Lw.slice, Y = { __e: function(t, e, n, r) {
  for (var i, s, o; e = e.__; )
    if ((i = e.__c) && !i.__)
      try {
        if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, r || {}), o = i.__d), o)
          return i.__E = i;
      } catch (l) {
        t = l;
      }
  throw t;
} }, Rw = 0, Nn.prototype.setState = function(t, e) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = rr({}, this.state), typeof t == "function" && (t = t(rr({}, n), this.props)), t && rr(n, t), t != null && this.__v && (e && this._sb.push(e), sd(this));
}, Nn.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), sd(this));
}, Nn.prototype.render = cr, ii = [], Zw = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, id = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, Ac.__r = 0, Iw = 0;
var Nr, Ae, Tu, wO, Os = 0, Ww = [], Ja = [], kO = Y.__b, xO = Y.__r, vO = Y.diffed, SO = Y.__c, _O = Y.unmount;
function Ys(t, e) {
  Y.__h && Y.__h(Ae, t, Os || e), Os = 0;
  var n = Ae.__H || (Ae.__H = { __: [], __h: [] });
  return t >= n.__.length && n.__.push({ __V: Ja }), n.__[t];
}
function Ee(t) {
  return Os = 1, $h(Vw, t);
}
function $h(t, e, n) {
  var r = Ys(Nr++, 2);
  if (r.t = t, !r.__c && (r.__ = [n ? n(e) : Vw(void 0, e), function(l) {
    var a = r.__N ? r.__N[0] : r.__[0], c = r.t(a, l);
    a !== c && (r.__N = [c, r.__[1]], r.__c.setState({}));
  }], r.__c = Ae, !Ae.u)) {
    var i = function(l, a, c) {
      if (!r.__c.__H)
        return !0;
      var h = r.__c.__H.__.filter(function(f) {
        return f.__c;
      });
      if (h.every(function(f) {
        return !f.__N;
      }))
        return !s || s.call(this, l, a, c);
      var u = !1;
      return h.forEach(function(f) {
        if (f.__N) {
          var d = f.__[0];
          f.__ = f.__N, f.__N = void 0, d !== f.__[0] && (u = !0);
        }
      }), !(!u && r.__c.props === l) && (!s || s.call(this, l, a, c));
    };
    Ae.u = !0;
    var s = Ae.shouldComponentUpdate, o = Ae.componentWillUpdate;
    Ae.componentWillUpdate = function(l, a, c) {
      if (this.__e) {
        var h = s;
        s = void 0, i(l, a, c), s = h;
      }
      o && o.call(this, l, a, c);
    }, Ae.shouldComponentUpdate = i;
  }
  return r.__N || r.__;
}
function Ke(t, e) {
  var n = Ys(Nr++, 3);
  !Y.__s && sg(n.__H, e) && (n.__ = t, n.i = e, Ae.__H.__h.push(n));
}
function Ph(t, e) {
  var n = Ys(Nr++, 4);
  !Y.__s && sg(n.__H, e) && (n.__ = t, n.i = e, Ae.__h.push(n));
}
function hn(t) {
  return Os = 5, Le(function() {
    return { current: t };
  }, []);
}
function c2(t, e, n) {
  Os = 6, Ph(function() {
    return typeof t == "function" ? (t(e()), function() {
      return t(null);
    }) : t ? (t.current = e(), function() {
      return t.current = null;
    }) : void 0;
  }, n == null ? n : n.concat(t));
}
function Le(t, e) {
  var n = Ys(Nr++, 7);
  return sg(n.__H, e) ? (n.__V = t(), n.i = e, n.__h = t, n.__V) : n.__;
}
function ig(t, e) {
  return Os = 8, Le(function() {
    return t;
  }, e);
}
function zw(t) {
  var e = Ae.context[t.__c], n = Ys(Nr++, 9);
  return n.c = t, e ? (n.__ == null && (n.__ = !0, e.sub(Ae)), e.props.value) : t.__;
}
function ld(t, e) {
  Y.useDebugValue && Y.useDebugValue(e ? e(t) : t);
}
function h2() {
  var t = Ys(Nr++, 11);
  if (!t.__) {
    for (var e = Ae.__v; e !== null && !e.__m && e.__ !== null; )
      e = e.__;
    var n = e.__m || (e.__m = [0, 0]);
    t.__ = "P" + n[0] + "-" + n[1]++;
  }
  return t.__;
}
function u2() {
  for (var t; t = Ww.shift(); )
    if (t.__P && t.__H)
      try {
        t.__H.__h.forEach(Ka), t.__H.__h.forEach(ad), t.__H.__h = [];
      } catch (e) {
        t.__H.__h = [], Y.__e(e, t.__v);
      }
}
Y.__b = function(t) {
  Ae = null, kO && kO(t);
}, Y.__r = function(t) {
  xO && xO(t), Nr = 0;
  var e = (Ae = t.__c).__H;
  e && (Tu === Ae ? (e.__h = [], Ae.__h = [], e.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = Ja, n.__N = n.i = void 0;
  })) : (e.__h.forEach(Ka), e.__h.forEach(ad), e.__h = [], Nr = 0)), Tu = Ae;
}, Y.diffed = function(t) {
  vO && vO(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (Ww.push(e) !== 1 && wO === Y.requestAnimationFrame || ((wO = Y.requestAnimationFrame) || f2)(u2)), e.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== Ja && (n.__ = n.__V), n.i = void 0, n.__V = Ja;
  })), Tu = Ae = null;
}, Y.__c = function(t, e) {
  e.some(function(n) {
    try {
      n.__h.forEach(Ka), n.__h = n.__h.filter(function(r) {
        return !r.__ || ad(r);
      });
    } catch (r) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], Y.__e(r, n.__v);
    }
  }), SO && SO(t, e);
}, Y.unmount = function(t) {
  _O && _O(t);
  var e, n = t.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      Ka(r);
    } catch (i) {
      e = i;
    }
  }), n.__H = void 0, e && Y.__e(e, n.__v));
};
var CO = typeof requestAnimationFrame == "function";
function f2(t) {
  var e, n = function() {
    clearTimeout(r), CO && cancelAnimationFrame(e), setTimeout(t);
  }, r = setTimeout(n, 100);
  CO && (e = requestAnimationFrame(n));
}
function Ka(t) {
  var e = Ae, n = t.__c;
  typeof n == "function" && (t.__c = void 0, n()), Ae = e;
}
function ad(t) {
  var e = Ae;
  t.__c = t.__(), Ae = e;
}
function sg(t, e) {
  return !t || t.length !== e.length || e.some(function(n, r) {
    return n !== t[r];
  });
}
function Vw(t, e) {
  return typeof e == "function" ? e(t) : e;
}
var Uw = function(t, e, n, r) {
  var i;
  e[0] = 0;
  for (var s = 1; s < e.length; s++) {
    var o = e[s++], l = e[s] ? (e[0] |= o ? 1 : 2, n[e[s++]]) : e[++s];
    o === 3 ? r[0] = l : o === 4 ? r[1] = Object.assign(r[1] || {}, l) : o === 5 ? (r[1] = r[1] || {})[e[++s]] = l : o === 6 ? r[1][e[++s]] += l + "" : o ? (i = t.apply(l, Uw(t, l, n, ["", null])), r.push(i), l[0] ? e[0] |= 2 : (e[s - 2] = 0, e[s] = i)) : r.push(l);
  }
  return r;
}, AO = /* @__PURE__ */ new Map();
function d2(t) {
  var e = AO.get(this);
  return e || (e = /* @__PURE__ */ new Map(), AO.set(this, e)), (e = Uw(this, e.get(t) || (e.set(t, e = function(n) {
    for (var r, i, s = 1, o = "", l = "", a = [0], c = function(f) {
      s === 1 && (f || (o = o.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? a.push(0, f, o) : s === 3 && (f || o) ? (a.push(3, f, o), s = 2) : s === 2 && o === "..." && f ? a.push(4, f, 0) : s === 2 && o && !f ? a.push(5, 0, !0, o) : s >= 5 && ((o || !f && s === 5) && (a.push(s, 0, o, i), s = 6), f && (a.push(s, f, 0, i), s = 6)), o = "";
    }, h = 0; h < n.length; h++) {
      h && (s === 1 && c(), c(h));
      for (var u = 0; u < n[h].length; u++)
        r = n[h][u], s === 1 ? r === "<" ? (c(), a = [a], s = 3) : o += r : s === 4 ? o === "--" && r === ">" ? (s = 1, o = "") : o = r + o[0] : l ? r === l ? l = "" : o += r : r === '"' || r === "'" ? l = r : r === ">" ? (c(), s = 1) : s && (r === "=" ? (s = 5, i = o, o = "") : r === "/" && (s < 5 || n[h][u + 1] === ">") ? (c(), s === 3 && (a = a[0]), s = a, (a = a[0]).push(2, 0, s), s = 0) : r === " " || r === "	" || r === `
` || r === "\r" ? (c(), s = 2) : o += r), s === 3 && o === "!--" && (s = 4, a = a[0]);
    }
    return c(), a;
  }(t)), e), arguments, [])).length > 1 ? e : e[0];
}
var j = d2.bind(dn), At = function() {
  return At = Object.assign || function(e) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, At.apply(this, arguments);
};
function bs(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
function p2(t) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var g2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, m2 = /* @__PURE__ */ p2(
  function(t) {
    return g2.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }
);
function Fw(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function cd(t, e) {
  for (var n in t)
    if (n !== "__source" && !(n in e))
      return !0;
  for (var r in e)
    if (r !== "__source" && t[r] !== e[r])
      return !0;
  return !1;
}
function hd(t) {
  this.props = t;
}
function O2(t, e) {
  function n(i) {
    var s = this.props.ref, o = s == i.ref;
    return !o && s && (s.call ? s(null) : s.current = null), e ? !e(this.props, i) || !o : cd(this.props, i);
  }
  function r(i) {
    return this.shouldComponentUpdate = n, dn(t, i);
  }
  return r.displayName = "Memo(" + (t.displayName || t.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
}
(hd.prototype = new Nn()).isPureReactComponent = !0, hd.prototype.shouldComponentUpdate = function(t, e) {
  return cd(this.props, t) || cd(this.state, e);
};
var $O = Y.__b;
Y.__b = function(t) {
  t.type && t.type.__f && t.ref && (t.props.ref = t.ref, t.ref = null), $O && $O(t);
};
var b2 = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function y2(t) {
  function e(n) {
    var r = Fw({}, n);
    return delete r.ref, t(r, n.ref || null);
  }
  return e.$$typeof = b2, e.render = e, e.prototype.isReactComponent = e.__f = !0, e.displayName = "ForwardRef(" + (t.displayName || t.name) + ")", e;
}
var PO = function(t, e) {
  return t == null ? null : ir(ir(t).map(e));
}, w2 = { map: PO, forEach: PO, count: function(t) {
  return t ? ir(t).length : 0;
}, only: function(t) {
  var e = ir(t);
  if (e.length !== 1)
    throw "Children.only";
  return e[0];
}, toArray: ir }, k2 = Y.__e;
Y.__e = function(t, e, n, r) {
  if (t.then) {
    for (var i, s = e; s = s.__; )
      if ((i = s.__c) && i.__c)
        return e.__e == null && (e.__e = n.__e, e.__k = n.__k), i.__c(t, e);
  }
  k2(t, e, n, r);
};
var TO = Y.unmount;
function Gw(t, e, n) {
  return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function(r) {
    typeof r.__c == "function" && r.__c();
  }), t.__c.__H = null), (t = Fw({}, t)).__c != null && (t.__c.__P === n && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function(r) {
    return Gw(r, e, n);
  })), t;
}
function Hw(t, e, n) {
  return t && n && (t.__v = null, t.__k = t.__k && t.__k.map(function(r) {
    return Hw(r, e, n);
  }), t.__c && t.__c.__P === e && (t.__e && n.appendChild(t.__e), t.__c.__e = !0, t.__c.__P = n)), t;
}
function ec() {
  this.__u = 0, this.t = null, this.__b = null;
}
function Jw(t) {
  var e = t.__.__c;
  return e && e.__a && e.__a(t);
}
function x2(t) {
  var e, n, r;
  function i(s) {
    if (e || (e = t()).then(function(o) {
      n = o.default || o;
    }, function(o) {
      r = o;
    }), r)
      throw r;
    if (!n)
      throw e;
    return dn(n, s);
  }
  return i.displayName = "Lazy", i.__f = !0, i;
}
function ko() {
  this.u = null, this.o = null;
}
Y.unmount = function(t) {
  var e = t.__c;
  e && e.__R && e.__R(), e && 32 & t.__u && (t.type = null), TO && TO(t);
}, (ec.prototype = new Nn()).__c = function(t, e) {
  var n = e.__c, r = this;
  r.t == null && (r.t = []), r.t.push(n);
  var i = Jw(r.__v), s = !1, o = function() {
    s || (s = !0, n.__R = null, i ? i(l) : l());
  };
  n.__R = o;
  var l = function() {
    if (!--r.__u) {
      if (r.state.__a) {
        var a = r.state.__a;
        r.__v.__k[0] = Hw(a, a.__c.__P, a.__c.__O);
      }
      var c;
      for (r.setState({ __a: r.__b = null }); c = r.t.pop(); )
        c.forceUpdate();
    }
  };
  r.__u++ || 32 & e.__u || r.setState({ __a: r.__b = r.__v.__k[0] }), t.then(o, o);
}, ec.prototype.componentWillUnmount = function() {
  this.t = [];
}, ec.prototype.render = function(t, e) {
  if (this.__b) {
    if (this.__v.__k) {
      var n = document.createElement("div"), r = this.__v.__k[0].__c;
      this.__v.__k[0] = Gw(this.__b, n, r.__O = r.__P);
    }
    this.__b = null;
  }
  var i = e.__a && dn(cr, null, t.fallback);
  return i && (i.__u &= -33), [dn(cr, null, e.__a ? null : t.children), i];
};
var QO = function(t, e, n) {
  if (++n[1] === n[0] && t.o.delete(e), t.props.revealOrder && (t.props.revealOrder[0] !== "t" || !t.o.size))
    for (n = t.u; n; ) {
      for (; n.length > 3; )
        n.pop()();
      if (n[1] < n[0])
        break;
      t.u = n = n[2];
    }
};
function v2(t) {
  return this.getChildContext = function() {
    return t.context;
  }, t.children;
}
function S2(t) {
  var e = this, n = t.i;
  e.componentWillUnmount = function() {
    Vo(null, e.l), e.l = null, e.i = null;
  }, e.i && e.i !== n && e.componentWillUnmount(), e.l || (e.i = n, e.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function(r) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, insertBefore: function(r, i) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, removeChild: function(r) {
    this.childNodes.splice(this.childNodes.indexOf(r) >>> 1, 1), e.i.removeChild(r);
  } }), Vo(dn(v2, { context: e.context }, t.__v), e.l);
}
function _2(t, e) {
  var n = dn(S2, { __v: t, i: e });
  return n.containerInfo = e, n;
}
(ko.prototype = new Nn()).__a = function(t) {
  var e = this, n = Jw(e.__v), r = e.o.get(t);
  return r[0]++, function(i) {
    var s = function() {
      e.props.revealOrder ? (r.push(i), QO(e, t, r)) : i();
    };
    n ? n(s) : s();
  };
}, ko.prototype.render = function(t) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var e = ir(t.children);
  t.revealOrder && t.revealOrder[0] === "b" && e.reverse();
  for (var n = e.length; n--; )
    this.o.set(e[n], this.u = [1, 0, this.u]);
  return t.children;
}, ko.prototype.componentDidUpdate = ko.prototype.componentDidMount = function() {
  var t = this;
  this.o.forEach(function(e, n) {
    QO(t, n, e);
  });
};
var Kw = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, C2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, A2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, $2 = /[A-Z0-9]/g, P2 = typeof document < "u", T2 = function(t) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(t);
};
function Q2(t, e, n) {
  return e.__k == null && (e.textContent = ""), Vo(t, e), typeof n == "function" && n(), t ? t.__c : null;
}
function E2(t, e, n) {
  return Xw(t, e), typeof n == "function" && n(), t ? t.__c : null;
}
Nn.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t) {
  Object.defineProperty(Nn.prototype, t, { configurable: !0, get: function() {
    return this["UNSAFE_" + t];
  }, set: function(e) {
    Object.defineProperty(this, t, { configurable: !0, writable: !0, value: e });
  } });
});
var EO = Y.event;
function D2() {
}
function M2() {
  return this.cancelBubble;
}
function R2() {
  return this.defaultPrevented;
}
Y.event = function(t) {
  return EO && (t = EO(t)), t.persist = D2, t.isPropagationStopped = M2, t.isDefaultPrevented = R2, t.nativeEvent = t;
};
var og, Z2 = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, DO = Y.vnode;
Y.vnode = function(t) {
  typeof t.type == "string" && function(e) {
    var n = e.props, r = e.type, i = {};
    for (var s in n) {
      var o = n[s];
      if (!(s === "value" && "defaultValue" in n && o == null || P2 && s === "children" && r === "noscript" || s === "class" || s === "className")) {
        var l = s.toLowerCase();
        s === "defaultValue" && "value" in n && n.value == null ? s = "value" : s === "download" && o === !0 ? o = "" : l === "ondoubleclick" ? s = "ondblclick" : l !== "onchange" || r !== "input" && r !== "textarea" || T2(n.type) ? l === "onfocus" ? s = "onfocusin" : l === "onblur" ? s = "onfocusout" : A2.test(s) ? s = l : r.indexOf("-") === -1 && C2.test(s) ? s = s.replace($2, "-$&").toLowerCase() : o === null && (o = void 0) : l = s = "oninput", l === "oninput" && i[s = l] && (s = "oninputCapture"), i[s] = o;
      }
    }
    r == "select" && i.multiple && Array.isArray(i.value) && (i.value = ir(n.children).forEach(function(a) {
      a.props.selected = i.value.indexOf(a.props.value) != -1;
    })), r == "select" && i.defaultValue != null && (i.value = ir(n.children).forEach(function(a) {
      a.props.selected = i.multiple ? i.defaultValue.indexOf(a.props.value) != -1 : i.defaultValue == a.props.value;
    })), n.class && !n.className ? (i.class = n.class, Object.defineProperty(i, "className", Z2)) : (n.className && !n.class || n.class && n.className) && (i.class = i.className = n.className), e.props = i;
  }(t), t.$$typeof = Kw, DO && DO(t);
};
var MO = Y.__r;
Y.__r = function(t) {
  MO && MO(t), og = t.__c;
};
var RO = Y.diffed;
Y.diffed = function(t) {
  RO && RO(t);
  var e = t.props, n = t.__e;
  n != null && t.type === "textarea" && "value" in e && e.value !== n.value && (n.value = e.value == null ? "" : e.value), og = null;
};
var I2 = { ReactCurrentDispatcher: { current: { readContext: function(t) {
  return og.__n[t.__c].props.value;
} } } };
function L2(t) {
  return dn.bind(null, t);
}
function Th(t) {
  return !!t && t.$$typeof === Kw;
}
function N2(t) {
  return Th(t) && t.type === cr;
}
function q2(t) {
  return Th(t) ? l2.apply(null, arguments) : t;
}
function B2(t) {
  return !!t.__k && (Vo(null, t), !0);
}
function Y2(t) {
  return t && (t.base || t.nodeType === 1 && t) || null;
}
var j2 = function(t, e) {
  return t(e);
}, X2 = function(t, e) {
  return t(e);
}, W2 = cr;
function ek(t) {
  t();
}
function z2(t) {
  return t;
}
function V2() {
  return [!1, ek];
}
var U2 = Ph, F2 = Th;
function G2(t, e) {
  var n = e(), r = Ee({ h: { __: n, v: e } }), i = r[0].h, s = r[1];
  return Ph(function() {
    i.__ = n, i.v = e, Qu(i) && s({ h: i });
  }, [t, n, e]), Ke(function() {
    return Qu(i) && s({ h: i }), t(function() {
      Qu(i) && s({ h: i });
    });
  }, [t]), n;
}
function Qu(t) {
  var e, n, r = t.v, i = t.__;
  try {
    var s = r();
    return !((e = i) === (n = s) && (e !== 0 || 1 / e == 1 / n) || e != e && n != n);
  } catch {
    return !0;
  }
}
var xi = { useState: Ee, useId: h2, useReducer: $h, useEffect: Ke, useLayoutEffect: Ph, useInsertionEffect: U2, useTransition: V2, useDeferredValue: z2, useSyncExternalStore: G2, startTransition: ek, useRef: hn, useImperativeHandle: c2, useMemo: Le, useCallback: ig, useContext: zw, useDebugValue: ld, version: "17.0.2", Children: w2, render: Q2, hydrate: E2, unmountComponentAtNode: B2, createPortal: _2, createElement: dn, createContext: a2, createFactory: L2, cloneElement: q2, createRef: n2, Fragment: cr, isValidElement: Th, isElement: F2, isFragment: N2, findDOMNode: Y2, Component: Nn, PureComponent: hd, memo: O2, forwardRef: y2, flushSync: X2, unstable_batchedUpdates: j2, StrictMode: W2, Suspense: ec, SuspenseList: ko, lazy: x2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: I2 };
function H2(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function tk(t) {
  var e = t.default;
  if (typeof e == "function") {
    var n = function() {
      return e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.keys(t).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var J2 = function(e, n, r, i) {
  var s = r ? r.call(i, e, n) : void 0;
  if (s !== void 0)
    return !!s;
  if (e === n)
    return !0;
  if (typeof e != "object" || !e || typeof n != "object" || !n)
    return !1;
  var o = Object.keys(e), l = Object.keys(n);
  if (o.length !== l.length)
    return !1;
  for (var a = Object.prototype.hasOwnProperty.bind(n), c = 0; c < o.length; c++) {
    var h = o[c];
    if (!a(h))
      return !1;
    var u = e[h], f = n[h];
    if (s = r ? r.call(i, u, f, h) : void 0, s === !1 || s === void 0 && u !== f)
      return !1;
  }
  return !0;
}, _e = "-ms-", Do = "-moz-", de = "-webkit-", nk = "comm", Qh = "rule", lg = "decl", K2 = "@import", rk = "@keyframes", eP = "@layer", tP = Math.abs, ag = String.fromCharCode, ud = Object.assign;
function nP(t, e) {
  return Je(t, 0) ^ 45 ? (((e << 2 ^ Je(t, 0)) << 2 ^ Je(t, 1)) << 2 ^ Je(t, 2)) << 2 ^ Je(t, 3) : 0;
}
function ik(t) {
  return t.trim();
}
function tr(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function ne(t, e, n) {
  return t.replace(e, n);
}
function tc(t, e) {
  return t.indexOf(e);
}
function Je(t, e) {
  return t.charCodeAt(e) | 0;
}
function ys(t, e, n) {
  return t.slice(e, n);
}
function Tn(t) {
  return t.length;
}
function sk(t) {
  return t.length;
}
function xo(t, e) {
  return e.push(t), t;
}
function rP(t, e) {
  return t.map(e).join("");
}
function ZO(t, e) {
  return t.filter(function(n) {
    return !tr(n, e);
  });
}
var Eh = 1, ws = 1, ok = 0, Gt = 0, Be = 0, js = "";
function Dh(t, e, n, r, i, s, o, l) {
  return { value: t, root: e, parent: n, type: r, props: i, children: s, line: Eh, column: ws, length: o, return: "", siblings: l };
}
function kr(t, e) {
  return ud(Dh("", null, null, "", null, null, 0, t.siblings), t, { length: -t.length }, e);
}
function Xi(t) {
  for (; t.root; )
    t = kr(t.root, { children: [t] });
  xo(t, t.siblings);
}
function iP() {
  return Be;
}
function sP() {
  return Be = Gt > 0 ? Je(js, --Gt) : 0, ws--, Be === 10 && (ws = 1, Eh--), Be;
}
function un() {
  return Be = Gt < ok ? Je(js, Gt++) : 0, ws++, Be === 10 && (ws = 1, Eh++), Be;
}
function mi() {
  return Je(js, Gt);
}
function nc() {
  return Gt;
}
function Mh(t, e) {
  return ys(js, t, e);
}
function fd(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function oP(t) {
  return Eh = ws = 1, ok = Tn(js = t), Gt = 0, [];
}
function lP(t) {
  return js = "", t;
}
function Eu(t) {
  return ik(Mh(Gt - 1, dd(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function aP(t) {
  for (; (Be = mi()) && Be < 33; )
    un();
  return fd(t) > 2 || fd(Be) > 3 ? "" : " ";
}
function cP(t, e) {
  for (; --e && un() && !(Be < 48 || Be > 102 || Be > 57 && Be < 65 || Be > 70 && Be < 97); )
    ;
  return Mh(t, nc() + (e < 6 && mi() == 32 && un() == 32));
}
function dd(t) {
  for (; un(); )
    switch (Be) {
      case t:
        return Gt;
      case 34:
      case 39:
        t !== 34 && t !== 39 && dd(Be);
        break;
      case 40:
        t === 41 && dd(t);
        break;
      case 92:
        un();
        break;
    }
  return Gt;
}
function hP(t, e) {
  for (; un() && t + Be !== 47 + 10; )
    if (t + Be === 42 + 42 && mi() === 47)
      break;
  return "/*" + Mh(e, Gt - 1) + "*" + ag(t === 47 ? t : un());
}
function uP(t) {
  for (; !fd(mi()); )
    un();
  return Mh(t, Gt);
}
function fP(t) {
  return lP(rc("", null, null, null, [""], t = oP(t), 0, [0], t));
}
function rc(t, e, n, r, i, s, o, l, a) {
  for (var c = 0, h = 0, u = o, f = 0, d = 0, p = 0, g = 1, m = 1, O = 1, b = 0, y = "", w = i, S = s, x = r, v = y; m; )
    switch (p = b, b = un()) {
      case 40:
        if (p != 108 && Je(v, u - 1) == 58) {
          tc(v += ne(Eu(b), "&", "&\f"), "&\f") != -1 && (O = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        v += Eu(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        v += aP(p);
        break;
      case 92:
        v += cP(nc() - 1, 7);
        continue;
      case 47:
        switch (mi()) {
          case 42:
          case 47:
            xo(dP(hP(un(), nc()), e, n, a), a);
            break;
          default:
            v += "/";
        }
        break;
      case 123 * g:
        l[c++] = Tn(v) * O;
      case 125 * g:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            m = 0;
          case 59 + h:
            O == -1 && (v = ne(v, /\f/g, "")), d > 0 && Tn(v) - u && xo(d > 32 ? LO(v + ";", r, n, u - 1, a) : LO(ne(v, " ", "") + ";", r, n, u - 2, a), a);
            break;
          case 59:
            v += ";";
          default:
            if (xo(x = IO(v, e, n, c, h, i, l, y, w = [], S = [], u, s), s), b === 123)
              if (h === 0)
                rc(v, e, x, x, w, s, u, l, S);
              else
                switch (f === 99 && Je(v, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    rc(t, x, x, r && xo(IO(t, x, x, 0, 0, i, l, y, i, w = [], u, S), S), i, S, u, l, r ? w : S);
                    break;
                  default:
                    rc(v, x, x, x, [""], S, 0, l, S);
                }
        }
        c = h = d = 0, g = O = 1, y = v = "", u = o;
        break;
      case 58:
        u = 1 + Tn(v), d = p;
      default:
        if (g < 1) {
          if (b == 123)
            --g;
          else if (b == 125 && g++ == 0 && sP() == 125)
            continue;
        }
        switch (v += ag(b), b * g) {
          case 38:
            O = h > 0 ? 1 : (v += "\f", -1);
            break;
          case 44:
            l[c++] = (Tn(v) - 1) * O, O = 1;
            break;
          case 64:
            mi() === 45 && (v += Eu(un())), f = mi(), h = u = Tn(y = v += uP(nc())), b++;
            break;
          case 45:
            p === 45 && Tn(v) == 2 && (g = 0);
        }
    }
  return s;
}
function IO(t, e, n, r, i, s, o, l, a, c, h, u) {
  for (var f = i - 1, d = i === 0 ? s : [""], p = sk(d), g = 0, m = 0, O = 0; g < r; ++g)
    for (var b = 0, y = ys(t, f + 1, f = tP(m = o[g])), w = t; b < p; ++b)
      (w = ik(m > 0 ? d[b] + " " + y : ne(y, /&\f/g, d[b]))) && (a[O++] = w);
  return Dh(t, e, n, i === 0 ? Qh : l, a, c, h, u);
}
function dP(t, e, n, r) {
  return Dh(t, e, n, nk, ag(iP()), ys(t, 2, -2), 0, r);
}
function LO(t, e, n, r, i) {
  return Dh(t, e, n, lg, ys(t, 0, r), ys(t, r + 1, -1), r, i);
}
function lk(t, e, n) {
  switch (nP(t, e)) {
    case 5103:
      return de + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return de + t + t;
    case 4789:
      return Do + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return de + t + Do + t + _e + t + t;
    case 5936:
      switch (Je(t, e + 11)) {
        case 114:
          return de + t + _e + ne(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return de + t + _e + ne(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return de + t + _e + ne(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
    case 6828:
    case 4268:
    case 2903:
      return de + t + _e + t + t;
    case 6165:
      return de + t + _e + "flex-" + t + t;
    case 5187:
      return de + t + ne(t, /(\w+).+(:[^]+)/, de + "box-$1$2" + _e + "flex-$1$2") + t;
    case 5443:
      return de + t + _e + "flex-item-" + ne(t, /flex-|-self/g, "") + (tr(t, /flex-|baseline/) ? "" : _e + "grid-row-" + ne(t, /flex-|-self/g, "")) + t;
    case 4675:
      return de + t + _e + "flex-line-pack" + ne(t, /align-content|flex-|-self/g, "") + t;
    case 5548:
      return de + t + _e + ne(t, "shrink", "negative") + t;
    case 5292:
      return de + t + _e + ne(t, "basis", "preferred-size") + t;
    case 6060:
      return de + "box-" + ne(t, "-grow", "") + de + t + _e + ne(t, "grow", "positive") + t;
    case 4554:
      return de + ne(t, /([^-])(transform)/g, "$1" + de + "$2") + t;
    case 6187:
      return ne(ne(ne(t, /(zoom-|grab)/, de + "$1"), /(image-set)/, de + "$1"), t, "") + t;
    case 5495:
    case 3959:
      return ne(t, /(image-set\([^]*)/, de + "$1$`$1");
    case 4968:
      return ne(ne(t, /(.+:)(flex-)?(.*)/, de + "box-pack:$3" + _e + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + de + t + t;
    case 4200:
      if (!tr(t, /flex-|baseline/))
        return _e + "grid-column-align" + ys(t, e) + t;
      break;
    case 2592:
    case 3360:
      return _e + ne(t, "template-", "") + t;
    case 4384:
    case 3616:
      return n && n.some(function(r, i) {
        return e = i, tr(r.props, /grid-\w+-end/);
      }) ? ~tc(t + (n = n[e].value), "span") ? t : _e + ne(t, "-start", "") + t + _e + "grid-row-span:" + (~tc(n, "span") ? tr(n, /\d+/) : +tr(n, /\d+/) - +tr(t, /\d+/)) + ";" : _e + ne(t, "-start", "") + t;
    case 4896:
    case 4128:
      return n && n.some(function(r) {
        return tr(r.props, /grid-\w+-start/);
      }) ? t : _e + ne(ne(t, "-end", "-span"), "span ", "") + t;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return ne(t, /(.+)-inline(.+)/, de + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Tn(t) - 1 - e > 6)
        switch (Je(t, e + 1)) {
          case 109:
            if (Je(t, e + 4) !== 45)
              break;
          case 102:
            return ne(t, /(.+:)(.+)-([^]+)/, "$1" + de + "$2-$3$1" + Do + (Je(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
          case 115:
            return ~tc(t, "stretch") ? lk(ne(t, "stretch", "fill-available"), e, n) + t : t;
        }
      break;
    case 5152:
    case 5920:
      return ne(t, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(r, i, s, o, l, a, c) {
        return _e + i + ":" + s + c + (o ? _e + i + "-span:" + (l ? a : +a - +s) + c : "") + t;
      });
    case 4949:
      if (Je(t, e + 6) === 121)
        return ne(t, ":", ":" + de) + t;
      break;
    case 6444:
      switch (Je(t, Je(t, 14) === 45 ? 18 : 11)) {
        case 120:
          return ne(t, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + de + (Je(t, 14) === 45 ? "inline-" : "") + "box$3$1" + de + "$2$3$1" + _e + "$2box$3") + t;
        case 100:
          return ne(t, ":", ":" + _e) + t;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return ne(t, "scroll-", "scroll-snap-") + t;
  }
  return t;
}
function $c(t, e) {
  for (var n = "", r = 0; r < t.length; r++)
    n += e(t[r], r, t, e) || "";
  return n;
}
function pP(t, e, n, r) {
  switch (t.type) {
    case eP:
      if (t.children.length)
        break;
    case K2:
    case lg:
      return t.return = t.return || t.value;
    case nk:
      return "";
    case rk:
      return t.return = t.value + "{" + $c(t.children, r) + "}";
    case Qh:
      if (!Tn(t.value = t.props.join(",")))
        return "";
  }
  return Tn(n = $c(t.children, r)) ? t.return = t.value + "{" + n + "}" : "";
}
function gP(t) {
  var e = sk(t);
  return function(n, r, i, s) {
    for (var o = "", l = 0; l < e; l++)
      o += t[l](n, r, i, s) || "";
    return o;
  };
}
function mP(t) {
  return function(e) {
    e.root || (e = e.return) && t(e);
  };
}
function OP(t, e, n, r) {
  if (t.length > -1 && !t.return)
    switch (t.type) {
      case lg:
        t.return = lk(t.value, t.length, n);
        return;
      case rk:
        return $c([kr(t, { value: ne(t.value, "@", "@" + de) })], r);
      case Qh:
        if (t.length)
          return rP(n = t.props, function(i) {
            switch (tr(i, r = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Xi(kr(t, { props: [ne(i, /:(read-\w+)/, ":" + Do + "$1")] })), Xi(kr(t, { props: [i] })), ud(t, { props: ZO(n, r) });
                break;
              case "::placeholder":
                Xi(kr(t, { props: [ne(i, /:(plac\w+)/, ":" + de + "input-$1")] })), Xi(kr(t, { props: [ne(i, /:(plac\w+)/, ":" + Do + "$1")] })), Xi(kr(t, { props: [ne(i, /:(plac\w+)/, _e + "input-$1")] })), Xi(kr(t, { props: [i] })), ud(t, { props: ZO(n, r) });
                break;
            }
            return "";
          });
    }
}
var bP = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, vi = typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", ak = "active", ck = "data-styled-version", Rh = "6.1.2", cg = `/*!sc*/
`, hg = typeof window < "u" && "HTMLElement" in window, yP = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" ? {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY : {}.NODE_ENV !== "production"), NO = /invalid hook call/i, aa = /* @__PURE__ */ new Set(), wP = function(t, e) {
  if ({}.NODE_ENV !== "production") {
    var n = e ? ' with the id of "'.concat(e, '"') : "", r = "The component ".concat(t).concat(n, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, i = console.error;
    try {
      var s = !0;
      console.error = function(o) {
        for (var l = [], a = 1; a < arguments.length; a++)
          l[a - 1] = arguments[a];
        NO.test(o) ? (s = !1, aa.delete(r)) : i.apply(void 0, bs([o], l, !1));
      }, hn(), s && !aa.has(r) && (console.warn(r), aa.add(r));
    } catch (o) {
      NO.test(o.message) && aa.delete(r);
    } finally {
      console.error = i;
    }
  }
}, Zh = Object.freeze([]), ks = Object.freeze({});
function kP(t, e, n) {
  return n === void 0 && (n = ks), t.theme !== n.theme && t.theme || e || n.theme;
}
var pd = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), xP = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, vP = /(^-|-$)/g;
function qO(t) {
  return t.replace(xP, "-").replace(vP, "");
}
var SP = /(a)(d)/gi, ca = 52, BO = function(t) {
  return String.fromCharCode(t + (t > 25 ? 39 : 97));
};
function gd(t) {
  var e, n = "";
  for (e = Math.abs(t); e > ca; e = e / ca | 0)
    n = BO(e % ca) + n;
  return (BO(e % ca) + n).replace(SP, "$1-$2");
}
var Du, hk = 5381, si = function(t, e) {
  for (var n = e.length; n; )
    t = 33 * t ^ e.charCodeAt(--n);
  return t;
}, uk = function(t) {
  return si(hk, t);
};
function _P(t) {
  return gd(uk(t) >>> 0);
}
function fk(t) {
  return {}.NODE_ENV !== "production" && typeof t == "string" && t || t.displayName || t.name || "Component";
}
function Mu(t) {
  return typeof t == "string" && ({}.NODE_ENV === "production" || t.charAt(0) === t.charAt(0).toLowerCase());
}
var dk = typeof Symbol == "function" && Symbol.for, pk = dk ? Symbol.for("react.memo") : 60115, CP = dk ? Symbol.for("react.forward_ref") : 60112, AP = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, $P = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, gk = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, PP = ((Du = {})[CP] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, Du[pk] = gk, Du);
function YO(t) {
  return ("type" in (e = t) && e.type.$$typeof) === pk ? gk : "$$typeof" in t ? PP[t.$$typeof] : AP;
  var e;
}
var TP = Object.defineProperty, QP = Object.getOwnPropertyNames, jO = Object.getOwnPropertySymbols, EP = Object.getOwnPropertyDescriptor, DP = Object.getPrototypeOf, XO = Object.prototype;
function mk(t, e, n) {
  if (typeof e != "string") {
    if (XO) {
      var r = DP(e);
      r && r !== XO && mk(t, r, n);
    }
    var i = QP(e);
    jO && (i = i.concat(jO(e)));
    for (var s = YO(t), o = YO(e), l = 0; l < i.length; ++l) {
      var a = i[l];
      if (!(a in $P || n && n[a] || o && a in o || s && a in s)) {
        var c = EP(e, a);
        try {
          TP(t, a, c);
        } catch {
        }
      }
    }
  }
  return t;
}
function xs(t) {
  return typeof t == "function";
}
function ug(t) {
  return typeof t == "object" && "styledComponentId" in t;
}
function hi(t, e) {
  return t && e ? "".concat(t, " ").concat(e) : t || e || "";
}
function WO(t, e) {
  if (t.length === 0)
    return "";
  for (var n = t[0], r = 1; r < t.length; r++)
    n += e ? e + t[r] : t[r];
  return n;
}
function vs(t) {
  return t !== null && typeof t == "object" && t.constructor.name === Object.name && !("props" in t && t.$$typeof);
}
function md(t, e, n) {
  if (n === void 0 && (n = !1), !n && !vs(t) && !Array.isArray(t))
    return e;
  if (Array.isArray(e))
    for (var r = 0; r < e.length; r++)
      t[r] = md(t[r], e[r]);
  else if (vs(e))
    for (var r in e)
      t[r] = md(t[r], e[r]);
  return t;
}
function fg(t, e) {
  Object.defineProperty(t, "toString", { value: e });
}
var MP = {}.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function RP() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t[e] = arguments[e];
  for (var n = t[0], r = [], i = 1, s = t.length; i < s; i += 1)
    r.push(t[i]);
  return r.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
function Xs(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  return {}.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(e.length > 0 ? " Args: ".concat(e.join(", ")) : "")) : new Error(RP.apply(void 0, bs([MP[t]], e, !1)).trim());
}
var ZP = function() {
  function t(e) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;
  }
  return t.prototype.indexOfGroup = function(e) {
    for (var n = 0, r = 0; r < e; r++)
      n += this.groupSizes[r];
    return n;
  }, t.prototype.insertRules = function(e, n) {
    if (e >= this.groupSizes.length) {
      for (var r = this.groupSizes, i = r.length, s = i; e >= s; )
        if ((s <<= 1) < 0)
          throw Xs(16, "".concat(e));
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(r), this.length = s;
      for (var o = i; o < s; o++)
        this.groupSizes[o] = 0;
    }
    for (var l = this.indexOfGroup(e + 1), a = (o = 0, n.length); o < a; o++)
      this.tag.insertRule(l, n[o]) && (this.groupSizes[e]++, l++);
  }, t.prototype.clearGroup = function(e) {
    if (e < this.length) {
      var n = this.groupSizes[e], r = this.indexOfGroup(e), i = r + n;
      this.groupSizes[e] = 0;
      for (var s = r; s < i; s++)
        this.tag.deleteRule(r);
    }
  }, t.prototype.getGroup = function(e) {
    var n = "";
    if (e >= this.length || this.groupSizes[e] === 0)
      return n;
    for (var r = this.groupSizes[e], i = this.indexOfGroup(e), s = i + r, o = i; o < s; o++)
      n += "".concat(this.tag.getRule(o)).concat(cg);
    return n;
  }, t;
}(), ic = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), sc = 1, ha = function(t) {
  if (ic.has(t))
    return ic.get(t);
  for (; Pc.has(sc); )
    sc++;
  var e = sc++;
  if ({}.NODE_ENV !== "production" && ((0 | e) < 0 || e > 1073741824))
    throw Xs(16, "".concat(e));
  return ic.set(t, e), Pc.set(e, t), e;
}, IP = function(t, e) {
  sc = e + 1, ic.set(t, e), Pc.set(e, t);
}, LP = "style[".concat(vi, "][").concat(ck, '="').concat(Rh, '"]'), NP = new RegExp("^".concat(vi, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), qP = function(t, e, n) {
  for (var r, i = n.split(","), s = 0, o = i.length; s < o; s++)
    (r = i[s]) && t.registerName(e, r);
}, BP = function(t, e) {
  for (var n, r = ((n = e.textContent) !== null && n !== void 0 ? n : "").split(cg), i = [], s = 0, o = r.length; s < o; s++) {
    var l = r[s].trim();
    if (l) {
      var a = l.match(NP);
      if (a) {
        var c = 0 | parseInt(a[1], 10), h = a[2];
        c !== 0 && (IP(h, c), qP(t, h, a[3]), t.getTag().insertRules(c, i)), i.length = 0;
      } else
        i.push(l);
    }
  }
};
function YP() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var Ok = function(t) {
  var e = document.head, n = t || e, r = document.createElement("style"), i = function(l) {
    var a = Array.from(l.querySelectorAll("style[".concat(vi, "]")));
    return a[a.length - 1];
  }(n), s = i !== void 0 ? i.nextSibling : null;
  r.setAttribute(vi, ak), r.setAttribute(ck, Rh);
  var o = YP();
  return o && r.setAttribute("nonce", o), n.insertBefore(r, s), r;
}, jP = function() {
  function t(e) {
    this.element = Ok(e), this.element.appendChild(document.createTextNode("")), this.sheet = function(n) {
      if (n.sheet)
        return n.sheet;
      for (var r = document.styleSheets, i = 0, s = r.length; i < s; i++) {
        var o = r[i];
        if (o.ownerNode === n)
          return o;
      }
      throw Xs(17);
    }(this.element), this.length = 0;
  }
  return t.prototype.insertRule = function(e, n) {
    try {
      return this.sheet.insertRule(n, e), this.length++, !0;
    } catch {
      return !1;
    }
  }, t.prototype.deleteRule = function(e) {
    this.sheet.deleteRule(e), this.length--;
  }, t.prototype.getRule = function(e) {
    var n = this.sheet.cssRules[e];
    return n && n.cssText ? n.cssText : "";
  }, t;
}(), XP = function() {
  function t(e) {
    this.element = Ok(e), this.nodes = this.element.childNodes, this.length = 0;
  }
  return t.prototype.insertRule = function(e, n) {
    if (e <= this.length && e >= 0) {
      var r = document.createTextNode(n);
      return this.element.insertBefore(r, this.nodes[e] || null), this.length++, !0;
    }
    return !1;
  }, t.prototype.deleteRule = function(e) {
    this.element.removeChild(this.nodes[e]), this.length--;
  }, t.prototype.getRule = function(e) {
    return e < this.length ? this.nodes[e].textContent : "";
  }, t;
}(), WP = function() {
  function t(e) {
    this.rules = [], this.length = 0;
  }
  return t.prototype.insertRule = function(e, n) {
    return e <= this.length && (this.rules.splice(e, 0, n), this.length++, !0);
  }, t.prototype.deleteRule = function(e) {
    this.rules.splice(e, 1), this.length--;
  }, t.prototype.getRule = function(e) {
    return e < this.length ? this.rules[e] : "";
  }, t;
}(), zO = hg, zP = { isServer: !hg, useCSSOMInjection: !yP }, bk = function() {
  function t(e, n, r) {
    e === void 0 && (e = ks), n === void 0 && (n = {});
    var i = this;
    this.options = At(At({}, zP), e), this.gs = n, this.names = new Map(r), this.server = !!e.isServer, !this.server && hg && zO && (zO = !1, function(s) {
      for (var o = document.querySelectorAll(LP), l = 0, a = o.length; l < a; l++) {
        var c = o[l];
        c && c.getAttribute(vi) !== ak && (BP(s, c), c.parentNode && c.parentNode.removeChild(c));
      }
    }(this)), fg(this, function() {
      return function(s) {
        for (var o = s.getTag(), l = o.length, a = "", c = function(u) {
          var f = function(O) {
            return Pc.get(O);
          }(u);
          if (f === void 0)
            return "continue";
          var d = s.names.get(f), p = o.getGroup(u);
          if (d === void 0 || p.length === 0)
            return "continue";
          var g = "".concat(vi, ".g").concat(u, '[id="').concat(f, '"]'), m = "";
          d !== void 0 && d.forEach(function(O) {
            O.length > 0 && (m += "".concat(O, ","));
          }), a += "".concat(p).concat(g, '{content:"').concat(m, '"}').concat(cg);
        }, h = 0; h < l; h++)
          c(h);
        return a;
      }(i);
    });
  }
  return t.registerId = function(e) {
    return ha(e);
  }, t.prototype.reconstructWithOptions = function(e, n) {
    return n === void 0 && (n = !0), new t(At(At({}, this.options), e), this.gs, n && this.names || void 0);
  }, t.prototype.allocateGSInstance = function(e) {
    return this.gs[e] = (this.gs[e] || 0) + 1;
  }, t.prototype.getTag = function() {
    return this.tag || (this.tag = (e = function(n) {
      var r = n.useCSSOMInjection, i = n.target;
      return n.isServer ? new WP(i) : r ? new jP(i) : new XP(i);
    }(this.options), new ZP(e)));
    var e;
  }, t.prototype.hasNameForId = function(e, n) {
    return this.names.has(e) && this.names.get(e).has(n);
  }, t.prototype.registerName = function(e, n) {
    if (ha(e), this.names.has(e))
      this.names.get(e).add(n);
    else {
      var r = /* @__PURE__ */ new Set();
      r.add(n), this.names.set(e, r);
    }
  }, t.prototype.insertRules = function(e, n, r) {
    this.registerName(e, n), this.getTag().insertRules(ha(e), r);
  }, t.prototype.clearNames = function(e) {
    this.names.has(e) && this.names.get(e).clear();
  }, t.prototype.clearRules = function(e) {
    this.getTag().clearGroup(ha(e)), this.clearNames(e);
  }, t.prototype.clearTag = function() {
    this.tag = void 0;
  }, t;
}(), VP = /&/g, UP = /^\s*\/\/.*$/gm;
function yk(t, e) {
  return t.map(function(n) {
    return n.type === "rule" && (n.value = "".concat(e, " ").concat(n.value), n.value = n.value.replaceAll(",", ",".concat(e, " ")), n.props = n.props.map(function(r) {
      return "".concat(e, " ").concat(r);
    })), Array.isArray(n.children) && n.type !== "@keyframes" && (n.children = yk(n.children, e)), n;
  });
}
function wk(t) {
  var e, n, r, i = t === void 0 ? ks : t, s = i.options, o = s === void 0 ? ks : s, l = i.plugins, a = l === void 0 ? Zh : l, c = function(f, d, p) {
    return p === n || p.startsWith(n) && p.endsWith(n) && p.replaceAll(n, "").length > 0 ? ".".concat(e) : f;
  }, h = a.slice();
  h.push(function(f) {
    f.type === Qh && f.value.includes("&") && (f.props[0] = f.props[0].replace(VP, n).replace(r, c));
  }), o.prefix && h.push(OP), h.push(pP);
  var u = function(f, d, p, g) {
    d === void 0 && (d = ""), p === void 0 && (p = ""), g === void 0 && (g = "&"), e = g, n = d, r = new RegExp("\\".concat(n, "\\b"), "g");
    var m = f.replace(UP, ""), O = fP(p || d ? "".concat(p, " ").concat(d, " { ").concat(m, " }") : m);
    o.namespace && (O = yk(O, o.namespace));
    var b = [];
    return $c(O, gP(h.concat(mP(function(y) {
      return b.push(y);
    })))), b;
  };
  return u.hash = a.length ? a.reduce(function(f, d) {
    return d.name || Xs(15), si(f, d.name);
  }, hk).toString() : "", u;
}
var FP = new bk(), Od = wk(), dg = xi.createContext({ shouldForwardProp: void 0, styleSheet: FP, stylis: Od });
dg.Consumer;
var GP = xi.createContext(void 0);
function bd() {
  return zw(dg);
}
function HP(t) {
  var e = Ee(t.stylisPlugins), n = e[0], r = e[1], i = bd().styleSheet, s = Le(function() {
    var a = i;
    return t.sheet ? a = t.sheet : t.target && (a = a.reconstructWithOptions({ target: t.target }, !1)), t.disableCSSOMInjection && (a = a.reconstructWithOptions({ useCSSOMInjection: !1 })), a;
  }, [t.disableCSSOMInjection, t.sheet, t.target, i]), o = Le(function() {
    return wk({ options: { namespace: t.namespace, prefix: t.enableVendorPrefixes }, plugins: n });
  }, [t.enableVendorPrefixes, t.namespace, n]);
  Ke(function() {
    J2(n, t.stylisPlugins) || r(t.stylisPlugins);
  }, [t.stylisPlugins]);
  var l = Le(function() {
    return { shouldForwardProp: t.shouldForwardProp, styleSheet: s, stylis: o };
  }, [t.shouldForwardProp, s, o]);
  return xi.createElement(dg.Provider, { value: l }, xi.createElement(GP.Provider, { value: o }, t.children));
}
var VO = function() {
  function t(e, n) {
    var r = this;
    this.inject = function(i, s) {
      s === void 0 && (s = Od);
      var o = r.name + s.hash;
      i.hasNameForId(r.id, o) || i.insertRules(r.id, o, s(r.rules, o, "@keyframes"));
    }, this.name = e, this.id = "sc-keyframes-".concat(e), this.rules = n, fg(this, function() {
      throw Xs(12, String(r.name));
    });
  }
  return t.prototype.getName = function(e) {
    return e === void 0 && (e = Od), this.name + e.hash;
  }, t;
}(), JP = function(t) {
  return t >= "A" && t <= "Z";
};
function UO(t) {
  for (var e = "", n = 0; n < t.length; n++) {
    var r = t[n];
    if (n === 1 && r === "-" && t[0] === "-")
      return t;
    JP(r) ? e += "-" + r.toLowerCase() : e += r;
  }
  return e.startsWith("ms-") ? "-" + e : e;
}
var kk = function(t) {
  return t == null || t === !1 || t === "";
}, xk = function(t) {
  var e, n, r = [];
  for (var i in t) {
    var s = t[i];
    t.hasOwnProperty(i) && !kk(s) && (Array.isArray(s) && s.isCss || xs(s) ? r.push("".concat(UO(i), ":"), s, ";") : vs(s) ? r.push.apply(r, bs(bs(["".concat(i, " {")], xk(s), !1), ["}"], !1)) : r.push("".concat(UO(i), ": ").concat((e = i, (n = s) == null || typeof n == "boolean" || n === "" ? "" : typeof n != "number" || n === 0 || e in bP || e.startsWith("--") ? String(n).trim() : "".concat(n, "px")), ";")));
  }
  return r;
};
function Oi(t, e, n, r) {
  if (kk(t))
    return [];
  if (ug(t))
    return [".".concat(t.styledComponentId)];
  if (xs(t)) {
    if (!xs(s = t) || s.prototype && s.prototype.isReactComponent || !e)
      return [t];
    var i = t(e);
    return {}.NODE_ENV === "production" || typeof i != "object" || Array.isArray(i) || i instanceof VO || vs(i) || i === null || console.error("".concat(fk(t), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Oi(i, e, n, r);
  }
  var s;
  return t instanceof VO ? n ? (t.inject(n, r), [t.getName(r)]) : [t] : vs(t) ? xk(t) : Array.isArray(t) ? Array.prototype.concat.apply(Zh, t.map(function(o) {
    return Oi(o, e, n, r);
  })) : [t.toString()];
}
function KP(t) {
  for (var e = 0; e < t.length; e += 1) {
    var n = t[e];
    if (xs(n) && !ug(n))
      return !1;
  }
  return !0;
}
var eT = uk(Rh), tT = function() {
  function t(e, n, r) {
    this.rules = e, this.staticRulesId = "", this.isStatic = {}.NODE_ENV === "production" && (r === void 0 || r.isStatic) && KP(e), this.componentId = n, this.baseHash = si(eT, n), this.baseStyle = r, bk.registerId(n);
  }
  return t.prototype.generateAndInjectStyles = function(e, n, r) {
    var i = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, n, r) : "";
    if (this.isStatic && !r.hash)
      if (this.staticRulesId && n.hasNameForId(this.componentId, this.staticRulesId))
        i = hi(i, this.staticRulesId);
      else {
        var s = WO(Oi(this.rules, e, n, r)), o = gd(si(this.baseHash, s) >>> 0);
        if (!n.hasNameForId(this.componentId, o)) {
          var l = r(s, ".".concat(o), void 0, this.componentId);
          n.insertRules(this.componentId, o, l);
        }
        i = hi(i, o), this.staticRulesId = o;
      }
    else {
      for (var a = si(this.baseHash, r.hash), c = "", h = 0; h < this.rules.length; h++) {
        var u = this.rules[h];
        if (typeof u == "string")
          c += u, {}.NODE_ENV !== "production" && (a = si(a, u));
        else if (u) {
          var f = WO(Oi(u, e, n, r));
          a = si(a, f + h), c += f;
        }
      }
      if (c) {
        var d = gd(a >>> 0);
        n.hasNameForId(this.componentId, d) || n.insertRules(this.componentId, d, r(c, ".".concat(d), void 0, this.componentId)), i = hi(i, d);
      }
    }
    return i;
  }, t;
}(), vk = xi.createContext(void 0);
vk.Consumer;
var Ru = {}, FO = /* @__PURE__ */ new Set();
function nT(t, e, n) {
  var r = ug(t), i = t, s = !Mu(t), o = e.attrs, l = o === void 0 ? Zh : o, a = e.componentId, c = a === void 0 ? function(w, S) {
    var x = typeof w != "string" ? "sc" : qO(w);
    Ru[x] = (Ru[x] || 0) + 1;
    var v = "".concat(x, "-").concat(_P(Rh + x + Ru[x]));
    return S ? "".concat(S, "-").concat(v) : v;
  }(e.displayName, e.parentComponentId) : a, h = e.displayName, u = h === void 0 ? function(w) {
    return Mu(w) ? "styled.".concat(w) : "Styled(".concat(fk(w), ")");
  }(t) : h, f = e.displayName && e.componentId ? "".concat(qO(e.displayName), "-").concat(e.componentId) : e.componentId || c, d = r && i.attrs ? i.attrs.concat(l).filter(Boolean) : l, p = e.shouldForwardProp;
  if (r && i.shouldForwardProp) {
    var g = i.shouldForwardProp;
    if (e.shouldForwardProp) {
      var m = e.shouldForwardProp;
      p = function(w, S) {
        return g(w, S) && m(w, S);
      };
    } else
      p = g;
  }
  var O = new tT(n, f, r ? i.componentStyle : void 0);
  function b(w, S) {
    return function(x, v, P) {
      var D = x.attrs, Q = x.componentStyle, R = x.defaultProps, N = x.foldedComponentIds, F = x.styledComponentId, A = x.target, z = xi.useContext(vk), V = bd(), ie = x.shouldForwardProp || V.shouldForwardProp;
      ({}).NODE_ENV !== "production" && ld(F);
      var ae = function(fe, Qt, me) {
        for (var Bt, rn = At(At({}, Qt), { className: void 0, theme: me }), Ii = 0; Ii < fe.length; Ii += 1) {
          var yr = xs(Bt = fe[Ii]) ? Bt(rn) : Bt;
          for (var sn in yr)
            rn[sn] = sn === "className" ? hi(rn[sn], yr[sn]) : sn === "style" ? At(At({}, rn[sn]), yr[sn]) : yr[sn];
        }
        return Qt.className && (rn.className = hi(rn.className, Qt.className)), rn;
      }(D, v, kP(v, z, R) || ks), Te = ae.as || A, Oe = {};
      for (var ge in ae)
        ae[ge] === void 0 || ge[0] === "$" || ge === "as" || ge === "theme" || (ge === "forwardedAs" ? Oe.as = ae.forwardedAs : ie && !ie(ge, Te) || (Oe[ge] = ae[ge], ie || {}.NODE_ENV !== "development" || m2(ge) || FO.has(ge) || !pd.has(Te) || (FO.add(ge), console.warn('styled-components: it looks like an unknown prop "'.concat(ge, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var se = function(fe, Qt) {
        var me = bd(), Bt = fe.generateAndInjectStyles(Qt, me.styleSheet, me.stylis);
        return {}.NODE_ENV !== "production" && ld(Bt), Bt;
      }(Q, ae);
      ({}).NODE_ENV !== "production" && x.warnTooManyClasses && x.warnTooManyClasses(se);
      var xt = hi(N, F);
      return se && (xt += " " + se), ae.className && (xt += " " + ae.className), Oe[Mu(Te) && !pd.has(Te) ? "class" : "className"] = xt, Oe.ref = P, dn(Te, Oe);
    }(y, w, S);
  }
  b.displayName = u;
  var y = xi.forwardRef(b);
  return y.attrs = d, y.componentStyle = O, y.displayName = u, y.shouldForwardProp = p, y.foldedComponentIds = r ? hi(i.foldedComponentIds, i.styledComponentId) : "", y.styledComponentId = f, y.target = r ? i.target : t, Object.defineProperty(y, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(w) {
    this._foldedDefaultProps = r ? function(S) {
      for (var x = [], v = 1; v < arguments.length; v++)
        x[v - 1] = arguments[v];
      for (var P = 0, D = x; P < D.length; P++)
        md(S, D[P], !0);
      return S;
    }({}, i.defaultProps, w) : w;
  } }), {}.NODE_ENV !== "production" && (wP(u, f), y.warnTooManyClasses = function(w, S) {
    var x = {}, v = !1;
    return function(P) {
      if (!v && (x[P] = !0, Object.keys(x).length >= 200)) {
        var D = S ? ' with the id of "'.concat(S, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(w).concat(D, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), v = !0, x = {};
      }
    };
  }(u, f)), fg(y, function() {
    return ".".concat(y.styledComponentId);
  }), s && mk(y, t, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), y;
}
function GO(t, e) {
  for (var n = [t[0]], r = 0, i = e.length; r < i; r += 1)
    n.push(e[r], t[r + 1]);
  return n;
}
var HO = function(t) {
  return Object.assign(t, { isCss: !0 });
};
function Mo(t) {
  for (var e = [], n = 1; n < arguments.length; n++)
    e[n - 1] = arguments[n];
  if (xs(t) || vs(t))
    return HO(Oi(GO(Zh, bs([t], e, !0))));
  var r = t;
  return e.length === 0 && r.length === 1 && typeof r[0] == "string" ? Oi(r) : HO(Oi(GO(r, e)));
}
function yd(t, e, n) {
  if (n === void 0 && (n = ks), !e)
    throw Xs(1, e);
  var r = function(i) {
    for (var s = [], o = 1; o < arguments.length; o++)
      s[o - 1] = arguments[o];
    return t(e, n, Mo.apply(void 0, bs([i], s, !1)));
  };
  return r.attrs = function(i) {
    return yd(t, e, At(At({}, n), { attrs: Array.prototype.concat(n.attrs, i).filter(Boolean) }));
  }, r.withConfig = function(i) {
    return yd(t, e, At(At({}, n), i));
  }, r;
}
var Sk = function(t) {
  return yd(nT, t);
}, H = Sk;
pd.forEach(function(t) {
  H[t] = Sk(t);
});
({}).NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var ua = "__sc-".concat(vi, "__");
({}).NODE_ENV !== "production" && {}.NODE_ENV !== "test" && typeof window < "u" && (window[ua] || (window[ua] = 0), window[ua] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[ua] += 1);
class le {
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, n, r) {
    [e, n] = Ss(this, e, n);
    let i = [];
    return this.decompose(0, e, i, 2), r.length && r.decompose(0, r.length, i, 3), this.decompose(n, this.length, i, 1), Qn.from(i, this.length - (n - e) + r.length);
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, n = this.length) {
    [e, n] = Ss(this, e, n);
    let r = [];
    return this.decompose(e, n, r, 0), Qn.from(r, n - e);
  }
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new Ro(this), s = new Ro(e);
    for (let o = n, l = n; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (l += i.value.length, i.done || l >= r)
        return !0;
    }
  }
  iter(e = 1) {
    return new Ro(this, e);
  }
  iterRange(e, n = this.length) {
    return new _k(this, e, n);
  }
  iterLines(e, n) {
    let r;
    if (e == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(e).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new Ck(r);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {
  }
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? le.empty : e.length <= 32 ? new Ze(e) : Qn.from(Ze.split(e, []));
  }
}
class Ze extends le {
  constructor(e, n = rT(e)) {
    super(), this.text = e, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = i + o.length;
      if ((n ? r : l) >= e)
        return new iT(i, l, r, o);
      i = l + 1, r++;
    }
  }
  decompose(e, n, r, i) {
    let s = e <= 0 && n >= this.length ? this : new Ze(JO(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = r.pop(), l = oc(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        r.push(new Ze(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        r.push(new Ze(l.slice(0, a)), new Ze(l.slice(a)));
      }
    } else
      r.push(s);
  }
  replace(e, n, r) {
    if (!(r instanceof Ze))
      return super.replace(e, n, r);
    [e, n] = Ss(this, e, n);
    let i = oc(this.text, oc(r.text, JO(this.text, 0, e)), n), s = this.length + r.length - (n - e);
    return i.length <= 32 ? new Ze(i, s) : Qn.from(Ze.split(i, []), s);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = Ss(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (i += r), e < a && n > s && (i += l.slice(Math.max(0, e - s), n - s)), s = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.text)
      e.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, n) {
    let r = [], i = -1;
    for (let s of e)
      r.push(s), i += s.length + 1, r.length == 32 && (n.push(new Ze(r, i)), r = [], i = -1);
    return i > -1 && n.push(new Ze(r, i)), n;
  }
}
class Qn extends le {
  constructor(e, n) {
    super(), this.children = e, this.length = n, this.lines = 0;
    for (let r of e)
      this.lines += r.lines;
  }
  lineInner(e, n, r, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = i + o.length, a = r + o.lines - 1;
      if ((n ? a : l) >= e)
        return o.lineInner(e, n, r, i);
      i = l + 1, r = a + 1;
    }
  }
  decompose(e, n, r, i) {
    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && n >= o) {
        let c = i & ((o <= e ? 1 : 0) | (a >= n ? 2 : 0));
        o >= e && a <= n && !c ? r.push(l) : l.decompose(e - o, n - o, r, c);
      }
      o = a + 1;
    }
  }
  replace(e, n, r) {
    if ([e, n] = Ss(this, e, n), r.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], l = s + o.length;
        if (e >= s && n <= l) {
          let a = o.replace(e - s, n - s, r), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 5 - 1 && a.lines > c >> 5 + 1) {
            let h = this.children.slice();
            return h[i] = a, new Qn(h, this.length - (n - e) + r.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, n, r);
  }
  sliceString(e, n = this.length, r = `
`) {
    [e, n] = Ss(this, e, n);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (i += r), e < a && n > o && (i += l.sliceString(e - o, n - o, r)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let n of this.children)
      n.flatten(e);
  }
  scanIdentical(e, n) {
    if (!(e instanceof Qn))
      return 0;
    let r = 0, [i, s, o, l] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += n, s += n) {
      if (i == o || s == l)
        return r;
      let a = this.children[i], c = e.children[s];
      if (a != c)
        return r + a.scanIdentical(c, n);
      r += a.length + 1;
    }
  }
  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let d of e)
      r += d.lines;
    if (r < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new Ze(d, n);
    }
    let i = Math.max(32, r >> 5), s = i << 1, o = i >> 1, l = [], a = 0, c = -1, h = [];
    function u(d) {
      let p;
      if (d.lines > s && d instanceof Qn)
        for (let g of d.children)
          u(g);
      else
        d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof Ze && a && (p = h[h.length - 1]) instanceof Ze && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, h[h.length - 1] = new Ze(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > i && f(), a += d.lines, c += d.length + 1, h.push(d));
    }
    function f() {
      a != 0 && (l.push(h.length == 1 ? h[0] : Qn.from(h, c)), c = -1, a = h.length = 0);
    }
    for (let d of e)
      u(d);
    return f(), l.length == 1 ? l[0] : new Qn(l, n);
  }
}
le.empty = /* @__PURE__ */ new Ze([""], 0);
function rT(t) {
  let e = -1;
  for (let n of t)
    e += n.length + 1;
  return e;
}
function oc(t, e, n = 0, r = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= r; s++) {
    let l = t[s], a = i + l.length;
    a >= n && (a > r && (l = l.slice(0, r - i)), i < n && (l = l.slice(n - i)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), i = a + 1;
  }
  return e;
}
function JO(t, e, n) {
  return oc(t, [""], e, n);
}
class Ro {
  constructor(e, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof Ze ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, l = i instanceof Ze ? i.text.length : i.children.length;
      if (o == (n > 0 ? l : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof Ze) {
        let a = i.text[o + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : n > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[o + (n < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(a), this.offsets.push(n > 0 ? 1 : (a instanceof Ze ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class _k {
  constructor(e, n, r) {
    this.value = "", this.done = !1, this.cursor = new Ro(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(e, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    e > r && (e = r), r -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Ck {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(e);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (le.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ro.prototype[Symbol.iterator] = _k.prototype[Symbol.iterator] = Ck.prototype[Symbol.iterator] = function() {
  return this;
});
class iT {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.number = r, this.text = i;
  }
  get length() {
    return this.to - this.from;
  }
}
function Ss(t, e, n) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];
}
let is = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < is.length; t++)
  is[t] += is[t - 1];
function sT(t) {
  for (let e = 1; e < is.length; e += 2)
    if (is[e] > t)
      return is[e - 1] <= t;
  return !1;
}
function KO(t) {
  return t >= 127462 && t <= 127487;
}
const e0 = 8205;
function st(t, e, n = !0, r = !0) {
  return (n ? Ak : oT)(t, e, r);
}
function Ak(t, e, n) {
  if (e == t.length)
    return e;
  e && $k(t.charCodeAt(e)) && Pk(t.charCodeAt(e - 1)) && e--;
  let r = rt(t, e);
  for (e += Yt(r); e < t.length; ) {
    let i = rt(t, e);
    if (r == e0 || i == e0 || n && sT(i))
      e += Yt(i), r = i;
    else if (KO(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && KO(rt(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function oT(t, e, n) {
  for (; e > 0; ) {
    let r = Ak(t, e - 2, n);
    if (r < e)
      return r;
    e--;
  }
  return 0;
}
function $k(t) {
  return t >= 56320 && t < 57344;
}
function Pk(t) {
  return t >= 55296 && t < 56320;
}
function rt(t, e) {
  let n = t.charCodeAt(e);
  if (!Pk(n) || e + 1 == t.length)
    return n;
  let r = t.charCodeAt(e + 1);
  return $k(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function pg(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function Yt(t) {
  return t < 65536 ? 1 : 2;
}
const wd = /\r\n?|\n/;
var We = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(We || (We = {}));
class qn {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      e += this.sections[n];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      e += r < 0 ? this.sections[n] : r;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(e) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let s = this.sections[n++], o = this.sections[n++];
      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;
    }
  }
  iterChangedRanges(e, n = !1) {
    kd(this, e, n);
  }
  get invertedDesc() {
    let e = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? e.push(r, i) : e.push(i, r);
    }
    return new qn(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Tk(this, e);
  }
  mapDesc(e, n = !1) {
    return e.empty ? this : xd(this, e, n);
  }
  mapPos(e, n = -1, r = We.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = i + l;
      if (a < 0) {
        if (c > e)
          return s + (e - i);
        s += l;
      } else {
        if (r != We.Simple && c >= e && (r == We.TrackDel && i < e && c > e || r == We.TrackBefore && i < e || r == We.TrackAfter && c > e))
          return null;
        if (c > e || c == e && n < 0 && !l)
          return e == i || n < 0 ? s : s + a;
        s += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  touchesRange(e, n = e) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let s = this.sections[r++], o = this.sections[r++], l = i + s;
      if (o >= 0 && i <= n && l >= e)
        return i < e && l > n ? "cover" : !0;
      i = l;
    }
    return !1;
  }
  toString() {
    let e = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      e += (e ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new qn(e);
  }
  static create(e) {
    return new qn(e);
  }
}
class qe extends qn {
  constructor(e, n) {
    super(e), this.inserted = n;
  }
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return kd(this, (n, r, i, s, o) => e = e.replace(i, i + (r - n), o), !1), e;
  }
  mapDesc(e, n = !1) {
    return xd(this, e, n, !0);
  }
  invert(e) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, s = 0; i < n.length; i += 2) {
      let o = n[i], l = n[i + 1];
      if (l >= 0) {
        n[i] = l, n[i + 1] = o;
        let a = i >> 1;
        for (; r.length < a; )
          r.push(le.empty);
        r.push(o ? e.slice(s, s + o) : le.empty);
      }
      s += o;
    }
    return new qe(n, r);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : Tk(this, e, !0);
  }
  map(e, n = !1) {
    return e.empty ? this : xd(this, e, n, !0);
  }
  iterChanges(e, n = !1) {
    kd(this, e, n);
  }
  get desc() {
    return qn.create(this.sections);
  }
  filter(e) {
    let n = [], r = [], i = [], s = new Uo(this);
    e:
      for (let o = 0, l = 0; ; ) {
        let a = o == e.length ? 1e9 : e[o++];
        for (; l < a || l == a && s.len == 0; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, a - l);
          ut(i, h, -1);
          let u = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          ut(n, h, u), u > 0 && $r(r, n, s.text), s.forward(h), l += h;
        }
        let c = e[o++];
        for (; l < c; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, c - l);
          ut(n, h, -1), ut(i, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), l += h;
        }
      }
    return {
      changes: new qe(n, r),
      filtered: qn.create(i)
    };
  }
  toJSON() {
    let e = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return e;
  }
  static of(e, n, r) {
    let i = [], s = [], o = 0, l = null;
    function a(h = !1) {
      if (!h && !i.length)
        return;
      o < n && ut(i, n - o, -1);
      let u = new qe(i, s);
      l = l ? l.compose(u.map(l)) : u, i = [], s = [], o = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let u of h)
          c(u);
      else if (h instanceof qe) {
        if (h.length != n)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${n})`);
        a(), l = l ? l.compose(h.map(l)) : h;
      } else {
        let { from: u, to: f = u, insert: d } = h;
        if (u > f || u < 0 || f > n)
          throw new RangeError(`Invalid change range ${u} to ${f} (in doc of length ${n})`);
        let p = d ? typeof d == "string" ? le.of(d.split(r || wd)) : d : le.empty, g = p.length;
        if (u == f && g == 0)
          return;
        u < o && a(), u > o && ut(i, u - o, -1), ut(i, f - u, g), $r(s, i, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  static empty(e) {
    return new qe(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        n.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          n.push(s[0], 0);
        else {
          for (; r.length < i; )
            r.push(le.empty);
          r[i] = le.of(s.slice(1)), n.push(s[0], r[i].length);
        }
      }
    }
    return new qe(n, r);
  }
  static createSet(e, n) {
    return new qe(e, n);
  }
}
function ut(t, e, n, r = !1) {
  if (e == 0 && n <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);
}
function $r(t, e, n) {
  if (n.length == 0)
    return;
  let r = e.length - 2 >> 1;
  if (r < t.length)
    t[t.length - 1] = t[t.length - 1].append(n);
  else {
    for (; t.length < r; )
      t.push(le.empty);
    t.push(n);
  }
}
function kd(t, e, n) {
  let r = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let l = t.sections[o++], a = t.sections[o++];
    if (a < 0)
      i += l, s += l;
    else {
      let c = i, h = s, u = le.empty;
      for (; c += l, h += a, a && r && (u = u.append(r[o - 2 >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )
        l = t.sections[o++], a = t.sections[o++];
      e(i, c, s, h, u), i = c, s = h;
    }
  }
}
function xd(t, e, n, r = !1) {
  let i = [], s = r ? [] : null, o = new Uo(t), l = new Uo(e);
  for (let a = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      ut(i, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !n))) {
      let c = l.len;
      for (ut(i, l.ins, -1); c; ) {
        let h = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= h && (ut(i, 0, o.ins), s && $r(s, i, o.text), a = o.i), o.forward(h), c -= h;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, h = o.len;
      for (; h; )
        if (l.ins == -1) {
          let u = Math.min(h, l.len);
          c += u, h -= u, l.forward(u);
        } else if (l.ins == 0 && l.len < h)
          h -= l.len, l.next();
        else
          break;
      ut(i, c, a < o.i ? o.ins : 0), s && a < o.i && $r(s, i, o.text), a = o.i, o.forward(o.len - h);
    } else {
      if (o.done && l.done)
        return s ? qe.createSet(i, s) : qn.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function Tk(t, e, n = !1) {
  let r = [], i = n ? [] : null, s = new Uo(t), o = new Uo(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return i ? qe.createSet(r, i) : qn.create(r);
    if (s.ins == 0)
      ut(r, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      ut(r, 0, o.ins, l), i && $r(i, r, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = r.length;
        if (s.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          ut(r, a, h, l), i && h && $r(i, r, o.text);
        } else
          o.ins == -1 ? (ut(r, s.off ? 0 : s.len, a, l), i && $r(i, r, s.textBit(a))) : (ut(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), i && !o.off && $r(i, r, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || r.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class Uo {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, n = this.i - 2 >> 1;
    return n >= e.length ? le.empty : e[n];
  }
  textBit(e) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !e ? le.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class ui {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.flags = r;
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  map(e, n = -1) {
    let r, i;
    return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new ui(r, i, this.flags);
  }
  extend(e, n = e) {
    if (e <= this.anchor && n >= this.anchor)
      return C.range(e, n);
    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;
    return C.range(this.anchor, r);
  }
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return C.range(e.anchor, e.head);
  }
  static create(e, n, r) {
    return new ui(e, n, r);
  }
}
class C {
  constructor(e, n) {
    this.ranges = e, this.mainIndex = n;
  }
  map(e, n = -1) {
    return e.empty ? this : C.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);
  }
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n]))
        return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new C([this.main], 0);
  }
  addRange(e, n = !0) {
    return C.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = e, C.create(r, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new C(e.ranges.map((n) => ui.fromJSON(n)), e.main);
  }
  static single(e, n = e) {
    return new C([C.range(e, n)], 0);
  }
  static create(e, n = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= r : s.from < r)
        return C.normalized(e.slice(), n);
      r = s.to;
    }
    return new C(e, n);
  }
  static cursor(e, n = 0, r, i) {
    return ui.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i != null ? i : 16777215) << 6);
  }
  static range(e, n, r, i) {
    let s = (r != null ? r : 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < e ? ui.create(n, e, 48 | s) : ui.create(e, n, (n > e ? 8 : 0) | s);
  }
  static normalized(e, n = 0) {
    let r = e[n];
    e.sort((i, s) => i.from - s.from), n = e.indexOf(r);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        i <= n && n--, e.splice(--i, 2, s.anchor > s.head ? C.range(a, l) : C.range(l, a));
      }
    }
    return new C(e, n);
  }
}
function Qk(t, e) {
  for (let n of t.ranges)
    if (n.to > e)
      throw new RangeError("Selection points outside of document");
}
let gg = 0;
class L {
  constructor(e, n, r, i, s) {
    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = gg++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  get reader() {
    return this;
  }
  static define(e = {}) {
    return new L(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : mg), !!e.static, e.enables);
  }
  of(e) {
    return new lc([], this, 0, e);
  }
  compute(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new lc(e, this, 1, n);
  }
  computeN(e, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new lc(e, this, 2, n);
  }
  from(e, n) {
    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));
  }
}
function mg(t, e) {
  return t == e || t.length == e.length && t.every((n, r) => n === e[r]);
}
class lc {
  constructor(e, n, r, i) {
    this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = gg++;
  }
  dynamicSlot(e) {
    var n;
    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, h = [];
    for (let u of this.dependencies)
      u == "doc" ? a = !0 : u == "selection" ? c = !0 : (((n = e[u.id]) !== null && n !== void 0 ? n : 1) & 1) == 0 && h.push(e[u.id]);
    return {
      create(u) {
        return u.values[o] = r(u), 1;
      },
      update(u, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || vd(u, h)) {
          let d = r(u);
          if (l ? !t0(d, u.values[o], i) : !i(d, u.values[o]))
            return u.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (u, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let g = Qc(f, p);
          if (this.dependencies.every((m) => m instanceof L ? f.facet(m) === u.facet(m) : m instanceof Me ? f.field(m, !1) == u.field(m, !1) : !0) || (l ? t0(d = r(u), g, i) : i(d = r(u), g)))
            return u.values[o] = g, 0;
        } else
          d = r(u);
        return u.values[o] = d, 1;
      }
    };
  }
}
function t0(t, e, n) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!n(t[r], e[r]))
      return !1;
  return !0;
}
function vd(t, e) {
  let n = !1;
  for (let r of e)
    Zo(t, r) & 1 && (n = !0);
  return n;
}
function lT(t, e, n) {
  let r = n.map((a) => t[a.id]), i = n.map((a) => a.type), s = r.filter((a) => !(a & 1)), o = t[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let h = 0; h < r.length; h++) {
      let u = Qc(a, r[h]);
      if (i[h] == 2)
        for (let f of u)
          c.push(f);
      else
        c.push(u);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of r)
        Zo(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!vd(a, s))
        return 0;
      let h = l(a);
      return e.compare(h, a.values[o]) ? 0 : (a.values[o] = h, 1);
    },
    reconfigure(a, c) {
      let h = vd(a, r), u = c.config.facets[e.id], f = c.facet(e);
      if (u && !h && mg(n, u))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const n0 = /* @__PURE__ */ L.define({ static: !0 });
class Me {
  constructor(e, n, r, i, s) {
    this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  static define(e) {
    let n = new Me(gg++, e.create, e.update, e.compare || ((r, i) => r === i), e);
    return e.provide && (n.provides = e.provide(n)), n;
  }
  create(e) {
    let n = e.facet(n0).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(e);
  }
  slot(e) {
    let n = e[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let s = r.values[n], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (r.values[n] = o, 1);
      },
      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1)
    };
  }
  init(e) {
    return [this, n0.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const oi = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ao(t) {
  return (e) => new Ek(e, t);
}
const yn = {
  highest: /* @__PURE__ */ ao(oi.highest),
  high: /* @__PURE__ */ ao(oi.high),
  default: /* @__PURE__ */ ao(oi.default),
  low: /* @__PURE__ */ ao(oi.low),
  lowest: /* @__PURE__ */ ao(oi.lowest)
};
class Ek {
  constructor(e, n) {
    this.inner = e, this.prec = n;
  }
}
class Mi {
  of(e) {
    return new Sd(this, e);
  }
  reconfigure(e) {
    return Mi.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class Sd {
  constructor(e, n) {
    this.compartment = e, this.inner = n;
  }
}
class Tc {
  constructor(e, n, r, i, s, o) {
    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let n = this.address[e.id];
    return n == null ? e.default : this.staticValues[n >> 1];
  }
  static resolve(e, n, r) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of aT(e, n, o))
      f instanceof Me ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of i)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let h = r == null ? void 0 : r.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, g = h && h[f] || [];
      if (d.every((m) => m.type == 0))
        if (l[p.id] = a.length << 1 | 1, mg(g, d))
          a.push(r.facet(p));
        else {
          let m = p.combine(d.map((O) => O.value));
          a.push(r && p.compare(m, r.facet(p)) ? r.facet(p) : m);
        }
      else {
        for (let m of d)
          m.type == 0 ? (l[m.id] = a.length << 1 | 1, a.push(m.value)) : (l[m.id] = c.length << 1, c.push((O) => m.dynamicSlot(O)));
        l[p.id] = c.length << 1, c.push((m) => lT(m, p, d));
      }
    }
    let u = c.map((f) => f(l));
    return new Tc(e, o, u, l, a, s);
  }
}
function aT(t, e, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = i.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = r[a].indexOf(o);
      c > -1 && r[a].splice(c, 1), o instanceof Sd && n.delete(o.compartment);
    }
    if (i.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof Sd) {
      if (n.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      n.set(o.compartment, c), s(c, l);
    } else if (o instanceof Ek)
      s(o.inner, o.prec);
    else if (o instanceof Me)
      r[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof lc)
      r[l].push(o), o.facet.extensions && s(o.facet.extensions, oi.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(t, oi.default), r.reduce((o, l) => o.concat(l));
}
function Zo(t, e) {
  if (e & 1)
    return 2;
  let n = e >> 1, r = t.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  t.status[n] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[n]);
  return t.status[n] = 2 | i;
}
function Qc(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const Dk = /* @__PURE__ */ L.define(), _d = /* @__PURE__ */ L.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), Mk = /* @__PURE__ */ L.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), Rk = /* @__PURE__ */ L.define(), Zk = /* @__PURE__ */ L.define(), Ik = /* @__PURE__ */ L.define(), Lk = /* @__PURE__ */ L.define({
  combine: (t) => t.length ? t[0] : !1
});
class wn {
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  static define() {
    return new cT();
  }
}
class cT {
  of(e) {
    return new wn(this, e);
  }
}
class hT {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new G(this, e);
  }
}
class G {
  constructor(e, n) {
    this.type = e, this.value = n;
  }
  map(e) {
    let n = this.type.map(this.value, e);
    return n === void 0 ? void 0 : n == this.value ? this : new G(this.type, n);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new hT(e.map || ((n) => n));
  }
  static mapEffects(e, n) {
    if (!e.length)
      return e;
    let r = [];
    for (let i of e) {
      let s = i.map(n);
      s && r.push(s);
    }
    return r;
  }
}
G.reconfigure = /* @__PURE__ */ G.define();
G.appendConfig = /* @__PURE__ */ G.define();
class je {
  constructor(e, n, r, i, s, o) {
    this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && Qk(r, n.newLength), s.some((l) => l.type == je.time) || (this.annotations = s.concat(je.time.of(Date.now())));
  }
  static create(e, n, r, i, s, o) {
    return new je(e, n, r, i, s, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let n of this.annotations)
      if (n.type == e)
        return n.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let n = this.annotation(je.userEvent);
    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == "."));
  }
}
je.time = /* @__PURE__ */ wn.define();
je.userEvent = /* @__PURE__ */ wn.define();
je.addToHistory = /* @__PURE__ */ wn.define();
je.remote = /* @__PURE__ */ wn.define();
function uT(t, e) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let s, o;
    if (r < t.length && (i == e.length || e[i] >= t[r]))
      s = t[r++], o = t[r++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return n;
    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);
  }
}
function Nk(t, e, n) {
  var r;
  let i, s, o;
  return n ? (i = e.changes, s = qe.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: G.mapEffects(t.effects, i).concat(G.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function Cd(t, e, n) {
  let r = e.selection, i = ss(e.annotations);
  return e.userEvent && (i = i.concat(je.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof qe ? e.changes : qe.of(e.changes || [], n, t.facet(Mk)),
    selection: r && (r instanceof C ? r : C.single(r.anchor, r.head)),
    effects: ss(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function qk(t, e, n) {
  let r = Cd(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (n = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (n = !1);
    let o = !!e[s].sequential;
    r = Nk(r, Cd(t, e[s], o ? r.changes.newLength : t.doc.length), o);
  }
  let i = je.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return dT(n ? fT(i) : i);
}
function fT(t) {
  let e = t.startState, n = !0;
  for (let i of e.facet(Rk)) {
    let s = i(t);
    if (s === !1) {
      n = !1;
      break;
    }
    Array.isArray(s) && (n = n === !0 ? s : uT(n, s));
  }
  if (n !== !0) {
    let i, s;
    if (n === !1)
      s = t.changes.invertedDesc, i = qe.empty(e.doc.length);
    else {
      let o = t.changes.filter(n);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = je.create(e, i, t.selection && t.selection.map(s), G.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let r = e.facet(Zk);
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s instanceof je ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof je ? t = s[0] : t = qk(e, ss(s), !1);
  }
  return t;
}
function dT(t) {
  let e = t.startState, n = e.facet(Ik), r = t;
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s && Object.keys(s).length && (r = Nk(r, Cd(e, s, t.changes.newLength), !0));
  }
  return r == t ? t : je.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);
}
const pT = [];
function ss(t) {
  return t == null ? pT : Array.isArray(t) ? t : [t];
}
var Pe = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(Pe || (Pe = {}));
const gT = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let Ad;
try {
  Ad = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function mT(t) {
  if (Ad)
    return Ad.test(t);
  for (let e = 0; e < t.length; e++) {
    let n = t[e];
    if (/\w/.test(n) || n > "\x80" && (n.toUpperCase() != n.toLowerCase() || gT.test(n)))
      return !0;
  }
  return !1;
}
function OT(t) {
  return (e) => {
    if (!/\S/.test(e))
      return Pe.Space;
    if (mT(e))
      return Pe.Word;
    for (let n = 0; n < t.length; n++)
      if (e.indexOf(t[n]) > -1)
        return Pe.Word;
    return Pe.Other;
  };
}
class re {
  constructor(e, n, r, i, s, o) {
    this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Zo(this, l << 1);
    this.computeSlot = null;
  }
  field(e, n = !0) {
    let r = this.config.address[e.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Zo(this, r), Qc(this, r);
  }
  update(...e) {
    return qk(this, e, !0);
  }
  applyTransaction(e) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let l of e.effects)
      l.is(Mi.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((a, c) => i.set(c, a)), n = null), i.set(l.value.compartment, l.value.extension)) : l.is(G.reconfigure) ? (n = null, r = l.value) : l.is(G.appendConfig) && (n = null, r = ss(r).concat(l.value));
    let s;
    n ? s = e.startState.values.slice() : (n = Tc.resolve(r, i, this), s = new re(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (a, c) => c.reconfigure(a, this), null).values);
    let o = e.startState.facet(_d) ? e.newSelection : e.newSelection.asSingle();
    new re(n, e.newDoc, o, s, (l, a) => a.update(l, e), e);
  }
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: e },
      range: C.cursor(n.from + e.length)
    }));
  }
  changeByRange(e) {
    let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), s = [r.range], o = ss(r.effects);
    for (let l = 1; l < n.ranges.length; l++) {
      let a = e(n.ranges[l]), c = this.changes(a.changes), h = c.map(i);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(h);
      let u = i.mapDesc(c, !0);
      s.push(a.range.map(u)), i = i.compose(h), o = G.mapEffects(o, h).concat(G.mapEffects(ss(a.effects), u));
    }
    return {
      changes: i,
      selection: C.create(s, n.mainIndex),
      effects: o
    };
  }
  changes(e = []) {
    return e instanceof qe ? e : qe.of(e, this.doc.length, this.facet(re.lineSeparator));
  }
  toText(e) {
    return le.of(e.split(this.facet(re.lineSeparator) || wd));
  }
  sliceDoc(e = 0, n = this.doc.length) {
    return this.doc.sliceString(e, n, this.lineBreak);
  }
  facet(e) {
    let n = this.config.address[e.id];
    return n == null ? e.default : (Zo(this, n), Qc(this, n));
  }
  toJSON(e) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let r in e) {
        let i = e[r];
        i instanceof Me && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));
      }
    return n;
  }
  static fromJSON(e, n = {}, r) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let s in r)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = r[s], l = e[s];
          i.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return re.create({
      doc: e.doc,
      selection: C.fromJSON(e.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  static create(e = {}) {
    let n = Tc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof le ? e.doc : le.of((e.doc || "").split(n.staticFacet(re.lineSeparator) || wd)), i = e.selection ? e.selection instanceof C ? e.selection : C.single(e.selection.anchor, e.selection.head) : C.single(0);
    return Qk(i, r.length), n.staticFacet(_d) || (i = i.asSingle()), new re(n, r, i, n.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  get tabSize() {
    return this.facet(re.tabSize);
  }
  get lineBreak() {
    return this.facet(re.lineSeparator) || `
`;
  }
  get readOnly() {
    return this.facet(Lk);
  }
  phrase(e, ...n) {
    for (let r of this.facet(re.phrases))
      if (Object.prototype.hasOwnProperty.call(r, e)) {
        e = r[e];
        break;
      }
    return n.length && (e = e.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > n.length ? r : n[s - 1];
    })), e;
  }
  languageDataAt(e, n, r = -1) {
    let i = [];
    for (let s of this.facet(Dk))
      for (let o of s(this, n, r))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  charCategorizer(e) {
    return OT(this.languageDataAt("wordChars", e).join(""));
  }
  wordAt(e) {
    let { text: n, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, l = e - r;
    for (; o > 0; ) {
      let a = st(n, o, !1);
      if (s(n.slice(a, o)) != Pe.Word)
        break;
      o = a;
    }
    for (; l < i; ) {
      let a = st(n, l);
      if (s(n.slice(l, a)) != Pe.Word)
        break;
      l = a;
    }
    return o == l ? null : C.range(o + r, l + r);
  }
}
re.allowMultipleSelections = _d;
re.tabSize = /* @__PURE__ */ L.define({
  combine: (t) => t.length ? t[0] : 4
});
re.lineSeparator = Mk;
re.readOnly = Lk;
re.phrases = /* @__PURE__ */ L.define({
  compare(t, e) {
    let n = Object.keys(t), r = Object.keys(e);
    return n.length == r.length && n.every((i) => t[i] == e[i]);
  }
});
re.languageData = Dk;
re.changeFilter = Rk;
re.transactionFilter = Zk;
re.transactionExtender = Ik;
Mi.reconfigure = /* @__PURE__ */ G.define();
function zn(t, e, n = {}) {
  let r = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s], l = r[s];
      if (l === void 0)
        r[s] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(n, s))
          r[s] = n[s](l, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    r[i] === void 0 && (r[i] = e[i]);
  return r;
}
class Si {
  eq(e) {
    return this == e;
  }
  range(e, n = e) {
    return Fo.create(e, n, this);
  }
}
Si.prototype.startSide = Si.prototype.endSide = 0;
Si.prototype.point = !1;
Si.prototype.mapMode = We.TrackDel;
class Fo {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.value = r;
  }
  static create(e, n, r) {
    return new Fo(e, n, r);
  }
}
function $d(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class Og {
  constructor(e, n, r, i) {
    this.from = e, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, n, r, i = 0) {
    let s = r ? this.to : this.from;
    for (let o = i, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (r ? this.value[a].endSide : this.value[a].startSide) - n;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, n, r, i) {
    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, n) {
    let r = [], i = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], h = this.from[a] + e, u = this.to[a] + e, f, d;
      if (h == u) {
        let p = n.mapPos(h, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = n.mapPos(h, c.endSide), d < f)))
          continue;
      } else if (f = n.mapPos(h, c.startSide), d = n.mapPos(u, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), r.push(c), i.push(f - o), s.push(d - o));
    }
    return { mapped: r.length ? new Og(i, s, r, l) : null, pos: o };
  }
}
class oe {
  constructor(e, n, r, i) {
    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  static create(e, n, r, i) {
    return new oe(e, n, r, i);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let n of this.chunk)
      e += n.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (n.length == 0 && !o)
      return this;
    if (r && (n = n.slice().sort($d)), this.isEmpty)
      return n.length ? oe.of(n) : this;
    let l = new Bk(this, null, -1).goto(0), a = 0, c = [], h = new et();
    for (; l.value || a < n.length; )
      if (a < n.length && (l.from - n[a].from || l.startSide - n[a].value.startSide) >= 0) {
        let u = n[a++];
        h.addInner(u.from, u.to, u.value) || c.push(u);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == n.length || this.chunkEnd(l.chunkIndex) < n[a].from) && (!o || i > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && h.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || i > l.to || s < l.from || o(l.from, l.to, l.value)) && (h.addInner(l.from, l.to, l.value) || c.push(Fo.create(l.from, l.to, l.value))), l.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? oe.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), n.push(a), r.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: h, pos: u } = a.map(l, e);
        h && (i = Math.max(i, h.maxPoint), n.push(h), r.push(u));
      }
    }
    let s = this.nextLayer.map(e);
    return n.length == 0 ? s : new oe(r, n, s || oe.empty, i);
  }
  between(e, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, r) === !1)
          return;
      }
      this.nextLayer.between(e, n, r);
    }
  }
  iter(e = 0) {
    return Go.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, n = 0) {
    return Go.from(e).goto(n);
  }
  static compare(e, n, r, i, s = -1) {
    let o = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), l = n.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), a = r0(o, l, r), c = new co(o, a, s), h = new co(l, a, s);
    r.iterGaps((u, f, d) => i0(c, u, h, f, d, i)), r.empty && r.length == 0 && i0(c, 0, h, 0, 0, i);
  }
  static eq(e, n, r = 0, i) {
    i == null && (i = 1e9 - 1);
    let s = e.filter((h) => !h.isEmpty && n.indexOf(h) < 0), o = n.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = r0(s, o), a = new co(s, l, 0).goto(r), c = new co(o, l, 0).goto(r);
    for (; ; ) {
      if (a.to != c.to || !Pd(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  static spans(e, n, r, i, s = -1) {
    let o = new co(e, null, s).goto(n), l = n, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, r);
      if (o.point) {
        let h = o.activeForPoint(o.to), u = o.pointFrom < n ? h.length + 1 : Math.min(h.length, a);
        i.point(l, c, o.point, h, u, o.pointRank), a = Math.min(o.openEnd(c), h.length);
      } else
        c > l && (i.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > r)
        return a + (o.point && o.to > r ? 1 : 0);
      l = o.to, o.next();
    }
  }
  static of(e, n = !1) {
    let r = new et();
    for (let i of e instanceof Fo ? [e] : n ? bT(e) : e)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
}
oe.empty = /* @__PURE__ */ new oe([], [], null, -1);
function bT(t) {
  if (t.length > 1)
    for (let e = t[0], n = 1; n < t.length; n++) {
      let r = t[n];
      if ($d(e, r) > 0)
        return t.slice().sort($d);
      e = r;
    }
  return t;
}
oe.empty.nextLayer = oe.empty;
class et {
  finishChunk(e) {
    this.chunks.push(new Og(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  add(e, n, r) {
    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new et())).add(e, n, r);
  }
  addInner(e, n, r) {
    let i = e - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);
  }
  addChunk(e, n) {
    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, !0;
  }
  finish() {
    return this.finishInner(oe.empty);
  }
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let n = oe.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, n;
  }
}
function r0(t, e, n) {
  let r = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = r.get(s.chunk[o]);
      l != null && (n ? n.mapPos(l) : l) == s.chunkPos[o] && !(n != null && n.touchesRange(l, l + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class Bk {
  constructor(e, n, r, i = 0) {
    this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;
  }
  gotoInner(e, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, n) {
    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];
        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Go {
  constructor(e) {
    this.heap = e;
  }
  static from(e, n = null, r = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= r && i.push(new Bk(o, n, r, s));
    return i.length == 1 ? i[0] : new Go(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, n = -1e9) {
    for (let r of this.heap)
      r.goto(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Zu(this.heap, r);
    return this.next(), this;
  }
  forward(e, n) {
    for (let r of this.heap)
      r.forward(e, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Zu(this.heap, r);
    (this.to - e || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Zu(this.heap, 0);
    }
  }
}
function Zu(t, e) {
  for (let n = t[e]; ; ) {
    let r = (e << 1) + 1;
    if (r >= t.length)
      break;
    let i = t[r];
    if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)
      break;
    t[r] = n, t[e] = i, e = r;
  }
}
class co {
  constructor(e, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Go.from(e, n, r);
  }
  goto(e, n = -1e9) {
    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(e, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, n);
  }
  removeActive(e) {
    fa(this.active, e), fa(this.activeTo, e), fa(this.activeRank, e), this.minActive = s0(this.active, this.activeTo);
  }
  addActive(e) {
    let n = 0, { value: r, to: i, rank: s } = this.cursor;
    for (; n < this.activeRank.length && this.activeRank[n] <= s; )
      n++;
    da(this.active, n, r), da(this.activeTo, n, i), da(this.activeRank, n, s), e && da(e, n, this.cursor.from), this.minActive = s0(this.active, this.activeTo);
  }
  next() {
    let e = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && fa(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(e) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)
      n++;
    return n;
  }
}
function i0(t, e, n, r, i, s) {
  t.goto(e), n.goto(r);
  let o = r + i, l = r, a = r - e;
  for (; ; ) {
    let c = t.to + a - n.to || t.endSide - n.endSide, h = c < 0 ? t.to + a : n.to, u = Math.min(h, o);
    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Pd(t.activeForPoint(t.to), n.activeForPoint(n.to)) || s.comparePoint(l, u, t.point, n.point) : u > l && !Pd(t.active, n.active) && s.compareRange(l, u, t.active, n.active), h > o)
      break;
    l = h, c <= 0 && t.next(), c >= 0 && n.next();
  }
}
function Pd(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] != e[n] && !t[n].eq(e[n]))
      return !1;
  return !0;
}
function fa(t, e) {
  for (let n = e, r = t.length - 1; n < r; n++)
    t[n] = t[n + 1];
  t.pop();
}
function da(t, e, n) {
  for (let r = t.length - 1; r >= e; r--)
    t[r + 1] = t[r];
  t[e] = n;
}
function s0(t, e) {
  let n = -1, r = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);
  return n;
}
function pn(t, e, n = t.length) {
  let r = 0;
  for (let i = 0; i < n; )
    t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = st(t, i));
  return r;
}
function Td(t, e, n, r) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? n - s % n : 1, i = st(t, i);
  }
  return r === !0 ? -1 : t.length;
}
const Qd = "\u037C", o0 = typeof Symbol > "u" ? "__" + Qd : Symbol.for(Qd), Ed = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), l0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class hr {
  constructor(e, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let h = [], u = /^@(\w+)\b/.exec(o[0]), f = u && u[1] == "keyframes";
      if (u && l == null)
        return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((g) => o.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!u)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(i(d), p, h, f);
        } else
          p != null && h.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (h.length || f) && a.push((r && !u && !c ? o.map(r) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e)
      s(i(o), e[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = l0[o0] || 1;
    return l0[o0] = e + 1, Qd + e.toString(36);
  }
  static mount(e, n, r) {
    let i = e[Ed], s = r && r.nonce;
    i ? s && i.setNonce(s) : i = new yT(e, s), i.mount(Array.isArray(n) ? n : [n]);
  }
}
let a0 = /* @__PURE__ */ new Map();
class yT {
  constructor(e, n) {
    let r = e.ownerDocument || e, i = r.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = a0.get(r);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[Ed] = s;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], a0.set(r, this);
    } else {
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[Ed] = this;
  }
  mount(e) {
    let n = this.sheet, r = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], l = this.modules.indexOf(o);
      if (l < i && l > -1 && (this.modules.splice(l, 1), i--, l = -1), l == -1) {
        if (this.modules.splice(i++, 0, o), n)
          for (let a = 0; a < o.rules.length; a++)
            n.insertRule(o.rules[a], r++);
      } else {
        for (; i < l; )
          r += this.modules[i++].rules.length;
        r += o.rules.length, i++;
      }
    }
    if (!n) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var qr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ho = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, wT = typeof navigator < "u" && /Mac/.test(navigator.platform), kT = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var it = 0; it < 10; it++)
  qr[48 + it] = qr[96 + it] = String(it);
for (var it = 1; it <= 24; it++)
  qr[it + 111] = "F" + it;
for (var it = 65; it <= 90; it++)
  qr[it] = String.fromCharCode(it + 32), Ho[it] = String.fromCharCode(it);
for (var Iu in qr)
  Ho.hasOwnProperty(Iu) || (Ho[Iu] = qr[Iu]);
function xT(t) {
  var e = wT && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || kT && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Ho : qr)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Ec(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function Dd(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function vT(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function ac(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Dd(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Jo(t) {
  return t.nodeType == 3 ? _i(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Dc(t, e, n, r) {
  return n ? c0(t, e, n, r, -1) || c0(t, e, n, r, 1) : !1;
}
function Ko(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function c0(t, e, n, r, i) {
  for (; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (i < 0 ? 0 : ur(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Ko(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? ur(t) : 0;
    } else
      return !1;
  }
}
function ur(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function bg(t, e) {
  let n = e ? t.left : t.right;
  return { left: n, right: n, top: t.top, bottom: t.bottom };
}
function ST(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function Yk(t, e) {
  let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function _T(t, e, n, r, i, s, o, l) {
  let a = t.ownerDocument, c = a.defaultView || window;
  for (let h = t, u = !1; h && !u; )
    if (h.nodeType == 1) {
      let f, d = h == a.body, p = 1, g = 1;
      if (d)
        f = ST(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (u = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let b = h.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = Yk(h, b)), f = {
          left: b.left,
          right: b.left + h.clientWidth * p,
          top: b.top,
          bottom: b.top + h.clientHeight * g
        };
      }
      let m = 0, O = 0;
      if (i == "nearest")
        e.top < f.top ? (O = -(f.top - e.top + o), n > 0 && e.bottom > f.bottom + O && (O = e.bottom - f.bottom + O + o)) : e.bottom > f.bottom && (O = e.bottom - f.bottom + o, n < 0 && e.top - O < f.top && (O = -(f.top + O - e.top + o)));
      else {
        let b = e.bottom - e.top, y = f.bottom - f.top;
        O = (i == "center" && b <= y ? e.top + b / 2 - y / 2 : i == "start" || i == "center" && n < 0 ? e.top - o : e.bottom - y + o) - f.top;
      }
      if (r == "nearest" ? e.left < f.left ? (m = -(f.left - e.left + s), n > 0 && e.right > f.right + m && (m = e.right - f.right + m + s)) : e.right > f.right && (m = e.right - f.right + s, n < 0 && e.left < f.left + m && (m = -(f.left + m - e.left + s))) : m = (r == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, m || O)
        if (d)
          c.scrollBy(m, O);
        else {
          let b = 0, y = 0;
          if (O) {
            let w = h.scrollTop;
            h.scrollTop += O / g, y = (h.scrollTop - w) * g;
          }
          if (m) {
            let w = h.scrollLeft;
            h.scrollLeft += m / p, b = (h.scrollLeft - w) * p;
          }
          e = {
            left: e.left - b,
            top: e.top - y,
            right: e.right - b,
            bottom: e.bottom - y
          }, b && Math.abs(b - m) < 1 && (r = "nearest"), y && Math.abs(y - O) < 1 && (i = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function CT(t) {
  let e = t.ownerDocument;
  for (let n = t.parentNode; n && n != e.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
        return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11)
      n = n.host;
    else
      break;
  return null;
}
class AT {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: n, focusNode: r } = e;
    this.set(n, Math.min(e.anchorOffset, n ? ur(n) : 0), r, Math.min(e.focusOffset, r ? ur(r) : 0));
  }
  set(e, n, r, i) {
    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
}
let Wi = null;
function jk(t) {
  if (t.setActive)
    return t.setActive();
  if (Wi)
    return t.focus(Wi);
  let e = [];
  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (t.focus(Wi == null ? {
    get preventScroll() {
      return Wi = { preventScroll: !0 }, !0;
    }
  } : void 0), !Wi) {
    Wi = !1;
    for (let n = 0; n < e.length; ) {
      let r = e[n++], i = e[n++], s = e[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);
    }
  }
}
let h0;
function _i(t, e, n = e) {
  let r = h0 || (h0 = document.createRange());
  return r.setEnd(t, n), r.setStart(t, e), r;
}
function os(t, e, n) {
  let r = { key: e, code: e, keyCode: n, which: n, cancelable: !0 }, i = new KeyboardEvent("keydown", r);
  i.synthetic = !0, t.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", r);
  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function $T(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function Xk(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function PT(t, e) {
  let n = e.focusNode, r = e.focusOffset;
  if (!n || e.anchorNode != n || e.anchorOffset != r)
    return !1;
  for (r = Math.min(r, ur(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = ur(n));
    } else {
      if (n == t)
        return !0;
      r = Ko(n), n = n.parentNode;
    }
}
function Wk(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class ft {
  constructor(e, n, r = !0) {
    this.node = e, this.offset = n, this.precise = r;
  }
  static before(e, n) {
    return new ft(e.parentNode, Ko(e), n);
  }
  static after(e, n) {
    return new ft(e.parentNode, Ko(e) + 1, n);
  }
}
const yg = [];
class $e {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == e)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {
            let l = $e.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, n), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && s != o.dom && (n.written = !0), o.dom.parentNode == r)
          for (; s && s != o.dom; )
            s = u0(s);
        else
          r.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : r.firstChild, s && n && n.node == r && (n.written = !0); s; )
        s = u0(s);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(e, n), r.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, n) {
    let r;
    if (e == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = ur(e) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? r = e : r = e.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !$e.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == r)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, n, r = 0) {
    let i = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = r, h = r; a < this.children.length; a++) {
      let u = this.children[a], f = c + u.length;
      if (c < e && f > n)
        return u.domBoundsAround(e, n, c);
      if (f >= e && i == -1 && (i = a, s = c), c > n && u.dom.parentNode == this.dom) {
        o = a, l = h;
        break;
      }
      h = f, c = f + u.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? r + this.length : l,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let n = this.parent; n; n = n.parent) {
      if (e && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let n = e.parent;
      if (!n)
        return e;
      e = n;
    }
  }
  replaceChildren(e, n, r = yg) {
    this.markDirty();
    for (let i = e; i < n; i++) {
      let s = this.children[i];
      s.parent == this && r.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, n - e, ...r);
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new zk(this.children, e, this.children.length);
  }
  childPos(e, n = 1) {
    return this.childCursor().findPos(e, n);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, n, r, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
$e.prototype.breakAfter = 0;
function u0(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class zk {
  constructor(e, n, r) {
    this.children = e, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(e, n = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function Vk(t, e, n, r, i, s, o, l, a) {
  let { children: c } = t, h = c.length ? c[e] : null, u = s.length ? s[s.length - 1] : null, f = u ? u.breakAfter : o;
  if (!(e == r && h && !o && !f && s.length < 2 && h.merge(n, i, s.length ? u : null, n == 0, l, a))) {
    if (r < c.length) {
      let d = c[r];
      d && (i < d.length || d.breakAfter && (u == null ? void 0 : u.breakAfter)) ? (e == r && (d = d.split(i), i = 0), !f && u && d.merge(0, i, u, !0, 0, a) ? s[s.length - 1] = d : ((i || d.children.length && !d.children[0].length) && d.merge(0, i, null, !1, 0, a), s.push(d))) : d != null && d.breakAfter && (u ? u.breakAfter = 1 : o = 1), r++;
    }
    for (h && (h.breakAfter = o, n > 0 && (!o && s.length && h.merge(n, h.length, s[0], !1, l, 0) ? h.breakAfter = s.shift().breakAfter : (n < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(n, h.length, null, !1, l, 0), e++)); e < r && s.length; )
      if (c[r - 1].become(s[s.length - 1]))
        r--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < r || s.length) && t.replaceChildren(e, r, s);
  }
}
function Uk(t, e, n, r, i, s) {
  let o = t.childCursor(), { i: l, off: a } = o.findPos(n, 1), { i: c, off: h } = o.findPos(e, -1), u = e - n;
  for (let f of r)
    u += f.length;
  t.length += u, Vk(t, c, h, l, a, r, 0, i, s);
}
let Lt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Md = typeof document < "u" ? document : { documentElement: { style: {} } };
const Rd = /* @__PURE__ */ /Edge\/(\d+)/.exec(Lt.userAgent), Fk = /* @__PURE__ */ /MSIE \d/.test(Lt.userAgent), Zd = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Lt.userAgent), Ih = !!(Fk || Zd || Rd), f0 = !Ih && /* @__PURE__ */ /gecko\/(\d+)/i.test(Lt.userAgent), Lu = !Ih && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Lt.userAgent), d0 = "webkitFontSmoothing" in Md.documentElement.style, Gk = !Ih && /* @__PURE__ */ /Apple Computer/.test(Lt.vendor), p0 = Gk && (/* @__PURE__ */ /Mobile\/\w+/.test(Lt.userAgent) || Lt.maxTouchPoints > 2);
var q = {
  mac: p0 || /* @__PURE__ */ /Mac/.test(Lt.platform),
  windows: /* @__PURE__ */ /Win/.test(Lt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Lt.platform),
  ie: Ih,
  ie_version: Fk ? Md.documentMode || 6 : Zd ? +Zd[1] : Rd ? +Rd[1] : 0,
  gecko: f0,
  gecko_version: f0 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Lt.userAgent) || [0, 0])[1] : 0,
  chrome: !!Lu,
  chrome_version: Lu ? +Lu[1] : 0,
  ios: p0,
  android: /* @__PURE__ */ /Android\b/.test(Lt.userAgent),
  webkit: d0,
  safari: Gk,
  webkit_version: d0 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Md.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const TT = 256;
class fr extends $e {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, n, r) {
    return this.flags & 8 || r && (!(r instanceof fr) || this.length - (n - e) + r.length > TT || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(e) {
    let n = new fr(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(e, n) {
    return e == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ft(this.dom, e);
  }
  domBoundsAround(e, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, n) {
    return QT(this.dom, e, n);
  }
}
class dr extends $e {
  constructor(e, n = [], r = 0) {
    super(), this.mark = e, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(e) {
    if (Xk(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        e.setAttribute(n, this.mark.attrs[n]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof dr && r.mark.eq(this.mark)) || e && s <= 0 || n < this.length && o <= 0) ? !1 : (Uk(this, e, n, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let n = [], r = 0, i = -1, s = 0;
    for (let l of this.children) {
      let a = r + l.length;
      a > e && n.push(r < e ? l.split(e - r) : l), i < 0 && r >= e && (i = s), r = a, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new dr(this.mark, n, o);
  }
  domAtPos(e) {
    return Hk(this, e);
  }
  coordsAt(e, n) {
    return Kk(this, e, n);
  }
}
function QT(t, e, n) {
  let r = t.nodeValue.length;
  e > r && (e = r);
  let i = e, s = e, o = 0;
  e == 0 && n < 0 || e == r && n >= 0 ? q.chrome || q.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : n < 0 ? i-- : s < r && s++;
  let l = _i(t, i, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : n >= 0) ? 0 : l.length - 1];
  return q.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? bg(a, o < 0) : a || null;
}
class Pr extends $e {
  static create(e, n, r) {
    return new Pr(e, n, r);
  }
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(e) {
    let n = Pr.create(this.widget, this.length - e, this.side);
    return this.length -= e, n;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Pr) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(e) {
    return e instanceof Pr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return le.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : le.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ft.before(this.dom) : ft.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, n) {
    let r = this.widget.coordsAt(this.dom, e, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? i.length - 1 : 0; s = i[l], !(e > 0 ? l == 0 : l == i.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return bg(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class _s extends $e {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof _s && e.side == this.side;
  }
  split() {
    return new _s(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ft.before(this.dom) : ft.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return le.empty;
  }
  get isHidden() {
    return !0;
  }
}
fr.prototype.children = Pr.prototype.children = _s.prototype.children = yg;
function Hk(t, e) {
  let n = t.dom, { children: r } = t, i = 0;
  for (let s = 0; i < r.length; i++) {
    let o = r[i], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == n)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = r[s - 1];
    if (o.dom.parentNode == n)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < r.length; s++) {
    let o = r[s];
    if (o.dom.parentNode == n)
      return o.domAtPos(0);
  }
  return new ft(n, 0);
}
function Jk(t, e, n) {
  let r, { children: i } = t;
  n > 0 && e instanceof dr && i.length && (r = i[i.length - 1]) instanceof dr && r.mark.eq(e.mark) ? Jk(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function Kk(t, e, n) {
  let r = null, i = -1, s = null, o = -1;
  function l(c, h) {
    for (let u = 0, f = 0; u < c.children.length && f <= h; u++) {
      let d = c.children[u], p = f + d.length;
      p >= h && (d.children.length ? l(d, h - f) : (!s || s.isHidden && n > 0) && (p > h || f == p && d.getSide() > 0) ? (s = d, o = h - f) : (f < h || f == p && d.getSide() < 0 && !d.isHidden) && (r = d, i = h - f)), f = p;
    }
  }
  l(t, e);
  let a = (n < 0 ? r : s) || r || s;
  return a ? a.coordsAt(Math.max(0, a == r ? i : o), n) : ET(t);
}
function ET(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let n = Jo(e);
  return n[n.length - 1] || null;
}
function Id(t, e) {
  for (let n in t)
    n == "class" && e.class ? e.class += " " + t.class : n == "style" && e.style ? e.style += ";" + t.style : e[n] = t[n];
  return e;
}
const g0 = /* @__PURE__ */ Object.create(null);
function wg(t, e, n) {
  if (t == e)
    return !0;
  t || (t = g0), e || (e = g0);
  let r = Object.keys(t), i = Object.keys(e);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let s of r)
    if (s != n && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Ld(t, e, n) {
  let r = !1;
  if (e)
    for (let i in e)
      n && i in n || (r = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (n)
    for (let i in n)
      e && e[i] == n[i] || (r = !0, i == "style" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));
  return r;
}
function DT(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < t.attributes.length; n++) {
    let r = t.attributes[n];
    e[r.name] = r.value;
  }
  return e;
}
class Xe extends $e {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e, n, r, i, s, o) {
    if (r) {
      if (!(r instanceof Xe))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), Uk(this, e, n, r ? r.children.slice() : [], s, o), !0;
  }
  split(e) {
    let n = new Xe();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(e);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let s = r; s < this.children.length; s++)
      n.append(this.children[s], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = e, n;
  }
  transferDOM(e) {
    !this.dom || (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    wg(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, n) {
    Jk(this, e, n);
  }
  addLineDeco(e) {
    let n = e.spec.attributes, r = e.spec.class;
    n && (this.attrs = Id(n, this.attrs || {})), r && (this.attrs = Id({ class: r }, this.attrs || {}));
  }
  domAtPos(e) {
    return Hk(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, n) {
    var r;
    this.dom ? this.flags & 4 && (Xk(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Ld(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, n);
    let i = this.dom.lastChild;
    for (; i && $e.get(i) instanceof dr; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = $e.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!q.ios || !this.children.some((s) => s instanceof fr))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, n;
    for (let r of this.children) {
      if (!(r instanceof fr) || /[^ -~]/.test(r.text))
        return null;
      let i = Jo(r.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, n = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(e, n) {
    let r = Kk(this, e, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, n) {
    for (let r = 0, i = 0; r < e.children.length; r++) {
      let s = e.children[r], o = i + s.length;
      if (o >= n) {
        if (s instanceof Xe)
          return s;
        if (o > n)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class Dr extends $e {
  constructor(e, n, r) {
    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, n, r, i, s, o) {
    return r && (!(r instanceof Dr) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(e) {
    return e == 0 ? ft.before(this.dom) : ft.after(this.dom, e == this.length);
  }
  split(e) {
    let n = this.length - e;
    this.length = e;
    let r = new Dr(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return yg;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : le.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Dr && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, n) {
    return this.widget.coordsAt(this.dom, e, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : e < 0 ? n < 0 : r > 0;
  }
}
class Tt {
  eq(e) {
    return !1;
  }
  updateDOM(e, n) {
    return !1;
  }
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, n, r) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(e) {
  }
}
var yt = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(yt || (yt = {}));
class I extends Si {
  constructor(e, n, r, i) {
    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new Il(e);
  }
  static widget(e) {
    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;
    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new Br(e, n, n, r, e.widget || null, !1);
  }
  static replace(e) {
    let n = !!e.block, r, i;
    if (e.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = ex(e, n);
      r = (s ? n ? -3e8 : -1 : 5e8) - 1, i = (o ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new Br(e, r, i, n, e.widget || null, !0);
  }
  static line(e) {
    return new Ll(e);
  }
  static set(e, n = !1) {
    return oe.of(e, n);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
I.none = oe.empty;
class Il extends I {
  constructor(e) {
    let { start: n, end: r } = ex(e);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var n, r;
    return this == e || e instanceof Il && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && wg(this.attrs, e.attrs, "class");
  }
  range(e, n = e) {
    if (e >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, n);
  }
}
Il.prototype.point = !1;
class Ll extends I {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ll && this.spec.class == e.spec.class && wg(this.spec.attributes, e.spec.attributes);
  }
  range(e, n = e) {
    if (n != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, n);
  }
}
Ll.prototype.mapMode = We.TrackBefore;
Ll.prototype.point = !0;
class Br extends I {
  constructor(e, n, r, i, s, o) {
    super(n, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? n <= 0 ? We.TrackBefore : We.TrackAfter : We.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? yt.WidgetRange : this.startSide <= 0 ? yt.WidgetBefore : yt.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Br && MT(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, n = e) {
    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, n);
  }
}
Br.prototype.point = !0;
function ex(t, e = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = t;
  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n != null ? n : e, end: r != null ? r : e };
}
function MT(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function Nd(t, e, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);
}
class Io {
  constructor(e, n, r, i) {
    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof Dr && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Xe()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(pa(new _s(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Dr) && this.getLine();
  }
  buildText(e, n, r) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(pa(new fr(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;
    }
  }
  span(e, n, r, i) {
    this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(e, n, r, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && r instanceof Br) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = n - e;
    if (r instanceof Br)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Dr(r.widget || new m0("div"), l, r));
      else {
        let a = Pr.create(r.widget || new m0("span"), l, l ? 0 : r.startSide), c = this.atCursorPos && !a.isEditable && s <= i.length && (e < n || r.startSide > 0), h = !a.isEditable && (e < n || s > i.length || r.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (u.append(pa(new _s(1), i), s), s = i.length + Math.max(0, s - i.length)), u.append(pa(a, i), s), this.atCursorPos = h, this.pendingBuffer = h ? e < n || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, n, r, i, s) {
    let o = new Io(e, n, r, s);
    return o.openEnd = oe.spans(i, n, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function pa(t, e) {
  for (let n of e)
    t = new dr(n, [t], t.length);
  return t;
}
class m0 extends Tt {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const tx = /* @__PURE__ */ L.define(), nx = /* @__PURE__ */ L.define(), rx = /* @__PURE__ */ L.define(), ix = /* @__PURE__ */ L.define(), qd = /* @__PURE__ */ L.define(), sx = /* @__PURE__ */ L.define(), ox = /* @__PURE__ */ L.define(), lx = /* @__PURE__ */ L.define({
  combine: (t) => t.some((e) => e)
}), ax = /* @__PURE__ */ L.define({
  combine: (t) => t.some((e) => e)
});
class ls {
  constructor(e, n = "nearest", r = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new ls(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new ls(C.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const ga = /* @__PURE__ */ G.define({ map: (t, e) => t.map(e) });
function Ut(t, e, n) {
  let r = t.facet(ix);
  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + ":", e) : console.error(e);
}
const Lh = /* @__PURE__ */ L.define({ combine: (t) => t.length ? t[0] : !0 });
let RT = 0;
const vo = /* @__PURE__ */ L.define();
class ke {
  constructor(e, n, r, i, s) {
    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = s(this);
  }
  static define(e, n) {
    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = n || {};
    return new ke(RT++, e, r, i, (l) => {
      let a = [vo.of(l)];
      return o && a.push(el.of((c) => {
        let h = c.plugin(l);
        return h ? o(h) : I.none;
      })), s && a.push(s(l)), a;
    });
  }
  static fromClass(e, n) {
    return ke.define((r) => new e(r), n);
  }
}
class Nu {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (Ut(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (n) {
        Ut(e.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        Ut(e.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const cx = /* @__PURE__ */ L.define(), kg = /* @__PURE__ */ L.define(), el = /* @__PURE__ */ L.define(), xg = /* @__PURE__ */ L.define(), hx = /* @__PURE__ */ L.define();
function O0(t, e, n) {
  let r = t.state.facet(hx);
  if (!r.length)
    return r;
  let i = r.map((o) => o instanceof Function ? o(t) : o), s = [];
  return oe.spans(i, e, n, {
    point() {
    },
    span(o, l, a, c) {
      let h = s;
      for (let u = a.length - 1; u >= 0; u--, c--) {
        let f = a[u].spec.bidiIsolate, d;
        if (f != null)
          if (c > 0 && h.length && (d = h[h.length - 1]).to == o && d.direction == f)
            d.to = l, h = d.inner;
          else {
            let p = { from: o, to: l, direction: f, inner: [] };
            h.push(p), h = p.inner;
          }
      }
    }
  }), s;
}
const ux = /* @__PURE__ */ L.define();
function fx(t) {
  let e = 0, n = 0, r = 0, i = 0;
  for (let s of t.state.facet(ux)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: n, top: r, bottom: i };
}
const So = /* @__PURE__ */ L.define();
class Ft {
  constructor(e, n, r, i) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(e) {
    return new Ft(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let n = e.length, r = this;
    for (; n > 0; n--) {
      let i = e[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), e.splice(n - 1, 1);
      }
    }
    return e.splice(n, 0, r), e;
  }
  static extendWithRanges(e, n) {
    if (n.length == 0)
      return e;
    let r = [];
    for (let i = 0, s = 0, o = 0, l = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = o - l, h = a ? a.fromB : 1e9;
      for (; s < n.length && n[s] < h; ) {
        let u = n[s], f = n[s + 1], d = Math.max(l, u), p = Math.min(h, f);
        if (d <= p && new Ft(d + c, p + c, d, p).addToSet(r), f > h)
          break;
        s += 2;
      }
      if (!a)
        return r;
      new Ft(a.fromA, a.toA, a.fromB, a.toB).addToSet(r), o = a.toA, l = a.toB;
    }
  }
}
class Mc {
  constructor(e, n, r) {
    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = qe.empty(this.startState.doc.length);
    for (let s of r)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, l, a) => i.push(new Ft(s, o, l, a))), this.changedRanges = i;
  }
  static create(e, n, r) {
    return new Mc(e, n, r);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var De = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(De || (De = {}));
const tl = De.LTR, dx = De.RTL;
function px(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    e.push(1 << +t[n]);
  return e;
}
const ZT = /* @__PURE__ */ px("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), IT = /* @__PURE__ */ px("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Bd = /* @__PURE__ */ Object.create(null), _n = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);
  Bd[e] = n, Bd[n] = -e;
}
function LT(t) {
  return t <= 247 ? ZT[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? IT[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const NT = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Tr {
  get dir() {
    return this.level % 2 ? dx : tl;
  }
  constructor(e, n, r) {
    this.from = e, this.to = n, this.level = r;
  }
  side(e, n) {
    return this.dir == n == e ? this.to : this.from;
  }
  static find(e, n, r, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= n && l.to >= n) {
        if (l.level == r)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? l.from < n : l.to > n : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function gx(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++) {
    let r = t[n], i = e[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !gx(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const be = [];
function qT(t, e, n, r, i) {
  for (let s = 0; s <= r.length; s++) {
    let o = s ? r[s - 1].to : e, l = s < r.length ? r[s].from : n, a = s ? 256 : i;
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = LT(t.charCodeAt(c));
      f == 512 ? f = h : f == 8 && u == 4 && (f = 16), be[c] = f == 4 ? 2 : f, f & 7 && (u = f), h = f;
    }
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = be[c];
      if (f == 128)
        c < l - 1 && h == be[c + 1] && h & 24 ? f = be[c] = h : be[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && be[d] == 64; )
          d++;
        let p = c && h == 8 || d < n && be[d] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let g = c; g < d; g++)
          be[g] = p;
        c = d - 1;
      } else
        f == 8 && u == 1 && (be[c] = 1);
      h = f, f & 7 && (u = f);
    }
  }
}
function BT(t, e, n, r, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= r.length; o++) {
    let c = o ? r[o - 1].to : e, h = o < r.length ? r[o].from : n;
    for (let u = c, f, d, p; u < h; u++)
      if (d = Bd[f = t.charCodeAt(u)])
        if (d < 0) {
          for (let g = l - 3; g >= 0; g -= 3)
            if (_n[g + 1] == -d) {
              let m = _n[g + 2], O = m & 2 ? i : m & 4 ? m & 1 ? s : i : 0;
              O && (be[u] = be[_n[g]] = O), l = g;
              break;
            }
        } else {
          if (_n.length == 189)
            break;
          _n[l++] = u, _n[l++] = f, _n[l++] = a;
        }
      else if ((p = be[u]) == 2 || p == 1) {
        let g = p == i;
        a = g ? 0 : 1;
        for (let m = l - 3; m >= 0; m -= 3) {
          let O = _n[m + 2];
          if (O & 2)
            break;
          if (g)
            _n[m + 2] |= 2;
          else {
            if (O & 4)
              break;
            _n[m + 2] |= 4;
          }
        }
      }
  }
}
function YT(t, e, n, r) {
  for (let i = 0, s = r; i <= n.length; i++) {
    let o = i ? n[i - 1].to : t, l = i < n.length ? n[i].from : e;
    for (let a = o; a < l; ) {
      let c = be[a];
      if (c == 256) {
        let h = a + 1;
        for (; ; )
          if (h == l) {
            if (i == n.length)
              break;
            h = n[i++].to, l = i < n.length ? n[i].from : e;
          } else if (be[h] == 256)
            h++;
          else
            break;
        let u = s == 1, f = (h < e ? be[h] : r) == 1, d = u == f ? u ? 1 : 2 : r;
        for (let p = h, g = i, m = g ? n[g - 1].to : t; p > a; )
          p == m && (p = n[--g].from, m = g ? n[g - 1].to : t), be[--p] = d;
        a = h;
      } else
        s = c, a++;
    }
  }
}
function Yd(t, e, n, r, i, s, o) {
  let l = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let a = e, c = 0; a < n; ) {
      let h = !0, u = !1;
      if (c == s.length || a < s[c].from) {
        let g = be[a];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? r : r + 1, p = a;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (u)
              break e;
            let g = s[c];
            if (!h)
              for (let m = g.to, O = c + 1; ; ) {
                if (m == n)
                  break e;
                if (O < s.length && s[O].from == m)
                  m = s[O++].to;
                else {
                  if (be[m] == l)
                    break e;
                  break;
                }
              }
            if (c++, f)
              f.push(g);
            else {
              g.from > a && o.push(new Tr(a, g.from, d));
              let m = g.direction == tl != !(d % 2);
              jd(t, m ? r + 1 : r, i, g.inner, g.from, g.to, o), a = g.to;
            }
            p = g.to;
          } else {
            if (p == n || (h ? be[p] != l : be[p] == l))
              break;
            p++;
          }
      f ? Yd(t, a, p, r + 1, i, f, o) : a < p && o.push(new Tr(a, p, d)), a = p;
    }
  else
    for (let a = n, c = s.length; a > e; ) {
      let h = !0, u = !1;
      if (!c || a > s[c - 1].to) {
        let g = be[a - 1];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? r : r + 1, p = a;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (u)
              break e;
            let g = s[--c];
            if (!h)
              for (let m = g.from, O = c; ; ) {
                if (m == e)
                  break e;
                if (O && s[O - 1].to == m)
                  m = s[--O].from;
                else {
                  if (be[m - 1] == l)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < a && o.push(new Tr(g.to, a, d));
              let m = g.direction == tl != !(d % 2);
              jd(t, m ? r + 1 : r, i, g.inner, g.from, g.to, o), a = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (h ? be[p - 1] != l : be[p - 1] == l))
              break;
            p--;
          }
      f ? Yd(t, p, a, r + 1, i, f, o) : p < a && o.push(new Tr(p, a, d)), a = p;
    }
}
function jd(t, e, n, r, i, s, o) {
  let l = e % 2 ? 2 : 1;
  qT(t, i, s, r, l), BT(t, i, s, r, l), YT(i, s, r, l), Yd(t, i, s, e, n, r, o);
}
function jT(t, e, n) {
  if (!t)
    return [new Tr(0, 0, e == dx ? 1 : 0)];
  if (e == tl && !n.length && !NT.test(t))
    return mx(t.length);
  if (n.length)
    for (; t.length > be.length; )
      be[be.length] = 256;
  let r = [], i = e == tl ? 0 : 1;
  return jd(t, i, i, n, 0, t.length, r), r;
}
function mx(t) {
  return [new Tr(0, t, 0)];
}
let Ox = "";
function XT(t, e, n, r, i) {
  var s;
  let o = r.head - t.from, l = -1;
  if (o == 0) {
    if (!i || !t.length)
      return null;
    e[0].level != n && (o = e[0].side(!1, n), l = 0);
  } else if (o == t.length) {
    if (i)
      return null;
    let f = e[e.length - 1];
    f.level != n && (o = f.side(!0, n), l = e.length - 1);
  }
  l < 0 && (l = Tr.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc));
  let a = e[l];
  o == a.side(i, n) && (a = e[l += i ? 1 : -1], o = a.side(!i, n));
  let c = i == (a.dir == n), h = st(t.text, o, c);
  if (Ox = t.text.slice(Math.min(o, h), Math.max(o, h)), h > a.from && h < a.to)
    return C.cursor(h + t.from, c ? -1 : 1, a.level);
  let u = l == (i ? e.length - 1 : 0) ? null : e[l + (i ? 1 : -1)];
  return !u && a.level != n ? C.cursor(i ? t.to : t.from, i ? -1 : 1, n) : u && u.level < a.level ? C.cursor(u.side(!i, n) + t.from, i ? 1 : -1, u.level) : C.cursor(h + t.from, i ? -1 : 1, a.level);
}
class b0 extends $e {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Xe()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ft(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var n;
    let r = e.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !HT(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? zT(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      r = new Ft(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(r.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (q.ie || q.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = FT(o, l, e.changes);
    return r = Ft.extendWithRanges(r, a), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  updateInner(e, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = q.chrome || q.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach((o) => o.flags &= -9);
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Dr && o.widget instanceof y0 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, n, r) {
    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(n);
    for (let o = i.length - 1; ; o--) {
      let l = o >= 0 ? i[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: h, toB: u } = l, f, d, p, g;
      if (r && r.range.fromB < u && r.range.toB > h) {
        let w = Io.build(this.view.state.doc, h, r.range.fromB, this.decorations, this.dynamicDecorationMap), S = Io.build(this.view.state.doc, r.range.toB, u, this.decorations, this.dynamicDecorationMap);
        d = w.breakAtStart, p = w.openStart, g = S.openEnd;
        let x = this.compositionView(r);
        S.breakAtStart ? x.breakAfter = 1 : S.content.length && x.merge(x.length, x.length, S.content[0], !1, S.openStart, 0) && (x.breakAfter = S.content[0].breakAfter, S.content.shift()), w.content.length && x.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat(x).concat(S.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = Io.build(this.view.state.doc, h, u, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: O } = s.findPos(c, 1), { i: b, off: y } = s.findPos(a, -1);
      Vk(this, b, y, m, O, f, d, p, g);
    }
    r && this.fixCompositionDOM(r);
  }
  compositionView(e) {
    let n = new fr(e.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of e.marks)
      n = new dr(i, [n], n.length);
    let r = new Xe();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(e) {
    let n = (s, o) => {
      o.flags |= 8 | (o.children.some((a) => a.flags & 7) ? 1 : 0), this.markedForComposition.add(o);
      let l = $e.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];
    n(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(s >= 0 ? e.marks[s].node : e.text, i);
  }
  updateSelection(e = !1, n = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, s = !i && ac(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (q.gecko && l.empty && !this.hasComposition && WT(a)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(u, a.node.childNodes[a.offset] || null)), a = c = new ft(u, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || !Dc(a.node, a.offset, h.anchorNode, h.anchorOffset) || !Dc(c.node, c.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      q.android && q.chrome && this.dom.contains(h.focusNode) && GT(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = Ec(this.view.root);
      if (u)
        if (l.empty) {
          if (q.gecko) {
            let f = VT(a.node, a.offset);
            if (f && f != 3) {
              let d = yx(a.node, a.offset, f == 1 ? 1 : -1);
              d && (a = new ft(d.node, d.offset));
            }
          }
          u.collapse(a.node, a.offset), l.bidiLevel != null && u.caretBidiLevel !== void 0 && (u.caretBidiLevel = l.bidiLevel);
        } else if (u.extend) {
          u.collapse(a.node, a.offset);
          try {
            u.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(f);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new ft(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new ft(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, n = e.state.selection.main, r = Ec(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let o = Xe.find(this, n.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (n.head == l || n.head == l + o.length)
      return;
    let a = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let h = this.domAtPos(n.head + n.assoc);
    r.collapse(h.node, h.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != n.from && r.collapse(i, s);
  }
  moveToLine(e) {
    let n = this.dom, r;
    if (e.node != n)
      return e;
    for (let i = e.offset; !r && i < n.childNodes.length; i++) {
      let s = $e.get(n.childNodes[i]);
      s instanceof Xe && (r = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !r && i >= 0; i--) {
      let s = $e.get(n.childNodes[i]);
      s instanceof Xe && (r = s.domAtPos(s.length));
    }
    return r ? new ft(r.node, r.offset, !0) : e;
  }
  nearest(e) {
    for (let n = e; n; ) {
      let r = $e.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(e, n) {
    let r = this.nearest(e);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(e, n) + r.posAtStart;
  }
  domAtPos(e) {
    let { i: n, off: r } = this.childCursor().findPos(e, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof Xe)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(e, n) {
    let r = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!r || l instanceof Xe && !(r instanceof Xe && n >= 0)) && (r = l, i = c), s = c;
    }
    return r ? r.coordsAt(e - i, n) : null;
  }
  coordsForChar(e) {
    let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];
    if (!(i instanceof Xe))
      return null;
    for (; i.children.length; ) {
      let { i: l, off: a } = i.childPos(r, 1);
      for (; ; l++) {
        if (l == i.children.length)
          return null;
        if ((i = i.children[l]).length)
          break;
      }
      r = a;
    }
    if (!(i instanceof fr))
      return null;
    let s = st(i.text, r);
    if (s == r)
      return null;
    let o = _i(i.dom, r, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let n = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == De.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let u = this.children[h], f = c + u.length;
      if (f > i)
        break;
      if (c >= r) {
        let d = u.dom.getBoundingClientRect();
        if (n.push(d.height), o) {
          let p = u.dom.lastChild, g = p ? Jo(p) : [];
          if (g.length) {
            let m = g[g.length - 1], O = a ? m.right - d.left : d.right - m.left;
            O > l && (l = O, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + u.breakAfter;
    }
    return n;
  }
  textDirectionAt(e) {
    let { i: n } = this.childPos(e, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? De.RTL : De.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Xe) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), n, r, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Jo(e.firstChild)[0];
      n = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : n, e.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(e = this.length) {
    let n = this.children.length;
    return n && (e -= this.children[--n].length), new zk(this.children, e, n);
  }
  computeBlockGapDeco() {
    let e = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let s = i == n.viewports.length ? null : n.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > r) {
        let l = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        e.push(I.replace({
          widget: new y0(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, o));
      }
      if (!s)
        break;
      r = s.to + 1;
    }
    return I.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(el).map((n, r) => (this.dynamicDecorationMap[r] = typeof n == "function") ? n(this.view) : n);
    for (let n = e.length; n < e.length + 3; n++)
      this.dynamicDecorationMap[n] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let s = fx(this.view), o = {
      left: r.left - s.left,
      top: r.top - s.top,
      right: r.right + s.right,
      bottom: r.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    _T(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == De.LTR);
  }
}
function WT(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class y0 extends Tt {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function bx(t, e) {
  let n = t.observer.selectionRange, r = n.focusNode && yx(n.focusNode, n.focusOffset, 0);
  if (!r)
    return null;
  let i = e - r.offset;
  return { from: i, to: i + r.node.nodeValue.length, node: r.node };
}
function zT(t, e, n) {
  let r = bx(t, n);
  if (!r)
    return null;
  let { node: i, from: s, to: o } = r, l = i.nodeValue;
  if (/[\n\r]/.test(l) || t.state.doc.sliceString(r.from, r.to) != l)
    return null;
  let a = e.invertedDesc, c = new Ft(a.mapPos(s), a.mapPos(o), s, o), h = [];
  for (let u = i.parentNode; ; u = u.parentNode) {
    let f = $e.get(u);
    if (f instanceof dr)
      h.push({ node: u, deco: f.mark });
    else {
      if (f instanceof Xe || u.nodeName == "DIV" && u.parentNode == t.contentDOM)
        return { range: c, text: i, marks: h, line: u };
      if (u != t.contentDOM)
        h.push({ node: u, deco: new Il({
          inclusive: !0,
          attributes: DT(u),
          tagName: u.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function yx(t, e, n) {
  if (n <= 0)
    for (let r = t, i = e; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i > 0)
        r = r.childNodes[i - 1], i = ur(r);
      else
        break;
    }
  if (n >= 0)
    for (let r = t, i = e; ; ) {
      if (r.nodeType == 3)
        return { node: r, offset: i };
      if (r.nodeType == 1 && i < r.childNodes.length && n >= 0)
        r = r.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function VT(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let UT = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, n) {
    Nd(e, n, this.changes);
  }
  comparePoint(e, n) {
    Nd(e, n, this.changes);
  }
};
function FT(t, e, n) {
  let r = new UT();
  return oe.compare(t, e, n, r), r.changes;
}
function GT(t, e) {
  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function HT(t, e) {
  let n = !1;
  return e && t.iterChangedRanges((r, i) => {
    r < e.to && i > e.from && (n = !0);
  }), n;
}
function JT(t, e, n = 1) {
  let r = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return C.cursor(e);
  s == 0 ? n = 1 : s == i.length && (n = -1);
  let o = s, l = s;
  n < 0 ? o = st(i.text, s, !1) : l = st(i.text, s);
  let a = r(i.text.slice(o, l));
  for (; o > 0; ) {
    let c = st(i.text, o, !1);
    if (r(i.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < i.length; ) {
    let c = st(i.text, l);
    if (r(i.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return C.range(o + i.from, l + i.from);
}
function KT(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function eQ(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function qu(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function w0(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function k0(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Xd(t, e, n) {
  let r, i, s, o, l = !1, a, c, h, u;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let g = Jo(p);
    for (let m = 0; m < g.length; m++) {
      let O = g[m];
      i && qu(i, O) && (O = w0(k0(O, i.bottom), i.top));
      let b = KT(e, O), y = eQ(n, O);
      if (b == 0 && y == 0)
        return p.nodeType == 3 ? x0(p, e, n) : Xd(p, e, n);
      if (!r || o > y || o == y && s > b) {
        r = p, i = O, s = b, o = y;
        let w = y ? n < O.top ? -1 : 1 : b ? e < O.left ? -1 : 1 : 0;
        l = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      b == 0 ? n > O.bottom && (!h || h.bottom < O.bottom) ? (a = p, h = O) : n < O.top && (!u || u.top > O.top) && (c = p, u = O) : h && qu(h, O) ? h = k0(h, O.bottom) : u && qu(u, O) && (u = w0(u, O.top));
    }
  }
  if (h && h.bottom >= n ? (r = a, i = h) : u && u.top <= n && (r = c, i = u), !r)
    return { node: t, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (r.nodeType == 3)
    return x0(r, f, n);
  if (l && r.contentEditable != "false")
    return Xd(r, f, n);
  let d = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: d };
}
function x0(t, e, n) {
  let r = t.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let l = 0; l < r; l++) {
    let a = _i(t, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let h = a[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let u = (h.top > n ? h.top - n : n - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && u < s) {
        let f = e >= (h.left + h.right) / 2, d = f;
        if ((q.chrome || q.gecko) && _i(t, l).getBoundingClientRect().left == h.right && (d = !f), u <= 0)
          return { node: t, offset: l + (d ? 1 : 0) };
        i = l + (d ? 1 : 0), s = u;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function wx(t, e, n, r = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(), l = o.top + t.viewState.paddingTop, a, { docHeight: c } = t.viewState, { x: h, y: u } = e, f = u - l;
  if (f < 0)
    return 0;
  if (f > c)
    return t.state.doc.length;
  for (let w = t.viewState.heightOracle.textHeight / 2, S = !1; a = t.elementAtHeight(f), a.type != yt.Text; )
    for (; f = r > 0 ? a.bottom + w : a.top - w, !(f >= 0 && f <= c); ) {
      if (S)
        return n ? null : 0;
      S = !0, r = -r;
    }
  u = l + f;
  let d = a.from;
  if (d < t.viewport.from)
    return t.viewport.from == 0 ? 0 : n ? null : v0(t, o, a, h, u);
  if (d > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : v0(t, o, a, h, u);
  let p = t.dom.ownerDocument, g = t.root.elementFromPoint ? t.root : p, m = g.elementFromPoint(h, u);
  m && !t.contentDOM.contains(m) && (m = null), m || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), m = g.elementFromPoint(h, u), m && !t.contentDOM.contains(m) && (m = null));
  let O, b = -1;
  if (m && ((i = t.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(h, u);
      w && ({ offsetNode: O, offset: b } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(h, u);
      w && ({ startContainer: O, startOffset: b } = w, (!t.contentDOM.contains(O) || q.safari && tQ(O, b, h) || q.chrome && nQ(O, b, h)) && (O = void 0));
    }
  }
  if (!O || !t.docView.dom.contains(O)) {
    let w = Xe.find(t.docView, d);
    if (!w)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: O, offset: b } = Xd(w.dom, h, u));
  }
  let y = t.docView.nearest(O);
  if (!y)
    return null;
  if (y.isWidget && ((s = y.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = y.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? y.posAtStart : y.posAtEnd;
  } else
    return y.localPosFromDOM(O, b) + y.posAtStart;
}
function v0(t, e, n, r, i) {
  let s = Math.round((r - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {
    let l = t.viewState.heightOracle.textHeight, a = Math.floor((i - n.top - (t.defaultLineHeight - l) * 0.5) / l);
    s += a * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(n.from, n.to);
  return n.from + Td(o, s, t.state.tabSize);
}
function tQ(t, e, n) {
  let r;
  if (t.nodeType != 3 || e != (r = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return _i(t, r - 1, r).getBoundingClientRect().left > n;
}
function nQ(t, e, n) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let r = t.nodeType == 1 ? t.getBoundingClientRect() : _i(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function Wd(t, e) {
  let n = t.lineBlockAt(e);
  if (Array.isArray(n.type)) {
    for (let r of n.type)
      if (r.to > e || r.to == e && (r.to == n.to || r.type == yt.Text))
        return r;
  }
  return n;
}
function rQ(t, e, n, r) {
  let i = Wd(t, e.head), s = !r || i.type != yt.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), l = t.textDirectionAt(i.from), a = t.posAtCoords({
      x: n == (l == De.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return C.cursor(a, n ? -1 : 1);
  }
  return C.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function S0(t, e, n, r) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);
  for (let l = e, a = null; ; ) {
    let c = XT(i, s, o, l, n), h = Ox;
    if (!c) {
      if (i.number == (n ? t.state.doc.lines : 1))
        return l;
      h = `
`, i = t.state.doc.line(i.number + (n ? 1 : -1)), s = t.bidiSpans(i), c = C.cursor(n ? i.from : i.to);
    }
    if (a) {
      if (!a(h))
        return l;
    } else {
      if (!r)
        return c;
      a = r(h);
    }
    l = c;
  }
}
function iQ(t, e, n) {
  let r = t.state.charCategorizer(e), i = r(n);
  return (s) => {
    let o = r(s);
    return i == Pe.Space && (i = o), i == o;
  };
}
function sQ(t, e, n, r) {
  let i = e.head, s = n ? 1 : -1;
  if (i == (n ? t.state.doc.length : 0))
    return C.cursor(i, e.assoc);
  let o = e.goalColumn, l, a = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), h = t.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(a.right - a.left, t.defaultCharacterWidth * (i - d.from))), l = (s < 0 ? d.top : d.bottom) + h;
  }
  let u = a.left + o, f = r != null ? r : t.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, g = wx(t, { x: u, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? g < i : g > i)) {
      let m = t.docView.coordsForChar(g), O = !m || p < m.top ? -1 : 1;
      return C.cursor(g, O, void 0, o);
    }
  }
}
function cc(t, e, n) {
  for (; ; ) {
    let r = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = r || n || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, r = a;
        }
      });
    if (!r)
      return e;
  }
}
function Bu(t, e, n) {
  let r = cc(t.state.facet(xg).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);
  return r == n.from ? n : C.cursor(r, r < n.from ? 1 : -1);
}
class oQ {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, q.safari && e.contentDOM.addEventListener("input", () => null), q.gecko && xQ(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !pQ(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, n) {
    let r = this.handlers[e];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let n = lQ(e), r = this.handlers, i = this.view.contentDOM;
    for (let s in n)
      if (s != "scroll") {
        let o = !n[s].handlers.length, l = r[s];
        l && o != !l.handlers.length && (i.removeEventListener(s, this.handleEvent), l = null), l || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in r)
      s != "scroll" && !n[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = n;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && xx.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), q.android && q.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let n;
    return q.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = kx.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || aQ.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, os(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : q.safari && !q.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function _0(t, e) {
  return (n, r) => {
    try {
      return e.call(t, r, n);
    } catch (i) {
      Ut(n.state, i);
    }
  };
}
function lQ(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return e[r] || (e[r] = { observers: [], handlers: [] });
  }
  for (let r of t) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && n(s).handlers.push(_0(r.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && n(s).observers.push(_0(r.value, o));
      }
  }
  for (let r in gn)
    n(r).handlers.push(gn[r]);
  for (let r in mn)
    n(r).observers.push(mn[r]);
  return e;
}
const kx = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], aQ = "dthko", xx = [16, 17, 18, 20, 91, 92, 224, 225], ma = 6;
function Oa(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function cQ(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class hQ {
  constructor(e, n, r, i) {
    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParent = CT(e.contentDOM), this.atoms = e.state.facet(xg).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(re.allowMultipleSelections) && uQ(e, n), this.dragging = dQ(e, n) && Cx(n) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var n;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && cQ(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let r = 0, i = 0, s = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = fx(this.view);
    e.clientX - o.left <= s.left + ma ? r = -Oa(s.left - e.clientX) : e.clientX + o.right >= s.right - ma && (r = Oa(e.clientX - s.right)), e.clientY - o.top <= s.top + ma ? i = -Oa(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - ma && (i = Oa(e.clientY - s.bottom)), this.setScrollSpeed(r, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, n) {
    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let n = null;
    for (let r = 0; r < e.ranges.length; r++) {
      let i = e.ranges[r], s = null;
      if (i.empty) {
        let o = cc(this.atoms, i.from, 0);
        o != i.from && (s = C.cursor(o, -1));
      } else {
        let o = cc(this.atoms, i.from, -1), l = cc(this.atoms, i.to, 1);
        (o != i.from || l != i.to) && (s = C.range(i.from == i.anchor ? o : l, i.from == i.head ? o : l));
      }
      s && (n || (n = e.ranges.slice()), n[r] = s);
    }
    return n ? C.create(n, e.mainIndex) : e;
  }
  select(e) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection) || r.main.assoc != n.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function uQ(t, e) {
  let n = t.state.facet(tx);
  return n.length ? n[0](e) : q.mac ? e.metaKey : e.ctrlKey;
}
function fQ(t, e) {
  let n = t.state.facet(nx);
  return n.length ? n[0](e) : q.mac ? !e.altKey : !e.ctrlKey;
}
function dQ(t, e) {
  let { main: n } = t.state.selection;
  if (n.empty)
    return !1;
  let r = Ec(t.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function pQ(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = $e.get(n)) && r.ignoreEvent(e))
      return !1;
  return !0;
}
const gn = /* @__PURE__ */ Object.create(null), mn = /* @__PURE__ */ Object.create(null), vx = q.ie && q.ie_version < 15 || q.ios && q.webkit_version < 604;
function gQ(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let n = e.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    t.focus(), n.remove(), Sx(t, n.value);
  }, 50);
}
function Sx(t, e) {
  let { state: n } = t, r, i = 1, s = n.toText(e), o = s.lines == n.selection.ranges.length;
  if (zd != null && n.selection.ranges.every((a) => a.empty) && zd == s.toString()) {
    let a = -1;
    r = n.changeByRange((c) => {
      let h = n.doc.lineAt(c.from);
      if (h.from == a)
        return { range: c };
      a = h.from;
      let u = n.toText((o ? s.line(i++).text : e) + n.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: C.cursor(c.from + u.length)
      };
    });
  } else
    o ? r = n.changeByRange((a) => {
      let c = s.line(i++);
      return {
        changes: { from: a.from, to: a.to, insert: c.text },
        range: C.cursor(a.from + c.length)
      };
    }) : r = n.replaceSelection(s);
  t.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
mn.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
gn.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
mn.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
mn.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
gn.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of t.state.facet(rx))
    if (n = r(t, e), n)
      break;
  if (!n && e.button == 0 && (n = bQ(t, e)), n) {
    let r = !t.hasFocus;
    t.inputState.startMouseSelection(new hQ(t, e, n, r)), r && t.observer.ignore(() => jk(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function C0(t, e, n, r) {
  if (r == 1)
    return C.cursor(e, n);
  if (r == 2)
    return JT(t.state, e, n);
  {
    let i = Xe.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, l = i ? i.posAtEnd : s.to;
    return l < t.state.doc.length && l == s.to && l++, C.range(o, l);
  }
}
let _x = (t, e) => t >= e.top && t <= e.bottom, A0 = (t, e, n) => _x(e, n) && t >= n.left && t <= n.right;
function mQ(t, e, n, r) {
  let i = Xe.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && A0(n, r, o))
    return -1;
  let l = i.coordsAt(s, 1);
  return l && A0(n, r, l) ? 1 : o && _x(r, o) ? -1 : 1;
}
function $0(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: n, bias: mQ(t, n, e.clientX, e.clientY) };
}
const OQ = q.ie && q.ie_version <= 11;
let P0 = null, T0 = 0, Q0 = 0;
function Cx(t) {
  if (!OQ)
    return t.detail;
  let e = P0, n = Q0;
  return P0 = t, Q0 = Date.now(), T0 = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (T0 + 1) % 3 : 1;
}
function bQ(t, e) {
  let n = $0(t, e), r = Cx(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (n.pos = s.changes.mapPos(n.pos), i = i.map(s.changes));
    },
    get(s, o, l) {
      let a = $0(t, s), c, h = C0(t, a.pos, a.bias, r);
      if (n.pos != a.pos && !o) {
        let u = C0(t, n.pos, n.bias, r), f = Math.min(u.from, h.from), d = Math.max(u.to, h.to);
        h = f < h.from ? C.range(f, d) : C.range(d, f);
      }
      return o ? i.replaceRange(i.main.extend(h.from, h.to)) : l && r == 1 && i.ranges.length > 1 && (c = yQ(i, a.pos)) ? c : l ? i.addRange(h) : C.create([h]);
    }
  };
}
function yQ(t, e) {
  for (let n = 0; n < t.ranges.length; n++) {
    let { from: r, to: i } = t.ranges[n];
    if (r <= e && i >= e)
      return C.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));
  }
  return null;
}
gn.dragstart = (t, e) => {
  let { selection: { main: n } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= n.to || o <= n.from) && (n = C.range(s, o));
    }
  }
  let { inputState: r } = t;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(n.from, n.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
gn.dragend = (t) => (t.inputState.draggedContent = null, !1);
function E0(t, e, n, r) {
  if (!n)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = r && s && fQ(t, e) ? { from: s.from, to: s.to } : null, l = { from: i, insert: n }, a = t.state.changes(o ? [o, l] : l);
  t.focus(), t.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
gn.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let n = e.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, s = () => {
      ++i == n.length && E0(t, e, r.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < n.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (r[o] = l.result), s();
      }, l.readAsText(n[o]);
    }
    return !0;
  } else {
    let r = e.dataTransfer.getData("Text");
    if (r)
      return E0(t, e, r, !0), !0;
  }
  return !1;
};
gn.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let n = vx ? null : e.clipboardData;
  return n ? (Sx(t, n.getData("text/plain") || n.getData("text/uri-text")), !0) : (gQ(t), !1);
};
function wQ(t, e) {
  let n = t.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), t.focus();
  }, 50);
}
function kQ(t) {
  let e = [], n = [], r = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;
    }
    r = !0;
  }
  return { text: e.join(t.lineBreak), ranges: n, linewise: r };
}
let zd = null;
gn.copy = gn.cut = (t, e) => {
  let { text: n, ranges: r, linewise: i } = kQ(t.state);
  if (!n && !i)
    return !1;
  zd = i ? n : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = vx ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", n), !0) : (wQ(t, n), !1);
};
const Ax = /* @__PURE__ */ wn.define();
function $x(t, e) {
  let n = [];
  for (let r of t.facet(ox)) {
    let i = r(t, e);
    i && n.push(i);
  }
  return n ? t.update({ effects: n, annotations: Ax.of(!0) }) : null;
}
function Px(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let n = $x(t.state, e);
      n ? t.dispatch(n) : t.update([]);
    }
  }, 10);
}
mn.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Px(t);
};
mn.blur = (t) => {
  t.observer.clearSelectionRange(), Px(t);
};
mn.compositionstart = mn.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
mn.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, q.chrome && q.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
mn.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
gn.beforeinput = (t, e) => {
  var n;
  let r;
  if (q.chrome && q.android && (r = kx.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const D0 = /* @__PURE__ */ new Set();
function xQ(t) {
  D0.has(t) || (D0.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const M0 = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class vQ {
  constructor(e) {
    this.lineWrapping = e, this.doc = le.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return M0.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let n = !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(e, n, r, i, s, o) {
    let l = M0.indexOf(e) > -1, a = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return a;
  }
}
class SQ {
  constructor(e, n) {
    this.from = e, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class En {
  constructor(e, n, r, i, s) {
    this.from = e, this.length = n, this.top = r, this.height = i, this._content = s;
  }
  get type() {
    return typeof this._content == "number" ? yt.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof Br ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(e) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new En(this.from, this.length + e.length, this.top, this.height + e.height, n);
  }
}
var Ce = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Ce || (Ce = {}));
const hc = 1e-3;
class wt {
  constructor(e, n, r = 2) {
    this.length = e, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, n) {
    this.height != n && (Math.abs(this.height - n) > hc && (e.heightChanged = !0), this.height = n);
  }
  replace(e, n, r) {
    return wt.of(r);
  }
  decomposeLeft(e, n) {
    n.push(this);
  }
  decomposeRight(e, n) {
    n.push(this);
  }
  applyChanges(e, n, r, i) {
    let s = this, o = r.doc;
    for (let l = i.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: h, toB: u } = i[l], f = s.lineAt(a, Ce.ByPosNoHeight, r.setDoc(n), 0, 0), d = f.to >= c ? f : s.lineAt(c, Ce.ByPosNoHeight, r, 0, 0);
      for (u += d.to - c, c = d.to; l > 0 && f.from <= i[l - 1].toA; )
        a = i[l - 1].fromA, h = i[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, Ce.ByPosNoHeight, r, 0, 0));
      h += f.from - a, a = f.from;
      let p = vg.build(r.setDoc(o), e, h, u);
      s = s.replace(a, c, p);
    }
    return s.updateHeight(r, 0);
  }
  static empty() {
    return new Zt(0, 0);
  }
  static of(e) {
    if (e.length == 1)
      return e[0];
    let n = 0, r = e.length, i = 0, s = 0;
    for (; ; )
      if (n == r)
        if (i > s * 2) {
          let l = e[n - 1];
          l.break ? e.splice(--n, 1, l.left, null, l.right) : e.splice(--n, 1, l.left, l.right), r += 1 + l.break, i -= l.size;
        } else if (s > i * 2) {
          let l = e[r];
          l.break ? e.splice(r, 1, l.left, null, l.right) : e.splice(r, 1, l.left, l.right), r += 2 + l.break, s -= l.size;
        } else
          break;
      else if (i < s) {
        let l = e[n++];
        l && (i += l.size);
      } else {
        let l = e[--r];
        l && (s += l.size);
      }
    let o = 0;
    return e[n - 1] == null ? (o = 1, n--) : e[n] == null && (o = 1, r++), new _Q(wt.of(e.slice(0, n)), o, wt.of(e.slice(r)));
  }
}
wt.prototype.size = 1;
class Tx extends wt {
  constructor(e, n, r) {
    super(e, n), this.deco = r;
  }
  blockAt(e, n, r, i) {
    return new En(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(e, n, r, i, s) {
    return this.blockAt(0, r, i, s);
  }
  forEachLine(e, n, r, i, s, o) {
    e <= s + this.length && n >= s && o(this.blockAt(0, r, i, s));
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Zt extends Tx {
  constructor(e, n) {
    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, n, r, i) {
    return new En(i, this.length, r, this.height, this.breaks);
  }
  replace(e, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Zt || i instanceof nt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof nt ? i = new Zt(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : wt.of(r);
  }
  updateHeight(e, n = 0, r = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(e, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class nt extends wt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, n) {
    let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, s = i - r + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: r, lastLine: i, perLine: o, perChar: l };
  }
  blockAt(e, n, r, i) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let c = i + Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length), h = n.doc.lineAt(c), u = l + h.length * a, f = Math.max(r, e - u / 2);
      return new En(h.from, h.length, f, u, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / l))), { from: h, length: u } = n.doc.line(s + c);
      return new En(h, u, r + l * c, l, 0);
    }
  }
  lineAt(e, n, r, i, s) {
    if (n == Ce.ByHeight)
      return this.blockAt(e, r, i, s);
    if (n == Ce.ByPosNoHeight) {
      let { from: d, to: p } = r.doc.lineAt(e);
      return new En(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(r, s), c = r.doc.lineAt(e), h = l + c.length * a, u = c.number - o, f = i + l * u + a * (c.from - s - u);
    return new En(c.from, c.length, Math.max(i, Math.min(f, i + this.height - h)), h, 0);
  }
  forEachLine(e, n, r, i, s, o) {
    e = Math.max(e, s), n = Math.min(n, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(r, s);
    for (let h = e, u = i; h <= n; ) {
      let f = r.doc.lineAt(h);
      if (h == e) {
        let p = f.number - l;
        u += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new En(f.from, f.length, u, d, 0)), u += d, h = f.to + 1;
    }
  }
  replace(e, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let s = r[r.length - 1];
      s instanceof nt ? r[r.length - 1] = new nt(s.length + i) : r.push(null, new nt(i - 1));
    }
    if (e > 0) {
      let s = r[0];
      s instanceof nt ? r[0] = new nt(e + s.length) : r.unshift(new nt(e - 1), null);
    }
    return wt.of(r);
  }
  decomposeLeft(e, n) {
    n.push(new nt(e - 1), null);
  }
  decomposeRight(e, n) {
    n.push(null, new nt(this.length - e - 1));
  }
  updateHeight(e, n = 0, r = !1, i) {
    let s = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let o = [], l = Math.max(n, i.from), a = -1;
      for (i.from > n && o.push(new nt(i.from - n - 1).updateHeight(e, n)); l <= s && i.more; ) {
        let h = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let u = i.heights[i.index++];
        a == -1 ? a = u : Math.abs(u - a) >= hc && (a = -2);
        let f = new Zt(h, u);
        f.outdated = !1, o.push(f), l += h + 1;
      }
      l <= s && o.push(null, new nt(s - l).updateHeight(e, l));
      let c = wt.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= hc || Math.abs(a - this.heightMetrics(e, n).perLine) >= hc) && (e.heightChanged = !0), c;
    } else
      (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class _Q extends wt {
  constructor(e, n, r) {
    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, n, r, i) {
    let s = r + this.left.height;
    return e < s ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, s, i + this.left.length + this.break);
  }
  lineAt(e, n, r, i, s) {
    let o = i + this.left.height, l = s + this.left.length + this.break, a = n == Ce.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, n, r, i, s) : this.right.lineAt(e, n, r, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let h = n == Ce.ByPosNoHeight ? Ce.ByPosNoHeight : Ce.ByPos;
    return a ? c.join(this.right.lineAt(l, h, r, o, l)) : this.left.lineAt(l, h, r, i, s).join(c);
  }
  forEachLine(e, n, r, i, s, o) {
    let l = i + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, n, r, i, s, o), n >= a && this.right.forEachLine(e, n, r, l, a, o);
    else {
      let c = this.lineAt(a, Ce.ByPos, r, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= n && o(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, l, a, o);
    }
  }
  replace(e, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(e, n, r), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, n - i, r));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of r)
      s.push(l);
    if (e > 0 && R0(s, o - 1), n < this.length) {
      let l = s.length;
      this.decomposeRight(n, s), R0(s, l);
    }
    return wt.of(s);
  }
  decomposeLeft(e, n) {
    let r = this.left.length;
    if (e <= r)
      return this.left.decomposeLeft(e, n);
    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);
  }
  decomposeRight(e, n) {
    let r = this.left.length, i = r + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, n);
    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);
  }
  balanced(e, n) {
    return e.size > 2 * n.size || n.size > 2 * e.size ? wt.of(this.break ? [e, null, n] : [e, n]) : (this.left = e, this.right = n, this.height = e.height + n.height, this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);
  }
  updateHeight(e, n = 0, r = !1, i) {
    let { left: s, right: o } = this, l = n + s.length + this.break, a = null;
    return i && i.from <= n + s.length && i.more ? a = s = s.updateHeight(e, n, r, i) : s.updateHeight(e, n, r), i && i.from <= l + o.length && i.more ? a = o = o.updateHeight(e, l, r, i) : o.updateHeight(e, l, r), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function R0(t, e) {
  let n, r;
  t[e] == null && (n = t[e - 1]) instanceof nt && (r = t[e + 1]) instanceof nt && t.splice(e - 1, 3, new nt(n.length + 1 + r.length));
}
const CQ = 5;
class vg {
  constructor(e, n) {
    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Zt ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Zt(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(e, n, r) {
    if (e < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = n - e;
      r.block ? this.addBlock(new Tx(o, i, r)) : (o || s || i >= CQ) && this.addLineDeco(i, s, o);
    } else
      n > e && this.span(e, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Zt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, n) {
    let r = new nt(n - e);
    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Zt)
      return e;
    let n = new Zt(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(e) {
    this.enterLine();
    let n = e.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(e) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Zt) && !this.isCovered ? this.nodes.push(new Zt(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = e;
    for (let i of this.nodes)
      i instanceof Zt && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  static build(e, n, r, i) {
    let s = new vg(r, e);
    return oe.spans(n, r, i, s, 0), s.finish(r);
  }
}
function AQ(t, e, n) {
  let r = new $Q();
  return oe.compare(t, e, n, r, 0), r.changes;
}
class $Q {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, n, r, i) {
    (e < n || r && r.heightRelevant || i && i.heightRelevant) && Nd(e, n, this.changes, 5);
  }
}
function PQ(t, e) {
  let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, s = Math.max(0, n.left), o = Math.min(i.innerWidth, n.right), l = Math.max(0, n.top), a = Math.min(i.innerHeight, n.bottom);
  for (let c = t.parentNode; c && c != r.body; )
    if (c.nodeType == 1) {
      let h = c, u = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && u.overflow != "visible") {
        let f = h.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = c == t.parentNode ? f.bottom : Math.min(a, f.bottom);
      }
      c = u.position == "absolute" || u.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - n.left,
    right: Math.max(s, o) - n.left,
    top: l - (n.top + e),
    bottom: Math.max(l, a) - (n.top + e)
  };
}
function TQ(t, e) {
  let n = t.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: e,
    bottom: n.bottom - (n.top + e)
  };
}
class Yu {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.size = r;
  }
  static same(e, n) {
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++) {
      let i = e[r], s = n[r];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, n) {
    return I.replace({
      widget: new QQ(this.size * (n ? e.scaleY : e.scaleX), n)
    }).range(this.from, this.to);
  }
}
class QQ extends Tt {
  constructor(e, n) {
    super(), this.size = e, this.vertical = n;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Z0 {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = I0, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = De.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = e.facet(kg).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new vQ(n), this.stateDeco = e.facet(el).filter((r) => typeof r != "function"), this.heightMap = wt.empty().applyChanges(this.stateDeco, le.empty, this.heightOracle.setDoc(e.doc), [new Ft(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = I.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new ba(s, o));
      }
    }
    this.viewports = e.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? I0 : new MQ(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : _o(e, this.scaler));
    });
  }
  update(e, n = null) {
    this.state = e.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(el).filter((h) => typeof h != "function");
    let i = e.changedRanges, s = Ft.extendWithRanges(i, AQ(r, this.stateDeco, e ? e.changes : qe.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (n && (n.range.head < a.from || n.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, n));
    let c = !e.changes.empty || e.flags & 2 || a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(ax) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, s = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? De.RTL : De.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = n.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (l.width && l.height) {
      let { scaleX: w, scaleY: S } = Yk(n, l);
      (this.scaleX != w || this.scaleY != S) && (this.scaleX = w, this.scaleY = S, c |= 8, o = a = !0);
    }
    let u = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != u || this.paddingBottom != f) && (this.paddingTop = u, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = Wk(e.scrollDOM);
    let p = (this.printing ? TQ : PQ)(n, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let O = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (O != this.inView && (this.inView = O, O && (a = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let b = l.width;
    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), a) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(w) && (o = !0), o || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: S, charWidth: x, textHeight: v } = e.docView.measureTextSize();
        o = S > 0 && i.refresh(s, S, x, v, b / x, w), o && (e.docView.minWidth = 0, c |= 8);
      }
      g > 0 && m > 0 ? h = Math.max(g, m) : g < 0 && m < 0 && (h = Math.min(g, m)), i.heightChanged = !1;
      for (let S of this.viewports) {
        let x = S.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(S);
        this.heightMap = (o ? wt.empty().applyChanges(this.stateDeco, le.empty, this.heightOracle, [new Ft(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new SQ(S.from, x));
      }
      i.heightChanged && (c |= 2);
    }
    let y = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return y && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (c & 2 || y) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new ba(i.lineAt(o - r * 1e3, Ce.ByHeight, s, 0, 0).from, i.lineAt(l + (1 - r) * 1e3, Ce.ByHeight, s, 0, 0).to);
    if (n) {
      let { head: c } = n.range;
      if (c < a.from || c > a.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = i.lineAt(c, Ce.ByPos, s, 0, 0), f;
        n.y == "center" ? f = (u.top + u.bottom) / 2 - h / 2 : n.y == "start" || n.y == "nearest" && c < a.from ? f = u.top : f = u.bottom - h, a = new ba(i.lineAt(f - 1e3 / 2, Ce.ByHeight, s, 0, 0).from, i.lineAt(f + h + 1e3 / 2, Ce.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, n) {
    let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);
    return new ba(this.heightMap.lineAt(r, Ce.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Ce.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate({ from: e, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Ce.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(n, Ce.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(-r, 250))) && (n == this.state.doc.length || s >= l + Math.max(10, Math.min(r, 250))) && i > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, n) {
    if (!e.length || n.empty)
      return e;
    let r = [];
    for (let i of e)
      n.touchesRange(i.from, i.to) || r.push(new Yu(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  ensureLineGaps(e, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != De.LTR && !r)
      return [];
    let l = [], a = (c, h, u, f) => {
      if (h - c < s)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let m of p)
        if (m > c && m < h) {
          a(c, m - 10, u, f), a(m + 10, h, u, f);
          return;
        }
      let g = DQ(e, (m) => m.from >= u.from && m.to <= u.to && Math.abs(m.from - c) < s && Math.abs(m.to - h) < s && !p.some((O) => m.from < O && m.to > O));
      if (!g) {
        if (h < u.to && n && r && n.visibleRanges.some((m) => m.from <= h && m.to >= h)) {
          let m = n.moveToLineBoundary(C.cursor(h), !1, !0).head;
          m > c && (h = m);
        }
        g = new Yu(c, h, this.gapSize(u, c, h, f));
      }
      l.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let h = EQ(c.from, c.to, this.stateDeco);
      if (h.total < o)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (r) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (u != null) {
          let O = wa(h, u), b = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          g = O - b, m = O + b;
        } else
          g = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        f = ya(h, g), d = ya(h, m);
      } else {
        let p = h.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, m, O;
        if (u != null) {
          let b = wa(h, u), y = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = b - y, O = b + y;
        } else
          m = (this.pixelViewport.left - g) / p, O = (this.pixelViewport.right + g) / p;
        f = ya(h, m), d = ya(h, O);
      }
      f > c.from && a(c.from, f, c, h), d < c.to && a(d, c.to, c, h);
    }
    return l;
  }
  gapSize(e, n, r, i) {
    let s = wa(i, r) - wa(i, n);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Yu.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = I.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let n = [];
    oe.spans(e, this.viewport.from, this.viewport.to, {
      span(i, s) {
        n.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != n[s].from || i.to != n[s].to);
    return this.visibleRanges = n, r ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || _o(this.heightMap.lineAt(e, Ce.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return _o(this.heightMap.lineAt(this.scaler.fromDOM(e), Ce.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let n = this.lineBlockAtHeight(e + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return _o(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class ba {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
function EQ(t, e, n) {
  let r = [], i = t, s = 0;
  return oe.spans(n, t, e, {
    span() {
    },
    point(o, l) {
      o > i && (r.push({ from: i, to: o }), s += o - i), i = l;
    }
  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };
}
function ya({ total: t, ranges: e }, n) {
  if (n <= 0)
    return e[0].from;
  if (n >= 1)
    return e[e.length - 1].to;
  let r = Math.floor(t * n);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], l = o - s;
    if (r <= l)
      return s + r;
    r -= l;
  }
}
function wa(t, e) {
  let n = 0;
  for (let { from: r, to: i } of t.ranges) {
    if (e <= i) {
      n += e - r;
      break;
    }
    n += i - r;
  }
  return n / t.total;
}
function DQ(t, e) {
  for (let n of t)
    if (e(n))
      return n;
}
const I0 = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class MQ {
  constructor(e, n, r) {
    let i = 0, s = 0, o = 0;
    this.viewports = r.map(({ from: l, to: a }) => {
      let c = n.lineAt(l, Ce.ByPos, e, 0, 0).top, h = n.lineAt(a, Ce.ByPos, e, 0, 0).bottom;
      return i += h - c, { from: l, to: a, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.top)
        return i + (e - r) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      r = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let s = n < this.viewports.length ? this.viewports[n] : null;
      if (!s || e < s.domTop)
        return r + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      r = s.bottom, i = s.domBottom;
    }
  }
}
function _o(t, e) {
  if (e.scale == 1)
    return t;
  let n = e.toDOM(t.top), r = e.toDOM(t.bottom);
  return new En(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => _o(i, e)) : t._content);
}
const ka = /* @__PURE__ */ L.define({ combine: (t) => t.join(" ") }), Vd = /* @__PURE__ */ L.define({ combine: (t) => t.indexOf(!0) > -1 }), Ud = /* @__PURE__ */ hr.newName(), Qx = /* @__PURE__ */ hr.newName(), Ex = /* @__PURE__ */ hr.newName(), Dx = { "&light": "." + Qx, "&dark": "." + Ex };
function Fd(t, e, n) {
  return new hr(e, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : t + " " + r;
    }
  });
}
const RQ = /* @__PURE__ */ Fd("." + Ud, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Dx), Co = "\uFFFF";
class ZQ {
  constructor(e, n) {
    this.points = e, this.text = "", this.lineSeparator = n.facet(re.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Co;
  }
  readRange(e, n) {
    if (!e)
      return this;
    let r = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(r, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == n)
        break;
      let l = $e.get(i), a = $e.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : L0(i)) || L0(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(e) {
    let n = e.nodeValue;
    for (let r of this.points)
      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (l = i.exec(n)) && (s = l.index, o = l[0].length), this.append(n.slice(r, s < 0 ? n.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      r = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let n = $e.get(e), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(e, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, n) {
    for (let r of this.points)
      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(e, n) {
    for (let r of this.points)
      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (IQ(e, r.node, r.offset) ? n : 0));
  }
}
function IQ(t, e, n) {
  for (; ; ) {
    if (!e || n < ur(e))
      return !1;
    if (e == t)
      return !0;
    n = Ko(e) + 1, e = e.parentNode;
  }
}
function L0(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class N0 {
  constructor(e, n) {
    this.node = e, this.offset = n, this.pos = -1;
  }
}
class LQ {
  constructor(e, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {
      let l = s || o ? [] : BQ(e), a = new ZQ(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = YQ(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !Dd(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !Dd(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset);
      this.newSel = C.single(c, a);
    }
  }
}
function Mx(t, e) {
  let n, { newSel: r } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = i.from, c = null;
    (s === 8 || q.android && e.text.length < l - o) && (a = i.to, c = "end");
    let h = qQ(t.state.doc.sliceString(o, l, Co), e.text, a - o, c);
    h && (q.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Co + Co && h.toB--, n = {
      from: o + h.from,
      to: o + h.toA,
      insert: le.of(e.text.slice(h.from, h.toB).split(Co))
    });
  } else
    r && (!t.hasFocus && t.state.facet(Lh) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))
  } : (q.mac || q.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = C.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: le.of([" "]) }) : q.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && t.lineWrapping && (r && (r = C.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: le.of([" "]) }), n) {
    if (q.ios && t.inputState.flushIOSKey() || q.android && (n.from == i.from && n.to == i.to && n.insert.length == 1 && n.insert.lines == 2 && os(t.contentDOM, "Enter", 13) || (n.from == i.from - 1 && n.to == i.to && n.insert.length == 0 || s == 8 && n.insert.length < n.to - n.from && n.to > i.head) && os(t.contentDOM, "Backspace", 8) || n.from == i.from && n.to == i.to + 1 && n.insert.length == 0 && os(t.contentDOM, "Delete", 46)))
      return !0;
    let o = n.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let l, a = () => l || (l = NQ(t, n, r));
    return t.state.facet(sx).some((c) => c(t, n.from, n.to, o, a)) || t.dispatch(a()), !0;
  } else if (r && !r.main.eq(i)) {
    let o = !1, l = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), l = t.inputState.lastSelectionOrigin), t.dispatch({ selection: r, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function NQ(t, e, n) {
  let r, i = t.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let l = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    r = i.replaceSelection(t.state.toText(l + e.insert.sliceString(0, void 0, t.state.lineBreak) + a));
  } else {
    let l = i.changes(e), a = n && n.main.to <= l.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), h, u = n && bx(t, n.main.head);
      if (u) {
        let p = e.insert.length - (e.to - e.from);
        h = { from: u.from, to: u.to - p };
      } else
        h = t.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      r = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: l, range: a || p.map(l) };
        let g = p.to - f, m = g - c.length;
        if (p.to - p.from != d || t.state.sliceDoc(m, g) != c || p.to >= h.from && p.from <= h.to)
          return { range: p };
        let O = i.changes({ from: m, to: g, insert: e.insert }), b = p.to - s.to;
        return {
          changes: O,
          range: a ? C.range(Math.max(0, a.anchor + b), Math.max(0, a.head + b)) : p.map(O)
        };
      });
    } else
      r = {
        changes: l,
        selection: a && i.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });
}
function qQ(t, e, n, r) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let o = t.length, l = e.length;
  for (; o > 0 && l > 0 && t.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (r == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    n -= o + a - s;
  }
  if (o < s && t.length < e.length) {
    let a = n <= s && n >= o ? s - n : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = n <= s && n >= l ? s - n : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function BQ(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return n && (e.push(new N0(n, r)), (i != n || s != r) && e.push(new N0(i, s))), e;
}
function YQ(t, e) {
  if (t.length == 0)
    return null;
  let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;
  return n > -1 && r > -1 ? C.single(n + e, r + e) : null;
}
const jQ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, ju = q.ie && q.ie_version <= 11;
class XQ {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new AT(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (q.ie && q.ie_version <= 11 || q.ios && e.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), ju && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {
      this.gapIntersection.disconnect();
      for (let n of e)
        this.gapIntersection.observe(n);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(Lh) ? r.root.activeElement != this.dom : !ac(r.dom, i))
      return;
    let s = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (q.ie && q.ie_version <= 11 || q.android && q.chrome) && !r.state.selection.main.empty && i.focusNode && Dc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, n = q.safari && e.root.nodeType == 11 && vT(this.dom.ownerDocument) == this.dom && WQ(this.view) || Ec(e.root);
    if (!n || this.selectionRange.eq(n))
      return !1;
    let r = ac(this.dom, n);
    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && PT(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), r && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, n) {
    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, jQ), ju && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    !this.active || (this.active = !1, this.observer.disconnect(), ju && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  delayAndroidKey(e, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && os(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: n,
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let n = -1, r = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      !o || (o.typeOver && (i = !0), n == -1 ? { from: n, to: r } = o : (n = Math.min(o.from, n), r = Math.max(o.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && ac(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new LQ(this.view, e, n, r);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = Mx(this.view, n);
    return this.view.state == r && this.view.update([]), i;
  }
  readMutation(e) {
    let n = this.view.docView.nearest(e.target);
    if (!n || n.ignoreMutation(e))
      return null;
    if (n.markDirty(e.type == "attributes"), e.type == "attributes" && (n.flags |= 4), e.type == "childList") {
      let r = q0(n, e.previousSibling || e.target.previousSibling, -1), i = q0(n, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, n, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function q0(t, e, n) {
  for (; e; ) {
    let r = $e.get(e);
    if (r && r.parent == t)
      return r;
    let i = e.parentNode;
    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function WQ(t) {
  let e = null;
  function n(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", n, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", n, !0), !e)
    return null;
  let r = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, l = t.docView.domAtPos(t.state.selection.main.anchor);
  return Dc(l.node, l.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };
}
class T {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: n } = e;
    this.dispatchTransactions = e.dispatchTransactions || n && ((r) => r.forEach((i) => n(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || $T(e.parent) || document, this.viewState = new Z0(e.state || re.create(e)), e.scrollTo && e.scrollTo.is(ga) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(vo).map((r) => new Nu(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new XQ(this), this.inputState = new oQ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new b0(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let n = e.length == 1 && e[0] instanceof je ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(n, this);
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(Ax)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = $x(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(re.phrases) != this.state.facet(re.phrases))
      return this.setState(s);
    i = Mc.create(this, s, e), i.flags |= l;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (u && (u = u.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          u = new ls(d.empty ? d : C.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(ga) && (u = d.value.clip(this.state));
      }
      this.viewState.update(i, u), this.bidiCache = Rc.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(So) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(ka) != i.state.facet(ka) && (this.viewState.mustMeasureContent = !0), (n || r || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let f of this.state.facet(qd))
        try {
          f(i);
        } catch (d) {
          Ut(this.state, d, "update listener");
        }
    (a || h) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), h && !Mx(this, h) && c.force && os(this.contentDOM, c.key, c.keyCode);
    });
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new Z0(e), this.plugins = e.facet(vo).map((r) => new Nu(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new b0(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let n = e.startState.facet(vo), r = e.state.facet(vo);
    if (n != r) {
      let i = [];
      for (let s of r) {
        let o = n.indexOf(s);
        if (o < 0)
          i.push(new Nu(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, i.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (Wk(r))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(i);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Ut(this.state, p), B0;
          }
        }), u = Mc.create(this, this.state, []), f = !1;
        u.flags |= a, n ? n.flags |= a : n = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), f = this.docView.update(u));
        for (let d = 0; d < c.length; d++)
          if (h[d] != B0)
            try {
              let p = c[d];
              p.write && p.write(h[d], this);
            } catch (p) {
              Ut(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let l of this.state.facet(qd))
        l(n);
  }
  get themeClasses() {
    return Ud + " " + (this.state.facet(Vd) ? Ex : Qx) + " " + this.state.facet(ka);
  }
  updateAttrs() {
    let e = Y0(this, cx, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Lh) ? "true" : "false",
      class: "cm-content",
      style: `${q.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), Y0(this, kg, n);
    let r = this.observer.ignore(() => {
      let i = Ld(this.contentDOM, this.contentAttrs, n), s = Ld(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = n, r;
  }
  showAnnouncements(e) {
    let n = !0;
    for (let r of e)
      for (let i of r.effects)
        if (i.is(T.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(So);
    let e = this.state.facet(T.cspNonce);
    hr.mount(this.root, this.styleModules.concat(RQ).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === e.key) {
            this.measureRequests[n] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let n = this.pluginMap.get(e);
    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, n, r) {
    return Bu(this, e, S0(this, e, n, r));
  }
  moveByGroup(e, n) {
    return Bu(this, e, S0(this, e, n, (r) => iQ(this, e.head, r)));
  }
  moveToLineBoundary(e, n, r = !0) {
    return rQ(this, e, n, r);
  }
  moveVertically(e, n, r) {
    return Bu(this, e, sQ(this, e, n, r));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, n = 0) {
    return this.docView.posFromDOM(e, n);
  }
  posAtCoords(e, n = !0) {
    return this.readMeasured(), wx(this, e, n);
  }
  coordsAtPos(e, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(e, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Tr.find(s, e - i.from, -1, n)];
    return bg(r, o.dir == De.LTR == n > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(lx) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > zQ)
      return mx(e.length);
    let n = this.textDirectionAt(e.from), r;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == n && (s.fresh || gx(s.isolates, r = O0(this, e.from, e.to))))
        return s.order;
    r || (r = O0(this, e.from, e.to));
    let i = jT(e.text, n, r);
    return this.bidiCache.push(new Rc(e.from, e.to, n, r, !0, i)), i;
  }
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || q.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      jk(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  static scrollIntoView(e, n = {}) {
    return ga.of(new ls(typeof e == "number" ? C.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);
    return ga.of(new ls(C.cursor(r.from), "start", "start", r.top - e, n, !0));
  }
  static domEventHandlers(e) {
    return ke.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return ke.define(() => ({}), { eventObservers: e });
  }
  static theme(e, n) {
    let r = hr.newName(), i = [ka.of(r), So.of(Fd(`.${r}`, e))];
    return n && n.dark && i.push(Vd.of(!0)), i;
  }
  static baseTheme(e) {
    return yn.lowest(So.of(Fd("." + Ud, e, Dx)));
  }
  static findFromDOM(e) {
    var n;
    let r = e.querySelector(".cm-content"), i = r && $e.get(r) || $e.get(e);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
T.styleModule = So;
T.inputHandler = sx;
T.focusChangeEffect = ox;
T.perLineTextDirection = lx;
T.exceptionSink = ix;
T.updateListener = qd;
T.editable = Lh;
T.mouseSelectionStyle = rx;
T.dragMovesSelection = nx;
T.clickAddsSelectionRange = tx;
T.decorations = el;
T.atomicRanges = xg;
T.bidiIsolatedRanges = hx;
T.scrollMargins = ux;
T.darkTheme = Vd;
T.cspNonce = /* @__PURE__ */ L.define({ combine: (t) => t.length ? t[0] : "" });
T.contentAttributes = kg;
T.editorAttributes = cx;
T.lineWrapping = /* @__PURE__ */ T.contentAttributes.of({ class: "cm-lineWrapping" });
T.announce = /* @__PURE__ */ G.define();
const zQ = 4096, B0 = {};
class Rc {
  constructor(e, n, r, i, s, o) {
    this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, n) {
    if (n.empty && !e.some((s) => s.fresh))
      return e;
    let r = [], i = e.length ? e[e.length - 1].dir : De.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !n.touchesRange(o.from, o.to) && r.push(new Rc(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return r;
  }
}
function Y0(t, e, n) {
  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {
    let s = r[i], o = typeof s == "function" ? s(t) : s;
    o && Id(o, n);
  }
  return n;
}
const VQ = q.mac ? "mac" : q.windows ? "win" : q.linux ? "linux" : "key";
function UQ(t, e) {
  const n = t.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, s, o, l;
  for (let a = 0; a < n.length - 1; ++a) {
    const c = n[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (r = "Alt-" + r), s && (r = "Ctrl-" + r), l && (r = "Meta-" + r), o && (r = "Shift-" + r), r;
}
function xa(t, e, n) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const FQ = /* @__PURE__ */ yn.default(/* @__PURE__ */ T.domEventHandlers({
  keydown(t, e) {
    return Zx(Rx(e.state), t, e, "editor");
  }
})), sr = /* @__PURE__ */ L.define({ enables: FQ }), j0 = /* @__PURE__ */ new WeakMap();
function Rx(t) {
  let e = t.facet(sr), n = j0.get(e);
  return n || j0.set(e, n = JQ(e.reduce((r, i) => r.concat(i), []))), n;
}
function GQ(t, e, n) {
  return Zx(Rx(t.state), e, t, n);
}
let _r = null;
const HQ = 4e3;
function JQ(t, e = VQ) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, l) => {
    let a = r[o];
    if (a == null)
      r[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, h) => {
    var u, f;
    let d = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((O) => UQ(O, e));
    for (let O = 1; O < p.length; O++) {
      let b = p.slice(0, O).join(" ");
      i(b, !0), d[b] || (d[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(y) => {
          let w = _r = { view: y, prefix: b, scope: o };
          return setTimeout(() => {
            _r == w && (_r = null);
          }, HQ), !0;
        }]
      });
    }
    let g = p.join(" ");
    i(g, !1);
    let m = d[g] || (d[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (u = d._any) === null || u === void 0 ? void 0 : u.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && m.run.push(a), c && (m.preventDefault = !0), h && (m.stopPropagation = !0);
  };
  for (let o of t) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let h = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let u in h)
          h[u].run.push(o.any);
      }
    let a = o[e] || o.key;
    if (!!a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return n;
}
function Zx(t, e, n, r) {
  let i = xT(e), s = rt(i, 0), o = Yt(s) == i.length && i != " ", l = "", a = !1, c = !1, h = !1;
  _r && _r.view == n && _r.scope == r && (l = _r.prefix + " ", xx.indexOf(e.keyCode) < 0 && (c = !0, _r = null));
  let u = /* @__PURE__ */ new Set(), f = (m) => {
    if (m) {
      for (let O of m.run)
        if (!u.has(O) && (u.add(O), O(n, e)))
          return m.stopPropagation && (h = !0), !0;
      m.preventDefault && (m.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, d = t[r], p, g;
  return d && (f(d[l + xa(i, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && !(q.windows && e.ctrlKey && e.altKey) && (p = qr[e.keyCode]) && p != i ? (f(d[l + xa(p, e, !0)]) || e.shiftKey && (g = Ho[e.keyCode]) != i && g != p && f(d[l + xa(g, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + xa(i, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && h && e.stopPropagation(), a;
}
class Nl {
  constructor(e, n, r, i, s) {
    this.className = e, this.left = n, this.top = r, this.width = i, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, n) {
    return n.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  static forRange(e, n, r) {
    if (r.empty) {
      let i = e.coordsAtPos(r.head, r.assoc || 1);
      if (!i)
        return [];
      let s = Ix(e);
      return [new Nl(n, i.left - s.left, i.top - s.top, null, i.bottom - i.top)];
    } else
      return KQ(e, n, r);
  }
}
function Ix(t) {
  let e = t.scrollDOM.getBoundingClientRect();
  return { left: (t.textDirection == De.LTR ? e.left : e.right - t.scrollDOM.clientWidth * t.scaleX) - t.scrollDOM.scrollLeft * t.scaleX, top: e.top - t.scrollDOM.scrollTop * t.scaleY };
}
function X0(t, e, n) {
  let r = C.cursor(e);
  return {
    from: Math.max(n.from, t.moveToLineBoundary(r, !1, !0).from),
    to: Math.min(n.to, t.moveToLineBoundary(r, !0, !0).from),
    type: yt.Text
  };
}
function KQ(t, e, n) {
  if (n.to <= t.viewport.from || n.from >= t.viewport.to)
    return [];
  let r = Math.max(n.from, t.viewport.from), i = Math.min(n.to, t.viewport.to), s = t.textDirection == De.LTR, o = t.contentDOM, l = o.getBoundingClientRect(), a = Ix(t), c = o.querySelector(".cm-line"), h = c && window.getComputedStyle(c), u = l.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), f = l.right - (h ? parseInt(h.paddingRight) : 0), d = Wd(t, r), p = Wd(t, i), g = d.type == yt.Text ? d : null, m = p.type == yt.Text ? p : null;
  if (g && (t.lineWrapping || d.widgetLineBreaks) && (g = X0(t, r, g)), m && (t.lineWrapping || p.widgetLineBreaks) && (m = X0(t, i, m)), g && m && g.from == m.from)
    return b(y(n.from, n.to, g));
  {
    let S = g ? y(n.from, null, g) : w(d, !1), x = m ? y(null, n.to, m) : w(p, !0), v = [];
    return (g || d).to < (m || p).from - (g && m ? 1 : 0) || d.widgetLineBreaks > 1 && S.bottom + t.defaultLineHeight / 2 < x.top ? v.push(O(u, S.bottom, f, x.top)) : S.bottom < x.top && t.elementAtHeight((S.bottom + x.top) / 2).type == yt.Text && (S.bottom = x.top = (S.bottom + x.top) / 2), b(S).concat(v).concat(b(x));
  }
  function O(S, x, v, P) {
    return new Nl(e, S - a.left, x - a.top - 0.01, v - S, P - x + 0.01);
  }
  function b({ top: S, bottom: x, horizontal: v }) {
    let P = [];
    for (let D = 0; D < v.length; D += 2)
      P.push(O(v[D], S, v[D + 1], x));
    return P;
  }
  function y(S, x, v) {
    let P = 1e9, D = -1e9, Q = [];
    function R(A, z, V, ie, ae) {
      let Te = t.coordsAtPos(A, A == v.to ? -2 : 2), Oe = t.coordsAtPos(V, V == v.from ? 2 : -2);
      !Te || !Oe || (P = Math.min(Te.top, Oe.top, P), D = Math.max(Te.bottom, Oe.bottom, D), ae == De.LTR ? Q.push(s && z ? u : Te.left, s && ie ? f : Oe.right) : Q.push(!s && ie ? u : Oe.left, !s && z ? f : Te.right));
    }
    let N = S != null ? S : v.from, F = x != null ? x : v.to;
    for (let A of t.visibleRanges)
      if (A.to > N && A.from < F)
        for (let z = Math.max(A.from, N), V = Math.min(A.to, F); ; ) {
          let ie = t.state.doc.lineAt(z);
          for (let ae of t.bidiSpans(ie)) {
            let Te = ae.from + ie.from, Oe = ae.to + ie.from;
            if (Te >= V)
              break;
            Oe > z && R(Math.max(Te, z), S == null && Te <= N, Math.min(Oe, V), x == null && Oe >= F, ae.dir);
          }
          if (z = ie.to + 1, z >= V)
            break;
        }
    return Q.length == 0 && R(N, S == null, F, x == null, t.textDirection), { top: P, bottom: D, horizontal: Q };
  }
  function w(S, x) {
    let v = l.top + (x ? S.top : S.bottom);
    return { top: v, bottom: v, horizontal: [] };
  }
}
function eE(t, e) {
  return t.constructor == e.constructor && t.eq(e);
}
class tE {
  constructor(e, n) {
    this.view = e, this.layer = n, this.drawn = [], this.scaleX = 1, this.scaleY = 1, this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), n.above && this.dom.classList.add("cm-layer-above"), n.class && this.dom.classList.add(n.class), this.scale(), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), n.mount && n.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(uc) != e.state.facet(uc) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && (this.scale(), e.view.requestMeasure(this.measureReq));
  }
  setOrder(e) {
    let n = 0, r = e.facet(uc);
    for (; n < r.length && r[n] != this.layer; )
      n++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - n);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let { scaleX: e, scaleY: n } = this.view;
    (e != this.scaleX || n != this.scaleY) && (this.scaleX = e, this.scaleY = n, this.dom.style.transform = `scale(${1 / e}, ${1 / n})`);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((n, r) => !eE(n, this.drawn[r]))) {
      let n = this.dom.firstChild, r = 0;
      for (let i of e)
        i.update && n && i.constructor && this.drawn[r].constructor && i.update(n, this.drawn[r]) ? (n = n.nextSibling, r++) : this.dom.insertBefore(i.draw(), n);
      for (; n; ) {
        let i = n.nextSibling;
        n.remove(), n = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const uc = /* @__PURE__ */ L.define();
function Lx(t) {
  return [
    ke.define((e) => new tE(e, t)),
    uc.of(t)
  ];
}
const Nx = !q.ios, nl = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, n) => Math.min(e, n),
      drawRangeCursor: (e, n) => e || n
    });
  }
});
function qx(t = {}) {
  return [
    nl.of(t),
    nE,
    rE,
    iE,
    ax.of(!0)
  ];
}
function Bx(t) {
  return t.startState.facet(nl) != t.state.facet(nl);
}
const nE = /* @__PURE__ */ Lx({
  above: !0,
  markers(t) {
    let { state: e } = t, n = e.facet(nl), r = [];
    for (let i of e.selection.ranges) {
      let s = i == e.selection.main;
      if (i.empty ? !s || Nx : n.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = i.empty ? i : C.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of Nl.forRange(t, o, l))
          r.push(a);
      }
    }
    return r;
  },
  update(t, e) {
    t.transactions.some((r) => r.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let n = Bx(t);
    return n && W0(t.state, e), t.docChanged || t.selectionSet || n;
  },
  mount(t, e) {
    W0(e.state, t);
  },
  class: "cm-cursorLayer"
});
function W0(t, e) {
  e.style.animationDuration = t.facet(nl).cursorBlinkRate + "ms";
}
const rE = /* @__PURE__ */ Lx({
  above: !1,
  markers(t) {
    return t.state.selection.ranges.map((e) => e.empty ? [] : Nl.forRange(t, "cm-selectionBackground", e)).reduce((e, n) => e.concat(n));
  },
  update(t, e) {
    return t.docChanged || t.selectionSet || t.viewportChanged || Bx(t);
  },
  class: "cm-selectionLayer"
}), Gd = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Nx && (Gd[".cm-line"].caretColor = "transparent !important", Gd[".cm-content"] = { caretColor: "transparent !important" });
const iE = /* @__PURE__ */ yn.highest(/* @__PURE__ */ T.theme(Gd)), Yx = /* @__PURE__ */ G.define({
  map(t, e) {
    return t == null ? null : e.mapPos(t);
  }
}), Ao = /* @__PURE__ */ Me.define({
  create() {
    return null;
  },
  update(t, e) {
    return t != null && (t = e.changes.mapPos(t)), e.effects.reduce((n, r) => r.is(Yx) ? r.value : n, t);
  }
}), sE = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.view = t, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(t) {
    var e;
    let n = t.state.field(Ao);
    n == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (t.startState.field(Ao) != n || t.docChanged || t.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let { view: t } = this, e = t.state.field(Ao), n = e != null && t.coordsAtPos(e);
    if (!n)
      return null;
    let r = t.scrollDOM.getBoundingClientRect();
    return {
      left: n.left - r.left + t.scrollDOM.scrollLeft * t.scaleX,
      top: n.top - r.top + t.scrollDOM.scrollTop * t.scaleY,
      height: n.bottom - n.top
    };
  }
  drawCursor(t) {
    if (this.cursor) {
      let { scaleX: e, scaleY: n } = this.view;
      t ? (this.cursor.style.left = t.left / e + "px", this.cursor.style.top = t.top / n + "px", this.cursor.style.height = t.height / n + "px") : this.cursor.style.left = "-100000px";
    }
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(t) {
    this.view.state.field(Ao) != t && this.view.dispatch({ effects: Yx.of(t) });
  }
}, {
  eventObservers: {
    dragover(t) {
      this.setDropPos(this.view.posAtCoords({ x: t.clientX, y: t.clientY }));
    },
    dragleave(t) {
      (t.target == this.view.contentDOM || !this.view.contentDOM.contains(t.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function oE() {
  return [Ao, sE];
}
function z0(t, e, n, r, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(n, r), o = n, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        i(o + l.index, l);
}
function lE(t, e) {
  let n = t.visibleRanges;
  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)
    return n;
  let r = [];
  for (let { from: i, to: s } of n)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });
  return r;
}
class aE {
  constructor(e) {
    const { regexp: n, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!n.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = n, i)
      this.addMatch = (l, a, c, h) => i(h, c, c + l[0].length, l, a);
    else if (typeof r == "function")
      this.addMatch = (l, a, c, h) => {
        let u = r(l, a, c);
        u && h(c, c + l[0].length, u);
      };
    else if (r)
      this.addMatch = (l, a, c, h) => h(c, c + l[0].length, r);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  createDeco(e) {
    let n = new et(), r = n.add.bind(n);
    for (let { from: i, to: s } of lE(e, this.maxLength))
      z0(e.state.doc, this.regexp, i, s, (o, l) => this.addMatch(l, e, o, r));
    return n.finish();
  }
  updateDeco(e, n) {
    let r = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a > e.view.viewport.from && l < e.view.viewport.to && (r = Math.min(l, r), i = Math.max(a, i));
    }), e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;
  }
  updateRange(e, n, r, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, r), l = Math.min(s.to, i);
      if (l > o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, h = Math.max(s.from, a.from), u = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              h = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              u = l;
              break;
            }
        }
        let f = [], d, p = (g, m, O) => f.push(O.range(g, m));
        if (a == c)
          for (this.regexp.lastIndex = h - a.from; (d = this.regexp.exec(a.text)) && d.index < u - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          z0(e.state.doc, this.regexp, h, u, (g, m) => this.addMatch(m, e, g, p));
        n = n.update({ filterFrom: h, filterTo: u, filter: (g, m) => g < h || m > u, add: f });
      }
    }
    return n;
  }
}
const Hd = /x/.unicode != null ? "gu" : "g", cE = /* @__PURE__ */ new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, Hd), hE = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Xu = null;
function uE() {
  var t;
  if (Xu == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Xu = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Xu || !1;
}
const fc = /* @__PURE__ */ L.define({
  combine(t) {
    let e = zn(t, {
      render: null,
      specialChars: cE,
      addSpecialChars: null
    });
    return (e.replaceTabs = !uE()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Hd)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Hd)), e;
  }
});
function jx(t = {}) {
  return [fc.of(t), fE()];
}
let V0 = null;
function fE() {
  return V0 || (V0 = ke.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = I.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(fc)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new aE({
        regexp: t.specialChars,
        decoration: (e, n, r) => {
          let { doc: i } = n.state, s = rt(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(r), l = n.state.tabSize, a = pn(o.text, l, r - o.from);
            return I.replace({
              widget: new mE((l - a % l) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = I.replace({ widget: new gE(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(fc);
      t.startState.facet(fc) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const dE = "\u2022";
function pE(t) {
  return t >= 32 ? dE : t == 10 ? "\u2424" : String.fromCharCode(9216 + t);
}
class gE extends Tt {
  constructor(e, n) {
    super(), this.options = e, this.code = n;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let n = pE(this.code), r = e.state.phrase("Control character") + " " + (hE[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = n, s.title = r, s.setAttribute("aria-label", r), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class mE extends Tt {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Xx() {
  return bE;
}
const OE = /* @__PURE__ */ I.line({ class: "cm-activeLine" }), bE = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.docChanged || t.selectionSet) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = -1, n = [];
    for (let r of t.state.selection.ranges) {
      let i = t.lineBlockAt(r.head);
      i.from > e && (n.push(OE.range(i.from)), e = i.from);
    }
    return I.set(n);
  }
}, {
  decorations: (t) => t.decorations
}), Jd = 2e3;
function yE(t, e, n) {
  let r = Math.min(e.line, n.line), i = Math.max(e.line, n.line), s = [];
  if (e.off > Jd || n.off > Jd || e.col < 0 || n.col < 0) {
    let o = Math.min(e.off, n.off), l = Math.max(e.off, n.off);
    for (let a = r; a <= i; a++) {
      let c = t.doc.line(a);
      c.length <= l && s.push(C.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, n.col), l = Math.max(e.col, n.col);
    for (let a = r; a <= i; a++) {
      let c = t.doc.line(a), h = Td(c.text, o, t.tabSize, !0);
      if (h < 0)
        s.push(C.cursor(c.to));
      else {
        let u = Td(c.text, l, t.tabSize);
        s.push(C.range(c.from + h, c.from + u));
      }
    }
  }
  return s;
}
function wE(t, e) {
  let n = t.coordsAtPos(t.viewport.from);
  return n ? Math.round(Math.abs((n.left - e) / t.defaultCharacterWidth)) : -1;
}
function U0(t, e) {
  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), r = t.state.doc.lineAt(n), i = n - r.from, s = i > Jd ? -1 : i == r.length ? wE(t, e.clientX) : pn(r.text, t.state.tabSize, n - r.from);
  return { line: r.number, col: s, off: i };
}
function kE(t, e) {
  let n = U0(t, e), r = t.state.selection;
  return n ? {
    update(i) {
      if (i.docChanged) {
        let s = i.changes.mapPos(i.startState.doc.line(n.line).from), o = i.state.doc.lineAt(s);
        n = { line: o.number, col: n.col, off: Math.min(n.off, o.length) }, r = r.map(i.changes);
      }
    },
    get(i, s, o) {
      let l = U0(t, i);
      if (!l)
        return r;
      let a = yE(t.state, n, l);
      return a.length ? o ? C.create(a.concat(r.ranges)) : C.create(a) : r;
    }
  } : null;
}
function xE(t) {
  let e = (t == null ? void 0 : t.eventFilter) || ((n) => n.altKey && n.button == 0);
  return T.mouseSelectionStyle.of((n, r) => e(r) ? kE(n, r) : null);
}
const vE = {
  Alt: [18, (t) => !!t.altKey],
  Control: [17, (t) => !!t.ctrlKey],
  Shift: [16, (t) => !!t.shiftKey],
  Meta: [91, (t) => !!t.metaKey]
}, SE = { style: "cursor: crosshair" };
function _E(t = {}) {
  let [e, n] = vE[t.key || "Alt"], r = ke.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventObservers: {
      keydown(i) {
        this.set(i.keyCode == e || n(i));
      },
      keyup(i) {
        (i.keyCode == e || !n(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(n(i));
      }
    }
  });
  return [
    r,
    T.contentAttributes.of((i) => {
      var s;
      return !((s = i.plugin(r)) === null || s === void 0) && s.isDown ? SE : null;
    })
  ];
}
const ho = "-10000px";
class Wx {
  constructor(e, n, r) {
    this.facet = n, this.createTooltipView = r, this.input = e.state.facet(n), this.tooltips = this.input.filter((i) => i), this.tooltipViews = this.tooltips.map(r);
  }
  update(e, n) {
    var r;
    let i = e.state.facet(this.facet), s = i.filter((a) => a);
    if (i === this.input) {
      for (let a of this.tooltipViews)
        a.update && a.update(e);
      return !1;
    }
    let o = [], l = n ? [] : null;
    for (let a = 0; a < s.length; a++) {
      let c = s[a], h = -1;
      if (!!c) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let f = this.tooltips[u];
          f && f.create == c.create && (h = u);
        }
        if (h < 0)
          o[a] = this.createTooltipView(c), l && (l[a] = !!c.above);
        else {
          let u = o[a] = this.tooltipViews[h];
          l && (l[a] = n[h]), u.update && u.update(e);
        }
      }
    }
    for (let a of this.tooltipViews)
      o.indexOf(a) < 0 && (a.dom.remove(), (r = a.destroy) === null || r === void 0 || r.call(a));
    return n && (l.forEach((a, c) => n[c] = a), n.length = l.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function CE(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const Wu = /* @__PURE__ */ L.define({
  combine: (t) => {
    var e, n, r;
    return {
      position: q.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || CE
    };
  }
}), F0 = /* @__PURE__ */ new WeakMap(), Sg = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Wu);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Wx(t, _g, (n) => this.createTooltip(n)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let n = e || t.geometryChanged, r = t.state.facet(Wu);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(t) {
    let e = t.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), t.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let n = document.createElement("div");
      n.className = "cm-tooltip-arrow", e.dom.appendChild(n);
    }
    return e.dom.style.position = this.position, e.dom.style.top = ho, e.dom.style.left = "0px", this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var t, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, n = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (q.gecko)
        r = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == ho && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, n = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: n } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((i, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(Wu).tooltipSpace(this.view),
      scaleX: e,
      scaleY: n,
      makeAbsolute: r
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let l of this.manager.tooltipViews)
        l.dom.style.position = "absolute";
    }
    let { editor: n, space: r, scaleX: i, scaleY: s } = t, o = [];
    for (let l = 0; l < this.manager.tooltips.length; l++) {
      let a = this.manager.tooltips[l], c = this.manager.tooltipViews[l], { dom: h } = c, u = t.pos[l], f = t.size[l];
      if (!u || u.bottom <= Math.max(n.top, r.top) || u.top >= Math.min(n.bottom, r.bottom) || u.right < Math.max(n.left, r.left) - 0.1 || u.left > Math.min(n.right, r.right) + 0.1) {
        h.style.top = ho;
        continue;
      }
      let d = a.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = d ? 7 : 0, g = f.right - f.left, m = (e = F0.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, O = c.offset || $E, b = this.view.textDirection == De.LTR, y = f.width > r.right - r.left ? b ? r.left : r.right - f.width : b ? Math.min(u.left - (d ? 14 : 0) + O.x, r.right - g) : Math.max(r.left, u.left - g + (d ? 14 : 0) - O.x), w = this.above[l];
      !a.strictSide && (w ? u.top - (f.bottom - f.top) - O.y < r.top : u.bottom + (f.bottom - f.top) + O.y > r.bottom) && w == r.bottom - u.bottom > u.top - r.top && (w = this.above[l] = !w);
      let S = (w ? u.top - r.top : r.bottom - u.bottom) - p;
      if (S < m && c.resize !== !1) {
        if (S < this.view.defaultLineHeight) {
          h.style.top = ho;
          continue;
        }
        F0.set(c, m), h.style.height = (m = S) / s + "px";
      } else
        h.style.height && (h.style.height = "");
      let x = w ? u.top - m - p - O.y : u.bottom + p + O.y, v = y + g;
      if (c.overlap !== !0)
        for (let P of o)
          P.left < v && P.right > y && P.top < x + m && P.bottom > x && (x = w ? P.top - m - 2 - p : P.bottom + p + 2);
      if (this.position == "absolute" ? (h.style.top = (x - t.parent.top) / s + "px", h.style.left = (y - t.parent.left) / i + "px") : (h.style.top = x / s + "px", h.style.left = y / i + "px"), d) {
        let P = u.left + (b ? O.x : -O.x) - (y + 14 - 7);
        d.style.left = P / i + "px";
      }
      c.overlap !== !0 && o.push({ left: y, top: x, right: v, bottom: x + m }), h.classList.toggle("cm-tooltip-above", w), h.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = ho;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), AE = /* @__PURE__ */ T.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), $E = { x: 0, y: 0 }, _g = /* @__PURE__ */ L.define({
  enables: [Sg, AE]
}), Zc = /* @__PURE__ */ L.define();
class Nh {
  static create(e) {
    return new Nh(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Wx(e, Zc, (n) => this.createHostedView(n));
  }
  createHostedView(e) {
    let n = e.create(this.view);
    return n.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(n.dom), this.mounted && n.mount && n.mount(this.view), n;
  }
  mount(e) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let n of this.manager.tooltipViews)
      (e = n.destroy) === null || e === void 0 || e.call(n);
  }
  passProp(e) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[e];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const PE = /* @__PURE__ */ _g.compute([Zc], (t) => {
  let e = t.facet(Zc).filter((n) => n);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((n) => n.pos)),
    end: Math.max(...e.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: Nh.create,
    above: e[0].above,
    arrow: e.some((n) => n.arrow)
  };
});
class TE {
  constructor(e, n, r, i, s) {
    this.view = e, this.source = n, this.field = r, this.setHover = i, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: n } = this, r = e.docView.nearest(n.target);
    if (!r)
      return;
    let i, s = 1;
    if (r instanceof Pr)
      i = r.posAtStart;
    else {
      if (i = e.posAtCoords(n), i == null)
        return;
      let l = e.coordsAtPos(i);
      if (!l || n.y < l.top || n.y > l.bottom || n.x < l.left - e.defaultCharacterWidth || n.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(i)).find((h) => h.from <= i && h.to >= i), c = a && a.dir == De.RTL ? -1 : 1;
      s = n.x < l.left ? -c : c;
    }
    let o = this.source(e, i, s);
    if (o != null && o.then) {
      let l = this.pending = { pos: i };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && e.dispatch({ effects: this.setHover.of(a) }));
      }, (a) => Ut(e.state, a, "hover tooltip"));
    } else
      o && e.dispatch({ effects: this.setHover.of(o) });
  }
  get tooltip() {
    let e = this.view.plugin(Sg), n = e ? e.manager.tooltips.findIndex((r) => r.create == Nh.create) : -1;
    return n > -1 ? e.manager.tooltipViews[n] : null;
  }
  mousemove(e) {
    var n;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: r, tooltip: i } = this;
    if (r && i && !QE(i.dom, e) || this.pending) {
      let { pos: s } = r || this.pending, o = (n = r == null ? void 0 : r.end) !== null && n !== void 0 ? n : s;
      (s == o ? this.view.posAtCoords(this.lastMove) != s : !EE(this.view, s, o, e.clientX, e.clientY)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n) {
      let { tooltip: r } = this;
      r && r.dom.contains(e.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of(null) });
    }
  }
  watchTooltipLeave(e) {
    let n = (r) => {
      e.removeEventListener("mouseleave", n), this.active && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
    };
    e.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const va = 4;
function QE(t, e) {
  let n = t.getBoundingClientRect();
  return e.clientX >= n.left - va && e.clientX <= n.right + va && e.clientY >= n.top - va && e.clientY <= n.bottom + va;
}
function EE(t, e, n, r, i, s) {
  let o = t.scrollDOM.getBoundingClientRect(), l = t.documentTop + t.documentPadding.top + t.contentHeight;
  if (o.left > r || o.right < r || o.top > i || Math.min(o.bottom, l) < i)
    return !1;
  let a = t.posAtCoords({ x: r, y: i }, !1);
  return a >= e && a <= n;
}
function DE(t, e = {}) {
  let n = G.define(), r = Me.define({
    create() {
      return null;
    },
    update(i, s) {
      if (i && (e.hideOnChange && (s.docChanged || s.selection) || e.hideOn && e.hideOn(s, i)))
        return null;
      if (i && s.docChanged) {
        let o = s.changes.mapPos(i.pos, -1, We.TrackDel);
        if (o == null)
          return null;
        let l = Object.assign(/* @__PURE__ */ Object.create(null), i);
        l.pos = o, i.end != null && (l.end = s.changes.mapPos(i.end)), i = l;
      }
      for (let o of s.effects)
        o.is(n) && (i = o.value), o.is(ME) && (i = null);
      return i;
    },
    provide: (i) => Zc.from(i)
  });
  return [
    r,
    ke.define((i) => new TE(i, t, r, n, e.hoverTime || 300)),
    PE
  ];
}
function zx(t, e) {
  let n = t.plugin(Sg);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(e);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const ME = /* @__PURE__ */ G.define(), G0 = /* @__PURE__ */ L.define({
  combine(t) {
    let e, n;
    for (let r of t)
      e = e || r.topContainer, n = n || r.bottomContainer;
    return { topContainer: e, bottomContainer: n };
  }
});
function rl(t, e) {
  let n = t.plugin(Vx), r = n ? n.specs.indexOf(e) : -1;
  return r > -1 ? n.panels[r] : null;
}
const Vx = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.input = t.state.facet(il), this.specs = this.input.filter((n) => n), this.panels = this.specs.map((n) => n(t));
    let e = t.state.facet(G0);
    this.top = new Sa(t, !0, e.topContainer), this.bottom = new Sa(t, !1, e.bottomContainer), this.top.sync(this.panels.filter((n) => n.top)), this.bottom.sync(this.panels.filter((n) => !n.top));
    for (let n of this.panels)
      n.dom.classList.add("cm-panel"), n.mount && n.mount();
  }
  update(t) {
    let e = t.state.facet(G0);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Sa(t.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Sa(t.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let n = t.state.facet(il);
    if (n != this.input) {
      let r = n.filter((a) => a), i = [], s = [], o = [], l = [];
      for (let a of r) {
        let c = this.specs.indexOf(a), h;
        c < 0 ? (h = a(t.view), l.push(h)) : (h = this.panels[c], h.update && h.update(t)), i.push(h), (h.top ? s : o).push(h);
      }
      this.specs = r, this.panels = i, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let r of this.panels)
        r.update && r.update(t);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (t) => T.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return n && { top: n.top.scrollMargin(), bottom: n.bottom.scrollMargin() };
  })
});
class Sa {
  constructor(e, n, r) {
    this.view = e, this.top = n, this.container = r, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let n of this.panels)
      n.destroy && e.indexOf(n) < 0 && n.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let n = this.container || this.view.dom;
      n.insertBefore(this.dom, this.top ? n.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let n of this.panels)
      if (n.dom.parentNode == this.dom) {
        for (; e != n.dom; )
          e = H0(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(n.dom, e);
    for (; e; )
      e = H0(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function H0(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const il = /* @__PURE__ */ L.define({
  enables: Vx
});
class Ht extends Si {
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  eq(e) {
    return !1;
  }
  destroy(e) {
  }
}
Ht.prototype.elementClass = "";
Ht.prototype.toDOM = void 0;
Ht.prototype.mapMode = We.TrackBefore;
Ht.prototype.startSide = Ht.prototype.endSide = -1;
Ht.prototype.point = !0;
const dc = /* @__PURE__ */ L.define(), RE = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => oe.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Lo = /* @__PURE__ */ L.define();
function qh(t) {
  return [Ux(), Lo.of(Object.assign(Object.assign({}, RE), t))];
}
const Kd = /* @__PURE__ */ L.define({
  combine: (t) => t.some((e) => e)
});
function Ux(t) {
  let e = [
    ZE
  ];
  return t && t.fixed === !1 && e.push(Kd.of(!0)), e;
}
const ZE = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Lo).map((e) => new K0(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(Kd), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);
      this.syncGutters(r < (n.to - n.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Kd) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let n = oe.iter(this.view.state.facet(dc), this.view.viewport.from), r = [], i = this.gutters.map((s) => new IE(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (r.length && (r = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == yt.Text && o) {
            ep(n, r, l.from);
            for (let a of i)
              a.line(this.view, l, r);
            o = !1;
          } else if (l.widget)
            for (let a of i)
              a.widget(this.view, l);
      } else if (s.type == yt.Text) {
        ep(n, r, s.from);
        for (let o of i)
          o.line(this.view, s, r);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Lo), n = t.state.facet(Lo), r = t.docChanged || t.heightChanged || t.viewportChanged || !oe.eq(t.startState.facet(dc), t.state.facet(dc), t.view.viewport.from, t.view.viewport.to);
    if (e == n)
      for (let i of this.gutters)
        i.update(t) && (r = !0);
    else {
      r = !0;
      let i = [];
      for (let s of n) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new K0(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return r;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => T.scrollMargins.of((e) => {
    let n = e.plugin(t);
    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == De.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };
  })
});
function J0(t) {
  return Array.isArray(t) ? t : [t];
}
function ep(t, e, n) {
  for (; t.value && t.from <= n; )
    t.from == n && e.push(t.value), t.next();
}
class IE {
  constructor(e, n, r) {
    this.gutter = e, this.height = r, this.i = 0, this.cursor = oe.iter(e.markers, n.from);
  }
  addElement(e, n, r) {
    let { gutter: i } = this, s = (n.top - this.height) / e.scaleY, o = n.height / e.scaleY;
    if (this.i == i.elements.length) {
      let l = new Fx(e, o, s, r);
      i.elements.push(l), i.dom.appendChild(l.dom);
    } else
      i.elements[this.i].update(e, o, s, r);
    this.height = n.bottom, this.i++;
  }
  line(e, n, r) {
    let i = [];
    ep(this.cursor, i, n.from), r.length && (i = i.concat(r));
    let s = this.gutter.config.lineMarker(e, n, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, i);
  }
  widget(e, n) {
    let r = this.gutter.config.widgetMarker(e, n.widget, n);
    r && this.addElement(e, n, [r]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let n = e.elements.pop();
      e.dom.removeChild(n.dom), n.destroy();
    }
  }
}
class K0 {
  constructor(e, n) {
    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let r in n.domEventHandlers)
      this.dom.addEventListener(r, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = i.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        n.domEventHandlers[r](e, l, i) && i.preventDefault();
      });
    this.markers = J0(n.markers(e)), n.initialSpacer && (this.spacer = new Fx(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let n = this.markers;
    if (this.markers = J0(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let r = e.view.viewport;
    return !oe.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class Fx {
  constructor(e, n, r, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, n, r, i);
  }
  update(e, n, r, i) {
    this.height != n && (this.height = n, this.dom.style.height = n + "px"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + "px" : ""), LE(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, n) {
    let r = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < n.length ? n[s++] : null, c = !1;
      if (a) {
        let h = a.elementClass;
        h && (r += " " + h);
        for (let u = o; u < this.markers.length; u++)
          if (this.markers[u].compare(a)) {
            l = u, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(i);
          let u = i.nextSibling;
          i.remove(), i = u;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && o++;
    }
    this.dom.className = r, this.markers = n;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function LE(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].compare(e[n]))
      return !1;
  return !0;
}
const NE = /* @__PURE__ */ L.define(), Ki = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, n) {
        let r = Object.assign({}, e);
        for (let i in n) {
          let s = r[i], o = n[i];
          r[i] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return r;
      }
    });
  }
});
class zu extends Ht {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Vu(t, e) {
  return t.state.facet(Ki).formatNumber(e, t.state);
}
const qE = /* @__PURE__ */ Lo.compute([Ki], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(NE);
  },
  lineMarker(e, n, r) {
    return r.some((i) => i.toDOM) ? null : new zu(Vu(e, e.state.doc.lineAt(n.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(Ki) != e.state.facet(Ki),
  initialSpacer(e) {
    return new zu(Vu(e, e1(e.state.doc.lines)));
  },
  updateSpacer(e, n) {
    let r = Vu(n.view, e1(n.view.state.doc.lines));
    return r == e.number ? e : new zu(r);
  },
  domEventHandlers: t.facet(Ki).domEventHandlers
}));
function BE(t = {}) {
  return [
    Ki.of(t),
    Ux(),
    qE
  ];
}
function e1(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const YE = /* @__PURE__ */ new class extends Ht {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), jE = /* @__PURE__ */ dc.compute(["selection"], (t) => {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.head).from;
    i > n && (n = i, e.push(YE.range(i)));
  }
  return oe.of(e);
});
function XE() {
  return jE;
}
const Gx = 1024;
let WE = 0;
class Wt {
  constructor(e, n) {
    this.from = e, this.to = n;
  }
}
class K {
  constructor(e = {}) {
    this.id = WE++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Ve.match(e)), (n) => {
      let r = e(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
K.closedBy = new K({ deserialize: (t) => t.split(" ") });
K.openedBy = new K({ deserialize: (t) => t.split(" ") });
K.group = new K({ deserialize: (t) => t.split(" ") });
K.contextHash = new K({ perNode: !0 });
K.lookAhead = new K({ perNode: !0 });
K.mounted = new K({ perNode: !0 });
class sl {
  constructor(e, n, r) {
    this.tree = e, this.overlay = n, this.parser = r;
  }
  static get(e) {
    return e && e.props && e.props[K.mounted.id];
  }
}
const zE = /* @__PURE__ */ Object.create(null);
class Ve {
  constructor(e, n, r, i = 0) {
    this.name = e, this.props = n, this.id = r, this.flags = i;
  }
  static define(e) {
    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : zE, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Ve(e.name || "", n, e.id, r);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[s[0].id] = s[1];
        }
    }
    return i;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let n = this.prop(K.group);
      return n ? n.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in e)
      for (let i of r.split(" "))
        n[i] = e[r];
    return (r) => {
      for (let i = r.prop(K.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = n[s < 0 ? r.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
Ve.none = new Ve("", /* @__PURE__ */ Object.create(null), 0, 8);
class ql {
  constructor(e) {
    this.types = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...e) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(r);
        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);
      }
      n.push(i ? new Ve(r.name, i, r.id, r.flags) : r);
    }
    return new ql(n);
  }
}
const _a = /* @__PURE__ */ new WeakMap(), t1 = /* @__PURE__ */ new WeakMap();
var ve;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(ve || (ve = {}));
class pe {
  constructor(e, n, r, i, s) {
    if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  toString() {
    let e = sl.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  cursor(e = 0) {
    return new Ic(this.topNode, e);
  }
  cursorAt(e, n = 0, r = 0) {
    let i = _a.get(this) || this.topNode, s = new Ic(i);
    return s.moveTo(e, n), _a.set(this, s._tree), s;
  }
  get topNode() {
    return new pt(this, 0, 0, null);
  }
  resolve(e, n = 0) {
    let r = ol(_a.get(this) || this.topNode, e, n, !1);
    return _a.set(this, r), r;
  }
  resolveInner(e, n = 0) {
    let r = ol(t1.get(this) || this.topNode, e, n, !0);
    return t1.set(this, r), r;
  }
  resolveStack(e, n = 0) {
    return FE(this, e, n);
  }
  iterate(e) {
    let { enter: n, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & ve.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | ve.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= i && (!l && a.type.isAnonymous || n(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && r && (l || !a.type.isAnonymous) && r(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props)
      for (let n in this.props)
        e.push([+n, this.props[n]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8 ? this : $g(Ve.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new pe(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new pe(Ve.none, n, r, i)));
  }
  static build(e) {
    return GE(e);
  }
}
pe.empty = new pe(Ve.none, [], [], 0);
class Cg {
  constructor(e, n) {
    this.buffer = e, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Cg(this.buffer, this.index);
  }
}
class Yr {
  constructor(e, n, r) {
    this.buffer = e, this.length = n, this.set = r;
  }
  get type() {
    return Ve.none;
  }
  toString() {
    let e = [];
    for (let n = 0; n < this.buffer.length; )
      e.push(this.childString(n)), n = this.buffer[n + 3];
    return e.join(",");
  }
  childString(e) {
    let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)
      return s;
    let o = [];
    for (; e < r; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  findChild(e, n, r, i, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != n && !(Hx(s, i, o[a + 1], o[a + 2]) && (l = a, r > 0)); a = o[a + 3])
      ;
    return l;
  }
  slice(e, n, r) {
    let i = this.buffer, s = new Uint16Array(n - e), o = 0;
    for (let l = e, a = 0; l < n; ) {
      s[a++] = i[l++], s[a++] = i[l++] - r;
      let c = s[a++] = i[l++] - r;
      s[a++] = i[l++] - e, o = Math.max(o, c);
    }
    return new Yr(s, o, this.set);
  }
}
function Hx(t, e, n, r) {
  switch (t) {
    case -2:
      return n < e;
    case -1:
      return r >= e && n < e;
    case 0:
      return n < e && r > e;
    case 1:
      return n <= e && r > e;
    case 2:
      return r > e;
    case 4:
      return !0;
  }
}
function ol(t, e, n, r) {
  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {
    let o = !r && t instanceof pt && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = r ? 0 : ve.IgnoreOverlays;
  if (r)
    for (let o = t, l = o.parent; l; o = l, l = o.parent)
      o instanceof pt && o.index < 0 && ((i = l.enter(e, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = l);
  for (; ; ) {
    let o = t.enter(e, n, s);
    if (!o)
      return t;
    t = o;
  }
}
class Jx {
  cursor(e = 0) {
    return new Ic(this, e);
  }
  getChild(e, n = null, r = null) {
    let i = n1(this, e, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(e, n = null, r = null) {
    return n1(this, e, n, r);
  }
  resolve(e, n = 0) {
    return ol(this, e, n, !1);
  }
  resolveInner(e, n = 0) {
    return ol(this, e, n, !0);
  }
  matchContext(e) {
    return tp(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let n = this.childBefore(e), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class pt extends Jx {
  constructor(e, n, r, i) {
    super(), this._tree = e, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, n, r, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = n > 0 ? l.length : -1; e != c; e += n) {
        let h = l[e], u = a[e] + o.from;
        if (!!Hx(i, r, u, u + h.length)) {
          if (h instanceof Yr) {
            if (s & ve.ExcludeBuffers)
              continue;
            let f = h.findChild(0, h.buffer.length, n, r - u, i);
            if (f > -1)
              return new Mn(new VE(o, h, e, u), null, f);
          } else if (s & ve.IncludeAnonymous || !h.type.isAnonymous || Ag(h)) {
            let f;
            if (!(s & ve.IgnoreMounts) && (f = sl.get(h)) && !f.overlay)
              return new pt(f.tree, u, e, o);
            let d = new pt(h, u, e, o);
            return s & ve.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(n < 0 ? h.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (s & ve.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, n, r = 0) {
    let i;
    if (!(r & ve.IgnoreOverlays) && (i = sl.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of i.overlay)
        if ((n > 0 ? o <= s : o < s) && (n < 0 ? l >= s : l > s))
          return new pt(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, n, r);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function n1(t, e, n, r) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (n != null) {
    for (; !i.type.is(n); )
      if (!i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return r == null ? s : [];
  }
}
function tp(t, e, n = e.length - 1) {
  for (let r = t.parent; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (e[n] && e[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class VE {
  constructor(e, n, r, i) {
    this.parent = e, this.buffer = n, this.index = r, this.start = i;
  }
}
class Mn extends Jx {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, n, r) {
    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];
  }
  child(e, n, r) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);
    return s < 0 ? null : new Mn(this.context, this, s);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, n, r = 0) {
    if (r & ve.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);
    return s < 0 ? null : new Mn(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context, n = e.buffer[this.index + 3];
    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Mn(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Mn(this.context, this._parent, e.findChild(n, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];
    if (s > i) {
      let o = r.buffer[this.index + 1];
      e.push(r.slice(i, s, o)), n.push(0);
    }
    return new pe(this.type, e, n, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Kx(t) {
  if (!t.length)
    return null;
  let e = 0, n = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > n.from || o.to < n.to) && (n = o, e = s);
  }
  let r = n instanceof pt && n.index < 0 ? null : n.parent, i = t.slice();
  return r ? i[e] = r : i.splice(e, 1), new UE(i, n);
}
class UE {
  constructor(e, n) {
    this.heads = e, this.node = n;
  }
  get next() {
    return Kx(this.heads);
  }
}
function FE(t, e, n) {
  let r = t.resolveInner(e, n), i = null;
  for (let s = r instanceof pt ? r : r.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [r])).push(o.resolve(e, n)), s = o;
    } else {
      let o = sl.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let l = new pt(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [r])).push(ol(l, e, n, !1));
      }
    }
  return i ? Kx(i) : r;
}
class Ic {
  get name() {
    return this.type.name;
  }
  constructor(e, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof pt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let r = e._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, n) {
    this.index = e;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof pt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, n, r = this.mode) {
    return this.buffer ? r & ve.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & ve.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & ve.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (e < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(i, this.index, -1, 0, 4));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let s = n + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {
          let l = r._tree.children[s];
          if (this.mode & ve.IncludeAnonymous || l instanceof Yr || !l.type.isAnonymous || Ag(l))
            return !1;
        }
    return !0;
  }
  move(e, n) {
    if (n && this.enterChild(e, 0, 4))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, n); )
      ;
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, n = null, r = 0;
    if (e && e.context == this.buffer) {
      e:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == i) {
              if (i == this.index)
                return o;
              n = o, r = s + 1;
              break e;
            }
          i = this.stack[--s];
        }
    }
    for (let i = r; i < this.stack.length; i++)
      n = new Mn(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Mn(this.buffer, n, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && n && n(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, i = !0;
      }
    }
  }
  matchContext(e) {
    if (!this.buffer)
      return tp(this.node, e);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return tp(this.node, e, i);
      let o = r[n.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Ag(t) {
  return t.children.some((e) => e instanceof Yr || !e.type.isAnonymous || Ag(e));
}
function GE(t) {
  var e;
  let { buffer: n, nodeSet: r, maxBufferLength: i = Gx, reused: s = [], minRepeatType: o = r.types.length } = t, l = Array.isArray(n) ? new Cg(n, n.length) : n, a = r.types, c = 0, h = 0;
  function u(S, x, v, P, D, Q) {
    let { id: R, start: N, end: F, size: A } = l, z = h;
    for (; A < 0; )
      if (l.next(), A == -1) {
        let Oe = s[R];
        v.push(Oe), P.push(N - S);
        return;
      } else if (A == -3) {
        c = R;
        return;
      } else if (A == -4) {
        h = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${A}`);
    let V = a[R], ie, ae, Te = N - S;
    if (F - N <= i && (ae = m(l.pos - x, D))) {
      let Oe = new Uint16Array(ae.size - ae.skip), ge = l.pos - ae.size, se = Oe.length;
      for (; l.pos > ge; )
        se = O(ae.start, Oe, se);
      ie = new Yr(Oe, F - ae.start, r), Te = ae.start - S;
    } else {
      let Oe = l.pos - A;
      l.next();
      let ge = [], se = [], xt = R >= o ? R : -1, fe = 0, Qt = F;
      for (; l.pos > Oe; )
        xt >= 0 && l.id == xt && l.size >= 0 ? (l.end <= Qt - i && (p(ge, se, N, fe, l.end, Qt, xt, z), fe = ge.length, Qt = l.end), l.next()) : Q > 2500 ? f(N, Oe, ge, se) : u(N, Oe, ge, se, xt, Q + 1);
      if (xt >= 0 && fe > 0 && fe < ge.length && p(ge, se, N, fe, N, Qt, xt, z), ge.reverse(), se.reverse(), xt > -1 && fe > 0) {
        let me = d(V);
        ie = $g(V, ge, se, 0, ge.length, 0, F - N, me, me);
      } else
        ie = g(V, ge, se, F - N, z - F);
    }
    v.push(ie), P.push(Te);
  }
  function f(S, x, v, P) {
    let D = [], Q = 0, R = -1;
    for (; l.pos > x; ) {
      let { id: N, start: F, end: A, size: z } = l;
      if (z > 4)
        l.next();
      else {
        if (R > -1 && F < R)
          break;
        R < 0 && (R = A - i), D.push(N, F, A), Q++, l.next();
      }
    }
    if (Q) {
      let N = new Uint16Array(Q * 4), F = D[D.length - 2];
      for (let A = D.length - 3, z = 0; A >= 0; A -= 3)
        N[z++] = D[A], N[z++] = D[A + 1] - F, N[z++] = D[A + 2] - F, N[z++] = z;
      v.push(new Yr(N, D[2] - F, r)), P.push(F - S);
    }
  }
  function d(S) {
    return (x, v, P) => {
      let D = 0, Q = x.length - 1, R, N;
      if (Q >= 0 && (R = x[Q]) instanceof pe) {
        if (!Q && R.type == S && R.length == P)
          return R;
        (N = R.prop(K.lookAhead)) && (D = v[Q] + R.length + N);
      }
      return g(S, x, v, P, D);
    };
  }
  function p(S, x, v, P, D, Q, R, N) {
    let F = [], A = [];
    for (; S.length > P; )
      F.push(S.pop()), A.push(x.pop() + v - D);
    S.push(g(r.types[R], F, A, Q - D, N - Q)), x.push(D - v);
  }
  function g(S, x, v, P, D = 0, Q) {
    if (c) {
      let R = [K.contextHash, c];
      Q = Q ? [R].concat(Q) : [R];
    }
    if (D > 25) {
      let R = [K.lookAhead, D];
      Q = Q ? [R].concat(Q) : [R];
    }
    return new pe(S, x, v, P, Q);
  }
  function m(S, x) {
    let v = l.fork(), P = 0, D = 0, Q = 0, R = v.end - i, N = { size: 0, start: 0, skip: 0 };
    e:
      for (let F = v.pos - S; v.pos > F; ) {
        let A = v.size;
        if (v.id == x && A >= 0) {
          N.size = P, N.start = D, N.skip = Q, Q += 4, P += 4, v.next();
          continue;
        }
        let z = v.pos - A;
        if (A < 0 || z < F || v.start < R)
          break;
        let V = v.id >= o ? 4 : 0, ie = v.start;
        for (v.next(); v.pos > z; ) {
          if (v.size < 0)
            if (v.size == -3)
              V += 4;
            else
              break e;
          else
            v.id >= o && (V += 4);
          v.next();
        }
        D = ie, P += A, Q += V;
      }
    return (x < 0 || P == S) && (N.size = P, N.start = D, N.skip = Q), N.size > 4 ? N : void 0;
  }
  function O(S, x, v) {
    let { id: P, start: D, end: Q, size: R } = l;
    if (l.next(), R >= 0 && P < o) {
      let N = v;
      if (R > 4) {
        let F = l.pos - (R - 4);
        for (; l.pos > F; )
          v = O(S, x, v);
      }
      x[--v] = N, x[--v] = Q - S, x[--v] = D - S, x[--v] = P;
    } else
      R == -3 ? c = P : R == -4 && (h = P);
    return v;
  }
  let b = [], y = [];
  for (; l.pos > 0; )
    u(t.start || 0, t.bufferStart || 0, b, y, -1, 0);
  let w = (e = t.length) !== null && e !== void 0 ? e : b.length ? y[0] + b[0].length : 0;
  return new pe(a[t.topID], b.reverse(), y.reverse(), w);
}
const r1 = /* @__PURE__ */ new WeakMap();
function pc(t, e) {
  if (!t.isAnonymous || e instanceof Yr || e.type != t)
    return 1;
  let n = r1.get(e);
  if (n == null) {
    n = 1;
    for (let r of e.children) {
      if (r.type != t || !(r instanceof pe)) {
        n = 1;
        break;
      }
      n += pc(t, r);
    }
    r1.set(e, n);
  }
  return n;
}
function $g(t, e, n, r, i, s, o, l, a) {
  let c = 0;
  for (let p = r; p < i; p++)
    c += pc(t, e[p]);
  let h = Math.ceil(c * 1.5 / 8), u = [], f = [];
  function d(p, g, m, O, b) {
    for (let y = m; y < O; ) {
      let w = y, S = g[y], x = pc(t, p[y]);
      for (y++; y < O; y++) {
        let v = pc(t, p[y]);
        if (x + v >= h)
          break;
        x += v;
      }
      if (y == w + 1) {
        if (x > h) {
          let v = p[w];
          d(v.children, v.positions, 0, v.children.length, g[w] + b);
          continue;
        }
        u.push(p[w]);
      } else {
        let v = g[y - 1] + p[y - 1].length - S;
        u.push($g(t, p, g, w, y, S, v, null, a));
      }
      f.push(S + b - s);
    }
  }
  return d(e, n, r, i, 0), (l || a)(u, f, o);
}
class ev {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, n, r) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(n, r);
  }
  getBuffer(e, n) {
    let r = this.map.get(e);
    return r && r.get(n);
  }
  set(e, n) {
    e instanceof Mn ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof pt && this.map.set(e.tree, n);
  }
  get(e) {
    return e instanceof Mn ? this.getBuffer(e.context.buffer, e.index) : e instanceof pt ? this.map.get(e.tree) : void 0;
  }
  cursorSet(e, n) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);
  }
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class or {
  constructor(e, n, r, i, s = !1, o = !1) {
    this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, n = [], r = !1) {
    let i = [new or(0, e.length, e, 0, !1, r)];
    for (let s of n)
      s.to > e.length && i.push(s);
    return i;
  }
  static applyChanges(e, n, r = 128) {
    if (!n.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let h = l < n.length ? n[l] : null, u = h ? h.fromA : 1e9;
      if (u - a >= r)
        for (; o && o.from < u; ) {
          let f = o;
          if (a >= f.from || u <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, u) - c;
            f = d >= p ? null : new or(d, p, f.tree, f.offset + c, l > 0, !!h);
          }
          if (f && i.push(f), o.to > u)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      a = h.toA, c = h.toA - h.toB;
    }
    return i;
  }
}
class Pg {
  startParse(e, n, r) {
    return typeof e == "string" && (e = new HE(e)), r = r ? r.length ? r.map((i) => new Wt(i.from, i.to)) : [new Wt(0, 0)] : [new Wt(0, e.length)], this.createParse(e, n || [], r);
  }
  parse(e, n, r) {
    let i = this.startParse(e, n, r);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
}
class HE {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, n) {
    return this.string.slice(e, n);
  }
}
function tv(t) {
  return (e, n, r, i) => new KE(e, t, n, r, i);
}
class i1 {
  constructor(e, n, r, i, s) {
    this.parser = e, this.parse = n, this.overlay = r, this.target = i, this.from = s;
  }
}
function s1(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class JE {
  constructor(e, n, r, i, s, o, l) {
    this.parser = e, this.predicate = n, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = l, this.depth = 0, this.ranges = [];
  }
}
const np = new K({ perNode: !0 });
class KE {
  constructor(e, n, r, i, s) {
    this.nest = n, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new pe(r.type, r.children, r.positions, r.length, r.propValues.concat([[np, this.stoppedAt]]))), r;
    }
    let e = this.inner[this.innerDone], n = e.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      r[K.mounted.id] = new sl(n, e.overlay, e.parser), e.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(e);
  }
  startInner() {
    let e = new nD(this.fragments), n = null, r = null, i = new Ic(new pt(this.baseTree, this.ranges[0].from, 0, null), ve.IncludeAnonymous | ve.IgnoreMounts);
    e:
      for (let s, o; ; ) {
        let l = !0, a;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          l = !1;
        else if (e.hasNode(i)) {
          if (n) {
            let c = n.mounts.find((h) => h.frag.from <= i.from && h.frag.to >= i.to && h.mount.overlay);
            if (c)
              for (let h of c.mount.overlay) {
                let u = h.from + c.pos, f = h.to + c.pos;
                u >= i.from && f <= i.to && !n.ranges.some((d) => d.from < f && d.to > u) && n.ranges.push({ from: u, to: f });
              }
          }
          l = !1;
        } else if (r && (o = eD(r.ranges, i.from, i.to)))
          l = o != 2;
        else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
          i.tree || tD(i);
          let c = e.findMounts(i.from, s.parser);
          if (typeof s.overlay == "function")
            n = new JE(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, n);
          else {
            let h = a1(this.ranges, s.overlay || (i.from < i.to ? [new Wt(i.from, i.to)] : []));
            h.length && s1(h), (h.length || !s.overlay) && this.inner.push(new i1(s.parser, h.length ? s.parser.startParse(this.input, c1(c, h), h) : s.parser.startParse(""), s.overlay ? s.overlay.map((u) => new Wt(u.from - i.from, u.to - i.from)) : null, i.tree, h.length ? h[0].from : i.from)), s.overlay ? h.length && (r = { ranges: h, depth: 0, prev: r }) : l = !1;
          }
        } else
          n && (a = n.predicate(i)) && (a === !0 && (a = new Wt(i.from, i.to)), a.from < a.to && n.ranges.push(a));
        if (l && i.firstChild())
          n && n.depth++, r && r.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (n && !--n.depth) {
              let c = a1(this.ranges, n.ranges);
              c.length && (s1(c), this.inner.splice(n.index, 0, new i1(n.parser, n.parser.startParse(this.input, c1(n.mounts, c), c), n.ranges.map((h) => new Wt(h.from - n.start, h.to - n.start)), n.target, c[0].from))), n = n.prev;
            }
            r && !--r.depth && (r = r.prev);
          }
      }
  }
}
function eD(t, e, n) {
  for (let r of t) {
    if (r.from >= n)
      break;
    if (r.to > e)
      return r.from <= e && r.to >= n ? 2 : 1;
  }
  return 0;
}
function o1(t, e, n, r, i, s) {
  if (e < n) {
    let o = t.buffer[e + 1];
    r.push(t.slice(e, n, o)), i.push(o - s);
  }
}
function tD(t) {
  let { node: e } = t, n = [], r = e.context.buffer;
  do
    n.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree, s = i.children.indexOf(r), o = i.children[s], l = o.buffer, a = [s];
  function c(h, u, f, d, p, g) {
    let m = n[g], O = [], b = [];
    o1(o, h, m, O, b, d);
    let y = l[m + 1], w = l[m + 2];
    a.push(O.length);
    let S = g ? c(m + 4, l[m + 3], o.set.types[l[m]], y, w - y, g - 1) : e.toTree();
    return O.push(S), b.push(y - d), o1(o, l[m + 3], u, O, b, d), new pe(f, O, b, p);
  }
  i.children[s] = c(0, l.length, Ve.none, 0, o.length, n.length - 1);
  for (let h of a) {
    let u = t.tree.children[h], f = t.tree.positions[h];
    t.yield(new pt(u, f + t.from, h, t._tree));
  }
}
class l1 {
  constructor(e, n) {
    this.offset = n, this.done = !1, this.cursor = e.cursor(ve.IncludeAnonymous | ve.IgnoreMounts);
  }
  moveTo(e) {
    let { cursor: n } = this, r = e - this.offset;
    for (; !this.done && n.from < r; )
      n.to >= e && n.enter(r, 1, ve.IgnoreOverlays | ve.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == e.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof pe)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
class nD {
  constructor(e) {
    var n;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let r = this.curFrag = e[0];
      this.curTo = (n = r.tree.prop(np)) !== null && n !== void 0 ? n : r.to, this.inner = new l1(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = n.tree.prop(np)) !== null && e !== void 0 ? e : n.to, this.inner = new l1(n.tree, -n.offset);
    }
  }
  findMounts(e, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(K.mounted);
        if (o && o.parser == n)
          for (let l = this.fragI; l < this.fragments.length; l++) {
            let a = this.fragments[l];
            if (a.from >= s.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: s.from - a.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
}
function a1(t, e) {
  let n = null, r = e;
  for (let i = 1, s = 0; i < t.length; i++) {
    let o = t[i - 1].to, l = t[i].from;
    for (; s < r.length; s++) {
      let a = r[s];
      if (a.from >= l)
        break;
      a.to <= o || (n || (r = n = e.slice()), a.from < o ? (n[s] = new Wt(a.from, o), a.to > l && n.splice(s + 1, 0, new Wt(l, a.to))) : a.to > l ? n[s--] = new Wt(l, a.to) : n.splice(s--, 1));
    }
  }
  return r;
}
function rD(t, e, n, r) {
  let i = 0, s = 0, o = !1, l = !1, a = -1e9, c = [];
  for (; ; ) {
    let h = i == t.length ? 1e9 : o ? t[i].to : t[i].from, u = s == e.length ? 1e9 : l ? e[s].to : e[s].from;
    if (o != l) {
      let f = Math.max(a, n), d = Math.min(h, u, r);
      f < d && c.push(new Wt(f, d));
    }
    if (a = Math.min(h, u), a == 1e9)
      break;
    h == a && (o ? (o = !1, i++) : o = !0), u == a && (l ? (l = !1, s++) : l = !0);
  }
  return c;
}
function c1(t, e) {
  let n = [];
  for (let { pos: r, mount: i, frag: s } of t) {
    let o = r + (i.overlay ? i.overlay[0].from : 0), l = o + i.tree.length, a = Math.max(s.from, o), c = Math.min(s.to, l);
    if (i.overlay) {
      let h = i.overlay.map((f) => new Wt(f.from + r, f.to + r)), u = rD(e, h, a, c);
      for (let f = 0, d = a; ; f++) {
        let p = f == u.length, g = p ? c : u[f].from;
        if (g > d && n.push(new or(d, g, i.tree, -o, s.from >= d || s.openStart, s.to <= g || s.openEnd)), p)
          break;
        d = u[f].to;
      }
    } else
      n.push(new or(a, c, i.tree, -o, s.from >= o || s.openStart, s.to <= l || s.openEnd));
  }
  return n;
}
let iD = 0;
class an {
  constructor(e, n, r) {
    this.set = e, this.base = n, this.modified = r, this.id = iD++;
  }
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let n = new an([], null, []);
    if (n.set.push(n), e)
      for (let r of e.set)
        n.set.push(r);
    return n;
  }
  static defineModifier() {
    let e = new Lc();
    return (n) => n.modified.indexOf(e) > -1 ? n : Lc.get(n.base || n, n.modified.concat(e).sort((r, i) => r.id - i.id));
  }
}
let sD = 0;
class Lc {
  constructor() {
    this.instances = [], this.id = sD++;
  }
  static get(e, n) {
    if (!n.length)
      return e;
    let r = n[0].instances.find((l) => l.base == e && oD(n, l.modified));
    if (r)
      return r;
    let i = [], s = new an(i, e, n);
    for (let l of n)
      l.instances.push(s);
    let o = lD(n);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          i.push(Lc.get(l, a));
    return s;
  }
}
function oD(t, e) {
  return t.length == e.length && t.every((n, r) => n == e[r]);
}
function lD(t) {
  let e = [[]];
  for (let n = 0; n < t.length; n++)
    for (let r = 0, i = e.length; r < i; r++)
      e.push(e[r].concat(t[n]));
  return e.sort((n, r) => r.length - n.length);
}
function Ws(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let s = [], o = 2, l = i;
        for (let u = 0; ; ) {
          if (l == "..." && u > 0 && u + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), u += f[0].length, u == i.length)
            break;
          let d = i[u++];
          if (u == i.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + i);
          l = i.slice(u);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let h = new Nc(r, o, a > 0 ? s.slice(0, a) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return nv.add(e);
}
const nv = new K();
class Nc {
  constructor(e, n, r, i) {
    this.tags = e, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Nc.empty = new Nc([], 2, null);
function rv(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      n[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        n[o.id] = s.class;
  let { scope: r, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let l of s)
        for (let a of l.set) {
          let c = n[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: r
  };
}
function aD(t, e) {
  let n = null;
  for (let r of t) {
    let i = r.style(e);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function cD(t, e, n, r = 0, i = t.length) {
  let s = new hD(r, Array.isArray(e) ? e : [e], n);
  s.highlightRange(t.cursor(), r, i, "", s.highlighters), s.flush(i);
}
class hD {
  constructor(e, n, r) {
    this.at = e, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(e, n) {
    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, n, r, i, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= r || a <= n)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = i, h = uD(e) || Nc.empty, u = aD(s, h.tags);
    if (u && (c && (c += " "), c += u, h.mode == 1 && (i += (i ? " " : "") + u)), this.startSpan(Math.max(n, l), c), h.opaque)
      return;
    let f = e.tree && e.tree.prop(K.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(f.tree.type)), g = e.firstChild();
      for (let m = 0, O = l; ; m++) {
        let b = m < f.overlay.length ? f.overlay[m] : null, y = b ? b.from + l : a, w = Math.max(n, O), S = Math.min(r, y);
        if (w < S && g)
          for (; e.from < S && (this.highlightRange(e, w, S, i, s), this.startSpan(Math.min(S, e.to), c), !(e.to >= y || !e.nextSibling())); )
            ;
        if (!b || y > r)
          break;
        O = b.to + l, O > n && (this.highlightRange(d.cursor(), Math.max(n, b.from + l), Math.min(r, O), "", p), this.startSpan(Math.min(r, O), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= n)) {
          if (e.from >= r)
            break;
          this.highlightRange(e, n, r, i, s), this.startSpan(Math.min(r, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function uD(t) {
  let e = t.type.prop(nv);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const M = an.define, Ca = M(), xr = M(), h1 = M(xr), u1 = M(xr), vr = M(), Aa = M(vr), Uu = M(vr), Pn = M(), ei = M(Pn), Cn = M(), An = M(), rp = M(), uo = M(rp), $a = M(), k = {
  comment: Ca,
  lineComment: M(Ca),
  blockComment: M(Ca),
  docComment: M(Ca),
  name: xr,
  variableName: M(xr),
  typeName: h1,
  tagName: M(h1),
  propertyName: u1,
  attributeName: M(u1),
  className: M(xr),
  labelName: M(xr),
  namespace: M(xr),
  macroName: M(xr),
  literal: vr,
  string: Aa,
  docString: M(Aa),
  character: M(Aa),
  attributeValue: M(Aa),
  number: Uu,
  integer: M(Uu),
  float: M(Uu),
  bool: M(vr),
  regexp: M(vr),
  escape: M(vr),
  color: M(vr),
  url: M(vr),
  keyword: Cn,
  self: M(Cn),
  null: M(Cn),
  atom: M(Cn),
  unit: M(Cn),
  modifier: M(Cn),
  operatorKeyword: M(Cn),
  controlKeyword: M(Cn),
  definitionKeyword: M(Cn),
  moduleKeyword: M(Cn),
  operator: An,
  derefOperator: M(An),
  arithmeticOperator: M(An),
  logicOperator: M(An),
  bitwiseOperator: M(An),
  compareOperator: M(An),
  updateOperator: M(An),
  definitionOperator: M(An),
  typeOperator: M(An),
  controlOperator: M(An),
  punctuation: rp,
  separator: M(rp),
  bracket: uo,
  angleBracket: M(uo),
  squareBracket: M(uo),
  paren: M(uo),
  brace: M(uo),
  content: Pn,
  heading: ei,
  heading1: M(ei),
  heading2: M(ei),
  heading3: M(ei),
  heading4: M(ei),
  heading5: M(ei),
  heading6: M(ei),
  contentSeparator: M(Pn),
  list: M(Pn),
  quote: M(Pn),
  emphasis: M(Pn),
  strong: M(Pn),
  link: M(Pn),
  monospace: M(Pn),
  strikethrough: M(Pn),
  inserted: M(),
  deleted: M(),
  changed: M(),
  invalid: M(),
  meta: $a,
  documentMeta: M($a),
  annotation: M($a),
  processingInstruction: M($a),
  definition: an.defineModifier(),
  constant: an.defineModifier(),
  function: an.defineModifier(),
  standard: an.defineModifier(),
  local: an.defineModifier(),
  special: an.defineModifier()
};
rv([
  { tag: k.link, class: "tok-link" },
  { tag: k.heading, class: "tok-heading" },
  { tag: k.emphasis, class: "tok-emphasis" },
  { tag: k.strong, class: "tok-strong" },
  { tag: k.keyword, class: "tok-keyword" },
  { tag: k.atom, class: "tok-atom" },
  { tag: k.bool, class: "tok-bool" },
  { tag: k.url, class: "tok-url" },
  { tag: k.labelName, class: "tok-labelName" },
  { tag: k.inserted, class: "tok-inserted" },
  { tag: k.deleted, class: "tok-deleted" },
  { tag: k.literal, class: "tok-literal" },
  { tag: k.string, class: "tok-string" },
  { tag: k.number, class: "tok-number" },
  { tag: [k.regexp, k.escape, k.special(k.string)], class: "tok-string2" },
  { tag: k.variableName, class: "tok-variableName" },
  { tag: k.local(k.variableName), class: "tok-variableName tok-local" },
  { tag: k.definition(k.variableName), class: "tok-variableName tok-definition" },
  { tag: k.special(k.variableName), class: "tok-variableName2" },
  { tag: k.definition(k.propertyName), class: "tok-propertyName tok-definition" },
  { tag: k.typeName, class: "tok-typeName" },
  { tag: k.namespace, class: "tok-namespace" },
  { tag: k.className, class: "tok-className" },
  { tag: k.macroName, class: "tok-macroName" },
  { tag: k.propertyName, class: "tok-propertyName" },
  { tag: k.operator, class: "tok-operator" },
  { tag: k.comment, class: "tok-comment" },
  { tag: k.meta, class: "tok-meta" },
  { tag: k.invalid, class: "tok-invalid" },
  { tag: k.punctuation, class: "tok-punctuation" }
]);
var Fu;
const fi = /* @__PURE__ */ new K();
function Tg(t) {
  return L.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const Qg = /* @__PURE__ */ new K();
class zt {
  constructor(e, n, r = [], i = "") {
    this.data = e, this.name = i, re.prototype.hasOwnProperty("tree") || Object.defineProperty(re.prototype, "tree", { get() {
      return Se(this);
    } }), this.parser = n, this.extension = [
      jr.of(this),
      re.languageData.of((s, o, l) => {
        let a = f1(s, o, l), c = a.type.prop(fi);
        if (!c)
          return [];
        let h = s.facet(c), u = a.type.prop(Qg);
        if (u) {
          let f = a.resolve(o - a.from, l);
          for (let d of u)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(r);
  }
  isActiveAt(e, n, r = -1) {
    return f1(e, n, r).type.prop(fi) == this.data;
  }
  findRegions(e) {
    let n = e.facet(jr);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (s, o) => {
      if (s.prop(fi) == this.data) {
        r.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(K.mounted);
      if (l) {
        if (l.tree.prop(fi) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              r.push({ from: a.from + o, to: a.to + o });
          else
            r.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = r.length;
          if (i(l.tree, l.overlay[0].from + o), r.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof pe && i(c, s.positions[a] + o);
      }
    };
    return i(Se(e), 0), r;
  }
  get allowsNesting() {
    return !0;
  }
}
zt.setState = /* @__PURE__ */ G.define();
function f1(t, e, n) {
  let r = t.facet(jr), i = Se(t).topNode;
  if (!r || r.allowsNesting)
    for (let s = i; s; s = s.enter(e, n, ve.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class Cs extends zt {
  constructor(e, n, r) {
    super(e, n, [], r), this.parser = n;
  }
  static define(e) {
    let n = Tg(e.languageData);
    return new Cs(n, e.parser.configure({
      props: [fi.add((r) => r.isTop ? n : void 0)]
    }), e.name);
  }
  configure(e, n) {
    return new Cs(this.data, this.parser.configure(e), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Se(t) {
  let e = t.field(zt.state, !1);
  return e ? e.tree : pe.empty;
}
class fD {
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, n) {
    let r = this.cursorPos - this.string.length;
    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);
  }
}
let fo = null;
class ll {
  constructor(e, n, r = [], i, s, o, l, a) {
    this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  static create(e, n, r) {
    return new ll(e, n, [], pe.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new fD(this.state.doc), this.fragments);
  }
  work(e, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != pe.empty && this.isDone(n != null ? n : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(or.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n != null ? n : this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  takeTree() {
    let e, n;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(or.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let n = fo;
    fo = this;
    try {
      return e();
    } finally {
      fo = n;
    }
  }
  withoutTempSkipped(e) {
    for (let n; n = this.tempSkipped.pop(); )
      e = d1(e, n.from, n.to);
    return e;
  }
  changes(e, n) {
    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, h, u, f) => a.push({ fromA: c, toA: h, fromB: u, toB: f })), r = or.applyChanges(r, a), i = pe.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), u = e.mapPos(c.to, -1);
          h < u && l.push({ from: h, to: u });
        }
      }
    }
    return new ll(this.parser, n, r, i, s, o, l, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: s } = this.skipped[r];
      i < e.to && s > e.from && (this.fragments = d1(this.fragments, i, s), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  skipUntilInView(e, n) {
    this.skipped.push({ from: e, to: n });
  }
  static getSkippingParser(e) {
    return new class extends Pg {
      createParse(n, r, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = fo;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new pe(Ve.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;
  }
  static get() {
    return fo;
  }
}
function d1(t, e, n) {
  return or.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);
}
class As {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new As(n);
  }
  static init(e) {
    let n = Math.min(3e3, e.doc.length), r = ll.create(e.facet(jr).parser, e, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new As(r);
  }
}
zt.state = /* @__PURE__ */ Me.define({
  create: As.init,
  update(t, e) {
    for (let n of e.effects)
      if (n.is(zt.setState))
        return n.value;
    return e.startState.facet(jr) != e.state.facet(jr) ? As.init(e.state) : t.apply(e);
  }
});
let iv = (t) => {
  let e = setTimeout(() => t(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (iv = (t) => {
  let e = -1, n = setTimeout(() => {
    e = requestIdleCallback(t, { timeout: 500 - 100 });
  }, 100);
  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);
});
const Gu = typeof navigator < "u" && ((Fu = navigator.scheduling) === null || Fu === void 0 ? void 0 : Fu.isInputPending) ? () => navigator.scheduling.isInputPending() : null, dD = /* @__PURE__ */ ke.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let n = this.view.state.field(zt.state).context;
    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, n = e.field(zt.state);
    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = iv(this.work));
  }
  work(e) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, s = r.field(zt.state);
    if (s.tree == s.context.tree && s.context.isDone(i + 1e5))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Gu ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < i && r.doc.length > i + 1e3, a = s.context.work(() => Gu && Gu() || Date.now() > o, i + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: zt.setState.of(new As(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => Ut(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), jr = /* @__PURE__ */ L.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    zt.state,
    dD,
    T.contentAttributes.compute([t], (e) => {
      let n = e.facet(t);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class al {
  constructor(e, n = []) {
    this.language = e, this.support = n, this.extension = [e, n];
  }
}
class qc {
  constructor(e, n, r, i, s, o = void 0) {
    this.name = e, this.alias = n, this.extensions = r, this.filename = i, this.loadFunc = s, this.support = o, this.loading = null;
  }
  load() {
    return this.loading || (this.loading = this.loadFunc().then((e) => this.support = e, (e) => {
      throw this.loading = null, e;
    }));
  }
  static of(e) {
    let { load: n, support: r } = e;
    if (!n) {
      if (!r)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      n = () => Promise.resolve(r);
    }
    return new qc(e.name, (e.alias || []).concat(e.name).map((i) => i.toLowerCase()), e.extensions || [], e.filename, n, r);
  }
  static matchFilename(e, n) {
    for (let i of e)
      if (i.filename && i.filename.test(n))
        return i;
    let r = /\.([^.]+)$/.exec(n);
    if (r) {
      for (let i of e)
        if (i.extensions.indexOf(r[1]) > -1)
          return i;
    }
    return null;
  }
  static matchLanguageName(e, n, r = !0) {
    n = n.toLowerCase();
    for (let i of e)
      if (i.alias.some((s) => s == n))
        return i;
    if (r)
      for (let i of e)
        for (let s of i.alias) {
          let o = n.indexOf(s);
          if (o > -1 && (s.length > 2 || !/\w/.test(n[o - 1]) && !/\w/.test(n[o + s.length])))
            return i;
        }
    return null;
  }
}
const pD = /* @__PURE__ */ L.define(), Bl = /* @__PURE__ */ L.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((n) => n != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function Bc(t) {
  let e = t.facet(Bl);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function cl(t, e) {
  let n = "", r = t.tabSize, i = t.facet(Bl)[0];
  if (i == "	") {
    for (; e >= r; )
      n += "	", e -= r;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    n += i;
  return n;
}
function Eg(t, e) {
  t instanceof re && (t = new Bh(t));
  for (let r of t.state.facet(pD)) {
    let i = r(t, e);
    if (i !== void 0)
      return i;
  }
  let n = Se(t.state);
  return n.length >= e ? gD(t, n, e) : null;
}
class Bh {
  constructor(e, n = {}) {
    this.state = e, this.options = n, this.unit = Bc(e);
  }
  lineAt(e, n = 1) {
    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: "", from: e } : (n < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;
  }
  textAfterPos(e, n = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: r, from: i } = this.lineAt(e, n);
    return r.slice(e - i, Math.min(r.length, e + 100 - i));
  }
  column(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(r, r.search(/\S|$/))), s;
  }
  countColumn(e, n = e.length) {
    return pn(e, this.state.tabSize, n);
  }
  lineIndent(e, n = 1) {
    let { text: r, from: i } = this.lineAt(e, n), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(r, r.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Yl = /* @__PURE__ */ new K();
function gD(t, e, n) {
  let r = e.resolveStack(n), i = r.node.enterUnfinishedNodesBefore(n);
  if (i != r.node) {
    let s = [];
    for (let o = i; o != r.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      r = { node: s[o], next: r };
  }
  return sv(r, t, n);
}
function sv(t, e, n) {
  for (let r = t; r; r = r.next) {
    let i = OD(r.node);
    if (i)
      return i(Dg.create(e, n, r));
  }
  return 0;
}
function mD(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function OD(t) {
  let e = t.type.prop(Yl);
  if (e)
    return e;
  let n = t.firstChild, r;
  if (n && (r = n.type.prop(K.closedBy))) {
    let i = t.lastChild, s = i && r.indexOf(i.name) > -1;
    return (o) => ov(o, !0, 1, void 0, s && !mD(o) ? i.from : void 0);
  }
  return t.parent == null ? bD : null;
}
function bD() {
  return 0;
}
class Dg extends Bh {
  constructor(e, n, r) {
    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;
  }
  get node() {
    return this.context.node;
  }
  static create(e, n, r) {
    return new Dg(e, n, r);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let n = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let r = e.resolve(n.from);
      for (; r.parent && r.parent.from == r.from; )
        r = r.parent;
      if (yD(r, e))
        break;
      n = this.state.doc.lineAt(r.from);
    }
    return this.lineIndent(n.from);
  }
  continue() {
    return sv(this.context.next, this.base, this.pos);
  }
}
function yD(t, e) {
  for (let n = e; n; n = n.parent)
    if (t == n)
      return !0;
  return !1;
}
function wD(t) {
  let e = t.node, n = e.childAfter(e.from), r = e.lastChild;
  if (!n)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(n.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let l = n.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == r)
      return null;
    if (!a.type.isSkipped)
      return a.from < o ? n : null;
    l = a.to;
  }
}
function kD({ closing: t, align: e = !0, units: n = 1 }) {
  return (r) => ov(r, e, n, t);
}
function ov(t, e, n, r, i) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, l = r && s.slice(o, o + r.length) == r || i == t.pos + o, a = e ? wD(t) : null;
  return a ? l ? t.column(a.from) : t.column(a.to) : t.baseIndent + (l ? 0 : t.unit * n);
}
const xD = (t) => t.baseIndent;
function gc({ except: t, units: e = 1 } = {}) {
  return (n) => {
    let r = t && t.test(n.textAfter);
    return n.baseIndent + (r ? 0 : e * n.unit);
  };
}
const vD = 200;
function SD() {
  return re.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);
    if (r > i.from + vD)
      return t;
    let s = n.sliceString(i.from, r);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: o } = t, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let h = o.doc.lineAt(c);
      if (h.from == l)
        continue;
      l = h.from;
      let u = Eg(o, h.from);
      if (u == null)
        continue;
      let f = /^\s*/.exec(h.text)[0], d = cl(o, u);
      f != d && a.push({ from: h.from, to: h.from + f.length, insert: d });
    }
    return a.length ? [t, { changes: a, sequential: !0 }] : t;
  });
}
const lv = /* @__PURE__ */ L.define(), zs = /* @__PURE__ */ new K();
function av(t) {
  let e = t.firstChild, n = t.lastChild;
  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;
}
function _D(t, e, n) {
  let r = Se(t);
  if (r.length < n)
    return null;
  let i = r.resolveStack(n, 1), s = null;
  for (let o = i; o; o = o.next) {
    let l = o.node;
    if (l.to <= n || l.from > n)
      continue;
    if (s && l.from < e)
      break;
    let a = l.type.prop(zs);
    if (a && (l.to < r.length - 50 || r.length == t.doc.length || !CD(l))) {
      let c = a(l, t);
      c && c.from <= n && c.from >= e && c.to > n && (s = c);
    }
  }
  return s;
}
function CD(t) {
  let e = t.lastChild;
  return e && e.to == t.to && e.type.isError;
}
function Yc(t, e, n) {
  for (let r of t.facet(lv)) {
    let i = r(t, e, n);
    if (i)
      return i;
  }
  return _D(t, e, n);
}
function cv(t, e) {
  let n = e.mapPos(t.from, 1), r = e.mapPos(t.to, -1);
  return n >= r ? void 0 : { from: n, to: r };
}
const Yh = /* @__PURE__ */ G.define({ map: cv }), jl = /* @__PURE__ */ G.define({ map: cv });
function hv(t) {
  let e = [];
  for (let { head: n } of t.state.selection.ranges)
    e.some((r) => r.from <= n && r.to >= n) || e.push(t.lineBlockAt(n));
  return e;
}
const Ci = /* @__PURE__ */ Me.define({
  create() {
    return I.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      if (n.is(Yh) && !AD(t, n.value.from, n.value.to)) {
        let { preparePlaceholder: r } = e.state.facet(Mg), i = r ? I.replace({ widget: new MD(r(e.state, n.value)) }) : p1;
        t = t.update({ add: [i.range(n.value.from, n.value.to)] });
      } else
        n.is(jl) && (t = t.update({
          filter: (r, i) => n.value.from != r || n.value.to != i,
          filterFrom: n.value.from,
          filterTo: n.value.to
        }));
    if (e.selection) {
      let n = !1, { head: r } = e.selection.main;
      t.between(r, r, (i, s) => {
        i < r && s > r && (n = !0);
      }), n && (t = t.update({
        filterFrom: r,
        filterTo: r,
        filter: (i, s) => s <= r || i >= r
      }));
    }
    return t;
  },
  provide: (t) => T.decorations.from(t),
  toJSON(t, e) {
    let n = [];
    return t.between(0, e.doc.length, (r, i) => {
      n.push(r, i);
    }), n;
  },
  fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let n = 0; n < t.length; ) {
      let r = t[n++], i = t[n++];
      if (typeof r != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(p1.range(r, i));
    }
    return I.set(e, !0);
  }
});
function jc(t, e, n) {
  var r;
  let i = null;
  return (r = t.field(Ci, !1)) === null || r === void 0 || r.between(e, n, (s, o) => {
    (!i || i.from > s) && (i = { from: s, to: o });
  }), i;
}
function AD(t, e, n) {
  let r = !1;
  return t.between(e, e, (i, s) => {
    i == e && s == n && (r = !0);
  }), r;
}
function uv(t, e) {
  return t.field(Ci, !1) ? e : e.concat(G.appendConfig.of(dv()));
}
const $D = (t) => {
  for (let e of hv(t)) {
    let n = Yc(t.state, e.from, e.to);
    if (n)
      return t.dispatch({ effects: uv(t.state, [Yh.of(n), fv(t, n)]) }), !0;
  }
  return !1;
}, PD = (t) => {
  if (!t.state.field(Ci, !1))
    return !1;
  let e = [];
  for (let n of hv(t)) {
    let r = jc(t.state, n.from, n.to);
    r && e.push(jl.of(r), fv(t, r, !1));
  }
  return e.length && t.dispatch({ effects: e }), e.length > 0;
};
function fv(t, e, n = !0) {
  let r = t.state.doc.lineAt(e.from).number, i = t.state.doc.lineAt(e.to).number;
  return T.announce.of(`${t.state.phrase(n ? "Folded lines" : "Unfolded lines")} ${r} ${t.state.phrase("to")} ${i}.`);
}
const TD = (t) => {
  let { state: e } = t, n = [];
  for (let r = 0; r < e.doc.length; ) {
    let i = t.lineBlockAt(r), s = Yc(e, i.from, i.to);
    s && n.push(Yh.of(s)), r = (s ? t.lineBlockAt(s.to) : i).to + 1;
  }
  return n.length && t.dispatch({ effects: uv(t.state, n) }), !!n.length;
}, QD = (t) => {
  let e = t.state.field(Ci, !1);
  if (!e || !e.size)
    return !1;
  let n = [];
  return e.between(0, t.state.doc.length, (r, i) => {
    n.push(jl.of({ from: r, to: i }));
  }), t.dispatch({ effects: n }), !0;
}, ED = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: $D },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: PD },
  { key: "Ctrl-Alt-[", run: TD },
  { key: "Ctrl-Alt-]", run: QD }
], DD = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
}, Mg = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, DD);
  }
});
function dv(t) {
  let e = [Ci, ID];
  return t && e.push(Mg.of(t)), e;
}
function pv(t, e) {
  let { state: n } = t, r = n.facet(Mg), i = (o) => {
    let l = t.lineBlockAt(t.posAtDOM(o.target)), a = jc(t.state, l.from, l.to);
    a && t.dispatch({ effects: jl.of(a) }), o.preventDefault();
  };
  if (r.placeholderDOM)
    return r.placeholderDOM(t, i, e);
  let s = document.createElement("span");
  return s.textContent = r.placeholderText, s.setAttribute("aria-label", n.phrase("folded code")), s.title = n.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = i, s;
}
const p1 = /* @__PURE__ */ I.replace({ widget: /* @__PURE__ */ new class extends Tt {
  toDOM(t) {
    return pv(t, null);
  }
}() });
class MD extends Tt {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return pv(e, this.value);
  }
}
const RD = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Hu extends Ht {
  constructor(e, n) {
    super(), this.config = e, this.open = n;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let n = document.createElement("span");
    return n.textContent = this.open ? this.config.openText : this.config.closedText, n.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), n;
  }
}
function ZD(t = {}) {
  let e = Object.assign(Object.assign({}, RD), t), n = new Hu(e, !0), r = new Hu(e, !1), i = ke.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(jr) != o.state.facet(jr) || o.startState.field(Ci, !1) != o.state.field(Ci, !1) || Se(o.startState) != Se(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new et();
      for (let a of o.viewportLineBlocks) {
        let c = jc(o.state, a.from, a.to) ? r : Yc(o.state, a.from, a.to) ? n : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    i,
    qh({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(i)) === null || l === void 0 ? void 0 : l.markers) || oe.empty;
      },
      initialSpacer() {
        return new Hu(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, l, a) => {
        if (s.click && s.click(o, l, a))
          return !0;
        let c = jc(o.state, l.from, l.to);
        if (c)
          return o.dispatch({ effects: jl.of(c) }), !0;
        let h = Yc(o.state, l.from, l.to);
        return h ? (o.dispatch({ effects: Yh.of(h) }), !0) : !1;
      } })
    }),
    dv()
  ];
}
const ID = /* @__PURE__ */ T.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class jh {
  constructor(e, n) {
    this.specs = e;
    let r;
    function i(l) {
      let a = hr.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, o = n.scope;
    this.scope = o instanceof zt ? (l) => l.prop(fi) == o.data : o ? (l) => l == o : void 0, this.style = rv(e.map((l) => ({
      tag: l.tag,
      class: l.class || i(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = r ? new hr(r) : null, this.themeType = n.themeType;
  }
  static define(e, n) {
    return new jh(e, n || {});
  }
}
const ip = /* @__PURE__ */ L.define(), gv = /* @__PURE__ */ L.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Ju(t) {
  let e = t.facet(ip);
  return e.length ? e : t.facet(gv);
}
function mv(t, e) {
  let n = [ND], r;
  return t instanceof jh && (t.module && n.push(T.styleModule.of(t.module)), r = t.themeType), e != null && e.fallback ? n.push(gv.of(t)) : r ? n.push(ip.computeN([T.darkTheme], (i) => i.facet(T.darkTheme) == (r == "dark") ? [t] : [])) : n.push(ip.of(t)), n;
}
class LD {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Se(e.state), this.decorations = this.buildDeco(e, Ju(e.state));
  }
  update(e) {
    let n = Se(e.state), r = Ju(e.state), i = r != Ju(e.startState);
    n.length < e.view.viewport.to && !i && n.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r));
  }
  buildDeco(e, n) {
    if (!n || !this.tree.length)
      return I.none;
    let r = new et();
    for (let { from: i, to: s } of e.visibleRanges)
      cD(this.tree, n, (o, l, a) => {
        r.add(o, l, this.markCache[a] || (this.markCache[a] = I.mark({ class: a })));
      }, i, s);
    return r.finish();
  }
}
const ND = /* @__PURE__ */ yn.high(/* @__PURE__ */ ke.fromClass(LD, {
  decorations: (t) => t.decorations
})), Ov = /* @__PURE__ */ jh.define([
  {
    tag: k.meta,
    color: "#404740"
  },
  {
    tag: k.link,
    textDecoration: "underline"
  },
  {
    tag: k.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: k.emphasis,
    fontStyle: "italic"
  },
  {
    tag: k.strong,
    fontWeight: "bold"
  },
  {
    tag: k.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: k.keyword,
    color: "#708"
  },
  {
    tag: [k.atom, k.bool, k.url, k.contentSeparator, k.labelName],
    color: "#219"
  },
  {
    tag: [k.literal, k.inserted],
    color: "#164"
  },
  {
    tag: [k.string, k.deleted],
    color: "#a11"
  },
  {
    tag: [k.regexp, k.escape, /* @__PURE__ */ k.special(k.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ k.definition(k.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ k.local(k.variableName),
    color: "#30a"
  },
  {
    tag: [k.typeName, k.namespace],
    color: "#085"
  },
  {
    tag: k.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ k.special(k.variableName), k.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ k.definition(k.propertyName),
    color: "#00c"
  },
  {
    tag: k.comment,
    color: "#940"
  },
  {
    tag: k.invalid,
    color: "#f00"
  }
]), qD = /* @__PURE__ */ T.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), bv = 1e4, yv = "()[]{}", wv = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, {
      afterCursor: !0,
      brackets: yv,
      maxScanDistance: bv,
      renderMatch: jD
    });
  }
}), BD = /* @__PURE__ */ I.mark({ class: "cm-matchingBracket" }), YD = /* @__PURE__ */ I.mark({ class: "cm-nonmatchingBracket" });
function jD(t) {
  let e = [], n = t.matched ? BD : YD;
  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;
}
const XD = /* @__PURE__ */ Me.define({
  create() {
    return I.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let n = [], r = e.state.facet(wv);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = Rn(e.state, i.head, -1, r) || i.head > 0 && Rn(e.state, i.head - 1, 1, r) || r.afterCursor && (Rn(e.state, i.head, 1, r) || i.head < e.state.doc.length && Rn(e.state, i.head + 1, -1, r));
      s && (n = n.concat(r.renderMatch(s, e.state)));
    }
    return I.set(n, !0);
  },
  provide: (t) => T.decorations.from(t)
}), WD = [
  XD,
  qD
];
function zD(t = {}) {
  return [wv.of(t), WD];
}
const kv = /* @__PURE__ */ new K();
function sp(t, e, n) {
  let r = t.prop(e < 0 ? K.openedBy : K.closedBy);
  if (r)
    return r;
  if (t.name.length == 1) {
    let i = n.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [n[i + e]];
  }
  return null;
}
function op(t) {
  let e = t.type.prop(kv);
  return e ? e(t.node) : t;
}
function Rn(t, e, n, r = {}) {
  let i = r.maxScanDistance || bv, s = r.brackets || yv, o = Se(t), l = o.resolveInner(e, n);
  for (let a = l; a; a = a.parent) {
    let c = sp(a.type, n, s);
    if (c && a.from < a.to) {
      let h = op(a);
      if (h && (n > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return VD(t, e, n, a, h, c, s);
    }
  }
  return UD(t, e, n, o, l.type, i, s);
}
function VD(t, e, n, r, i, s, o) {
  let l = r.parent, a = { from: i.from, to: i.to }, c = 0, h = l == null ? void 0 : l.cursor();
  if (h && (n < 0 ? h.childBefore(r.from) : h.childAfter(r.to)))
    do
      if (n < 0 ? h.to <= r.from : h.from >= r.to) {
        if (c == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let u = op(h);
          return { start: a, end: u ? { from: u.from, to: u.to } : void 0, matched: !0 };
        } else if (sp(h.type, n, o))
          c++;
        else if (sp(h.type, -n, o)) {
          if (c == 0) {
            let u = op(h);
            return {
              start: a,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (n < 0 ? h.prevSibling() : h.nextSibling());
  return { start: a, matched: !1 };
}
function UD(t, e, n, r, i, s, o) {
  let l = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != n > 0)
    return null;
  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, h = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), u = 0;
  for (let f = 0; !h.next().done && f <= s; ) {
    let d = h.value;
    n < 0 && (f += d.length);
    let p = e + f * n;
    for (let g = n > 0 ? 0 : d.length - 1, m = n > 0 ? d.length : -1; g != m; g += n) {
      let O = o.indexOf(d[g]);
      if (!(O < 0 || r.resolveInner(p + g, 1).type != i))
        if (O % 2 == 0 == n > 0)
          u++;
        else {
          if (u == 1)
            return { start: c, end: { from: p + g, to: p + g + 1 }, matched: O >> 1 == a >> 1 };
          u--;
        }
    }
    n > 0 && (f += d.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const FD = /* @__PURE__ */ Object.create(null), g1 = [Ve.none], m1 = [], O1 = /* @__PURE__ */ Object.create(null), GD = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  GD[t] = /* @__PURE__ */ HD(FD, e);
function Ku(t, e) {
  m1.indexOf(t) > -1 || (m1.push(t), console.warn(e));
}
function HD(t, e) {
  let n = [];
  for (let l of e.split(" ")) {
    let a = [];
    for (let c of l.split(".")) {
      let h = t[c] || k[c];
      h ? typeof h == "function" ? a.length ? a = a.map(h) : Ku(c, `Modifier ${c} used at start of tag`) : a.length ? Ku(c, `Tag ${c} used as modifier`) : a = Array.isArray(h) ? h : [h] : Ku(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of a)
      n.push(c);
  }
  if (!n.length)
    return 0;
  let r = e.replace(/ /g, "_"), i = r + " " + n.map((l) => l.id), s = O1[i];
  if (s)
    return s.id;
  let o = O1[i] = Ve.define({
    id: g1.length,
    name: r,
    props: [Ws({ [r]: n })]
  });
  return g1.push(o), o.id;
}
const JD = (t) => {
  let { state: e } = t, n = e.doc.lineAt(e.selection.main.from), r = Zg(t.state, n.from);
  return r.line ? KD(t) : r.block ? tM(t) : !1;
};
function Rg(t, e) {
  return ({ state: n, dispatch: r }) => {
    if (n.readOnly)
      return !1;
    let i = t(e, n);
    return i ? (r(n.update(i)), !0) : !1;
  };
}
const KD = /* @__PURE__ */ Rg(iM, 0), eM = /* @__PURE__ */ Rg(xv, 0), tM = /* @__PURE__ */ Rg((t, e) => xv(t, e, rM(e)), 0);
function Zg(t, e) {
  let n = t.languageDataAt("commentTokens", e);
  return n.length ? n[0] : {};
}
const po = 50;
function nM(t, { open: e, close: n }, r, i) {
  let s = t.sliceDoc(r - po, r), o = t.sliceDoc(i, i + po), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + n.length) == n)
    return {
      open: { pos: r - l, margin: l && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let h, u;
  i - r <= 2 * po ? h = u = t.sliceDoc(r, i) : (h = t.sliceDoc(r, r + po), u = t.sliceDoc(i - po, i));
  let f = /^\s*/.exec(h)[0].length, d = /\s*$/.exec(u)[0].length, p = u.length - d - n.length;
  return h.slice(f, f + e.length) == e && u.slice(p, p + n.length) == n ? {
    open: {
      pos: r + f + e.length,
      margin: /\s/.test(h.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: i - d - n.length,
      margin: /\s/.test(u.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function rM(t) {
  let e = [];
  for (let n of t.selection.ranges) {
    let r = t.doc.lineAt(n.from), i = n.to <= r.to ? r : t.doc.lineAt(n.to), s = e.length - 1;
    s >= 0 && e[s].to > r.from ? e[s].to = i.to : e.push({ from: r.from + /^\s*/.exec(r.text)[0].length, to: i.to });
  }
  return e;
}
function xv(t, e, n = e.selection.ranges) {
  let r = n.map((s) => Zg(e, s.from).block);
  if (!r.every((s) => s))
    return null;
  let i = n.map((s, o) => nM(e, r[o], s.from, s.to));
  if (t != 2 && !i.every((s) => s))
    return { changes: e.changes(n.map((s, o) => i[o] ? [] : [{ from: s.from, insert: r[o].open + " " }, { from: s.to, insert: " " + r[o].close }])) };
  if (t != 1 && i.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < i.length; o++)
      if (l = i[o]) {
        let a = r[o], { open: c, close: h } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function iM(t, e, n = e.selection.ranges) {
  let r = [], i = -1;
  for (let { from: s, to: o } of n) {
    let l = r.length, a = 1e9, c = Zg(e, s).line;
    if (!!c) {
      for (let h = s; h <= o; ) {
        let u = e.doc.lineAt(h);
        if (u.from > i && (s == o || o > u.from)) {
          i = u.from;
          let f = /^\s*/.exec(u.text)[0].length, d = f == u.length, p = u.text.slice(f, f + c.length) == c ? f : -1;
          f < u.text.length && f < a && (a = f), r.push({ line: u, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        h = u.to + 1;
      }
      if (a < 1e9)
        for (let h = l; h < r.length; h++)
          r[h].indent < r[h].line.text.length && (r[h].indent = a);
      r.length == l + 1 && (r[l].single = !0);
    }
  }
  if (t != 2 && r.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: h, single: u } of r)
      (u || !h) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (t != 1 && r.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of r)
      if (l >= 0) {
        let c = o.from + l, h = c + a.length;
        o.text[h - o.from] == " " && h++, s.push({ from: c, to: h });
      }
    return { changes: s };
  }
  return null;
}
const lp = /* @__PURE__ */ wn.define(), sM = /* @__PURE__ */ wn.define(), oM = /* @__PURE__ */ L.define(), vv = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, n) => n
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, n) => (r, i) => e(r, i) || n(r, i)
    });
  }
}), Sv = /* @__PURE__ */ Me.define({
  create() {
    return Zn.empty;
  },
  update(t, e) {
    let n = e.state.facet(vv), r = e.annotation(lp);
    if (r) {
      let a = $t.fromTransaction(e, r.selection), c = r.side, h = c == 0 ? t.undone : t.done;
      return a ? h = Wc(h, h.length, n.minDepth, a) : h = Av(h, e.startState.selection), new Zn(c == 0 ? r.rest : h, c == 0 ? h : r.rest);
    }
    let i = e.annotation(sM);
    if ((i == "full" || i == "before") && (t = t.isolate()), e.annotation(je.addToHistory) === !1)
      return e.changes.empty ? t : t.addMapping(e.changes.desc);
    let s = $t.fromTransaction(e), o = e.annotation(je.time), l = e.annotation(je.userEvent);
    return s ? t = t.addChanges(s, o, l, n, e) : e.selection && (t = t.addSelection(e.startState.selection, o, l, n.newGroupDelay)), (i == "full" || i == "after") && (t = t.isolate()), t;
  },
  toJSON(t) {
    return { done: t.done.map((e) => e.toJSON()), undone: t.undone.map((e) => e.toJSON()) };
  },
  fromJSON(t) {
    return new Zn(t.done.map($t.fromJSON), t.undone.map($t.fromJSON));
  }
});
function Ig(t = {}) {
  return [
    Sv,
    vv.of(t),
    T.domEventHandlers({
      beforeinput(e, n) {
        let r = e.inputType == "historyUndo" ? _v : e.inputType == "historyRedo" ? Xc : null;
        return r ? (e.preventDefault(), r(n)) : !1;
      }
    })
  ];
}
function Xh(t, e) {
  return function({ state: n, dispatch: r }) {
    if (!e && n.readOnly)
      return !1;
    let i = n.field(Sv, !1);
    if (!i)
      return !1;
    let s = i.pop(t, n, e);
    return s ? (r(s), !0) : !1;
  };
}
const _v = /* @__PURE__ */ Xh(0, !1), Xc = /* @__PURE__ */ Xh(1, !1), lM = /* @__PURE__ */ Xh(0, !0), aM = /* @__PURE__ */ Xh(1, !0);
class $t {
  constructor(e, n, r, i, s) {
    this.changes = e, this.effects = n, this.mapped = r, this.startSelection = i, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new $t(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, n, r;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (n = this.mapped) === null || n === void 0 ? void 0 : n.toJSON(),
      startSelection: (r = this.startSelection) === null || r === void 0 ? void 0 : r.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new $t(e.changes && qe.fromJSON(e.changes), [], e.mapped && qn.fromJSON(e.mapped), e.startSelection && C.fromJSON(e.startSelection), e.selectionsAfter.map(C.fromJSON));
  }
  static fromTransaction(e, n) {
    let r = Vt;
    for (let i of e.startState.facet(oM)) {
      let s = i(e);
      s.length && (r = r.concat(s));
    }
    return !r.length && e.changes.empty ? null : new $t(e.changes.invert(e.startState.doc), r, void 0, n || e.startState.selection, Vt);
  }
  static selection(e) {
    return new $t(void 0, Vt, void 0, void 0, e);
  }
}
function Wc(t, e, n, r) {
  let i = e + 1 > n + 20 ? e - n - 1 : 0, s = t.slice(i, e);
  return s.push(r), s;
}
function cM(t, e) {
  let n = [], r = !1;
  return t.iterChangedRanges((i, s) => n.push(i, s)), e.iterChangedRanges((i, s, o, l) => {
    for (let a = 0; a < n.length; ) {
      let c = n[a++], h = n[a++];
      l >= c && o <= h && (r = !0);
    }
  }), r;
}
function hM(t, e) {
  return t.ranges.length == e.ranges.length && t.ranges.filter((n, r) => n.empty != e.ranges[r].empty).length === 0;
}
function Cv(t, e) {
  return t.length ? e.length ? t.concat(e) : t : e;
}
const Vt = [], uM = 200;
function Av(t, e) {
  if (t.length) {
    let n = t[t.length - 1], r = n.selectionsAfter.slice(Math.max(0, n.selectionsAfter.length - uM));
    return r.length && r[r.length - 1].eq(e) ? t : (r.push(e), Wc(t, t.length - 1, 1e9, n.setSelAfter(r)));
  } else
    return [$t.selection([e])];
}
function fM(t) {
  let e = t[t.length - 1], n = t.slice();
  return n[t.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), n;
}
function ef(t, e) {
  if (!t.length)
    return t;
  let n = t.length, r = Vt;
  for (; n; ) {
    let i = dM(t[n - 1], e, r);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let s = t.slice(0, n);
      return s[n - 1] = i, s;
    } else
      e = i.mapped, n--, r = i.selectionsAfter;
  }
  return r.length ? [$t.selection(r)] : Vt;
}
function dM(t, e, n) {
  let r = Cv(t.selectionsAfter.length ? t.selectionsAfter.map((l) => l.map(e)) : Vt, n);
  if (!t.changes)
    return $t.selection(r);
  let i = t.changes.map(e), s = e.mapDesc(t.changes, !0), o = t.mapped ? t.mapped.composeDesc(s) : s;
  return new $t(i, G.mapEffects(t.effects, e), o, t.startSelection.map(s), r);
}
const pM = /^(input\.type|delete)($|\.)/;
class Zn {
  constructor(e, n, r = 0, i = void 0) {
    this.done = e, this.undone = n, this.prevTime = r, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new Zn(this.done, this.undone) : this;
  }
  addChanges(e, n, r, i, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!r || pM.test(r)) && (!l.selectionsAfter.length && n - this.prevTime < i.newGroupDelay && i.joinToEvent(s, cM(l.changes, e.changes)) || r == "input.type.compose") ? o = Wc(o, o.length - 1, i.minDepth, new $t(e.changes.compose(l.changes), Cv(e.effects, l.effects), l.mapped, l.startSelection, Vt)) : o = Wc(o, o.length, i.minDepth, e), new Zn(o, Vt, n, r);
  }
  addSelection(e, n, r, i) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Vt;
    return s.length > 0 && n - this.prevTime < i && r == this.prevUserEvent && r && /^select($|\.)/.test(r) && hM(s[s.length - 1], e) ? this : new Zn(Av(this.done, e), this.undone, n, r);
  }
  addMapping(e) {
    return new Zn(ef(this.done, e), ef(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, n, r) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let s = i[i.length - 1], o = s.selectionsAfter[0] || n.selection;
    if (r && s.selectionsAfter.length)
      return n.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: lp.of({ side: e, rest: fM(i), selection: o }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let l = i.length == 1 ? Vt : i.slice(0, i.length - 1);
      return s.mapped && (l = ef(l, s.mapped)), n.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: lp.of({ side: e, rest: l, selection: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Zn.empty = /* @__PURE__ */ new Zn(Vt, Vt);
const $v = [
  { key: "Mod-z", run: _v, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Xc, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Xc, preventDefault: !0 },
  { key: "Mod-u", run: lM, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: aM, preventDefault: !0 }
];
function Vs(t, e) {
  return C.create(t.ranges.map(e), t.mainIndex);
}
function Vn(t, e) {
  return t.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function kn({ state: t, dispatch: e }, n) {
  let r = Vs(t.selection, n);
  return r.eq(t.selection) ? !1 : (e(Vn(t, r)), !0);
}
function Wh(t, e) {
  return C.cursor(e ? t.to : t.from);
}
function Pv(t, e) {
  return kn(t, (n) => n.empty ? t.moveByChar(n, e) : Wh(n, e));
}
function gt(t) {
  return t.textDirectionAt(t.state.selection.main.head) == De.LTR;
}
const Tv = (t) => Pv(t, !gt(t)), Qv = (t) => Pv(t, gt(t));
function Ev(t, e) {
  return kn(t, (n) => n.empty ? t.moveByGroup(n, e) : Wh(n, e));
}
const gM = (t) => Ev(t, !gt(t)), mM = (t) => Ev(t, gt(t));
function OM(t, e, n) {
  if (e.type.prop(n))
    return !0;
  let r = e.to - e.from;
  return r && (r > 2 || /[^\s,.;:]/.test(t.sliceDoc(e.from, e.to))) || e.firstChild;
}
function zh(t, e, n) {
  let r = Se(t).resolveInner(e.head), i = n ? K.closedBy : K.openedBy;
  for (let a = e.head; ; ) {
    let c = n ? r.childAfter(a) : r.childBefore(a);
    if (!c)
      break;
    OM(t, c, i) ? r = c : a = n ? c.to : c.from;
  }
  let s = r.type.prop(i), o, l;
  return s && (o = n ? Rn(t, r.from, 1) : Rn(t, r.to, -1)) && o.matched ? l = n ? o.end.to : o.end.from : l = n ? r.to : r.from, C.cursor(l, n ? -1 : 1);
}
const bM = (t) => kn(t, (e) => zh(t.state, e, !gt(t))), yM = (t) => kn(t, (e) => zh(t.state, e, gt(t)));
function Dv(t, e) {
  return kn(t, (n) => {
    if (!n.empty)
      return Wh(n, e);
    let r = t.moveVertically(n, e);
    return r.head != n.head ? r : t.moveToLineBoundary(n, e);
  });
}
const Mv = (t) => Dv(t, !1), Rv = (t) => Dv(t, !0);
function Zv(t) {
  let e = t.scrollDOM.clientHeight < t.scrollDOM.scrollHeight - 2, n = 0, r = 0, i;
  if (e) {
    for (let s of t.state.facet(T.scrollMargins)) {
      let o = s(t);
      o != null && o.top && (n = Math.max(o == null ? void 0 : o.top, n)), o != null && o.bottom && (r = Math.max(o == null ? void 0 : o.bottom, r));
    }
    i = t.scrollDOM.clientHeight - n - r;
  } else
    i = (t.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: n,
    marginBottom: r,
    selfScroll: e,
    height: Math.max(t.defaultLineHeight, i - 5)
  };
}
function Iv(t, e) {
  let n = Zv(t), { state: r } = t, i = Vs(r.selection, (o) => o.empty ? t.moveVertically(o, e, n.height) : Wh(o, e));
  if (i.eq(r.selection))
    return !1;
  let s;
  if (n.selfScroll) {
    let o = t.coordsAtPos(r.selection.main.head), l = t.scrollDOM.getBoundingClientRect(), a = l.top + n.marginTop, c = l.bottom - n.marginBottom;
    o && o.top > a && o.bottom < c && (s = T.scrollIntoView(i.main.head, { y: "start", yMargin: o.top - a }));
  }
  return t.dispatch(Vn(r, i), { effects: s }), !0;
}
const b1 = (t) => Iv(t, !1), ap = (t) => Iv(t, !0);
function Fr(t, e, n) {
  let r = t.lineBlockAt(e.head), i = t.moveToLineBoundary(e, n);
  if (i.head == e.head && i.head != (n ? r.to : r.from) && (i = t.moveToLineBoundary(e, n, !1)), !n && i.head == r.from && r.length) {
    let s = /^\s*/.exec(t.state.sliceDoc(r.from, Math.min(r.from + 100, r.to)))[0].length;
    s && e.head != r.from + s && (i = C.cursor(r.from + s));
  }
  return i;
}
const wM = (t) => kn(t, (e) => Fr(t, e, !0)), kM = (t) => kn(t, (e) => Fr(t, e, !1)), xM = (t) => kn(t, (e) => Fr(t, e, !gt(t))), vM = (t) => kn(t, (e) => Fr(t, e, gt(t))), SM = (t) => kn(t, (e) => C.cursor(t.lineBlockAt(e.head).from, 1)), _M = (t) => kn(t, (e) => C.cursor(t.lineBlockAt(e.head).to, -1));
function CM(t, e, n) {
  let r = !1, i = Vs(t.selection, (s) => {
    let o = Rn(t, s.head, -1) || Rn(t, s.head, 1) || s.head > 0 && Rn(t, s.head - 1, 1) || s.head < t.doc.length && Rn(t, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    r = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return n ? C.range(s.anchor, l) : C.cursor(l);
  });
  return r ? (e(Vn(t, i)), !0) : !1;
}
const AM = ({ state: t, dispatch: e }) => CM(t, e, !1);
function tn(t, e) {
  let n = Vs(t.state.selection, (r) => {
    let i = e(r);
    return C.range(r.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return n.eq(t.state.selection) ? !1 : (t.dispatch(Vn(t.state, n)), !0);
}
function Lv(t, e) {
  return tn(t, (n) => t.moveByChar(n, e));
}
const Nv = (t) => Lv(t, !gt(t)), qv = (t) => Lv(t, gt(t));
function Bv(t, e) {
  return tn(t, (n) => t.moveByGroup(n, e));
}
const $M = (t) => Bv(t, !gt(t)), PM = (t) => Bv(t, gt(t)), TM = (t) => tn(t, (e) => zh(t.state, e, !gt(t))), QM = (t) => tn(t, (e) => zh(t.state, e, gt(t)));
function Yv(t, e) {
  return tn(t, (n) => t.moveVertically(n, e));
}
const jv = (t) => Yv(t, !1), Xv = (t) => Yv(t, !0);
function Wv(t, e) {
  return tn(t, (n) => t.moveVertically(n, e, Zv(t).height));
}
const y1 = (t) => Wv(t, !1), w1 = (t) => Wv(t, !0), EM = (t) => tn(t, (e) => Fr(t, e, !0)), DM = (t) => tn(t, (e) => Fr(t, e, !1)), MM = (t) => tn(t, (e) => Fr(t, e, !gt(t))), RM = (t) => tn(t, (e) => Fr(t, e, gt(t))), ZM = (t) => tn(t, (e) => C.cursor(t.lineBlockAt(e.head).from)), IM = (t) => tn(t, (e) => C.cursor(t.lineBlockAt(e.head).to)), k1 = ({ state: t, dispatch: e }) => (e(Vn(t, { anchor: 0 })), !0), x1 = ({ state: t, dispatch: e }) => (e(Vn(t, { anchor: t.doc.length })), !0), v1 = ({ state: t, dispatch: e }) => (e(Vn(t, { anchor: t.selection.main.anchor, head: 0 })), !0), S1 = ({ state: t, dispatch: e }) => (e(Vn(t, { anchor: t.selection.main.anchor, head: t.doc.length })), !0), LM = ({ state: t, dispatch: e }) => (e(t.update({ selection: { anchor: 0, head: t.doc.length }, userEvent: "select" })), !0), NM = ({ state: t, dispatch: e }) => {
  let n = Vh(t).map(({ from: r, to: i }) => C.range(r, Math.min(i + 1, t.doc.length)));
  return e(t.update({ selection: C.create(n), userEvent: "select" })), !0;
}, qM = ({ state: t, dispatch: e }) => {
  let n = Vs(t.selection, (r) => {
    var i;
    let s = Se(t).resolveStack(r.from, 1);
    for (let o = s; o; o = o.next) {
      let { node: l } = o;
      if ((l.from < r.from && l.to >= r.to || l.to > r.to && l.from <= r.from) && ((i = l.parent) === null || i === void 0 ? void 0 : i.parent))
        return C.range(l.to, l.from);
    }
    return r;
  });
  return e(Vn(t, n)), !0;
}, BM = ({ state: t, dispatch: e }) => {
  let n = t.selection, r = null;
  return n.ranges.length > 1 ? r = C.create([n.main]) : n.main.empty || (r = C.create([C.cursor(n.main.head)])), r ? (e(Vn(t, r)), !0) : !1;
};
function Xl(t, e) {
  if (t.state.readOnly)
    return !1;
  let n = "delete.selection", { state: r } = t, i = r.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(s);
      a < o ? (n = "delete.backward", a = Pa(t, a, !1)) : a > o && (n = "delete.forward", a = Pa(t, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = Pa(t, o, !1), l = Pa(t, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: C.cursor(o, o < s.head ? -1 : 1) };
  });
  return i.changes.empty ? !1 : (t.dispatch(r.update(i, {
    scrollIntoView: !0,
    userEvent: n,
    effects: n == "delete.selection" ? T.announce.of(r.phrase("Selection deleted")) : void 0
  })), !0);
}
function Pa(t, e, n) {
  if (t instanceof T)
    for (let r of t.state.facet(T.atomicRanges).map((i) => i(t)))
      r.between(e, e, (i, s) => {
        i < e && s > e && (e = n ? s : i);
      });
  return e;
}
const zv = (t, e) => Xl(t, (n) => {
  let r = n.from, { state: i } = t, s = i.doc.lineAt(r), o, l;
  if (!e && r > s.from && r < s.from + 200 && !/[^ \t]/.test(o = s.text.slice(0, r - s.from))) {
    if (o[o.length - 1] == "	")
      return r - 1;
    let a = pn(o, i.tabSize), c = a % Bc(i) || Bc(i);
    for (let h = 0; h < c && o[o.length - 1 - h] == " "; h++)
      r--;
    l = r;
  } else
    l = st(s.text, r - s.from, e, e) + s.from, l == r && s.number != (e ? i.doc.lines : 1) ? l += e ? 1 : -1 : !e && /[\ufe00-\ufe0f]/.test(s.text.slice(l - s.from, r - s.from)) && (l = st(s.text, l - s.from, !1, !1) + s.from);
  return l;
}), cp = (t) => zv(t, !1), Vv = (t) => zv(t, !0), Uv = (t, e) => Xl(t, (n) => {
  let r = n.head, { state: i } = t, s = i.doc.lineAt(r), o = i.charCategorizer(r);
  for (let l = null; ; ) {
    if (r == (e ? s.to : s.from)) {
      r == n.head && s.number != (e ? i.doc.lines : 1) && (r += e ? 1 : -1);
      break;
    }
    let a = st(s.text, r - s.from, e) + s.from, c = s.text.slice(Math.min(r, a) - s.from, Math.max(r, a) - s.from), h = o(c);
    if (l != null && h != l)
      break;
    (c != " " || r != n.head) && (l = h), r = a;
  }
  return r;
}), Fv = (t) => Uv(t, !1), YM = (t) => Uv(t, !0), jM = (t) => Xl(t, (e) => {
  let n = t.lineBlockAt(e.head).to;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), XM = (t) => Xl(t, (e) => {
  let n = t.moveToLineBoundary(e, !1).head;
  return e.head > n ? n : Math.max(0, e.head - 1);
}), WM = (t) => Xl(t, (e) => {
  let n = t.moveToLineBoundary(e, !0).head;
  return e.head < n ? n : Math.min(t.state.doc.length, e.head + 1);
}), zM = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => ({
    changes: { from: r.from, to: r.to, insert: le.of(["", ""]) },
    range: C.cursor(r.from)
  }));
  return e(t.update(n, { scrollIntoView: !0, userEvent: "input" })), !0;
}, VM = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = t.changeByRange((r) => {
    if (!r.empty || r.from == 0 || r.from == t.doc.length)
      return { range: r };
    let i = r.from, s = t.doc.lineAt(i), o = i == s.from ? i - 1 : st(s.text, i - s.from, !1) + s.from, l = i == s.to ? i + 1 : st(s.text, i - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: t.doc.slice(i, l).append(t.doc.slice(o, i)) },
      range: C.cursor(l)
    };
  });
  return n.changes.empty ? !1 : (e(t.update(n, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Vh(t) {
  let e = [], n = -1;
  for (let r of t.selection.ranges) {
    let i = t.doc.lineAt(r.from), s = t.doc.lineAt(r.to);
    if (!r.empty && r.to == s.from && (s = t.doc.lineAt(r.to - 1)), n >= i.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(r);
    } else
      e.push({ from: i.from, to: s.to, ranges: [r] });
    n = s.number + 1;
  }
  return e;
}
function Gv(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [], i = [];
  for (let s of Vh(t)) {
    if (n ? s.to == t.doc.length : s.from == 0)
      continue;
    let o = t.doc.lineAt(n ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (n) {
      r.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + t.lineBreak });
      for (let a of s.ranges)
        i.push(C.range(Math.min(t.doc.length, a.anchor + l), Math.min(t.doc.length, a.head + l)));
    } else {
      r.push({ from: o.from, to: s.from }, { from: s.to, insert: t.lineBreak + o.text });
      for (let a of s.ranges)
        i.push(C.range(a.anchor - l, a.head - l));
    }
  }
  return r.length ? (e(t.update({
    changes: r,
    scrollIntoView: !0,
    selection: C.create(i, t.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const UM = ({ state: t, dispatch: e }) => Gv(t, e, !1), FM = ({ state: t, dispatch: e }) => Gv(t, e, !0);
function Hv(t, e, n) {
  if (t.readOnly)
    return !1;
  let r = [];
  for (let i of Vh(t))
    n ? r.push({ from: i.from, insert: t.doc.slice(i.from, i.to) + t.lineBreak }) : r.push({ from: i.to, insert: t.lineBreak + t.doc.slice(i.from, i.to) });
  return e(t.update({ changes: r, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const GM = ({ state: t, dispatch: e }) => Hv(t, e, !1), HM = ({ state: t, dispatch: e }) => Hv(t, e, !0), JM = (t) => {
  if (t.state.readOnly)
    return !1;
  let { state: e } = t, n = e.changes(Vh(e).map(({ from: i, to: s }) => (i > 0 ? i-- : s < e.doc.length && s++, { from: i, to: s }))), r = Vs(e.selection, (i) => t.moveVertically(i, !0)).map(n);
  return t.dispatch({ changes: n, selection: r, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function KM(t, e) {
  if (/\(\)|\[\]|\{\}/.test(t.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let n = Se(t).resolveInner(e), r = n.childBefore(e), i = n.childAfter(e), s;
  return r && i && r.to <= e && i.from >= e && (s = r.type.prop(K.closedBy)) && s.indexOf(i.name) > -1 && t.doc.lineAt(r.to).from == t.doc.lineAt(i.from).from && !/\S/.test(t.sliceDoc(r.to, i.from)) ? { from: r.to, to: i.from } : null;
}
const e5 = /* @__PURE__ */ Jv(!1), t5 = /* @__PURE__ */ Jv(!0);
function Jv(t) {
  return ({ state: e, dispatch: n }) => {
    if (e.readOnly)
      return !1;
    let r = e.changeByRange((i) => {
      let { from: s, to: o } = i, l = e.doc.lineAt(s), a = !t && s == o && KM(e, s);
      t && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new Bh(e, { simulateBreak: s, simulateDoubleBreak: !!a }), h = Eg(c, s);
      for (h == null && (h = pn(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let u = ["", cl(e, h)];
      return a && u.push(cl(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: le.of(u) },
        range: C.cursor(s + 1 + u[1].length)
      };
    });
    return n(e.update(r, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Lg(t, e) {
  let n = -1;
  return t.changeByRange((r) => {
    let i = [];
    for (let o = r.from; o <= r.to; ) {
      let l = t.doc.lineAt(o);
      l.number > n && (r.empty || r.to > l.from) && (e(l, i, r), n = l.number), o = l.to + 1;
    }
    let s = t.changes(i);
    return {
      changes: i,
      range: C.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))
    };
  });
}
const n5 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = /* @__PURE__ */ Object.create(null), r = new Bh(t, { overrideIndentation: (s) => {
    let o = n[s];
    return o == null ? -1 : o;
  } }), i = Lg(t, (s, o, l) => {
    let a = Eg(r, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], h = cl(t, a);
    (c != h || l.from < s.from + c.length) && (n[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: h }));
  });
  return i.changes.empty || e(t.update(i, { userEvent: "indent" })), !0;
}, Kv = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Lg(t, (n, r) => {
  r.push({ from: n.from, insert: t.facet(Bl) });
}), { userEvent: "input.indent" })), !0), eS = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Lg(t, (n, r) => {
  let i = /^\s*/.exec(n.text)[0];
  if (!i)
    return;
  let s = pn(i, t.tabSize), o = 0, l = cl(t, Math.max(0, s - Bc(t)));
  for (; o < i.length && o < l.length && i.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  r.push({ from: n.from + o, to: n.from + i.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), r5 = [
  { key: "Ctrl-b", run: Tv, shift: Nv, preventDefault: !0 },
  { key: "Ctrl-f", run: Qv, shift: qv },
  { key: "Ctrl-p", run: Mv, shift: jv },
  { key: "Ctrl-n", run: Rv, shift: Xv },
  { key: "Ctrl-a", run: SM, shift: ZM },
  { key: "Ctrl-e", run: _M, shift: IM },
  { key: "Ctrl-d", run: Vv },
  { key: "Ctrl-h", run: cp },
  { key: "Ctrl-k", run: jM },
  { key: "Ctrl-Alt-h", run: Fv },
  { key: "Ctrl-o", run: zM },
  { key: "Ctrl-t", run: VM },
  { key: "Ctrl-v", run: ap }
], i5 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Tv, shift: Nv, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: gM, shift: $M, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: xM, shift: MM, preventDefault: !0 },
  { key: "ArrowRight", run: Qv, shift: qv, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: mM, shift: PM, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: vM, shift: RM, preventDefault: !0 },
  { key: "ArrowUp", run: Mv, shift: jv, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: k1, shift: v1 },
  { mac: "Ctrl-ArrowUp", run: b1, shift: y1 },
  { key: "ArrowDown", run: Rv, shift: Xv, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: x1, shift: S1 },
  { mac: "Ctrl-ArrowDown", run: ap, shift: w1 },
  { key: "PageUp", run: b1, shift: y1 },
  { key: "PageDown", run: ap, shift: w1 },
  { key: "Home", run: kM, shift: DM, preventDefault: !0 },
  { key: "Mod-Home", run: k1, shift: v1 },
  { key: "End", run: wM, shift: EM, preventDefault: !0 },
  { key: "Mod-End", run: x1, shift: S1 },
  { key: "Enter", run: e5 },
  { key: "Mod-a", run: LM },
  { key: "Backspace", run: cp, shift: cp },
  { key: "Delete", run: Vv },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Fv },
  { key: "Mod-Delete", mac: "Alt-Delete", run: YM },
  { mac: "Mod-Backspace", run: XM },
  { mac: "Mod-Delete", run: WM }
].concat(/* @__PURE__ */ r5.map((t) => ({ mac: t.key, run: t.run, shift: t.shift }))), tS = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: bM, shift: TM },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: yM, shift: QM },
  { key: "Alt-ArrowUp", run: UM },
  { key: "Shift-Alt-ArrowUp", run: GM },
  { key: "Alt-ArrowDown", run: FM },
  { key: "Shift-Alt-ArrowDown", run: HM },
  { key: "Escape", run: BM },
  { key: "Mod-Enter", run: t5 },
  { key: "Alt-l", mac: "Ctrl-l", run: NM },
  { key: "Mod-i", run: qM, preventDefault: !0 },
  { key: "Mod-[", run: eS },
  { key: "Mod-]", run: Kv },
  { key: "Mod-Alt-\\", run: n5 },
  { key: "Shift-Mod-k", run: JM },
  { key: "Shift-Mod-\\", run: AM },
  { key: "Mod-/", run: JD },
  { key: "Alt-A", run: eM }
].concat(i5), s5 = { key: "Tab", run: Kv, shift: eS };
function xe() {
  var t = arguments[0];
  typeof t == "string" && (t = document.createElement(t));
  var e = 1, n = arguments[1];
  if (n && typeof n == "object" && n.nodeType == null && !Array.isArray(n)) {
    for (var r in n)
      if (Object.prototype.hasOwnProperty.call(n, r)) {
        var i = n[r];
        typeof i == "string" ? t.setAttribute(r, i) : i != null && (t[r] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    nS(t, arguments[e]);
  return t;
}
function nS(t, e) {
  if (typeof e == "string")
    t.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      t.appendChild(e);
    else if (Array.isArray(e))
      for (var n = 0; n < e.length; n++)
        nS(t, e[n]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const _1 = typeof String.prototype.normalize == "function" ? (t) => t.normalize("NFKD") : (t) => t;
class $s {
  constructor(e, n, r = 0, i = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(r, i), this.bufferStart = r, this.normalize = s ? (l) => s(_1(l)) : _1, this.query = this.normalize(n);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return rt(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let n = pg(e), r = this.bufferStart + this.bufferPos;
      this.bufferPos += Yt(e);
      let i = this.normalize(n);
      for (let s = 0, o = r; ; s++) {
        let l = i.charCodeAt(s), a = this.match(l, o);
        if (s == i.length - 1) {
          if (a)
            return this.value = a, this;
          break;
        }
        o == r && s < n.length && n.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, n) {
    let r = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let s = this.matches[i], o = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? r = { from: this.matches[i + 1], to: n + 1 } : (this.matches[i]++, o = !0)), o || (this.matches.splice(i, 2), i -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? r = { from: n, to: n + 1 } : this.matches.push(1, n)), r && this.test && !this.test(r.from, r.to, this.buffer, this.bufferStart) && (r = null), r;
  }
}
typeof Symbol < "u" && ($s.prototype[Symbol.iterator] = function() {
  return this;
});
const rS = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Ng = "gm" + (/x/.unicode == null ? "" : "u");
class iS {
  constructor(e, n, r, i = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = rS, /\\[sWDnr]|\n|\r|\[\^/.test(n))
      return new sS(e, n, r, i, s);
    this.re = new RegExp(n, Ng + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.iter = e.iter();
    let o = e.lineAt(i);
    this.curLineStart = o.from, this.matchPos = zc(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let n = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (n) {
        let r = this.curLineStart + n.index, i = r + n[0].length;
        if (this.matchPos = zc(this.text, i + (r == i ? 1 : 0)), r == this.curLineStart + this.curLine.length && this.nextLine(), (r < i || r > this.value.to) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const tf = /* @__PURE__ */ new WeakMap();
class as {
  constructor(e, n) {
    this.from = e, this.text = n;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, n, r) {
    let i = tf.get(e);
    if (!i || i.from >= r || i.to <= n) {
      let l = new as(n, e.sliceString(n, r));
      return tf.set(e, l), l;
    }
    if (i.from == n && i.to == r)
      return i;
    let { text: s, from: o } = i;
    return o > n && (s = e.sliceString(n, o) + s, o = n), i.to < r && (s += e.sliceString(i.to, r)), tf.set(e, new as(o, s)), new as(n, s.slice(n - o, r - o));
  }
}
class sS {
  constructor(e, n, r, i, s) {
    this.text = e, this.to = s, this.done = !1, this.value = rS, this.matchPos = zc(e, i), this.re = new RegExp(n, Ng + (r != null && r.ignoreCase ? "i" : "")), this.test = r == null ? void 0 : r.test, this.flat = as.get(e, i, this.chunkEnd(i + 5e3));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, n = this.re.exec(this.flat.text);
      if (n && !n[0] && n.index == e && (this.re.lastIndex = e + 1, n = this.re.exec(this.flat.text)), n) {
        let r = this.flat.from + n.index, i = r + n[0].length;
        if ((this.flat.to >= this.to || n.index + n[0].length <= this.flat.text.length - 10) && (!this.test || this.test(r, i, n)))
          return this.value = { from: r, to: i, match: n }, this.matchPos = zc(this.text, i + (r == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = as.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (iS.prototype[Symbol.iterator] = sS.prototype[Symbol.iterator] = function() {
  return this;
});
function o5(t) {
  try {
    return new RegExp(t, Ng), !0;
  } catch {
    return !1;
  }
}
function zc(t, e) {
  if (e >= t.length)
    return e;
  let n = t.lineAt(e), r;
  for (; e < n.to && (r = n.text.charCodeAt(e - n.from)) >= 56320 && r < 57344; )
    e++;
  return e;
}
function hp(t) {
  let e = String(t.state.doc.lineAt(t.state.selection.main.head).number), n = xe("input", { class: "cm-textfield", name: "line", value: e }), r = xe("form", {
    class: "cm-gotoLine",
    onkeydown: (s) => {
      s.keyCode == 27 ? (s.preventDefault(), t.dispatch({ effects: Vc.of(!1) }), t.focus()) : s.keyCode == 13 && (s.preventDefault(), i());
    },
    onsubmit: (s) => {
      s.preventDefault(), i();
    }
  }, xe("label", t.state.phrase("Go to line"), ": ", n), " ", xe("button", { class: "cm-button", type: "submit" }, t.state.phrase("go")));
  function i() {
    let s = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(n.value);
    if (!s)
      return;
    let { state: o } = t, l = o.doc.lineAt(o.selection.main.head), [, a, c, h, u] = s, f = h ? +h.slice(1) : 0, d = c ? +c : l.number;
    if (c && u) {
      let m = d / 100;
      a && (m = m * (a == "-" ? -1 : 1) + l.number / o.doc.lines), d = Math.round(o.doc.lines * m);
    } else
      c && a && (d = d * (a == "-" ? -1 : 1) + l.number);
    let p = o.doc.line(Math.max(1, Math.min(o.doc.lines, d))), g = C.cursor(p.from + Math.max(0, Math.min(f, p.length)));
    t.dispatch({
      effects: [Vc.of(!1), T.scrollIntoView(g.from, { y: "center" })],
      selection: g
    }), t.focus();
  }
  return { dom: r };
}
const Vc = /* @__PURE__ */ G.define(), C1 = /* @__PURE__ */ Me.define({
  create() {
    return !0;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Vc) && (t = n.value);
    return t;
  },
  provide: (t) => il.from(t, (e) => e ? hp : null)
}), l5 = (t) => {
  let e = rl(t, hp);
  if (!e) {
    let n = [Vc.of(!0)];
    t.state.field(C1, !1) == null && n.push(G.appendConfig.of([C1, a5])), t.dispatch({ effects: n }), e = rl(t, hp);
  }
  return e && e.dom.querySelector("input").select(), !0;
}, a5 = /* @__PURE__ */ T.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), c5 = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, oS = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, c5, {
      highlightWordAroundCursor: (e, n) => e || n,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function h5(t) {
  let e = [g5, p5];
  return t && e.push(oS.of(t)), e;
}
const u5 = /* @__PURE__ */ I.mark({ class: "cm-selectionMatch" }), f5 = /* @__PURE__ */ I.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function A1(t, e, n, r) {
  return (n == 0 || t(e.sliceDoc(n - 1, n)) != Pe.Word) && (r == e.doc.length || t(e.sliceDoc(r, r + 1)) != Pe.Word);
}
function d5(t, e, n, r) {
  return t(e.sliceDoc(n, n + 1)) == Pe.Word && t(e.sliceDoc(r - 1, r)) == Pe.Word;
}
const p5 = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.decorations = this.getDeco(t);
  }
  update(t) {
    (t.selectionSet || t.docChanged || t.viewportChanged) && (this.decorations = this.getDeco(t.view));
  }
  getDeco(t) {
    let e = t.state.facet(oS), { state: n } = t, r = n.selection;
    if (r.ranges.length > 1)
      return I.none;
    let i = r.main, s, o = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return I.none;
      let a = n.wordAt(i.head);
      if (!a)
        return I.none;
      o = n.charCategorizer(i.head), s = n.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return I.none;
      if (e.wholeWords) {
        if (s = n.sliceDoc(i.from, i.to), o = n.charCategorizer(i.head), !(A1(o, n, i.from, i.to) && d5(o, n, i.from, i.to)))
          return I.none;
      } else if (s = n.sliceDoc(i.from, i.to).trim(), !s)
        return I.none;
    }
    let l = [];
    for (let a of t.visibleRanges) {
      let c = new $s(n.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: h, to: u } = c.value;
        if ((!o || A1(o, n, h, u)) && (i.empty && h <= i.from && u >= i.to ? l.push(f5.range(h, u)) : (h >= i.to || u <= i.from) && l.push(u5.range(h, u)), l.length > e.maxMatches))
          return I.none;
      }
    }
    return I.set(l);
  }
}, {
  decorations: (t) => t.decorations
}), g5 = /* @__PURE__ */ T.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), m5 = ({ state: t, dispatch: e }) => {
  let { selection: n } = t, r = C.create(n.ranges.map((i) => t.wordAt(i.head) || C.cursor(i.head)), n.mainIndex);
  return r.eq(n) ? !1 : (e(t.update({ selection: r })), !0);
};
function O5(t, e) {
  let { main: n, ranges: r } = t.selection, i = t.wordAt(n.head), s = i && i.from == n.from && i.to == n.to;
  for (let o = !1, l = new $s(t.doc, e, r[r.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new $s(t.doc, e, 0, Math.max(0, r[r.length - 1].from - 1)), o = !0;
    } else {
      if (o && r.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = t.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const b5 = ({ state: t, dispatch: e }) => {
  let { ranges: n } = t.selection;
  if (n.some((s) => s.from === s.to))
    return m5({ state: t, dispatch: e });
  let r = t.sliceDoc(n[0].from, n[0].to);
  if (t.selection.ranges.some((s) => t.sliceDoc(s.from, s.to) != r))
    return !1;
  let i = O5(t, r);
  return i ? (e(t.update({
    selection: t.selection.addRange(C.range(i.from, i.to), !1),
    effects: T.scrollIntoView(i.to)
  })), !0) : !1;
}, Us = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new T5(e),
      scrollToMatch: (e) => T.scrollIntoView(e)
    });
  }
});
class lS {
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || o5(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (n, r) => r == "n" ? `
` : r == "r" ? "\r" : r == "t" ? "	" : "\\");
  }
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  create() {
    return this.regexp ? new x5(this) : new w5(this);
  }
  getCursor(e, n = 0, r) {
    let i = e.doc ? e : re.create({ doc: e });
    return r == null && (r = i.doc.length), this.regexp ? Fi(this, i, n, r) : Ui(this, i, n, r);
  }
}
class aS {
  constructor(e) {
    this.spec = e;
  }
}
function Ui(t, e, n, r) {
  return new $s(e.doc, t.unquoted, n, r, t.caseSensitive ? void 0 : (i) => i.toLowerCase(), t.wholeWord ? y5(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function y5(t, e) {
  return (n, r, i, s) => ((s > n || s + i.length < r) && (s = Math.max(0, n - 2), i = t.sliceString(s, Math.min(t.length, r + 2))), (e(Uc(i, n - s)) != Pe.Word || e(Fc(i, n - s)) != Pe.Word) && (e(Fc(i, r - s)) != Pe.Word || e(Uc(i, r - s)) != Pe.Word));
}
class w5 extends aS {
  constructor(e) {
    super(e);
  }
  nextMatch(e, n, r) {
    let i = Ui(this.spec, e, r, e.doc.length).nextOverlapping();
    return i.done && (i = Ui(this.spec, e, 0, n).nextOverlapping()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = r; ; ) {
      let s = Math.max(n, i - 1e4 - this.spec.unquoted.length), o = Ui(this.spec, e, s, i), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == n)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, n) {
    let r = Ui(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = Ui(this.spec, e, Math.max(0, n - this.spec.unquoted.length), Math.min(r + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
function Fi(t, e, n, r) {
  return new iS(e.doc, t.search, {
    ignoreCase: !t.caseSensitive,
    test: t.wholeWord ? k5(e.charCategorizer(e.selection.main.head)) : void 0
  }, n, r);
}
function Uc(t, e) {
  return t.slice(st(t, e, !1), e);
}
function Fc(t, e) {
  return t.slice(e, st(t, e));
}
function k5(t) {
  return (e, n, r) => !r[0].length || (t(Uc(r.input, r.index)) != Pe.Word || t(Fc(r.input, r.index)) != Pe.Word) && (t(Fc(r.input, r.index + r[0].length)) != Pe.Word || t(Uc(r.input, r.index + r[0].length)) != Pe.Word);
}
class x5 extends aS {
  nextMatch(e, n, r) {
    let i = Fi(this.spec, e, r, e.doc.length).next();
    return i.done && (i = Fi(this.spec, e, 0, n).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, n, r) {
    for (let i = 1; ; i++) {
      let s = Math.max(n, r - i * 1e4), o = Fi(this.spec, e, s, r), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == n || l.from > s + 10))
        return l;
      if (s == n)
        return null;
    }
  }
  prevMatch(e, n, r) {
    return this.prevMatchInRange(e, 0, n) || this.prevMatchInRange(e, r, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (n, r) => r == "$" ? "$" : r == "&" ? e.match[0] : r != "0" && +r < e.match.length ? e.match[r] : n);
  }
  matchAll(e, n) {
    let r = Fi(this.spec, e, 0, e.doc.length), i = [];
    for (; !r.next().done; ) {
      if (i.length >= n)
        return null;
      i.push(r.value);
    }
    return i;
  }
  highlight(e, n, r, i) {
    let s = Fi(this.spec, e, Math.max(0, n - 250), Math.min(r + 250, e.doc.length));
    for (; !s.next().done; )
      i(s.value.from, s.value.to);
  }
}
const hl = /* @__PURE__ */ G.define(), qg = /* @__PURE__ */ G.define(), Mr = /* @__PURE__ */ Me.define({
  create(t) {
    return new nf(up(t).create(), null);
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(hl) ? t = new nf(n.value.create(), t.panel) : n.is(qg) && (t = new nf(t.query, n.value ? Bg : null));
    return t;
  },
  provide: (t) => il.from(t, (e) => e.panel)
});
class nf {
  constructor(e, n) {
    this.query = e, this.panel = n;
  }
}
const v5 = /* @__PURE__ */ I.mark({ class: "cm-searchMatch" }), S5 = /* @__PURE__ */ I.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), _5 = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.view = t, this.decorations = this.highlight(t.state.field(Mr));
  }
  update(t) {
    let e = t.state.field(Mr);
    (e != t.startState.field(Mr) || t.docChanged || t.selectionSet || t.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: t, panel: e }) {
    if (!e || !t.spec.valid)
      return I.none;
    let { view: n } = this, r = new et();
    for (let i = 0, s = n.visibleRanges, o = s.length; i < o; i++) {
      let { from: l, to: a } = s[i];
      for (; i < o - 1 && a > s[i + 1].from - 2 * 250; )
        a = s[++i].to;
      t.highlight(n.state, l, a, (c, h) => {
        let u = n.state.selection.ranges.some((f) => f.from == c && f.to == h);
        r.add(c, h, u ? S5 : v5);
      });
    }
    return r.finish();
  }
}, {
  decorations: (t) => t.decorations
});
function Wl(t) {
  return (e) => {
    let n = e.state.field(Mr, !1);
    return n && n.query.spec.valid ? t(e, n) : uS(e);
  };
}
const Gc = /* @__PURE__ */ Wl((t, { query: e }) => {
  let { to: n } = t.state.selection.main, r = e.nextMatch(t.state, n, n);
  if (!r)
    return !1;
  let i = C.single(r.from, r.to), s = t.state.facet(Us);
  return t.dispatch({
    selection: i,
    effects: [Yg(t, r), s.scrollToMatch(i.main, t)],
    userEvent: "select.search"
  }), hS(t), !0;
}), Hc = /* @__PURE__ */ Wl((t, { query: e }) => {
  let { state: n } = t, { from: r } = n.selection.main, i = e.prevMatch(n, r, r);
  if (!i)
    return !1;
  let s = C.single(i.from, i.to), o = t.state.facet(Us);
  return t.dispatch({
    selection: s,
    effects: [Yg(t, i), o.scrollToMatch(s.main, t)],
    userEvent: "select.search"
  }), hS(t), !0;
}), C5 = /* @__PURE__ */ Wl((t, { query: e }) => {
  let n = e.matchAll(t.state, 1e3);
  return !n || !n.length ? !1 : (t.dispatch({
    selection: C.create(n.map((r) => C.range(r.from, r.to))),
    userEvent: "select.search.matches"
  }), !0);
}), A5 = ({ state: t, dispatch: e }) => {
  let n = t.selection;
  if (n.ranges.length > 1 || n.main.empty)
    return !1;
  let { from: r, to: i } = n.main, s = [], o = 0;
  for (let l = new $s(t.doc, t.sliceDoc(r, i)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == r && (o = s.length), s.push(C.range(l.value.from, l.value.to));
  }
  return e(t.update({
    selection: C.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, $1 = /* @__PURE__ */ Wl((t, { query: e }) => {
  let { state: n } = t, { from: r, to: i } = n.selection.main;
  if (n.readOnly)
    return !1;
  let s = e.nextMatch(n, r, r);
  if (!s)
    return !1;
  let o = [], l, a, c = [];
  if (s.from == r && s.to == i && (a = n.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: a }), s = e.nextMatch(n, s.from, s.to), c.push(T.announce.of(n.phrase("replaced match on line $", n.doc.lineAt(r).number) + "."))), s) {
    let h = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - a.length;
    l = C.single(s.from - h, s.to - h), c.push(Yg(t, s)), c.push(n.facet(Us).scrollToMatch(l.main, t));
  }
  return t.dispatch({
    changes: o,
    selection: l,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), $5 = /* @__PURE__ */ Wl((t, { query: e }) => {
  if (t.state.readOnly)
    return !1;
  let n = e.matchAll(t.state, 1e9).map((i) => {
    let { from: s, to: o } = i;
    return { from: s, to: o, insert: e.getReplacement(i) };
  });
  if (!n.length)
    return !1;
  let r = t.state.phrase("replaced $ matches", n.length) + ".";
  return t.dispatch({
    changes: n,
    effects: T.announce.of(r),
    userEvent: "input.replace.all"
  }), !0;
});
function Bg(t) {
  return t.state.facet(Us).createPanel(t);
}
function up(t, e) {
  var n, r, i, s, o;
  let l = t.selection.main, a = l.empty || l.to > l.from + 100 ? "" : t.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = t.facet(Us);
  return new lS({
    search: ((n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (r = e == null ? void 0 : e.caseSensitive) !== null && r !== void 0 ? r : c.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function cS(t) {
  let e = rl(t, Bg);
  return e && e.dom.querySelector("[main-field]");
}
function hS(t) {
  let e = cS(t);
  e && e == t.root.activeElement && e.select();
}
const uS = (t) => {
  let e = t.state.field(Mr, !1);
  if (e && e.panel) {
    let n = cS(t);
    if (n && n != t.root.activeElement) {
      let r = up(t.state, e.query.spec);
      r.valid && t.dispatch({ effects: hl.of(r) }), n.focus(), n.select();
    }
  } else
    t.dispatch({ effects: [
      qg.of(!0),
      e ? hl.of(up(t.state, e.query.spec)) : G.appendConfig.of(E5)
    ] });
  return !0;
}, fS = (t) => {
  let e = t.state.field(Mr, !1);
  if (!e || !e.panel)
    return !1;
  let n = rl(t, Bg);
  return n && n.dom.contains(t.root.activeElement) && t.focus(), t.dispatch({ effects: qg.of(!1) }), !0;
}, P5 = [
  { key: "Mod-f", run: uS, scope: "editor search-panel" },
  { key: "F3", run: Gc, shift: Hc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Gc, shift: Hc, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: fS, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: A5 },
  { key: "Mod-Alt-g", run: l5 },
  { key: "Mod-d", run: b5, preventDefault: !0 }
];
class T5 {
  constructor(e) {
    this.view = e;
    let n = this.query = e.state.field(Mr).query.spec;
    this.commit = this.commit.bind(this), this.searchField = xe("input", {
      value: n.search,
      placeholder: Et(e, "Find"),
      "aria-label": Et(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = xe("input", {
      value: n.replace,
      placeholder: Et(e, "Replace"),
      "aria-label": Et(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = xe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: n.caseSensitive,
      onchange: this.commit
    }), this.reField = xe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: n.regexp,
      onchange: this.commit
    }), this.wordField = xe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: n.wholeWord,
      onchange: this.commit
    });
    function r(i, s, o) {
      return xe("button", { class: "cm-button", name: i, onclick: s, type: "button" }, o);
    }
    this.dom = xe("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      r("next", () => Gc(e), [Et(e, "next")]),
      r("prev", () => Hc(e), [Et(e, "previous")]),
      r("select", () => C5(e), [Et(e, "all")]),
      xe("label", null, [this.caseField, Et(e, "match case")]),
      xe("label", null, [this.reField, Et(e, "regexp")]),
      xe("label", null, [this.wordField, Et(e, "by word")]),
      ...e.state.readOnly ? [] : [
        xe("br"),
        this.replaceField,
        r("replace", () => $1(e), [Et(e, "replace")]),
        r("replaceAll", () => $5(e), [Et(e, "replace all")])
      ],
      xe("button", {
        name: "close",
        onclick: () => fS(e),
        "aria-label": Et(e, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let e = new lS({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: hl.of(e) }));
  }
  keydown(e) {
    GQ(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Hc : Gc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), $1(this.view));
  }
  update(e) {
    for (let n of e.transactions)
      for (let r of n.effects)
        r.is(hl) && !r.value.eq(this.query) && this.setQuery(r.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Us).top;
  }
}
function Et(t, e) {
  return t.state.phrase(e);
}
const Ta = 30, Qa = /[\s\.,:;?!]/;
function Yg(t, { from: e, to: n }) {
  let r = t.state.doc.lineAt(e), i = t.state.doc.lineAt(n).to, s = Math.max(r.from, e - Ta), o = Math.min(i, n + Ta), l = t.state.sliceDoc(s, o);
  if (s != r.from) {
    for (let a = 0; a < Ta; a++)
      if (!Qa.test(l[a + 1]) && Qa.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != i) {
    for (let a = l.length - 1; a > l.length - Ta; a--)
      if (!Qa.test(l[a - 1]) && Qa.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return T.announce.of(`${t.state.phrase("current match")}. ${l} ${t.state.phrase("on line")} ${r.number}.`);
}
const Q5 = /* @__PURE__ */ T.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), E5 = [
  Mr,
  /* @__PURE__ */ yn.low(_5),
  Q5
];
class jg {
  constructor(e, n, r) {
    this.state = e, this.pos = n, this.explicit = r, this.abortListeners = [];
  }
  tokenBefore(e) {
    let n = Se(this.state).resolveInner(this.pos, -1);
    for (; n && e.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  matchBefore(e) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), s = i.search(pS(e, !1));
    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, n) {
    e == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function P1(t) {
  let e = Object.keys(t).join(""), n = /\w/.test(e);
  return n && (e = e.replace(/\w/g, "")), `[${n ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function D5(t) {
  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      n[i[s]] = !0;
  }
  let r = P1(e) + P1(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function dS(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : D5(e);
  return (i) => {
    let s = i.matchBefore(r);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: n } : null;
  };
}
function M5(t, e) {
  return (n) => {
    for (let r = Se(n.state).resolveInner(n.pos, -1); r; r = r.parent) {
      if (t.indexOf(r.name) > -1)
        return null;
      if (r.type.isTop)
        break;
    }
    return e(n);
  };
}
class T1 {
  constructor(e, n, r, i) {
    this.completion = e, this.source = n, this.match = r, this.score = i;
  }
}
function Rr(t) {
  return t.selection.main.from;
}
function pS(t, e) {
  var n;
  let { source: r } = t, i = e && r[0] != "^", s = r[r.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${r})${s ? "$" : ""}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? "i" : "");
}
const gS = /* @__PURE__ */ wn.define();
function R5(t, e, n, r) {
  let { main: i } = t.selection, s = n - i.from, o = r - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((l) => l != i && n != r && t.sliceDoc(l.from + s, l.from + o) != t.sliceDoc(n, r) ? { range: l } : {
    changes: { from: l.from + s, to: r == i.from ? l.to : l.from + o, insert: e },
    range: C.cursor(l.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const Q1 = /* @__PURE__ */ new WeakMap();
function Z5(t) {
  if (!Array.isArray(t))
    return t;
  let e = Q1.get(t);
  return e || Q1.set(t, e = dS(t)), e;
}
const Xg = /* @__PURE__ */ G.define(), ul = /* @__PURE__ */ G.define();
class I5 {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < e.length; ) {
      let r = rt(e, n), i = Yt(r);
      this.chars.push(r);
      let s = e.slice(n, n + i), o = s.toUpperCase();
      this.folded.push(rt(o == s ? s.toLowerCase() : o, 0)), n += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, n) {
    return this.score = e, this.matched = n, !0;
  }
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: n, folded: r, any: i, precise: s, byWord: o } = this;
    if (n.length == 1) {
      let b = rt(e, 0), y = Yt(b), w = y == e.length ? 0 : -100;
      if (b != n[0])
        if (b == r[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, y]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = n.length, c = 0;
    if (l < 0) {
      for (let b = 0, y = Math.min(e.length, 200); b < y && c < a; ) {
        let w = rt(e, b);
        (w == n[c] || w == r[c]) && (i[c++] = b), b += Yt(w);
      }
      if (c < a)
        return !1;
    }
    let h = 0, u = 0, f = !1, d = 0, p = -1, g = -1, m = /[a-z]/.test(e), O = !0;
    for (let b = 0, y = Math.min(e.length, 200), w = 0; b < y && u < a; ) {
      let S = rt(e, b);
      l < 0 && (h < a && S == n[h] && (s[h++] = b), d < a && (S == n[d] || S == r[d] ? (d == 0 && (p = b), g = b + 1, d++) : d = 0));
      let x, v = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (x = pg(S)) != x.toLowerCase() ? 1 : x != x.toUpperCase() ? 2 : 0;
      (!b || v == 1 && m || w == 0 && v != 0) && (n[u] == S || r[u] == S && (f = !0) ? o[u++] = b : o.length && (O = !1)), w = v, b += Yt(S);
    }
    return u == a && o[0] == 0 && O ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-200 + -700 - e.length, [p, g]) : u == a ? this.result(-100 + (f ? -200 : 0) + -700 + (O ? 0 : -1100), o, e) : n.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, n, r) {
    let i = [], s = 0;
    for (let o of n) {
      let l = o + (this.astral ? Yt(rt(r, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = l : (i[s++] = o, i[s++] = l);
    }
    return this.ret(e - r.length, i);
  }
}
const dt = /* @__PURE__ */ L.define({
  combine(t) {
    return zn(t, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: L5,
      compareCompletions: (e, n) => e.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, n) => e && n,
      closeOnBlur: (e, n) => e && n,
      icons: (e, n) => e && n,
      tooltipClass: (e, n) => (r) => E1(e(r), n(r)),
      optionClass: (e, n) => (r) => E1(e(r), n(r)),
      addToOptions: (e, n) => e.concat(n)
    });
  }
});
function E1(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function L5(t, e, n, r, i, s) {
  let o = t.textDirection == De.RTL, l = o, a = !1, c = "top", h, u, f = e.left - i.left, d = i.right - e.right, p = r.right - r.left, g = r.bottom - r.top;
  if (l && f < Math.min(p, d) ? l = !1 : !l && d < Math.min(p, f) && (l = !0), p <= (l ? f : d))
    h = Math.max(i.top, Math.min(n.top, i.bottom - g)) - e.top, u = Math.min(400, l ? f : d);
  else {
    a = !0, u = Math.min(400, (o ? e.right : i.right - e.left) - 30);
    let b = i.bottom - e.bottom;
    b >= g || b > e.top ? h = n.bottom - e.top : (c = "bottom", h = e.bottom - n.top);
  }
  let m = (e.bottom - e.top) / s.offsetHeight, O = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${h / m}px; max-width: ${u / O}px`,
    class: "cm-completionInfo-" + (a ? o ? "left-narrow" : "right-narrow" : l ? "left" : "right")
  };
}
function N5(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), e.push({
    render(n, r, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let l = n.displayLabel || n.label, a = 0;
      for (let c = 0; c < s.length; ) {
        let h = s[c++], u = s[c++];
        h > a && o.appendChild(document.createTextNode(l.slice(a, h)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(l.slice(h, u))), f.className = "cm-completionMatchedText", a = u;
      }
      return a < l.length && o.appendChild(document.createTextNode(l.slice(a))), o;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function rf(t, e, n) {
  if (t <= n)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((t - e) / n);
  return { from: t - (r + 1) * n, to: t - r * n };
}
class q5 {
  constructor(e, n, r) {
    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(n), { options: s, selected: o } = i.open, l = e.state.facet(dt);
    this.optionContent = N5(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = rf(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      let { options: c } = e.state.field(n).open;
      for (let h = a.target, u; h && h != this.dom; h = h.parentNode)
        if (h.nodeName == "LI" && (u = /-(\d+)$/.exec(h.id)) && +u[1] < c.length) {
          this.applyCompletion(e, c[+u[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(dt).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: ul.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var n;
    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), r != i) {
      let { options: s, selected: o, disabled: l } = r.open;
      (!i.open || i.open.options != s) && (this.range = rf(s.length, o, e.state.facet(dt).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), l != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!l);
    }
  }
  updateTooltipClass(e) {
    let n = this.tooltipClass(e);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), n = e.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = rf(n.options.length, n.selected, this.view.state.facet(dt).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: i } = r;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);
      }).catch((o) => Ut(this.view.state, o, "completion info")) : this.addInfoPane(s, r);
    }
  }
  addInfoPane(e, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      r.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      r.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == e ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && Y5(this.list, n), n;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(dt).positionInfo(this.view, n, i, r, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = r.from; o < r.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > r.from || r.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let d = i.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const h = i.appendChild(document.createElement("li"));
      h.id = n + "-" + o, h.setAttribute("role", "option");
      let u = this.optionClass(l);
      u && (h.className = u);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, this.view, a);
        d && h.appendChild(d);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function B5(t, e) {
  return (n) => new q5(n, t, e);
}
function Y5(t, e) {
  let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;
  r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);
}
function D1(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function j5(t, e) {
  let n = [], r = null, i = (a) => {
    n.push(a);
    let { section: c } = a.completion;
    if (c) {
      r || (r = []);
      let h = typeof c == "string" ? c : c.name;
      r.some((u) => u.name == h) || r.push(typeof c == "string" ? { name: h } : c);
    }
  };
  for (let a of t)
    if (a.hasResult()) {
      let c = a.result.getMatch;
      if (a.result.filter === !1)
        for (let h of a.result.options)
          i(new T1(h, a.source, c ? c(h) : [], 1e9 - n.length));
      else {
        let h = new I5(e.sliceDoc(a.from, a.to));
        for (let u of a.result.options)
          if (h.match(u.label)) {
            let f = u.displayLabel ? c ? c(u, h.matched) : [] : h.matched;
            i(new T1(u, a.source, f, h.score + (u.boost || 0)));
          }
      }
    }
  if (r) {
    let a = /* @__PURE__ */ Object.create(null), c = 0, h = (u, f) => {
      var d, p;
      return ((d = u.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (u.name < f.name ? -1 : 1);
    };
    for (let u of r.sort(h))
      c -= 1e5, a[u.name] = c;
    for (let u of n) {
      let { section: f } = u.completion;
      f && (u.score += a[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [], o = null, l = e.facet(dt).compareCompletions;
  for (let a of n.sort((c, h) => h.score - c.score || l(c.completion, h.completion))) {
    let c = a.completion;
    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(a) : D1(a.completion) > D1(o) && (s[s.length - 1] = a), o = a.completion;
  }
  return s;
}
class es {
  constructor(e, n, r, i, s, o) {
    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, n) {
    return e == this.selected || e >= this.options.length ? this : new es(this.options, M1(n, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, n, r, i, s) {
    let o = j5(e, n);
    if (!o.length)
      return i && e.some((a) => a.state == 1) ? new es(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let l = n.facet(dt).selectOnOpen ? 0 : -1;
    if (i && i.selected != l && i.selected != -1) {
      let a = i.options[i.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == a) {
          l = c;
          break;
        }
    }
    return new es(o, M1(r, l), {
      pos: e.reduce((a, c) => c.hasResult() ? Math.min(a, c.from) : a, 1e8),
      create: U5,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new es(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Jc {
  constructor(e, n, r) {
    this.active = e, this.id = n, this.open = r;
  }
  static start() {
    return new Jc(z5, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: n } = e, r = n.facet(dt), s = (r.override || n.languageDataAt("autocomplete", Rr(n)).map(Z5)).map((l) => (this.active.find((c) => c.source == l) || new _t(l, this.active.some((c) => c.state != 0) ? 1 : 0)).update(e, r));
    s.length == this.active.length && s.every((l, a) => l == this.active[a]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !X5(s, this.active) ? o = es.build(s, n, this.id, o, r) : o && o.disabled && !s.some((l) => l.state == 1) && (o = null), !o && s.every((l) => l.state != 1) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new _t(l.source, 0) : l));
    for (let l of e.effects)
      l.is(OS) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new Jc(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : W5;
  }
}
function X5(t, e) {
  if (t == e)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < t.length && !t[n].hasResult; )
      n++;
    for (; r < e.length && !e[r].hasResult; )
      r++;
    let i = n == t.length, s = r == e.length;
    if (i || s)
      return i == s;
    if (t[n++].result != e[r++].result)
      return !1;
  }
}
const W5 = {
  "aria-autocomplete": "list"
};
function M1(t, e) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (n["aria-activedescendant"] = t + "-" + e), n;
}
const z5 = [];
function fp(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class _t {
  constructor(e, n, r = -1) {
    this.source = e, this.state = n, this.explicitPos = r;
  }
  hasResult() {
    return !1;
  }
  update(e, n) {
    let r = fp(e), i = this;
    r ? i = i.handleUserEvent(e, r, n) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new _t(i.source, 0));
    for (let s of e.effects)
      if (s.is(Xg))
        i = new _t(i.source, 1, s.value ? Rr(e.state) : -1);
      else if (s.is(ul))
        i = new _t(i.source, 0);
      else if (s.is(mS))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(e, n, r) {
    return n == "delete" || !r.activateOnTyping ? this.map(e.changes) : new _t(this.source, 1);
  }
  handleChange(e) {
    return e.changes.touchesRange(Rr(e.startState)) ? new _t(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new _t(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class cs extends _t {
  constructor(e, n, r, i, s) {
    super(e, 2, n), this.result = r, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, n, r) {
    var i;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = Rr(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || n == "delete" && Rr(e.startState) == this.from)
      return new _t(this.source, n == "input" && r.activateOnTyping ? 1 : 0);
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return V5(this.result.validFor, e.state, s, o) ? new cs(this.source, a, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new jg(e.state, l, a >= 0))) ? new cs(this.source, a, c, c.from, (i = c.to) !== null && i !== void 0 ? i : Rr(e.state)) : new _t(this.source, 1, a);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new _t(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new cs(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function V5(t, e, n, r) {
  if (!t)
    return !1;
  let i = e.sliceDoc(n, r);
  return typeof t == "function" ? t(i, n, r, e) : pS(t, !0).test(i);
}
const mS = /* @__PURE__ */ G.define({
  map(t, e) {
    return t.map((n) => n.map(e));
  }
}), OS = /* @__PURE__ */ G.define(), It = /* @__PURE__ */ Me.define({
  create() {
    return Jc.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    _g.from(t, (e) => e.tooltip),
    T.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function bS(t, e) {
  const n = e.completion.apply || e.completion.label;
  let r = t.state.field(It).active.find((i) => i.source == e.source);
  return r instanceof cs ? (typeof n == "string" ? t.dispatch(Object.assign(Object.assign({}, R5(t.state, n, r.from, r.to)), { annotations: gS.of(e.completion) })) : n(t, e.completion, r.from, r.to), !0) : !1;
}
const U5 = /* @__PURE__ */ B5(It, bS);
function Ea(t, e = "option") {
  return (n) => {
    let r = n.state.field(It, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(dt).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = zx(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = r.open.options, l = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), n.dispatch({ effects: OS.of(l) }), !0;
  };
}
const F5 = (t) => {
  let e = t.state.field(It, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(dt).interactionDelay ? !1 : bS(t, e.open.options[e.open.selected]);
}, G5 = (t) => t.state.field(It, !1) ? (t.dispatch({ effects: Xg.of(!0) }), !0) : !1, H5 = (t) => {
  let e = t.state.field(It, !1);
  return !e || !e.active.some((n) => n.state != 0) ? !1 : (t.dispatch({ effects: ul.of(null) }), !0);
};
class J5 {
  constructor(e, n) {
    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const K5 = 50, eR = 1e3, tR = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of t.state.field(It).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(It);
    if (!t.selectionSet && !t.docChanged && t.startState.field(It) == e)
      return;
    let n = t.transactions.some((r) => (r.selection || r.docChanged) && !fp(r));
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (n || i.updates.length + t.transactions.length > K5 && Date.now() - i.time > eR) {
        for (let s of i.context.abortListeners)
          try {
            s();
          } catch (o) {
            Ut(this.view.state, o);
          }
        i.context.abortListeners = null, this.running.splice(r--, 1);
      } else
        i.updates.push(...t.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((r) => r.state == 1 && !this.running.some((i) => i.active.source == r.source)) ? setTimeout(() => this.startUpdate(), 50) : -1, this.composing != 0)
      for (let r of t.transactions)
        fp(r) == "input" ? this.composing = 2 : this.composing == 2 && r.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: t } = this.view, e = t.field(It);
    for (let n of e.active)
      n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
  }
  startQuery(t) {
    let { state: e } = this.view, n = Rr(e), r = new jg(e, n, t.explicitPos == n), i = new J5(t, r);
    this.running.push(i), Promise.resolve(t.source(r)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: ul.of(null) }), Ut(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(dt).updateSyncTime));
  }
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], n = this.view.state.facet(dt);
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (i.done === void 0)
        continue;
      if (this.running.splice(r--, 1), i.done) {
        let o = new cs(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : Rr(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let l of i.updates)
          o = o.update(l, n);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(It).active.find((o) => o.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let o = new _t(i.active.source, 0);
          for (let l of i.updates)
            o = o.update(l, n);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: mS.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(It, !1);
      if (e && e.tooltip && this.view.state.facet(dt).closeOnBlur) {
        let n = e.open && zx(this.view, e.open.tooltip);
        (!n || !n.dom.contains(t.relatedTarget)) && this.view.dispatch({ effects: ul.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Xg.of(!1) }), 20), this.composing = 0;
    }
  }
}), yS = /* @__PURE__ */ T.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class nR {
  constructor(e, n, r, i) {
    this.field = e, this.line = n, this.from = r, this.to = i;
  }
}
class Wg {
  constructor(e, n, r) {
    this.field = e, this.from = n, this.to = r;
  }
  map(e) {
    let n = e.mapPos(this.from, -1, We.TrackDel), r = e.mapPos(this.to, 1, We.TrackDel);
    return n == null || r == null ? null : new Wg(this.field, n, r);
  }
}
class zg {
  constructor(e, n) {
    this.lines = e, this.fieldPositions = n;
  }
  instantiate(e, n) {
    let r = [], i = [n], s = e.doc.lineAt(n), o = /^\s*/.exec(s.text)[0];
    for (let a of this.lines) {
      if (r.length) {
        let c = o, h = /^\t*/.exec(a)[0].length;
        for (let u = 0; u < h; u++)
          c += e.facet(Bl);
        i.push(n + c.length - h), a = c + a.slice(h);
      }
      r.push(a), n += a.length + 1;
    }
    let l = this.fieldPositions.map((a) => new Wg(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: r, ranges: l };
  }
  static parse(e) {
    let n = [], r = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let l = s[1] ? +s[1] : null, a = s[2] || s[3] || "", c = -1;
        for (let h = 0; h < n.length; h++)
          (l != null ? n[h].seq == l : a ? n[h].name == a : !1) && (c = h);
        if (c < 0) {
          let h = 0;
          for (; h < n.length && (l == null || n[h].seq != null && n[h].seq < l); )
            h++;
          n.splice(h, 0, { seq: l, name: a }), c = h;
          for (let u of i)
            u.field >= c && u.field++;
        }
        i.push(new nR(c, r.length, s.index, s.index + a.length)), o = o.slice(0, s.index) + a + o.slice(s.index + s[0].length);
      }
      for (let l; l = /\\([{}])/.exec(o); ) {
        o = o.slice(0, l.index) + l[1] + o.slice(l.index + l[0].length);
        for (let a of i)
          a.line == r.length && a.from > l.index && (a.from--, a.to--);
      }
      r.push(o);
    }
    return new zg(r, i);
  }
}
let rR = /* @__PURE__ */ I.widget({ widget: /* @__PURE__ */ new class extends Tt {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), iR = /* @__PURE__ */ I.mark({ class: "cm-snippetField" });
class Fs {
  constructor(e, n) {
    this.ranges = e, this.active = n, this.deco = I.set(e.map((r) => (r.from == r.to ? rR : iR).range(r.from, r.to)));
  }
  map(e) {
    let n = [];
    for (let r of this.ranges) {
      let i = r.map(e);
      if (!i)
        return null;
      n.push(i);
    }
    return new Fs(n, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));
  }
}
const zl = /* @__PURE__ */ G.define({
  map(t, e) {
    return t && t.map(e);
  }
}), sR = /* @__PURE__ */ G.define(), fl = /* @__PURE__ */ Me.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let n of e.effects) {
      if (n.is(zl))
        return n.value;
      if (n.is(sR) && t)
        return new Fs(t.ranges, n.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => T.decorations.from(t, (e) => e ? e.deco : I.none)
});
function Vg(t, e) {
  return C.create(t.filter((n) => n.field == e).map((n) => C.range(n.from, n.to)));
}
function oR(t) {
  let e = zg.parse(t);
  return (n, r, i, s) => {
    let { text: o, ranges: l } = e.instantiate(n.state, i), a = {
      changes: { from: i, to: s, insert: le.of(o) },
      scrollIntoView: !0,
      annotations: r ? gS.of(r) : void 0
    };
    if (l.length && (a.selection = Vg(l, 0)), l.length > 1) {
      let c = new Fs(l, 0), h = a.effects = [zl.of(c)];
      n.state.field(fl, !1) === void 0 && h.push(G.appendConfig.of([fl, uR, fR, yS]));
    }
    n.dispatch(n.state.update(a));
  };
}
function wS(t) {
  return ({ state: e, dispatch: n }) => {
    let r = e.field(fl, !1);
    if (!r || t < 0 && r.active == 0)
      return !1;
    let i = r.active + t, s = t > 0 && !r.ranges.some((o) => o.field == i + t);
    return n(e.update({
      selection: Vg(r.ranges, i),
      effects: zl.of(s ? null : new Fs(r.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const lR = ({ state: t, dispatch: e }) => t.field(fl, !1) ? (e(t.update({ effects: zl.of(null) })), !0) : !1, aR = /* @__PURE__ */ wS(1), cR = /* @__PURE__ */ wS(-1), hR = [
  { key: "Tab", run: aR, shift: cR },
  { key: "Escape", run: lR }
], R1 = /* @__PURE__ */ L.define({
  combine(t) {
    return t.length ? t[0] : hR;
  }
}), uR = /* @__PURE__ */ yn.highest(/* @__PURE__ */ sr.compute([R1], (t) => t.facet(R1)));
function St(t, e) {
  return Object.assign(Object.assign({}, e), { apply: oR(t) });
}
const fR = /* @__PURE__ */ T.domEventHandlers({
  mousedown(t, e) {
    let n = e.state.field(fl, !1), r;
    if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = n.ranges.find((s) => s.from <= r && s.to >= r);
    return !i || i.field == n.active ? !1 : (e.dispatch({
      selection: Vg(n.ranges, i.field),
      effects: zl.of(n.ranges.some((s) => s.field > i.field) ? new Fs(n.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), dl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, di = /* @__PURE__ */ G.define({
  map(t, e) {
    let n = e.mapPos(t, -1, We.TrackAfter);
    return n == null ? void 0 : n;
  }
}), Ug = /* @__PURE__ */ new class extends Si {
}();
Ug.startSide = 1;
Ug.endSide = -1;
const kS = /* @__PURE__ */ Me.define({
  create() {
    return oe.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let n = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of e.effects)
      n.is(di) && (t = t.update({ add: [Ug.range(n.value, n.value + 1)] }));
    return t;
  }
});
function dR() {
  return [gR, kS];
}
const sf = "()[]{}<>";
function xS(t) {
  for (let e = 0; e < sf.length; e += 2)
    if (sf.charCodeAt(e) == t)
      return sf.charAt(e + 1);
  return pg(t < 128 ? t : t + 1);
}
function vS(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || dl;
}
const pR = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), gR = /* @__PURE__ */ T.inputHandler.of((t, e, n, r) => {
  if ((pR ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (r.length > 2 || r.length == 2 && Yt(rt(r, 0)) == 1 || e != i.from || n != i.to)
    return !1;
  let s = bR(t.state, r);
  return s ? (t.dispatch(s), !0) : !1;
}), mR = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let r = vS(t, t.selection.main.head).brackets || dl.brackets, i = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let l = yR(t.doc, o.head);
      for (let a of r)
        if (a == l && Uh(t.doc, o.head) == xS(rt(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: C.cursor(o.head - a.length)
          };
    }
    return { range: i = o };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, OR = [
  { key: "Backspace", run: mR }
];
function bR(t, e) {
  let n = vS(t, t.selection.main.head), r = n.brackets || dl.brackets;
  for (let i of r) {
    let s = xS(rt(i, 0));
    if (e == i)
      return s == i ? xR(t, i, r.indexOf(i + i + i) > -1, n) : wR(t, i, s, n.before || dl.before);
    if (e == s && SS(t, t.selection.main.from))
      return kR(t, i, s);
  }
  return null;
}
function SS(t, e) {
  let n = !1;
  return t.field(kS).between(0, t.doc.length, (r) => {
    r == e && (n = !0);
  }), n;
}
function Uh(t, e) {
  let n = t.sliceString(e, e + 2);
  return n.slice(0, Yt(rt(n, 0)));
}
function yR(t, e) {
  let n = t.sliceString(e - 2, e);
  return Yt(rt(n, 0)) == n.length ? n : n.slice(1);
}
function wR(t, e, n, r) {
  let i = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: n, from: o.to }],
        effects: di.of(o.to + e.length),
        range: C.range(o.anchor + e.length, o.head + e.length)
      };
    let l = Uh(t.doc, o.head);
    return !l || /\s/.test(l) || r.indexOf(l) > -1 ? {
      changes: { insert: e + n, from: o.head },
      effects: di.of(o.head + e.length),
      range: C.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function kR(t, e, n) {
  let r = null, i = t.changeByRange((s) => s.empty && Uh(t.doc, s.head) == n ? {
    changes: { from: s.head, to: s.head + n.length, insert: n },
    range: C.cursor(s.head + n.length)
  } : r = { range: s });
  return r ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function xR(t, e, n, r) {
  let i = r.stringPrefixes || dl.stringPrefixes, s = null, o = t.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: di.of(l.to + e.length),
        range: C.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = Uh(t.doc, a), h;
    if (c == e) {
      if (Z1(t, a))
        return {
          changes: { insert: e + e, from: a },
          effects: di.of(a + e.length),
          range: C.cursor(a + e.length)
        };
      if (SS(t, a)) {
        let f = n && t.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: C.cursor(a + f.length)
        };
      }
    } else {
      if (n && t.sliceDoc(a - 2 * e.length, a) == e + e && (h = I1(t, a - 2 * e.length, i)) > -1 && Z1(t, h))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: di.of(a + e.length),
          range: C.cursor(a + e.length)
        };
      if (t.charCategorizer(a)(c) != Pe.Word && I1(t, a, i) > -1 && !vR(t, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: di.of(a + e.length),
          range: C.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Z1(t, e) {
  let n = Se(t).resolveInner(e + 1);
  return n.parent && n.from == e;
}
function vR(t, e, n, r) {
  let i = Se(t).resolveInner(e, -1), s = r.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s)), a = l.indexOf(n);
    if (!a || a > -1 && r.indexOf(l.slice(0, a)) > -1) {
      let h = i.firstChild;
      for (; h && h.from == i.from && h.to - h.from > n.length + a; ) {
        if (t.sliceDoc(h.to - n.length, h.to) == n)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function I1(t, e, n) {
  let r = t.charCategorizer(e);
  if (r(t.sliceDoc(e - 1, e)) != Pe.Word)
    return e;
  for (let i of n) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && r(t.sliceDoc(s - 1, s)) != Pe.Word)
      return s;
  }
  return -1;
}
function SR(t = {}) {
  return [
    It,
    dt.of(t),
    tR,
    _R,
    yS
  ];
}
const _S = [
  { key: "Ctrl-Space", run: G5 },
  { key: "Escape", run: H5 },
  { key: "ArrowDown", run: /* @__PURE__ */ Ea(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Ea(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Ea(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Ea(!1, "page") },
  { key: "Enter", run: F5 }
], _R = /* @__PURE__ */ yn.highest(/* @__PURE__ */ sr.computeN([dt], (t) => t.facet(dt).defaultKeymap ? [_S] : []));
class CR {
  constructor(e, n, r) {
    this.from = e, this.to = n, this.diagnostic = r;
  }
}
class li {
  constructor(e, n, r) {
    this.diagnostics = e, this.panel = n, this.selected = r;
  }
  static init(e, n, r) {
    let i = e, s = r.facet($S).markerFilter;
    s && (i = s(i));
    let o = I.set(i.map((l) => l.from == l.to || l.from == l.to - 1 && r.doc.lineAt(l.from).to == l.from ? I.widget({
      widget: new RR(l),
      diagnostic: l
    }).range(l.from) : I.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
      diagnostic: l
    }).range(l.from, l.to)), !0);
    return new li(o, n, Ps(o));
  }
}
function Ps(t, e = null, n = 0) {
  let r = null;
  return t.between(n, 1e9, (i, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return r = new CR(i, s, o.diagnostic), !1;
  }), r;
}
function AR(t, e) {
  let n = t.startState.doc.lineAt(e.pos);
  return !!(t.effects.some((r) => r.is(CS)) || t.changes.touchesRange(n.from, n.to));
}
function $R(t, e) {
  return t.field(Nt, !1) ? e : e.concat(G.appendConfig.of(LR));
}
const CS = /* @__PURE__ */ G.define(), Fg = /* @__PURE__ */ G.define(), AS = /* @__PURE__ */ G.define(), Nt = /* @__PURE__ */ Me.define({
  create() {
    return new li(I.none, null, null);
  },
  update(t, e) {
    if (e.docChanged) {
      let n = t.diagnostics.map(e.changes), r = null;
      if (t.selected) {
        let i = e.changes.mapPos(t.selected.from, 1);
        r = Ps(n, t.selected.diagnostic, i) || Ps(n, null, i);
      }
      t = new li(n, t.panel, r);
    }
    for (let n of e.effects)
      n.is(CS) ? t = li.init(n.value, t.panel, e.state) : n.is(Fg) ? t = new li(t.diagnostics, n.value ? Fh.open : null, t.selected) : n.is(AS) && (t = new li(t.diagnostics, t.panel, n.value));
    return t;
  },
  provide: (t) => [
    il.from(t, (e) => e.panel),
    T.decorations.from(t, (e) => e.diagnostics)
  ]
}), PR = /* @__PURE__ */ I.mark({ class: "cm-lintRange cm-lintRange-active" });
function TR(t, e, n) {
  let { diagnostics: r } = t.state.field(Nt), i = [], s = 2e8, o = 0;
  r.between(e - (n < 0 ? 1 : 0), e + (n > 0 ? 1 : 0), (a, c, { spec: h }) => {
    e >= a && e <= c && (a == c || (e > a || n > 0) && (e < c || n < 0)) && (i.push(h.diagnostic), s = Math.min(a, s), o = Math.max(c, o));
  });
  let l = t.state.facet($S).tooltipFilter;
  return l && (i = l(i)), i.length ? {
    pos: s,
    end: o,
    above: t.state.doc.lineAt(s).to < o,
    create() {
      return { dom: QR(t, i) };
    }
  } : null;
}
function QR(t, e) {
  return xe("ul", { class: "cm-tooltip-lint" }, e.map((n) => TS(t, n, !1)));
}
const ER = (t) => {
  let e = t.state.field(Nt, !1);
  (!e || !e.panel) && t.dispatch({ effects: $R(t.state, [Fg.of(!0)]) });
  let n = rl(t, Fh.open);
  return n && n.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, L1 = (t) => {
  let e = t.state.field(Nt, !1);
  return !e || !e.panel ? !1 : (t.dispatch({ effects: Fg.of(!1) }), !0);
}, DR = (t) => {
  let e = t.state.field(Nt, !1);
  if (!e)
    return !1;
  let n = t.state.selection.main, r = e.diagnostics.iter(n.to + 1);
  return !r.value && (r = e.diagnostics.iter(0), !r.value || r.from == n.from && r.to == n.to) ? !1 : (t.dispatch({ selection: { anchor: r.from, head: r.to }, scrollIntoView: !0 }), !0);
}, MR = [
  { key: "Mod-Shift-m", run: ER, preventDefault: !0 },
  { key: "F8", run: DR }
], $S = /* @__PURE__ */ L.define({
  combine(t) {
    return Object.assign({ sources: t.map((e) => e.source) }, zn(t.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, n) => e ? n ? (r) => e(r) || n(r) : e : n
    }));
  }
});
function PS(t) {
  let e = [];
  if (t)
    e:
      for (let { name: n } of t) {
        for (let r = 0; r < n.length; r++) {
          let i = n[r];
          if (/[a-zA-Z]/.test(i) && !e.some((s) => s.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function TS(t, e, n) {
  var r;
  let i = n ? PS(e.actions) : [];
  return xe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, xe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (r = e.actions) === null || r === void 0 ? void 0 : r.map((s, o) => {
    let l = !1, a = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let d = Ps(t.state.field(Nt).diagnostics, e);
      d && s.apply(t, d.from, d.to);
    }, { name: c } = s, h = i[o] ? c.indexOf(i[o]) : -1, u = h < 0 ? c : [
      c.slice(0, h),
      xe("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return xe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${i[o]})"`}.`
    }, u);
  }), e.source && xe("div", { class: "cm-diagnosticSource" }, e.source));
}
class RR extends Tt {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return xe("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class N1 {
  constructor(e, n) {
    this.diagnostic = n, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = TS(e, n, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Fh {
  constructor(e) {
    this.view = e, this.items = [];
    let n = (i) => {
      if (i.keyCode == 27)
        L1(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = PS(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = Ps(this.view.state.field(Nt).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, r = (i) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(i.target) && this.moveSelection(s);
    };
    this.list = xe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: n,
      onclick: r
    }), this.dom = xe("div", { class: "cm-panel-lint" }, this.list, xe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => L1(this.view)
    }, "\xD7")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Nt).selected;
    if (!e)
      return -1;
    for (let n = 0; n < this.items.length; n++)
      if (this.items[n].diagnostic == e.diagnostic)
        return n;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: n } = this.view.state.field(Nt), r = 0, i = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: a }) => {
      let c = -1, h;
      for (let u = r; u < this.items.length; u++)
        if (this.items[u].diagnostic == a.diagnostic) {
          c = u;
          break;
        }
      c < 0 ? (h = new N1(this.view, a.diagnostic), this.items.splice(r, 0, h), i = !0) : (h = this.items[c], c > r && (this.items.splice(r, c - r), i = !0)), n && h.diagnostic == n.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), s = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), r++;
    }); r < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new N1(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        let a = l.height / this.list.offsetHeight;
        o.top < l.top ? this.list.scrollTop -= (l.top - o.top) / a : o.bottom > l.bottom && (this.list.scrollTop += (o.bottom - l.bottom) / a);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function n() {
      let r = e;
      e = r.nextSibling, r.remove();
    }
    for (let r of this.items)
      if (r.dom.parentNode == this.list) {
        for (; e != r.dom; )
          n();
        e = r.dom.nextSibling;
      } else
        this.list.insertBefore(r.dom, e);
    for (; e; )
      n();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let n = this.view.state.field(Nt), r = Ps(n.diagnostics, this.items[e].diagnostic);
    !r || this.view.dispatch({
      selection: { anchor: r.from, head: r.to },
      scrollIntoView: !0,
      effects: AS.of(r)
    });
  }
  static open(e) {
    return new Fh(e);
  }
}
function ZR(t, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(t)}</svg>')`;
}
function Da(t) {
  return ZR(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${t}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const IR = /* @__PURE__ */ T.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Da("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Da("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Da("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Da("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), LR = [
  Nt,
  /* @__PURE__ */ T.decorations.compute([Nt], (t) => {
    let { selected: e, panel: n } = t.field(Nt);
    return !e || !n || e.from == e.to ? I.none : I.set([
      PR.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ DE(TR, { hideOn: AR }),
  IR
], NR = /* @__PURE__ */ (() => [
  BE(),
  XE(),
  jx(),
  Ig(),
  ZD(),
  qx(),
  oE(),
  re.allowMultipleSelections.of(!0),
  SD(),
  mv(Ov, { fallback: !0 }),
  zD(),
  dR(),
  SR(),
  xE(),
  _E(),
  Xx(),
  h5(),
  sr.of([
    ...OR,
    ...tS,
    ...P5,
    ...$v,
    ...ED,
    ..._S,
    ...MR
  ])
])(), qR = /* @__PURE__ */ (() => [
  jx(),
  Ig(),
  qx(),
  mv(Ov, { fallback: !0 }),
  sr.of([
    ...tS,
    ...$v
  ])
])(), fn = () => /* @__PURE__ */ new Map(), dp = (t) => {
  const e = fn();
  return t.forEach((n, r) => {
    e.set(r, n);
  }), e;
}, mr = (t, e, n) => {
  let r = t.get(e);
  return r === void 0 && t.set(e, r = n()), r;
}, BR = (t, e) => {
  const n = [];
  for (const [r, i] of t)
    n.push(e(i, r));
  return n;
}, YR = (t, e) => {
  for (const [n, r] of t)
    if (e(r, n))
      return !0;
  return !1;
}, Ai = () => /* @__PURE__ */ new Set(), of = (t) => t[t.length - 1], jR = (t, e) => {
  for (let n = 0; n < e.length; n++)
    t.push(e[n]);
}, Xr = Array.from, XR = (t, e) => {
  for (let n = 0; n < t.length; n++)
    if (e(t[n], n, t))
      return !0;
  return !1;
}, pp = Array.isArray;
class Gh {
  constructor() {
    this._observers = fn();
  }
  on(e, n) {
    mr(this._observers, e, Ai).add(n);
  }
  once(e, n) {
    const r = (...i) => {
      this.off(e, r), n(...i);
    };
    this.on(e, r);
  }
  off(e, n) {
    const r = this._observers.get(e);
    r !== void 0 && (r.delete(n), r.size === 0 && this._observers.delete(e));
  }
  emit(e, n) {
    return Xr((this._observers.get(e) || fn()).values()).forEach((r) => r(...n));
  }
  destroy() {
    this._observers = fn();
  }
}
const pr = Math.floor, mc = Math.abs, Hh = (t, e) => t < e ? t : e, Gr = (t, e) => t > e ? t : e, WR = Math.pow, QS = (t) => t !== 0 ? t < 0 : 1 / t < 0, q1 = 1, B1 = 2, lf = 4, af = 8, pl = 32, lr = 64, qt = 128, Jh = 31, gp = 63, bi = 127, zR = 2147483647, ES = Number.MAX_SAFE_INTEGER, VR = Number.isInteger || ((t) => typeof t == "number" && isFinite(t) && pr(t) === t), UR = String.fromCharCode, FR = (t) => t.toLowerCase(), GR = /^\s*/g, HR = (t) => t.replace(GR, ""), JR = /([A-Z])/g, Y1 = (t, e) => HR(t.replace(JR, (n) => `${e}${FR(n)}`)), KR = (t) => {
  const e = unescape(encodeURIComponent(t)), n = e.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = e.codePointAt(i);
  return r;
}, gl = typeof TextEncoder < "u" ? new TextEncoder() : null, eZ = (t) => gl.encode(t), tZ = gl ? eZ : KR;
let No = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
No && No.decode(new Uint8Array()).length === 1 && (No = null);
class Vl {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const ht = () => new Vl(), Gg = (t) => {
  let e = t.cpos;
  for (let n = 0; n < t.bufs.length; n++)
    e += t.bufs[n].length;
  return e;
}, Qe = (t) => {
  const e = new Uint8Array(Gg(t));
  let n = 0;
  for (let r = 0; r < t.bufs.length; r++) {
    const i = t.bufs[r];
    e.set(i, n), n += i.length;
  }
  return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
}, nZ = (t, e) => {
  const n = t.cbuf.length;
  n - t.cpos < e && (t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)), t.cbuf = new Uint8Array(Gr(n, e) * 2), t.cpos = 0);
}, He = (t, e) => {
  const n = t.cbuf.length;
  t.cpos === n && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(n * 2), t.cpos = 0), t.cbuf[t.cpos++] = e;
}, mp = He, U = (t, e) => {
  for (; e > bi; )
    He(t, qt | bi & e), e = pr(e / 128);
  He(t, bi & e);
}, Hg = (t, e) => {
  const n = QS(e);
  for (n && (e = -e), He(t, (e > gp ? qt : 0) | (n ? lr : 0) | gp & e), e = pr(e / 64); e > 0; )
    He(t, (e > bi ? qt : 0) | bi & e), e = pr(e / 128);
}, Op = new Uint8Array(3e4), rZ = Op.length / 3, iZ = (t, e) => {
  if (e.length < rZ) {
    const n = gl.encodeInto(e, Op).written || 0;
    U(t, n);
    for (let r = 0; r < n; r++)
      He(t, Op[r]);
  } else
    Re(t, tZ(e));
}, sZ = (t, e) => {
  const n = unescape(encodeURIComponent(e)), r = n.length;
  U(t, r);
  for (let i = 0; i < r; i++)
    He(t, n.codePointAt(i));
}, yi = gl && gl.encodeInto ? iZ : sZ, Kh = (t, e) => {
  const n = t.cbuf.length, r = t.cpos, i = Hh(n - r, e.length), s = e.length - i;
  t.cbuf.set(e.subarray(0, i), r), t.cpos += i, s > 0 && (t.bufs.push(t.cbuf), t.cbuf = new Uint8Array(Gr(n * 2, s)), t.cbuf.set(e.subarray(i)), t.cpos = s);
}, Re = (t, e) => {
  U(t, e.byteLength), Kh(t, e);
}, Jg = (t, e) => {
  nZ(t, e);
  const n = new DataView(t.cbuf.buffer, t.cpos, e);
  return t.cpos += e, n;
}, oZ = (t, e) => Jg(t, 4).setFloat32(0, e, !1), lZ = (t, e) => Jg(t, 8).setFloat64(0, e, !1), aZ = (t, e) => Jg(t, 8).setBigInt64(0, e, !1), j1 = new DataView(new ArrayBuffer(4)), cZ = (t) => (j1.setFloat32(0, t), j1.getFloat32(0) === t), ml = (t, e) => {
  switch (typeof e) {
    case "string":
      He(t, 119), yi(t, e);
      break;
    case "number":
      VR(e) && mc(e) <= zR ? (He(t, 125), Hg(t, e)) : cZ(e) ? (He(t, 124), oZ(t, e)) : (He(t, 123), lZ(t, e));
      break;
    case "bigint":
      He(t, 122), aZ(t, e);
      break;
    case "object":
      if (e === null)
        He(t, 126);
      else if (pp(e)) {
        He(t, 117), U(t, e.length);
        for (let n = 0; n < e.length; n++)
          ml(t, e[n]);
      } else if (e instanceof Uint8Array)
        He(t, 116), Re(t, e);
      else {
        He(t, 118);
        const n = Object.keys(e);
        U(t, n.length);
        for (let r = 0; r < n.length; r++) {
          const i = n[r];
          yi(t, i), ml(t, e[i]);
        }
      }
      break;
    case "boolean":
      He(t, e ? 120 : 121);
      break;
    default:
      He(t, 127);
  }
};
class X1 extends Vl {
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && U(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const W1 = (t) => {
  t.count > 0 && (Hg(t.encoder, t.count === 1 ? t.s : -t.s), t.count > 1 && U(t.encoder, t.count - 2));
};
class Oc {
  constructor() {
    this.encoder = new Vl(), this.s = 0, this.count = 0;
  }
  write(e) {
    this.s === e ? this.count++ : (W1(this), this.count = 1, this.s = e);
  }
  toUint8Array() {
    return W1(this), Qe(this.encoder);
  }
}
const z1 = (t) => {
  if (t.count > 0) {
    const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
    Hg(t.encoder, e), t.count > 1 && U(t.encoder, t.count - 2);
  }
};
class cf {
  constructor() {
    this.encoder = new Vl(), this.s = 0, this.count = 0, this.diff = 0;
  }
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (z1(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  toUint8Array() {
    return z1(this), Qe(this.encoder);
  }
}
class hZ {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Oc();
  }
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Vl();
    return this.sarr.push(this.s), this.s = "", yi(e, this.sarr.join("")), Kh(e, this.lensE.toUint8Array()), Qe(e);
  }
}
const Wr = (t) => new Error(t), Bn = () => {
  throw Wr("Method unimplemented");
}, On = () => {
  throw Wr("Unexpected case");
}, DS = Wr("Unexpected end of array"), MS = Wr("Integer out of Range");
class eu {
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const Hr = (t) => new eu(t), uZ = (t) => t.pos !== t.arr.length, fZ = (t, e) => {
  const n = new Uint8Array(t.arr.buffer, t.pos + t.arr.byteOffset, e);
  return t.pos += e, n;
}, ct = (t) => fZ(t, J(t)), Ts = (t) => t.arr[t.pos++], J = (t) => {
  let e = 0, n = 1;
  const r = t.arr.length;
  for (; t.pos < r; ) {
    const i = t.arr[t.pos++];
    if (e = e + (i & bi) * n, n *= 128, i < qt)
      return e;
    if (e > ES)
      throw MS;
  }
  throw DS;
}, Kg = (t) => {
  let e = t.arr[t.pos++], n = e & gp, r = 64;
  const i = (e & lr) > 0 ? -1 : 1;
  if ((e & qt) === 0)
    return i * n;
  const s = t.arr.length;
  for (; t.pos < s; ) {
    if (e = t.arr[t.pos++], n = n + (e & bi) * r, r *= 128, e < qt)
      return i * n;
    if (n > ES)
      throw MS;
  }
  throw DS;
}, dZ = (t) => {
  let e = J(t);
  if (e === 0)
    return "";
  {
    let n = String.fromCodePoint(Ts(t));
    if (--e < 100)
      for (; e--; )
        n += String.fromCodePoint(Ts(t));
    else
      for (; e > 0; ) {
        const r = e < 1e4 ? e : 1e4, i = t.arr.subarray(t.pos, t.pos + r);
        t.pos += r, n += String.fromCodePoint.apply(null, i), e -= r;
      }
    return decodeURIComponent(escape(n));
  }
}, pZ = (t) => No.decode(ct(t)), Zr = No ? pZ : dZ, em = (t, e) => {
  const n = new DataView(t.arr.buffer, t.arr.byteOffset + t.pos, e);
  return t.pos += e, n;
}, gZ = (t) => em(t, 4).getFloat32(0, !1), mZ = (t) => em(t, 8).getFloat64(0, !1), OZ = (t) => em(t, 8).getBigInt64(0, !1), bZ = [
  (t) => {
  },
  (t) => null,
  Kg,
  gZ,
  mZ,
  OZ,
  (t) => !1,
  (t) => !0,
  Zr,
  (t) => {
    const e = J(t), n = {};
    for (let r = 0; r < e; r++) {
      const i = Zr(t);
      n[i] = Ol(t);
    }
    return n;
  },
  (t) => {
    const e = J(t), n = [];
    for (let r = 0; r < e; r++)
      n.push(Ol(t));
    return n;
  },
  ct
], Ol = (t) => bZ[127 - Ts(t)](t);
class V1 extends eu {
  constructor(e, n) {
    super(e), this.reader = n, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), uZ(this) ? this.count = J(this) + 1 : this.count = -1), this.count--, this.s;
  }
}
class bc extends eu {
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Kg(this);
      const e = QS(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = J(this) + 2);
    }
    return this.count--, this.s;
  }
}
class hf extends eu {
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  read() {
    if (this.count === 0) {
      const e = Kg(this), n = e & 1;
      this.diff = pr(e / 2), this.count = 1, n && (this.count = J(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class yZ {
  constructor(e) {
    this.decoder = new bc(e), this.str = Zr(this.decoder), this.spos = 0;
  }
  read() {
    const e = this.spos + this.decoder.read(), n = this.str.slice(this.spos, e);
    return this.spos = e, n;
  }
}
const wZ = crypto.getRandomValues.bind(crypto), RS = () => wZ(new Uint32Array(1))[0], kZ = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, xZ = () => kZ.replace(
  /[018]/g,
  (t) => (t ^ RS() & 15 >> t / 4).toString(16)
), zr = Date.now, U1 = (t) => new Promise(t);
Promise.all.bind(Promise);
const F1 = (t) => t === void 0 ? null : t;
class vZ {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  setItem(e, n) {
    this.map.set(e, n);
  }
  getItem(e) {
    return this.map.get(e);
  }
}
let ZS = new vZ(), tm = !0;
try {
  typeof localStorage < "u" && localStorage && (ZS = localStorage, tm = !1);
} catch {
}
const IS = ZS, SZ = (t) => tm || addEventListener("storage", t), _Z = (t) => tm || removeEventListener("storage", t), CZ = Object.assign, AZ = Object.keys, $Z = (t, e) => {
  for (const n in t)
    e(t[n], n);
}, PZ = (t, e) => {
  const n = [];
  for (const r in t)
    n.push(e(t[r], r));
  return n;
}, Kc = (t) => AZ(t).length, TZ = (t) => {
  for (const e in t)
    return !1;
  return !0;
}, QZ = (t, e) => {
  for (const n in t)
    if (!e(t[n], n))
      return !1;
  return !0;
}, LS = (t, e) => Object.prototype.hasOwnProperty.call(t, e), EZ = (t, e) => t === e || Kc(t) === Kc(e) && QZ(t, (n, r) => (n !== void 0 || LS(e, r)) && e[r] === n), nm = (t, e, n = 0) => {
  try {
    for (; n < t.length; n++)
      t[n](...e);
  } finally {
    n < t.length && nm(t, e, n + 1);
  }
}, DZ = (t) => t, MZ = (t, e) => t === e, qo = (t, e) => {
  if (t == null || e == null)
    return MZ(t, e);
  if (t.constructor !== e.constructor)
    return !1;
  if (t === e)
    return !0;
  switch (t.constructor) {
    case ArrayBuffer:
      t = new Uint8Array(t), e = new Uint8Array(e);
    case Uint8Array: {
      if (t.byteLength !== e.byteLength)
        return !1;
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e[n])
          return !1;
      break;
    }
    case Set: {
      if (t.size !== e.size)
        return !1;
      for (const n of t)
        if (!e.has(n))
          return !1;
      break;
    }
    case Map: {
      if (t.size !== e.size)
        return !1;
      for (const n of t.keys())
        if (!e.has(n) || !qo(t.get(n), e.get(n)))
          return !1;
      break;
    }
    case Object:
      if (Kc(t) !== Kc(e))
        return !1;
      for (const n in t)
        if (!LS(t, n) || !qo(t[n], e[n]))
          return !1;
      break;
    case Array:
      if (t.length !== e.length)
        return !1;
      for (let n = 0; n < t.length; n++)
        if (!qo(t[n], e[n]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, RZ = (t, e) => e.includes(t), Qs = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", NS = typeof window < "u" && typeof document < "u" && !Qs;
typeof navigator < "u" && /Mac/.test(navigator.platform);
let $n;
const ZZ = () => {
  if ($n === void 0)
    if (Qs) {
      $n = fn();
      const t = process.argv;
      let e = null;
      for (let n = 0; n < t.length; n++) {
        const r = t[n];
        r[0] === "-" ? (e !== null && $n.set(e, ""), e = r) : e !== null && ($n.set(e, r), e = null);
      }
      e !== null && $n.set(e, "");
    } else
      typeof location == "object" ? ($n = fn(), (location.search || "?").slice(1).split("&").forEach((t) => {
        if (t.length !== 0) {
          const [e, n] = t.split("=");
          $n.set(`--${Y1(e, "-")}`, n), $n.set(`-${Y1(e, "-")}`, n);
        }
      })) : $n = fn();
  return $n;
}, bp = (t) => ZZ().has(t), yp = (t) => F1(Qs ? {}[t.toUpperCase()] : IS.getItem(t)), IZ = (t) => bp("--" + t) || yp(t) !== null;
IZ("production");
const G1 = Qs && RZ({}.FORCE_COLOR, ["true", "1", "2"]), LZ = !bp("no-colors") && (!Qs || process.stdout.isTTY || G1) && (!Qs || bp("color") || G1 || yp("COLORTERM") !== null || (yp("TERM") || "").includes("color")), qS = (t) => new Uint8Array(t), NZ = (t, e, n) => new Uint8Array(t, e, n), qZ = (t) => new Uint8Array(t), BZ = (t) => {
  let e = "";
  for (let n = 0; n < t.byteLength; n++)
    e += UR(t[n]);
  return btoa(e);
}, YZ = (t) => Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("base64"), jZ = (t) => {
  const e = atob(t), n = qS(e.length);
  for (let r = 0; r < e.length; r++)
    n[r] = e.charCodeAt(r);
  return n;
}, XZ = (t) => {
  const e = Buffer.from(t, "base64");
  return NZ(e.buffer, e.byteOffset, e.byteLength);
}, WZ = NS ? BZ : YZ, zZ = NS ? jZ : XZ, VZ = (t) => {
  const e = qS(t.byteLength);
  return e.set(t), e;
};
class UZ {
  constructor(e, n) {
    this.left = e, this.right = n;
  }
}
const Rt = (t, e) => new UZ(t, e), FZ = (t, e) => t.forEach((n) => e(n.left, n.right)), Un = typeof document < "u" ? document : {}, GZ = (t) => Un.createElement(t), HZ = () => Un.createDocumentFragment(), JZ = (t) => Un.createTextNode(t);
typeof DOMParser < "u" && new DOMParser();
const KZ = (t, e) => (FZ(e, (n, r) => {
  r === !1 ? t.removeAttribute(n) : r === !0 ? t.setAttribute(n, "") : t.setAttribute(n, r);
}), t), eI = (t) => {
  const e = HZ();
  for (let n = 0; n < t.length; n++)
    BS(e, t[n]);
  return e;
}, tI = (t, e) => (BS(t, eI(e)), t), uf = (t, e = [], n = []) => tI(KZ(GZ(t), e), n), Ma = JZ, nI = (t) => BR(t, (e, n) => `${n}:${e};`).join(""), BS = (t, e) => t.appendChild(e);
Un.ELEMENT_NODE;
Un.TEXT_NODE;
Un.CDATA_SECTION_NODE;
Un.COMMENT_NODE;
Un.DOCUMENT_NODE;
Un.DOCUMENT_TYPE_NODE;
Un.DOCUMENT_FRAGMENT_NODE;
const Or = Symbol, YS = Or(), jS = Or(), rI = Or(), iI = Or(), sI = Or(), XS = Or(), oI = Or(), rm = Or(), lI = Or(), aI = (t) => {
  const e = [];
  let n = 0;
  for (; n < t.length; n++) {
    const r = t[n];
    r.constructor === String || r.constructor === Number || r.constructor === Object && e.push(JSON.stringify(r));
  }
  return e;
}, cI = {
  [YS]: Rt("font-weight", "bold"),
  [jS]: Rt("font-weight", "normal"),
  [rI]: Rt("color", "blue"),
  [sI]: Rt("color", "green"),
  [iI]: Rt("color", "grey"),
  [XS]: Rt("color", "red"),
  [oI]: Rt("color", "purple"),
  [rm]: Rt("color", "orange"),
  [lI]: Rt("color", "black")
}, hI = (t) => {
  const e = [], n = [], r = fn();
  let i = [], s = 0;
  for (; s < t.length; s++) {
    const o = t[s], l = cI[o];
    if (l !== void 0)
      r.set(l.left, l.right);
    else if (o.constructor === String || o.constructor === Number) {
      const a = nI(r);
      s > 0 || a.length > 0 ? (e.push("%c" + o), n.push(a)) : e.push(o);
    } else
      break;
  }
  for (s > 0 && (i = n, i.unshift(e.join(""))); s < t.length; s++) {
    const o = t[s];
    o instanceof Symbol || i.push(o);
  }
  return i;
}, WS = LZ ? hI : aI, uI = (...t) => {
  console.log(...WS(t)), zS.forEach((e) => e.print(t));
}, fI = (...t) => {
  console.warn(...WS(t)), t.unshift(rm), zS.forEach((e) => e.print(t));
}, zS = Ai(), VS = (t) => ({
  [Symbol.iterator]() {
    return this;
  },
  next: t
}), dI = (t, e) => VS(() => {
  let n;
  do
    n = t.next();
  while (!n.done && !e(n.value));
  return n;
}), ff = (t, e) => VS(() => {
  const { done: n, value: r } = t.next();
  return { done: n, value: n ? void 0 : e(r) };
});
class im {
  constructor(e, n) {
    this.clock = e, this.len = n;
  }
}
class Gs {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const Es = (t, e, n) => e.clients.forEach((r, i) => {
  const s = t.doc.store.clients.get(i);
  for (let o = 0; o < r.length; o++) {
    const l = r[o];
    a_(t, s, l.clock, l.len, n);
  }
}), pI = (t, e) => {
  let n = 0, r = t.length - 1;
  for (; n <= r; ) {
    const i = pr((n + r) / 2), s = t[i], o = s.clock;
    if (o <= e) {
      if (e < o + s.len)
        return i;
      n = i + 1;
    } else
      r = i - 1;
  }
  return null;
}, Ul = (t, e) => {
  const n = t.clients.get(e.client);
  return n !== void 0 && pI(n, e.clock) !== null;
}, sm = (t) => {
  t.clients.forEach((e) => {
    e.sort((i, s) => i.clock - s.clock);
    let n, r;
    for (n = 1, r = 1; n < e.length; n++) {
      const i = e[r - 1], s = e[n];
      i.clock + i.len >= s.clock ? i.len = Gr(i.len, s.clock + s.len - i.clock) : (r < n && (e[r] = s), r++);
    }
    e.length = r;
  });
}, wp = (t) => {
  const e = new Gs();
  for (let n = 0; n < t.length; n++)
    t[n].clients.forEach((r, i) => {
      if (!e.clients.has(i)) {
        const s = r.slice();
        for (let o = n + 1; o < t.length; o++)
          jR(s, t[o].clients.get(i) || []);
        e.clients.set(i, s);
      }
    });
  return sm(e), e;
}, bl = (t, e, n, r) => {
  mr(t.clients, e, () => []).push(new im(n, r));
}, US = () => new Gs(), gI = (t) => {
  const e = US();
  return t.clients.forEach((n, r) => {
    const i = [];
    for (let s = 0; s < n.length; s++) {
      const o = n[s];
      if (o.deleted) {
        const l = o.id.clock;
        let a = o.length;
        if (s + 1 < n.length)
          for (let c = n[s + 1]; s + 1 < n.length && c.deleted; c = n[++s + 1])
            a += c.length;
        i.push(new im(l, a));
      }
    }
    i.length > 0 && e.clients.set(r, i);
  }), e;
}, Hs = (t, e) => {
  U(t.restEncoder, e.clients.size), Xr(e.clients.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
    t.resetDsCurVal(), U(t.restEncoder, n);
    const i = r.length;
    U(t.restEncoder, i);
    for (let s = 0; s < i; s++) {
      const o = r[s];
      t.writeDsClock(o.clock), t.writeDsLen(o.len);
    }
  });
}, om = (t) => {
  const e = new Gs(), n = J(t.restDecoder);
  for (let r = 0; r < n; r++) {
    t.resetDsCurVal();
    const i = J(t.restDecoder), s = J(t.restDecoder);
    if (s > 0) {
      const o = mr(e.clients, i, () => []);
      for (let l = 0; l < s; l++)
        o.push(new im(t.readDsClock(), t.readDsLen()));
    }
  }
  return e;
}, H1 = (t, e, n) => {
  const r = new Gs(), i = J(t.restDecoder);
  for (let s = 0; s < i; s++) {
    t.resetDsCurVal();
    const o = J(t.restDecoder), l = J(t.restDecoder), a = n.clients.get(o) || [], c = Ne(n, o);
    for (let h = 0; h < l; h++) {
      const u = t.readDsClock(), f = u + t.readDsLen();
      if (u < c) {
        c < f && bl(r, o, c, f - c);
        let d = Xn(a, u), p = a[d];
        for (!p.deleted && p.id.clock < u && (a.splice(d + 1, 0, lh(e, p, u - p.id.clock)), d++); d < a.length && (p = a[d++], p.id.clock < f); )
          p.deleted || (f < p.id.clock + p.length && a.splice(d, 0, lh(e, p, f - p.id.clock)), p.delete(e));
      } else
        bl(r, o, u, f - u);
    }
  }
  if (r.clients.size > 0) {
    const s = new $i();
    return U(s.restEncoder, 0), Hs(s, r), s.toUint8Array();
  }
  return null;
}, FS = RS;
class Js extends Gh {
  constructor({ guid: e = xZ(), collectionid: n = null, gc: r = !0, gcFilter: i = () => !0, meta: s = null, autoLoad: o = !1, shouldLoad: l = !0 } = {}) {
    super(), this.gc = r, this.gcFilter = i, this.clientID = FS(), this.guid = e, this.collectionid = n, this.share = /* @__PURE__ */ new Map(), this.store = new o_(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = l, this.autoLoad = o, this.meta = s, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = U1((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const a = () => U1((c) => {
      const h = (u) => {
        (u === void 0 || u === !0) && (this.off("sync", h), c());
      };
      this.on("sync", h);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = a()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", []);
    }), this.whenSynced = a();
  }
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && ye(e.parent.doc, (n) => {
      n.subdocsLoaded.add(this);
    }, null, !0), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Xr(this.subdocs).map((e) => e.guid));
  }
  transact(e, n = null) {
    return ye(this, e, n);
  }
  get(e, n = ot) {
    const r = mr(this.share, e, () => {
      const s = new n();
      return s._integrate(this, null), s;
    }), i = r.constructor;
    if (n !== ot && i !== n)
      if (i === ot) {
        const s = new n();
        s._map = r._map, r._map.forEach((o) => {
          for (; o !== null; o = o.left)
            o.parent = s;
        }), s._start = r._start;
        for (let o = s._start; o !== null; o = o.right)
          o.parent = s;
        return s._length = r._length, this.share.set(e, s), s._integrate(this, null), s;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return r;
  }
  getArray(e = "") {
    return this.get(e, us);
  }
  getText(e = "") {
    return this.get(e, Ms);
  }
  getMap(e = "") {
    return this.get(e, ar);
  }
  getXmlFragment(e = "") {
    return this.get(e, Pi);
  }
  toJSON() {
    const e = {};
    return this.share.forEach((n, r) => {
      e[r] = n.toJSON();
    }), e;
  }
  destroy() {
    Xr(this.subdocs).forEach((n) => n.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const n = e.content;
      n.doc = new Js({ guid: this.guid, ...n.opts, shouldLoad: !1 }), n.doc._item = e, ye(e.parent.doc, (r) => {
        const i = n.doc;
        e.deleted || r.subdocsAdded.add(i), r.subdocsRemoved.add(this);
      }, null, !0);
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
  on(e, n) {
    super.on(e, n);
  }
  off(e, n) {
    super.off(e, n);
  }
}
class GS {
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  readDsClock() {
    return J(this.restDecoder);
  }
  readDsLen() {
    return J(this.restDecoder);
  }
}
class HS extends GS {
  readLeftID() {
    return ee(J(this.restDecoder), J(this.restDecoder));
  }
  readRightID() {
    return ee(J(this.restDecoder), J(this.restDecoder));
  }
  readClient() {
    return J(this.restDecoder);
  }
  readInfo() {
    return Ts(this.restDecoder);
  }
  readString() {
    return Zr(this.restDecoder);
  }
  readParentInfo() {
    return J(this.restDecoder) === 1;
  }
  readTypeRef() {
    return J(this.restDecoder);
  }
  readLen() {
    return J(this.restDecoder);
  }
  readAny() {
    return Ol(this.restDecoder);
  }
  readBuf() {
    return VZ(ct(this.restDecoder));
  }
  readJSON() {
    return JSON.parse(Zr(this.restDecoder));
  }
  readKey() {
    return Zr(this.restDecoder);
  }
}
class mI {
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  readDsClock() {
    return this.dsCurrVal += J(this.restDecoder), this.dsCurrVal;
  }
  readDsLen() {
    const e = J(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Ds extends mI {
  constructor(e) {
    super(e), this.keys = [], J(e), this.keyClockDecoder = new hf(ct(e)), this.clientDecoder = new bc(ct(e)), this.leftClockDecoder = new hf(ct(e)), this.rightClockDecoder = new hf(ct(e)), this.infoDecoder = new V1(ct(e), Ts), this.stringDecoder = new yZ(ct(e)), this.parentInfoDecoder = new V1(ct(e), Ts), this.typeRefDecoder = new bc(ct(e)), this.lenDecoder = new bc(ct(e));
  }
  readLeftID() {
    return new hs(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  readRightID() {
    return new hs(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  readClient() {
    return this.clientDecoder.read();
  }
  readInfo() {
    return this.infoDecoder.read();
  }
  readString() {
    return this.stringDecoder.read();
  }
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  readLen() {
    return this.lenDecoder.read();
  }
  readAny() {
    return Ol(this.restDecoder);
  }
  readBuf() {
    return ct(this.restDecoder);
  }
  readJSON() {
    return Ol(this.restDecoder);
  }
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const n = this.stringDecoder.read();
      return this.keys.push(n), n;
    }
  }
}
class JS {
  constructor() {
    this.restEncoder = ht();
  }
  toUint8Array() {
    return Qe(this.restEncoder);
  }
  resetDsCurVal() {
  }
  writeDsClock(e) {
    U(this.restEncoder, e);
  }
  writeDsLen(e) {
    U(this.restEncoder, e);
  }
}
class Fl extends JS {
  writeLeftID(e) {
    U(this.restEncoder, e.client), U(this.restEncoder, e.clock);
  }
  writeRightID(e) {
    U(this.restEncoder, e.client), U(this.restEncoder, e.clock);
  }
  writeClient(e) {
    U(this.restEncoder, e);
  }
  writeInfo(e) {
    mp(this.restEncoder, e);
  }
  writeString(e) {
    yi(this.restEncoder, e);
  }
  writeParentInfo(e) {
    U(this.restEncoder, e ? 1 : 0);
  }
  writeTypeRef(e) {
    U(this.restEncoder, e);
  }
  writeLen(e) {
    U(this.restEncoder, e);
  }
  writeAny(e) {
    ml(this.restEncoder, e);
  }
  writeBuf(e) {
    Re(this.restEncoder, e);
  }
  writeJSON(e) {
    yi(this.restEncoder, JSON.stringify(e));
  }
  writeKey(e) {
    yi(this.restEncoder, e);
  }
}
class KS {
  constructor() {
    this.restEncoder = ht(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Qe(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  writeDsClock(e) {
    const n = e - this.dsCurrVal;
    this.dsCurrVal = e, U(this.restEncoder, n);
  }
  writeDsLen(e) {
    e === 0 && On(), U(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class $i extends KS {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new cf(), this.clientEncoder = new Oc(), this.leftClockEncoder = new cf(), this.rightClockEncoder = new cf(), this.infoEncoder = new X1(mp), this.stringEncoder = new hZ(), this.parentInfoEncoder = new X1(mp), this.typeRefEncoder = new Oc(), this.lenEncoder = new Oc();
  }
  toUint8Array() {
    const e = ht();
    return U(e, 0), Re(e, this.keyClockEncoder.toUint8Array()), Re(e, this.clientEncoder.toUint8Array()), Re(e, this.leftClockEncoder.toUint8Array()), Re(e, this.rightClockEncoder.toUint8Array()), Re(e, Qe(this.infoEncoder)), Re(e, this.stringEncoder.toUint8Array()), Re(e, Qe(this.parentInfoEncoder)), Re(e, this.typeRefEncoder.toUint8Array()), Re(e, this.lenEncoder.toUint8Array()), Kh(e, Qe(this.restEncoder)), Qe(e);
  }
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  writeString(e) {
    this.stringEncoder.write(e);
  }
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  writeAny(e) {
    ml(this.restEncoder, e);
  }
  writeBuf(e) {
    Re(this.restEncoder, e);
  }
  writeJSON(e) {
    ml(this.restEncoder, e);
  }
  writeKey(e) {
    const n = this.keyMap.get(e);
    n === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(n);
  }
}
const OI = (t, e, n, r) => {
  r = Gr(r, e[0].id.clock);
  const i = Xn(e, r);
  U(t.restEncoder, e.length - i), t.writeClient(n), U(t.restEncoder, r);
  const s = e[i];
  s.write(t, r - s.id.clock);
  for (let o = i + 1; o < e.length; o++)
    e[o].write(t, 0);
}, lm = (t, e, n) => {
  const r = /* @__PURE__ */ new Map();
  n.forEach((i, s) => {
    Ne(e, s) > i && r.set(s, i);
  }), tu(e).forEach((i, s) => {
    n.has(s) || r.set(s, 0);
  }), U(t.restEncoder, r.size), Xr(r.entries()).sort((i, s) => s[0] - i[0]).forEach(([i, s]) => {
    OI(t, e.clients.get(i), i, s);
  });
}, bI = (t, e) => {
  const n = fn(), r = J(t.restDecoder);
  for (let i = 0; i < r; i++) {
    const s = J(t.restDecoder), o = new Array(s), l = t.readClient();
    let a = J(t.restDecoder);
    n.set(l, { i: 0, refs: o });
    for (let c = 0; c < s; c++) {
      const h = t.readInfo();
      switch (Jh & h) {
        case 0: {
          const u = t.readLen();
          o[c] = new jt(ee(l, a), u), a += u;
          break;
        }
        case 10: {
          const u = J(t.restDecoder);
          o[c] = new Xt(ee(l, a), u), a += u;
          break;
        }
        default: {
          const u = (h & (lr | qt)) === 0, f = new we(
            ee(l, a),
            null,
            (h & qt) === qt ? t.readLeftID() : null,
            null,
            (h & lr) === lr ? t.readRightID() : null,
            u ? t.readParentInfo() ? e.get(t.readString()) : t.readLeftID() : null,
            u && (h & pl) === pl ? t.readString() : null,
            $_(t, h)
          );
          o[c] = f, a += f.length;
        }
      }
    }
  }
  return n;
}, yI = (t, e, n) => {
  const r = [];
  let i = Xr(n.keys()).sort((d, p) => d - p);
  if (i.length === 0)
    return null;
  const s = () => {
    if (i.length === 0)
      return null;
    let d = n.get(i[i.length - 1]);
    for (; d.refs.length === d.i; )
      if (i.pop(), i.length > 0)
        d = n.get(i[i.length - 1]);
      else
        return null;
    return d;
  };
  let o = s();
  if (o === null)
    return null;
  const l = new o_(), a = /* @__PURE__ */ new Map(), c = (d, p) => {
    const g = a.get(d);
    (g == null || g > p) && a.set(d, p);
  };
  let h = o.refs[o.i++];
  const u = /* @__PURE__ */ new Map(), f = () => {
    for (const d of r) {
      const p = d.id.client, g = n.get(p);
      g ? (g.i--, l.clients.set(p, g.refs.slice(g.i)), n.delete(p), g.i = 0, g.refs = []) : l.clients.set(p, [d]), i = i.filter((m) => m !== p);
    }
    r.length = 0;
  };
  for (; ; ) {
    if (h.constructor !== Xt) {
      const p = mr(u, h.id.client, () => Ne(e, h.id.client)) - h.id.clock;
      if (p < 0)
        r.push(h), c(h.id.client, h.id.clock - 1), f();
      else {
        const g = h.getMissing(t, e);
        if (g !== null) {
          r.push(h);
          const m = n.get(g) || { refs: [], i: 0 };
          if (m.refs.length === m.i)
            c(g, Ne(e, g)), f();
          else {
            h = m.refs[m.i++];
            continue;
          }
        } else
          (p === 0 || p < h.length) && (h.integrate(t, p), u.set(h.id.client, h.id.clock + h.length));
      }
    }
    if (r.length > 0)
      h = r.pop();
    else if (o !== null && o.i < o.refs.length)
      h = o.refs[o.i++];
    else {
      if (o = s(), o === null)
        break;
      h = o.refs[o.i++];
    }
  }
  if (l.clients.size > 0) {
    const d = new $i();
    return lm(d, l, /* @__PURE__ */ new Map()), U(d.restEncoder, 0), { missing: a, update: d.toUint8Array() };
  }
  return null;
}, wI = (t, e) => lm(t, e.doc.store, e.beforeState), kI = (t, e, n, r = new Ds(t)) => ye(e, (i) => {
  i.local = !1;
  let s = !1;
  const o = i.doc, l = o.store, a = bI(r, o), c = yI(i, l, a), h = l.pendingStructs;
  if (h) {
    for (const [f, d] of h.missing)
      if (d < Ne(l, f)) {
        s = !0;
        break;
      }
    if (c) {
      for (const [f, d] of c.missing) {
        const p = h.missing.get(f);
        (p == null || p > d) && h.missing.set(f, d);
      }
      h.update = th([h.update, c.update]);
    }
  } else
    l.pendingStructs = c;
  const u = H1(r, i, l);
  if (l.pendingDs) {
    const f = new Ds(Hr(l.pendingDs));
    J(f.restDecoder);
    const d = H1(f, i, l);
    u && d ? l.pendingDs = th([u, d]) : l.pendingDs = u || d;
  } else
    l.pendingDs = u;
  if (s) {
    const f = l.pendingStructs.update;
    l.pendingStructs = null, e_(i.doc, f);
  }
}, n, !1), e_ = (t, e, n, r = Ds) => {
  const i = Hr(e);
  kI(i, t, n, new r(i));
}, xI = (t, e, n) => e_(t, e, n, HS), vI = (t, e, n = /* @__PURE__ */ new Map()) => {
  lm(t, e.store, n), Hs(t, gI(e.store));
}, SI = (t, e = new Uint8Array([0]), n = new $i()) => {
  const r = t_(e);
  vI(n, t, r);
  const i = [n.toUint8Array()];
  if (t.store.pendingDs && i.push(t.store.pendingDs), t.store.pendingStructs && i.push(XI(t.store.pendingStructs.update, e)), i.length > 1) {
    if (n.constructor === Fl)
      return YI(i.map((s, o) => o === 0 ? s : zI(s)));
    if (n.constructor === $i)
      return th(i);
  }
  return i[0];
}, _I = (t, e) => SI(t, e, new Fl()), CI = (t) => {
  const e = /* @__PURE__ */ new Map(), n = J(t.restDecoder);
  for (let r = 0; r < n; r++) {
    const i = J(t.restDecoder), s = J(t.restDecoder);
    e.set(i, s);
  }
  return e;
}, t_ = (t) => CI(new GS(Hr(t))), n_ = (t, e) => (U(t.restEncoder, e.size), Xr(e.entries()).sort((n, r) => r[0] - n[0]).forEach(([n, r]) => {
  U(t.restEncoder, n), U(t.restEncoder, r);
}), t), AI = (t, e) => n_(t, tu(e.store)), $I = (t, e = new KS()) => (t instanceof Map ? n_(e, t) : AI(e, t), e.toUint8Array()), PI = (t) => $I(t, new JS());
class TI {
  constructor() {
    this.l = [];
  }
}
const J1 = () => new TI(), K1 = (t, e) => t.l.push(e), eb = (t, e) => {
  const n = t.l, r = n.length;
  t.l = n.filter((i) => e !== i), r === t.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, r_ = (t, e, n) => nm(t.l, [e, n]);
class hs {
  constructor(e, n) {
    this.client = e, this.clock = n;
  }
}
const ts = (t, e) => t === e || t !== null && e !== null && t.client === e.client && t.clock === e.clock, ee = (t, e) => new hs(t, e), i_ = (t) => {
  for (const [e, n] of t.doc.share.entries())
    if (n === t)
      return e;
  throw On();
}, eh = (t, e) => {
  for (; e !== null; ) {
    if (e.parent === t)
      return !0;
    e = e.parent._item;
  }
  return !1;
};
class s_ {
  constructor(e, n, r, i = 0) {
    this.type = e, this.tname = n, this.item = r, this.assoc = i;
  }
}
const tb = (t) => {
  const e = {};
  return t.type && (e.type = t.type), t.tname && (e.tname = t.tname), t.item && (e.item = t.item), t.assoc != null && (e.assoc = t.assoc), e;
}, yl = (t) => new s_(t.type == null ? null : ee(t.type.client, t.type.clock), t.tname || null, t.item == null ? null : ee(t.item.client, t.item.clock), t.assoc == null ? 0 : t.assoc);
class QI {
  constructor(e, n, r = 0) {
    this.type = e, this.index = n, this.assoc = r;
  }
}
const EI = (t, e, n = 0) => new QI(t, e, n), Ra = (t, e, n) => {
  let r = null, i = null;
  return t._item === null ? i = i_(t) : r = ee(t._item.id.client, t._item.id.clock), new s_(r, i, e, n);
}, wl = (t, e, n = 0) => {
  let r = t._start;
  if (n < 0) {
    if (e === 0)
      return Ra(t, null, n);
    e--;
  }
  for (; r !== null; ) {
    if (!r.deleted && r.countable) {
      if (r.length > e)
        return Ra(t, ee(r.id.client, r.id.clock + e), n);
      e -= r.length;
    }
    if (r.right === null && n < 0)
      return Ra(t, r.lastId, n);
    r = r.right;
  }
  return Ra(t, null, n);
}, kp = (t, e) => {
  const n = e.store, r = t.item, i = t.type, s = t.tname, o = t.assoc;
  let l = null, a = 0;
  if (r !== null) {
    if (Ne(n, r.client) <= r.clock)
      return null;
    const c = _p(n, r), h = c.item;
    if (!(h instanceof we))
      return null;
    if (l = h.parent, l._item === null || !l._item.deleted) {
      a = h.deleted || !h.countable ? 0 : c.diff + (o >= 0 ? 0 : 1);
      let u = h.left;
      for (; u !== null; )
        !u.deleted && u.countable && (a += u.length), u = u.left;
    }
  } else {
    if (s !== null)
      l = e.get(s);
    else if (i !== null) {
      if (Ne(n, i.client) <= i.clock)
        return null;
      const { item: c } = _p(n, i);
      if (c instanceof we && c.content instanceof Fn)
        l = c.content.type;
      else
        return null;
    } else
      throw On();
    o >= 0 ? a = l._length : a = 0;
  }
  return EI(l, a, t.assoc);
}, nb = (t, e) => t === e || t !== null && e !== null && t.tname === e.tname && ts(t.item, e.item) && ts(t.type, e.type) && t.assoc === e.assoc;
class DI {
  constructor(e, n) {
    this.ds = e, this.sv = n;
  }
}
const MI = (t, e) => new DI(t, e);
MI(US(), /* @__PURE__ */ new Map());
const Gi = (t, e) => e === void 0 ? !t.deleted : e.sv.has(t.id.client) && (e.sv.get(t.id.client) || 0) > t.id.clock && !Ul(e.ds, t.id), xp = (t, e) => {
  const n = mr(t.meta, xp, Ai), r = t.doc.store;
  n.has(e) || (e.sv.forEach((i, s) => {
    i < Ne(r, s) && Ct(t, ee(s, i));
  }), Es(t, e.ds, (i) => {
  }), n.add(e));
};
class o_ {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const tu = (t) => {
  const e = /* @__PURE__ */ new Map();
  return t.clients.forEach((n, r) => {
    const i = n[n.length - 1];
    e.set(r, i.id.clock + i.length);
  }), e;
}, Ne = (t, e) => {
  const n = t.clients.get(e);
  if (n === void 0)
    return 0;
  const r = n[n.length - 1];
  return r.id.clock + r.length;
}, l_ = (t, e) => {
  let n = t.clients.get(e.id.client);
  if (n === void 0)
    n = [], t.clients.set(e.id.client, n);
  else {
    const r = n[n.length - 1];
    if (r.id.clock + r.length !== e.id.clock)
      throw On();
  }
  n.push(e);
}, Xn = (t, e) => {
  let n = 0, r = t.length - 1, i = t[r], s = i.id.clock;
  if (s === e)
    return r;
  let o = pr(e / (s + i.length - 1) * r);
  for (; n <= r; ) {
    if (i = t[o], s = i.id.clock, s <= e) {
      if (e < s + i.length)
        return o;
      n = o + 1;
    } else
      r = o - 1;
    o = pr((n + r) / 2);
  }
  throw On();
}, RI = (t, e) => {
  const n = t.clients.get(e.client);
  return n[Xn(n, e.clock)];
}, yc = RI, vp = (t, e, n) => {
  const r = Xn(e, n), i = e[r];
  return i.id.clock < n && i instanceof we ? (e.splice(r + 1, 0, lh(t, i, n - i.id.clock)), r + 1) : r;
}, Ct = (t, e) => {
  const n = t.doc.store.clients.get(e.client);
  return n[vp(t, n, e.clock)];
}, rb = (t, e, n) => {
  const r = e.clients.get(n.client), i = Xn(r, n.clock), s = r[i];
  return n.clock !== s.id.clock + s.length - 1 && s.constructor !== jt && r.splice(i + 1, 0, lh(t, s, n.clock - s.id.clock + 1)), s;
}, ZI = (t, e, n) => {
  const r = t.clients.get(e.id.client);
  r[Xn(r, e.id.clock)] = n;
}, a_ = (t, e, n, r, i) => {
  if (r === 0)
    return;
  const s = n + r;
  let o = vp(t, e, n), l;
  do
    l = e[o++], s < l.id.clock + l.length && vp(t, e, s), i(l);
  while (o < e.length && e[o].id.clock < s);
};
class II {
  constructor(e, n, r) {
    this.doc = e, this.deleteSet = new Gs(), this.beforeState = tu(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = n, this.meta = /* @__PURE__ */ new Map(), this.local = r, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const ib = (t, e) => e.deleteSet.clients.size === 0 && !YR(e.afterState, (n, r) => e.beforeState.get(r) !== n) ? !1 : (sm(e.deleteSet), wI(t, e), Hs(t, e.deleteSet), !0), sb = (t, e, n) => {
  const r = e._item;
  (r === null || r.id.clock < (t.beforeState.get(r.id.client) || 0) && !r.deleted) && mr(t.changed, e, Ai).add(n);
}, wc = (t, e) => {
  let n = t[e], r = t[e - 1], i = e;
  for (; i > 0; n = r, r = t[--i - 1]) {
    if (r.deleted === n.deleted && r.constructor === n.constructor && r.mergeWith(n)) {
      n instanceof we && n.parentSub !== null && n.parent._map.get(n.parentSub) === n && n.parent._map.set(n.parentSub, r);
      continue;
    }
    break;
  }
  const s = e - i;
  return s && t.splice(e + 1 - s, s), s;
}, LI = (t, e, n) => {
  for (const [r, i] of t.clients.entries()) {
    const s = e.clients.get(r);
    for (let o = i.length - 1; o >= 0; o--) {
      const l = i[o], a = l.clock + l.len;
      for (let c = Xn(s, l.clock), h = s[c]; c < s.length && h.id.clock < a; h = s[++c]) {
        const u = s[c];
        if (l.clock + l.len <= u.id.clock)
          break;
        u instanceof we && u.deleted && !u.keep && n(u) && u.gc(e, !1);
      }
    }
  }
}, NI = (t, e) => {
  t.clients.forEach((n, r) => {
    const i = e.clients.get(r);
    for (let s = n.length - 1; s >= 0; s--) {
      const o = n[s], l = Hh(i.length - 1, 1 + Xn(i, o.clock + o.len - 1));
      for (let a = l, c = i[a]; a > 0 && c.id.clock >= o.clock; c = i[a])
        a -= 1 + wc(i, a);
    }
  });
}, c_ = (t, e) => {
  if (e < t.length) {
    const n = t[e], r = n.doc, i = r.store, s = n.deleteSet, o = n._mergeStructs;
    try {
      sm(s), n.afterState = tu(n.doc.store), r.emit("beforeObserverCalls", [n, r]);
      const l = [];
      n.changed.forEach(
        (a, c) => l.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(n, a);
        })
      ), l.push(() => {
        n.changedParentTypes.forEach((a, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (a = a.filter(
            (h) => h.target._item === null || !h.target._item.deleted
          ), a.forEach((h) => {
            h.currentTarget = c, h._path = null;
          }), a.sort((h, u) => h.path.length - u.path.length), r_(c._dEH, a, n));
        });
      }), l.push(() => r.emit("afterTransaction", [n, r])), nm(l, []), n._needFormattingCleanup && oL(n);
    } finally {
      r.gc && LI(s, i, r.gcFilter), NI(s, i), n.afterState.forEach((h, u) => {
        const f = n.beforeState.get(u) || 0;
        if (f !== h) {
          const d = i.clients.get(u), p = Gr(Xn(d, f), 1);
          for (let g = d.length - 1; g >= p; )
            g -= 1 + wc(d, g);
        }
      });
      for (let h = o.length - 1; h >= 0; h--) {
        const { client: u, clock: f } = o[h].id, d = i.clients.get(u), p = Xn(d, f);
        p + 1 < d.length && wc(d, p + 1) > 1 || p > 0 && wc(d, p);
      }
      if (!n.local && n.afterState.get(r.clientID) !== n.beforeState.get(r.clientID) && (uI(rm, YS, "[yjs] ", jS, XS, "Changed the client-id because another client seems to be using it."), r.clientID = FS()), r.emit("afterTransactionCleanup", [n, r]), r._observers.has("update")) {
        const h = new Fl();
        ib(h, n) && r.emit("update", [h.toUint8Array(), n.origin, r, n]);
      }
      if (r._observers.has("updateV2")) {
        const h = new $i();
        ib(h, n) && r.emit("updateV2", [h.toUint8Array(), n.origin, r, n]);
      }
      const { subdocsAdded: l, subdocsLoaded: a, subdocsRemoved: c } = n;
      (l.size > 0 || c.size > 0 || a.size > 0) && (l.forEach((h) => {
        h.clientID = r.clientID, h.collectionid == null && (h.collectionid = r.collectionid), r.subdocs.add(h);
      }), c.forEach((h) => r.subdocs.delete(h)), r.emit("subdocs", [{ loaded: a, added: l, removed: c }, r, n]), c.forEach((h) => h.destroy())), t.length <= e + 1 ? (r._transactionCleanups = [], r.emit("afterAllTransactions", [r, t])) : c_(t, e + 1);
    }
  }
}, ye = (t, e, n = null, r = !0) => {
  const i = t._transactionCleanups;
  let s = !1, o = null;
  t._transaction === null && (s = !0, t._transaction = new II(t, n, r), i.push(t._transaction), i.length === 1 && t.emit("beforeAllTransactions", [t]), t.emit("beforeTransaction", [t._transaction, t]));
  try {
    o = e(t._transaction);
  } finally {
    if (s) {
      const l = t._transaction === i[0];
      t._transaction = null, l && c_(i, 0);
    }
  }
  return o;
};
class qI {
  constructor(e, n) {
    this.insertions = n, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const ob = (t, e, n) => {
  Es(t, n.deletions, (r) => {
    r instanceof we && e.scope.some((i) => eh(i, r)) && mm(r, !1);
  });
}, lb = (t, e, n) => {
  let r = null, i = null;
  const s = t.doc, o = t.scope;
  if (ye(s, (l) => {
    for (; e.length > 0 && r === null; ) {
      const a = s.store, c = e.pop(), h = /* @__PURE__ */ new Set(), u = [];
      let f = !1;
      Es(l, c.insertions, (d) => {
        if (d instanceof we) {
          if (d.redone !== null) {
            let { item: p, diff: g } = _p(a, d.id);
            g > 0 && (p = Ct(l, ee(p.id.client, p.id.clock + g))), d = p;
          }
          !d.deleted && o.some((p) => eh(p, d)) && u.push(d);
        }
      }), Es(l, c.deletions, (d) => {
        d instanceof we && o.some((p) => eh(p, d)) && !Ul(c.insertions, d.id) && h.add(d);
      }), h.forEach((d) => {
        f = A_(l, d, h, c.insertions, t.ignoreRemoteMapChanges, t) !== null || f;
      });
      for (let d = u.length - 1; d >= 0; d--) {
        const p = u[d];
        t.deleteFilter(p) && (p.delete(l), f = !0);
      }
      r = f ? c : null;
    }
    l.changed.forEach((a, c) => {
      a.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), i = l;
  }, t), r != null) {
    const l = i.changedParentTypes;
    t.emit("stack-item-popped", [{ stackItem: r, type: n, changedParentTypes: l }, t]);
  }
  return r;
};
class am extends Gh {
  constructor(e, {
    captureTimeout: n = 500,
    captureTransaction: r = (a) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: s = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: l = pp(e) ? e[0].doc : e.doc
  } = {}) {
    super(), this.scope = [], this.doc = l, this.addToScope(e), this.deleteFilter = i, s.add(this), this.trackedOrigins = s, this.captureTransaction = r, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = n, this.afterTransactionHandler = (a) => {
      if (!this.captureTransaction(a) || !this.scope.some((m) => a.changedParentTypes.has(m)) || !this.trackedOrigins.has(a.origin) && (!a.origin || !this.trackedOrigins.has(a.origin.constructor)))
        return;
      const c = this.undoing, h = this.redoing, u = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : h || this.clear(!1, !0);
      const f = new Gs();
      a.afterState.forEach((m, O) => {
        const b = a.beforeState.get(O) || 0, y = m - b;
        y > 0 && bl(f, O, b, y);
      });
      const d = zr();
      let p = !1;
      if (this.lastChange > 0 && d - this.lastChange < this.captureTimeout && u.length > 0 && !c && !h) {
        const m = u[u.length - 1];
        m.deletions = wp([m.deletions, a.deleteSet]), m.insertions = wp([m.insertions, f]);
      } else
        u.push(new qI(a.deleteSet, f)), p = !0;
      !c && !h && (this.lastChange = d), Es(a, a.deleteSet, (m) => {
        m instanceof we && this.scope.some((O) => eh(O, m)) && mm(m, !0);
      });
      const g = [{ stackItem: u[u.length - 1], origin: a.origin, type: c ? "redo" : "undo", changedParentTypes: a.changedParentTypes }, this];
      p ? this.emit("stack-item-added", g) : this.emit("stack-item-updated", g);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  addToScope(e) {
    e = pp(e) ? e : [e], e.forEach((n) => {
      this.scope.every((r) => r !== n) && (n.doc !== this.doc && fI("[yjs#509] Not same Y.Doc"), this.scope.push(n));
    });
  }
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, n = !0) {
    (e && this.canUndo() || n && this.canRedo()) && this.doc.transact((r) => {
      e && (this.undoStack.forEach((i) => ob(r, this, i)), this.undoStack = []), n && (this.redoStack.forEach((i) => ob(r, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: n }]);
    });
  }
  stopCapturing() {
    this.lastChange = 0;
  }
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = lb(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = lb(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* BI(t) {
  const e = J(t.restDecoder);
  for (let n = 0; n < e; n++) {
    const r = J(t.restDecoder), i = t.readClient();
    let s = J(t.restDecoder);
    for (let o = 0; o < r; o++) {
      const l = t.readInfo();
      if (l === 10) {
        const a = J(t.restDecoder);
        yield new Xt(ee(i, s), a), s += a;
      } else if ((Jh & l) !== 0) {
        const a = (l & (lr | qt)) === 0, c = new we(
          ee(i, s),
          null,
          (l & qt) === qt ? t.readLeftID() : null,
          null,
          (l & lr) === lr ? t.readRightID() : null,
          a ? t.readParentInfo() ? t.readString() : t.readLeftID() : null,
          a && (l & pl) === pl ? t.readString() : null,
          $_(t, l)
        );
        yield c, s += c.length;
      } else {
        const a = t.readLen();
        yield new jt(ee(i, s), a), s += a;
      }
    }
  }
}
class cm {
  constructor(e, n) {
    this.gen = BI(e), this.curr = null, this.done = !1, this.filterSkips = n, this.next();
  }
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === Xt);
    return this.curr;
  }
}
class hm {
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const YI = (t) => th(t, HS, Fl), jI = (t, e) => {
  if (t.constructor === jt) {
    const { client: n, clock: r } = t.id;
    return new jt(ee(n, r + e), t.length - e);
  } else if (t.constructor === Xt) {
    const { client: n, clock: r } = t.id;
    return new Xt(ee(n, r + e), t.length - e);
  } else {
    const n = t, { client: r, clock: i } = n.id;
    return new we(
      ee(r, i + e),
      null,
      ee(r, i + e - 1),
      null,
      n.rightOrigin,
      n.parent,
      n.parentSub,
      n.content.splice(e)
    );
  }
}, th = (t, e = Ds, n = $i) => {
  if (t.length === 1)
    return t[0];
  const r = t.map((h) => new e(Hr(h)));
  let i = r.map((h) => new cm(h, !0)), s = null;
  const o = new n(), l = new hm(o);
  for (; i = i.filter((f) => f.curr !== null), i.sort(
    (f, d) => {
      if (f.curr.id.client === d.curr.id.client) {
        const p = f.curr.id.clock - d.curr.id.clock;
        return p === 0 ? f.curr.constructor === d.curr.constructor ? 0 : f.curr.constructor === Xt ? 1 : -1 : p;
      } else
        return d.curr.id.client - f.curr.id.client;
    }
  ), i.length !== 0; ) {
    const h = i[0], u = h.curr.id.client;
    if (s !== null) {
      let f = h.curr, d = !1;
      for (; f !== null && f.id.clock + f.length <= s.struct.id.clock + s.struct.length && f.id.client >= s.struct.id.client; )
        f = h.next(), d = !0;
      if (f === null || f.id.client !== u || d && f.id.clock > s.struct.id.clock + s.struct.length)
        continue;
      if (u !== s.struct.id.client)
        Cr(l, s.struct, s.offset), s = { struct: f, offset: 0 }, h.next();
      else if (s.struct.id.clock + s.struct.length < f.id.clock)
        if (s.struct.constructor === Xt)
          s.struct.length = f.id.clock + f.length - s.struct.id.clock;
        else {
          Cr(l, s.struct, s.offset);
          const p = f.id.clock - s.struct.id.clock - s.struct.length;
          s = { struct: new Xt(ee(u, s.struct.id.clock + s.struct.length), p), offset: 0 };
        }
      else {
        const p = s.struct.id.clock + s.struct.length - f.id.clock;
        p > 0 && (s.struct.constructor === Xt ? s.struct.length -= p : f = jI(f, p)), s.struct.mergeWith(f) || (Cr(l, s.struct, s.offset), s = { struct: f, offset: 0 }, h.next());
      }
    } else
      s = { struct: h.curr, offset: 0 }, h.next();
    for (let f = h.curr; f !== null && f.id.client === u && f.id.clock === s.struct.id.clock + s.struct.length && f.constructor !== Xt; f = h.next())
      Cr(l, s.struct, s.offset), s = { struct: f, offset: 0 };
  }
  s !== null && (Cr(l, s.struct, s.offset), s = null), um(l);
  const a = r.map((h) => om(h)), c = wp(a);
  return Hs(o, c), o.toUint8Array();
}, XI = (t, e, n = Ds, r = $i) => {
  const i = t_(e), s = new r(), o = new hm(s), l = new n(Hr(t)), a = new cm(l, !1);
  for (; a.curr; ) {
    const h = a.curr, u = h.id.client, f = i.get(u) || 0;
    if (a.curr.constructor === Xt) {
      a.next();
      continue;
    }
    if (h.id.clock + h.length > f)
      for (Cr(o, h, Gr(f - h.id.clock, 0)), a.next(); a.curr && a.curr.id.client === u; )
        Cr(o, a.curr, 0), a.next();
    else
      for (; a.curr && a.curr.id.client === u && a.curr.id.clock + a.curr.length <= f; )
        a.next();
  }
  um(o);
  const c = om(l);
  return Hs(s, c), s.toUint8Array();
}, h_ = (t) => {
  t.written > 0 && (t.clientStructs.push({ written: t.written, restEncoder: Qe(t.encoder.restEncoder) }), t.encoder.restEncoder = ht(), t.written = 0);
}, Cr = (t, e, n) => {
  t.written > 0 && t.currClient !== e.id.client && h_(t), t.written === 0 && (t.currClient = e.id.client, t.encoder.writeClient(e.id.client), U(t.encoder.restEncoder, e.id.clock + n)), e.write(t.encoder, n), t.written++;
}, um = (t) => {
  h_(t);
  const e = t.encoder.restEncoder;
  U(e, t.clientStructs.length);
  for (let n = 0; n < t.clientStructs.length; n++) {
    const r = t.clientStructs[n];
    U(e, r.written), Kh(e, r.restEncoder);
  }
}, WI = (t, e, n, r) => {
  const i = new n(Hr(t)), s = new cm(i, !1), o = new r(), l = new hm(o);
  for (let c = s.curr; c !== null; c = s.next())
    Cr(l, e(c), 0);
  um(l);
  const a = om(i);
  return Hs(o, a), o.toUint8Array();
}, zI = (t) => WI(t, DZ, Ds, Fl), ab = "You must not compute changes after the event-handler fired.";
class nu {
  constructor(e, n) {
    this.target = e, this.currentTarget = e, this.transaction = n, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  get path() {
    return this._path || (this._path = VI(this.currentTarget, this.target));
  }
  deletes(e) {
    return Ul(this.transaction.deleteSet, e.id);
  }
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Wr(ab);
      const e = /* @__PURE__ */ new Map(), n = this.target;
      this.transaction.changed.get(n).forEach((i) => {
        if (i !== null) {
          const s = n._map.get(i);
          let o, l;
          if (this.adds(s)) {
            let a = s.left;
            for (; a !== null && this.adds(a); )
              a = a.left;
            if (this.deletes(s))
              if (a !== null && this.deletes(a))
                o = "delete", l = of(a.content.getContent());
              else
                return;
            else
              a !== null && this.deletes(a) ? (o = "update", l = of(a.content.getContent())) : (o = "add", l = void 0);
          } else if (this.deletes(s))
            o = "delete", l = of(s.content.getContent());
          else
            return;
          e.set(i, { action: o, oldValue: l });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  get delta() {
    return this.changes.delta;
  }
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Wr(ab);
      const n = this.target, r = Ai(), i = Ai(), s = [];
      if (e = {
        added: r,
        deleted: i,
        delta: s,
        keys: this.keys
      }, this.transaction.changed.get(n).has(null)) {
        let l = null;
        const a = () => {
          l && s.push(l);
        };
        for (let c = n._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((l === null || l.delete === void 0) && (a(), l = { delete: 0 }), l.delete += c.length, i.add(c)) : this.adds(c) ? ((l === null || l.insert === void 0) && (a(), l = { insert: [] }), l.insert = l.insert.concat(c.content.getContent()), r.add(c)) : ((l === null || l.retain === void 0) && (a(), l = { retain: 0 }), l.retain += c.length);
        l !== null && l.retain === void 0 && a();
      }
      this._changes = e;
    }
    return e;
  }
}
const VI = (t, e) => {
  const n = [];
  for (; e._item !== null && e !== t; ) {
    if (e._item.parentSub !== null)
      n.unshift(e._item.parentSub);
    else {
      let r = 0, i = e._item.parent._start;
      for (; i !== e._item && i !== null; )
        i.deleted || r++, i = i.right;
      n.unshift(r);
    }
    e = e._item.parent;
  }
  return n;
}, u_ = 80;
let fm = 0;
class UI {
  constructor(e, n) {
    e.marker = !0, this.p = e, this.index = n, this.timestamp = fm++;
  }
}
const FI = (t) => {
  t.timestamp = fm++;
}, f_ = (t, e, n) => {
  t.p.marker = !1, t.p = e, e.marker = !0, t.index = n, t.timestamp = fm++;
}, GI = (t, e, n) => {
  if (t.length >= u_) {
    const r = t.reduce((i, s) => i.timestamp < s.timestamp ? i : s);
    return f_(r, e, n), r;
  } else {
    const r = new UI(e, n);
    return t.push(r), r;
  }
}, ru = (t, e) => {
  if (t._start === null || e === 0 || t._searchMarker === null)
    return null;
  const n = t._searchMarker.length === 0 ? null : t._searchMarker.reduce((s, o) => mc(e - s.index) < mc(e - o.index) ? s : o);
  let r = t._start, i = 0;
  for (n !== null && (r = n.p, i = n.index, FI(n)); r.right !== null && i < e; ) {
    if (!r.deleted && r.countable) {
      if (e < i + r.length)
        break;
      i += r.length;
    }
    r = r.right;
  }
  for (; r.left !== null && i > e; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  for (; r.left !== null && r.left.id.client === r.id.client && r.left.id.clock + r.left.length === r.id.clock; )
    r = r.left, !r.deleted && r.countable && (i -= r.length);
  return n !== null && mc(n.index - i) < r.parent.length / u_ ? (f_(n, r, i), n) : GI(t._searchMarker, r, i);
}, kl = (t, e, n) => {
  for (let r = t.length - 1; r >= 0; r--) {
    const i = t[r];
    if (n > 0) {
      let s = i.p;
      for (s.marker = !1; s && (s.deleted || !s.countable); )
        s = s.left, s && !s.deleted && s.countable && (i.index -= s.length);
      if (s === null || s.marker === !0) {
        t.splice(r, 1);
        continue;
      }
      i.p = s, s.marker = !0;
    }
    (e < i.index || n > 0 && e === i.index) && (i.index = Gr(e, i.index + n));
  }
}, iu = (t, e, n) => {
  const r = t, i = e.changedParentTypes;
  for (; mr(i, t, () => []).push(n), t._item !== null; )
    t = t._item.parent;
  r_(r._eH, n, e);
};
class ot {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = J1(), this._dEH = J1(), this._searchMarker = null;
  }
  get parent() {
    return this._item ? this._item.parent : null;
  }
  _integrate(e, n) {
    this.doc = e, this._item = n;
  }
  _copy() {
    throw Bn();
  }
  clone() {
    throw Bn();
  }
  _write(e) {
  }
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  _callObserver(e, n) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  observe(e) {
    K1(this._eH, e);
  }
  observeDeep(e) {
    K1(this._dEH, e);
  }
  unobserve(e) {
    eb(this._eH, e);
  }
  unobserveDeep(e) {
    eb(this._dEH, e);
  }
  toJSON() {
  }
}
const d_ = (t, e, n) => {
  e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
  let r = n - e;
  const i = [];
  let s = t._start;
  for (; s !== null && r > 0; ) {
    if (s.countable && !s.deleted) {
      const o = s.content.getContent();
      if (o.length <= e)
        e -= o.length;
      else {
        for (let l = e; l < o.length && r > 0; l++)
          i.push(o[l]), r--;
        e = 0;
      }
    }
    s = s.right;
  }
  return i;
}, p_ = (t) => {
  const e = [];
  let n = t._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const r = n.content.getContent();
      for (let i = 0; i < r.length; i++)
        e.push(r[i]);
    }
    n = n.right;
  }
  return e;
}, xl = (t, e) => {
  let n = 0, r = t._start;
  for (; r !== null; ) {
    if (r.countable && !r.deleted) {
      const i = r.content.getContent();
      for (let s = 0; s < i.length; s++)
        e(i[s], n++, t);
    }
    r = r.right;
  }
}, g_ = (t, e) => {
  const n = [];
  return xl(t, (r, i) => {
    n.push(e(r, i, t));
  }), n;
}, HI = (t) => {
  let e = t._start, n = null, r = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (n === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        n = e.content.getContent(), r = 0, e = e.right;
      }
      const i = n[r++];
      return n.length <= r && (n = null), {
        done: !1,
        value: i
      };
    }
  };
}, m_ = (t, e) => {
  const n = ru(t, e);
  let r = t._start;
  for (n !== null && (r = n.p, e -= n.index); r !== null; r = r.right)
    if (!r.deleted && r.countable) {
      if (e < r.length)
        return r.content.getContent()[e];
      e -= r.length;
    }
}, nh = (t, e, n, r) => {
  let i = n;
  const s = t.doc, o = s.clientID, l = s.store, a = n === null ? e._start : n.right;
  let c = [];
  const h = () => {
    c.length > 0 && (i = new we(ee(o, Ne(l, o)), i, i && i.lastId, a, a && a.id, e, null, new Ti(c)), i.integrate(t, 0), c = []);
  };
  r.forEach((u) => {
    if (u === null)
      c.push(u);
    else
      switch (u.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(u);
          break;
        default:
          switch (h(), u.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new we(ee(o, Ne(l, o)), i, i && i.lastId, a, a && a.id, e, null, new Gl(new Uint8Array(u))), i.integrate(t, 0);
              break;
            case Js:
              i = new we(ee(o, Ne(l, o)), i, i && i.lastId, a, a && a.id, e, null, new Hl(u)), i.integrate(t, 0);
              break;
            default:
              if (u instanceof ot)
                i = new we(ee(o, Ne(l, o)), i, i && i.lastId, a, a && a.id, e, null, new Fn(u)), i.integrate(t, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), h();
}, O_ = () => Wr("Length exceeded!"), b_ = (t, e, n, r) => {
  if (n > e._length)
    throw O_();
  if (n === 0)
    return e._searchMarker && kl(e._searchMarker, n, r.length), nh(t, e, null, r);
  const i = n, s = ru(e, n);
  let o = e._start;
  for (s !== null && (o = s.p, n -= s.index, n === 0 && (o = o.prev, n += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (n <= o.length) {
        n < o.length && Ct(t, ee(o.id.client, o.id.clock + n));
        break;
      }
      n -= o.length;
    }
  return e._searchMarker && kl(e._searchMarker, i, r.length), nh(t, e, o, r);
}, JI = (t, e, n) => {
  let i = (e._searchMarker || []).reduce((s, o) => o.index > s.index ? o : s, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return nh(t, e, i, n);
}, y_ = (t, e, n, r) => {
  if (r === 0)
    return;
  const i = n, s = r, o = ru(e, n);
  let l = e._start;
  for (o !== null && (l = o.p, n -= o.index); l !== null && n > 0; l = l.right)
    !l.deleted && l.countable && (n < l.length && Ct(t, ee(l.id.client, l.id.clock + n)), n -= l.length);
  for (; r > 0 && l !== null; )
    l.deleted || (r < l.length && Ct(t, ee(l.id.client, l.id.clock + r)), l.delete(t), r -= l.length), l = l.right;
  if (r > 0)
    throw O_();
  e._searchMarker && kl(e._searchMarker, i, -s + r);
}, rh = (t, e, n) => {
  const r = e._map.get(n);
  r !== void 0 && r.delete(t);
}, dm = (t, e, n, r) => {
  const i = e._map.get(n) || null, s = t.doc, o = s.clientID;
  let l;
  if (r == null)
    l = new Ti([r]);
  else
    switch (r.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        l = new Ti([r]);
        break;
      case Uint8Array:
        l = new Gl(r);
        break;
      case Js:
        l = new Hl(r);
        break;
      default:
        if (r instanceof ot)
          l = new Fn(r);
        else
          throw new Error("Unexpected content type");
    }
  new we(ee(o, Ne(s.store, o)), i, i && i.lastId, null, null, e, n, l).integrate(t, 0);
}, pm = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted ? n.content.getContent()[n.length - 1] : void 0;
}, w_ = (t) => {
  const e = {};
  return t._map.forEach((n, r) => {
    n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
  }), e;
}, k_ = (t, e) => {
  const n = t._map.get(e);
  return n !== void 0 && !n.deleted;
}, KI = (t, e) => {
  const n = {};
  return t._map.forEach((r, i) => {
    let s = r;
    for (; s !== null && (!e.sv.has(s.id.client) || s.id.clock >= (e.sv.get(s.id.client) || 0)); )
      s = s.left;
    s !== null && Gi(s, e) && (n[i] = s.content.getContent()[s.length - 1]);
  }), n;
}, Za = (t) => dI(t.entries(), (e) => !e[1].deleted);
class eL extends nu {
  constructor(e, n) {
    super(e, n), this._transaction = n;
  }
}
class us extends ot {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  static from(e) {
    const n = new us();
    return n.push(e), n;
  }
  _integrate(e, n) {
    super._integrate(e, n), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new us();
  }
  clone() {
    const e = new us();
    return e.insert(0, this.toArray().map(
      (n) => n instanceof ot ? n.clone() : n
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  _callObserver(e, n) {
    super._callObserver(e, n), iu(this, e, new eL(this, e));
  }
  insert(e, n) {
    this.doc !== null ? ye(this.doc, (r) => {
      b_(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  push(e) {
    this.doc !== null ? ye(this.doc, (n) => {
      JI(n, this, e);
    }) : this._prelimContent.push(...e);
  }
  unshift(e) {
    this.insert(0, e);
  }
  delete(e, n = 1) {
    this.doc !== null ? ye(this.doc, (r) => {
      y_(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  get(e) {
    return m_(this, e);
  }
  toArray() {
    return p_(this);
  }
  slice(e = 0, n = this.length) {
    return d_(this, e, n);
  }
  toJSON() {
    return this.map((e) => e instanceof ot ? e.toJSON() : e);
  }
  map(e) {
    return g_(this, e);
  }
  forEach(e) {
    xl(this, e);
  }
  [Symbol.iterator]() {
    return HI(this);
  }
  _write(e) {
    e.writeTypeRef(SL);
  }
}
const tL = (t) => new us();
class nL extends nu {
  constructor(e, n, r) {
    super(e, n), this.keysChanged = r;
  }
}
class ar extends ot {
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  _integrate(e, n) {
    super._integrate(e, n), this._prelimContent.forEach((r, i) => {
      this.set(i, r);
    }), this._prelimContent = null;
  }
  _copy() {
    return new ar();
  }
  clone() {
    const e = new ar();
    return this.forEach((n, r) => {
      e.set(r, n instanceof ot ? n.clone() : n);
    }), e;
  }
  _callObserver(e, n) {
    iu(this, e, new nL(this, e, n));
  }
  toJSON() {
    const e = {};
    return this._map.forEach((n, r) => {
      if (!n.deleted) {
        const i = n.content.getContent()[n.length - 1];
        e[r] = i instanceof ot ? i.toJSON() : i;
      }
    }), e;
  }
  get size() {
    return [...Za(this._map)].length;
  }
  keys() {
    return ff(Za(this._map), (e) => e[0]);
  }
  values() {
    return ff(Za(this._map), (e) => e[1].content.getContent()[e[1].length - 1]);
  }
  entries() {
    return ff(Za(this._map), (e) => [e[0], e[1].content.getContent()[e[1].length - 1]]);
  }
  forEach(e) {
    this._map.forEach((n, r) => {
      n.deleted || e(n.content.getContent()[n.length - 1], r, this);
    });
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  delete(e) {
    this.doc !== null ? ye(this.doc, (n) => {
      rh(n, this, e);
    }) : this._prelimContent.delete(e);
  }
  set(e, n) {
    return this.doc !== null ? ye(this.doc, (r) => {
      dm(r, this, e, n);
    }) : this._prelimContent.set(e, n), n;
  }
  get(e) {
    return pm(this, e);
  }
  has(e) {
    return k_(this, e);
  }
  clear() {
    this.doc !== null ? ye(this.doc, (e) => {
      this.forEach(function(n, r, i) {
        rh(e, i, r);
      });
    }) : this._prelimContent.clear();
  }
  _write(e) {
    e.writeTypeRef(_L);
  }
}
const rL = (t) => new ar(), Qr = (t, e) => t === e || typeof t == "object" && typeof e == "object" && t && e && EZ(t, e);
class Sp {
  constructor(e, n, r, i) {
    this.left = e, this.right = n, this.index = r, this.currentAttributes = i;
  }
  forward() {
    switch (this.right === null && On(), this.right.content.constructor) {
      case Ue:
        this.right.deleted || Ks(this.currentAttributes, this.right.content);
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const cb = (t, e, n) => {
  for (; e.right !== null && n > 0; ) {
    switch (e.right.content.constructor) {
      case Ue:
        e.right.deleted || Ks(e.currentAttributes, e.right.content);
        break;
      default:
        e.right.deleted || (n < e.right.length && Ct(t, ee(e.right.id.client, e.right.id.clock + n)), e.index += e.right.length, n -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Ia = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), i = ru(e, n);
  if (i) {
    const s = new Sp(i.p.left, i.p, i.index, r);
    return cb(t, s, n - i.index);
  } else {
    const s = new Sp(null, e._start, 0, r);
    return cb(t, s, n);
  }
}, x_ = (t, e, n, r) => {
  for (; n.right !== null && (n.right.deleted === !0 || n.right.content.constructor === Ue && Qr(r.get(n.right.content.key), n.right.content.value)); )
    n.right.deleted || r.delete(n.right.content.key), n.forward();
  const i = t.doc, s = i.clientID;
  r.forEach((o, l) => {
    const a = n.left, c = n.right, h = new we(ee(s, Ne(i.store, s)), a, a && a.lastId, c, c && c.id, e, null, new Ue(l, o));
    h.integrate(t, 0), n.right = h, n.forward();
  });
}, Ks = (t, e) => {
  const { key: n, value: r } = e;
  r === null ? t.delete(n) : t.set(n, r);
}, v_ = (t, e) => {
  for (; t.right !== null; ) {
    if (!(t.right.deleted || t.right.content.constructor === Ue && Qr(e[t.right.content.key] || null, t.right.content.value)))
      break;
    t.forward();
  }
}, S_ = (t, e, n, r) => {
  const i = t.doc, s = i.clientID, o = /* @__PURE__ */ new Map();
  for (const l in r) {
    const a = r[l], c = n.currentAttributes.get(l) || null;
    if (!Qr(c, a)) {
      o.set(l, c);
      const { left: h, right: u } = n;
      n.right = new we(ee(s, Ne(i.store, s)), h, h && h.lastId, u, u && u.id, e, null, new Ue(l, a)), n.right.integrate(t, 0), n.forward();
    }
  }
  return o;
}, df = (t, e, n, r, i) => {
  n.currentAttributes.forEach((f, d) => {
    i[d] === void 0 && (i[d] = null);
  });
  const s = t.doc, o = s.clientID;
  v_(n, i);
  const l = S_(t, e, n, i), a = r.constructor === String ? new Wn(r) : r instanceof ot ? new Fn(r) : new Ri(r);
  let { left: c, right: h, index: u } = n;
  e._searchMarker && kl(e._searchMarker, n.index, a.getLength()), h = new we(ee(o, Ne(s.store, o)), c, c && c.lastId, h, h && h.id, e, null, a), h.integrate(t, 0), n.right = h, n.index = u, n.forward(), x_(t, e, n, l);
}, hb = (t, e, n, r, i) => {
  const s = t.doc, o = s.clientID;
  v_(n, i);
  const l = S_(t, e, n, i);
  e:
    for (; n.right !== null && (r > 0 || l.size > 0 && (n.right.deleted || n.right.content.constructor === Ue)); ) {
      if (!n.right.deleted)
        switch (n.right.content.constructor) {
          case Ue: {
            const { key: a, value: c } = n.right.content, h = i[a];
            if (h !== void 0) {
              if (Qr(h, c))
                l.delete(a);
              else {
                if (r === 0)
                  break e;
                l.set(a, c);
              }
              n.right.delete(t);
            } else
              n.currentAttributes.set(a, c);
            break;
          }
          default:
            r < n.right.length && Ct(t, ee(n.right.id.client, n.right.id.clock + r)), r -= n.right.length;
            break;
        }
      n.forward();
    }
  if (r > 0) {
    let a = "";
    for (; r > 0; r--)
      a += `
`;
    n.right = new we(ee(o, Ne(s.store, o)), n.left, n.left && n.left.lastId, n.right, n.right && n.right.id, e, null, new Wn(a)), n.right.integrate(t, 0), n.forward();
  }
  x_(t, e, n, l);
}, __ = (t, e, n, r, i) => {
  let s = e;
  const o = fn();
  for (; s && (!s.countable || s.deleted); ) {
    if (!s.deleted && s.content.constructor === Ue) {
      const c = s.content;
      o.set(c.key, c);
    }
    s = s.right;
  }
  let l = 0, a = !1;
  for (; e !== s; ) {
    if (n === e && (a = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Ue: {
          const { key: h, value: u } = c, f = r.get(h) || null;
          (o.get(h) !== c || f === u) && (e.delete(t), l++, !a && (i.get(h) || null) === u && f !== u && (f === null ? i.delete(h) : i.set(h, f))), !a && !e.deleted && Ks(i, c);
          break;
        }
      }
    }
    e = e.right;
  }
  return l;
}, iL = (t, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const n = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Ue) {
      const r = e.content.key;
      n.has(r) ? e.delete(t) : n.add(r);
    }
    e = e.left;
  }
}, sL = (t) => {
  let e = 0;
  return ye(t.doc, (n) => {
    let r = t._start, i = t._start, s = fn();
    const o = dp(s);
    for (; i; ) {
      if (i.deleted === !1)
        switch (i.content.constructor) {
          case Ue:
            Ks(o, i.content);
            break;
          default:
            e += __(n, r, i, s, o), s = dp(o), r = i;
            break;
        }
      i = i.right;
    }
  }), e;
}, oL = (t) => {
  const e = /* @__PURE__ */ new Set(), n = t.doc;
  for (const [r, i] of t.afterState.entries()) {
    const s = t.beforeState.get(r) || 0;
    i !== s && a_(t, n.store.clients.get(r), s, i, (o) => {
      !o.deleted && o.content.constructor === Ue && o.constructor !== jt && e.add(o.parent);
    });
  }
  ye(n, (r) => {
    Es(t, t.deleteSet, (i) => {
      if (i instanceof jt || !i.parent._hasFormatting || e.has(i.parent))
        return;
      const s = i.parent;
      i.content.constructor === Ue ? e.add(s) : iL(r, i);
    });
    for (const i of e)
      sL(i);
  });
}, ub = (t, e, n) => {
  const r = n, i = dp(e.currentAttributes), s = e.right;
  for (; n > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Fn:
        case Ri:
        case Wn:
          n < e.right.length && Ct(t, ee(e.right.id.client, e.right.id.clock + n)), n -= e.right.length, e.right.delete(t);
          break;
      }
    e.forward();
  }
  s && __(t, s, e.right, i, e.currentAttributes);
  const o = (e.left || e.right).parent;
  return o._searchMarker && kl(o._searchMarker, e.index, -r + n), e;
};
class lL extends nu {
  constructor(e, n, r) {
    super(e, n), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), r.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return this._changes;
  }
  get delta() {
    if (this._delta === null) {
      const e = this.target.doc, n = [];
      ye(e, (r) => {
        const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
        let o = this.target._start, l = null;
        const a = {};
        let c = "", h = 0, u = 0;
        const f = () => {
          if (l !== null) {
            let d = null;
            switch (l) {
              case "delete":
                u > 0 && (d = { delete: u }), u = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (d = { insert: c }, i.size > 0 && (d.attributes = {}, i.forEach((p, g) => {
                  p !== null && (d.attributes[g] = p);
                }))), c = "";
                break;
              case "retain":
                h > 0 && (d = { retain: h }, TZ(a) || (d.attributes = CZ({}, a))), h = 0;
                break;
            }
            d && n.push(d), l = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case Fn:
            case Ri:
              this.adds(o) ? this.deletes(o) || (f(), l = "insert", c = o.content.getContent()[0], f()) : this.deletes(o) ? (l !== "delete" && (f(), l = "delete"), u += 1) : o.deleted || (l !== "retain" && (f(), l = "retain"), h += 1);
              break;
            case Wn:
              this.adds(o) ? this.deletes(o) || (l !== "insert" && (f(), l = "insert"), c += o.content.str) : this.deletes(o) ? (l !== "delete" && (f(), l = "delete"), u += o.length) : o.deleted || (l !== "retain" && (f(), l = "retain"), h += o.length);
              break;
            case Ue: {
              const { key: d, value: p } = o.content;
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const g = i.get(d) || null;
                  Qr(g, p) ? p !== null && o.delete(r) : (l === "retain" && f(), Qr(p, s.get(d) || null) ? delete a[d] : a[d] = p);
                }
              } else if (this.deletes(o)) {
                s.set(d, p);
                const g = i.get(d) || null;
                Qr(g, p) || (l === "retain" && f(), a[d] = g);
              } else if (!o.deleted) {
                s.set(d, p);
                const g = a[d];
                g !== void 0 && (Qr(g, p) ? g !== null && o.delete(r) : (l === "retain" && f(), p === null ? delete a[d] : a[d] = p));
              }
              o.deleted || (l === "insert" && f(), Ks(i, o.content));
              break;
            }
          }
          o = o.right;
        }
        for (f(); n.length > 0; ) {
          const d = n[n.length - 1];
          if (d.retain !== void 0 && d.attributes === void 0)
            n.pop();
          else
            break;
        }
      }), this._delta = n;
    }
    return this._delta;
  }
}
class Ms extends ot {
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  get length() {
    return this._length;
  }
  _integrate(e, n) {
    super._integrate(e, n);
    try {
      this._pending.forEach((r) => r());
    } catch (r) {
      console.error(r);
    }
    this._pending = null;
  }
  _copy() {
    return new Ms();
  }
  clone() {
    const e = new Ms();
    return e.applyDelta(this.toDelta()), e;
  }
  _callObserver(e, n) {
    super._callObserver(e, n);
    const r = new lL(this, e, n);
    iu(this, e, r), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  toString() {
    let e = "", n = this._start;
    for (; n !== null; )
      !n.deleted && n.countable && n.content.constructor === Wn && (e += n.content.str), n = n.right;
    return e;
  }
  toJSON() {
    return this.toString();
  }
  applyDelta(e, { sanitize: n = !0 } = {}) {
    this.doc !== null ? ye(this.doc, (r) => {
      const i = new Sp(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (o.insert !== void 0) {
          const l = !n && typeof o.insert == "string" && s === e.length - 1 && i.right === null && o.insert.slice(-1) === `
` ? o.insert.slice(0, -1) : o.insert;
          (typeof l != "string" || l.length > 0) && df(r, this, i, l, o.attributes || {});
        } else
          o.retain !== void 0 ? hb(r, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && ub(r, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  toDelta(e, n, r) {
    const i = [], s = /* @__PURE__ */ new Map(), o = this.doc;
    let l = "", a = this._start;
    function c() {
      if (l.length > 0) {
        const u = {};
        let f = !1;
        s.forEach((p, g) => {
          f = !0, u[g] = p;
        });
        const d = { insert: l };
        f && (d.attributes = u), i.push(d), l = "";
      }
    }
    const h = () => {
      for (; a !== null; ) {
        if (Gi(a, e) || n !== void 0 && Gi(a, n))
          switch (a.content.constructor) {
            case Wn: {
              const u = s.get("ychange");
              e !== void 0 && !Gi(a, e) ? (u === void 0 || u.user !== a.id.client || u.type !== "removed") && (c(), s.set("ychange", r ? r("removed", a.id) : { type: "removed" })) : n !== void 0 && !Gi(a, n) ? (u === void 0 || u.user !== a.id.client || u.type !== "added") && (c(), s.set("ychange", r ? r("added", a.id) : { type: "added" })) : u !== void 0 && (c(), s.delete("ychange")), l += a.content.str;
              break;
            }
            case Fn:
            case Ri: {
              c();
              const u = {
                insert: a.content.getContent()[0]
              };
              if (s.size > 0) {
                const f = {};
                u.attributes = f, s.forEach((d, p) => {
                  f[p] = d;
                });
              }
              i.push(u);
              break;
            }
            case Ue:
              Gi(a, e) && (c(), Ks(s, a.content));
              break;
          }
        a = a.right;
      }
      c();
    };
    return e || n ? ye(o, (u) => {
      e && xp(u, e), n && xp(u, n), h();
    }, "cleanup") : h(), i;
  }
  insert(e, n, r) {
    if (n.length <= 0)
      return;
    const i = this.doc;
    i !== null ? ye(i, (s) => {
      const o = Ia(s, this, e);
      r || (r = {}, o.currentAttributes.forEach((l, a) => {
        r[a] = l;
      })), df(s, this, o, n, r);
    }) : this._pending.push(() => this.insert(e, n, r));
  }
  insertEmbed(e, n, r = {}) {
    const i = this.doc;
    i !== null ? ye(i, (s) => {
      const o = Ia(s, this, e);
      df(s, this, o, n, r);
    }) : this._pending.push(() => this.insertEmbed(e, n, r));
  }
  delete(e, n) {
    if (n === 0)
      return;
    const r = this.doc;
    r !== null ? ye(r, (i) => {
      ub(i, Ia(i, this, e), n);
    }) : this._pending.push(() => this.delete(e, n));
  }
  format(e, n, r) {
    if (n === 0)
      return;
    const i = this.doc;
    i !== null ? ye(i, (s) => {
      const o = Ia(s, this, e);
      o.right !== null && hb(s, this, o, n, r);
    }) : this._pending.push(() => this.format(e, n, r));
  }
  removeAttribute(e) {
    this.doc !== null ? ye(this.doc, (n) => {
      rh(n, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  setAttribute(e, n) {
    this.doc !== null ? ye(this.doc, (r) => {
      dm(r, this, e, n);
    }) : this._pending.push(() => this.setAttribute(e, n));
  }
  getAttribute(e) {
    return pm(this, e);
  }
  getAttributes() {
    return w_(this);
  }
  _write(e) {
    e.writeTypeRef(CL);
  }
}
const aL = (t) => new Ms();
class pf {
  constructor(e, n = () => !0) {
    this._filter = n, this._root = e, this._currentNode = e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e = this._currentNode, n = e && e.content && e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
      do
        if (n = e.content.type, !e.deleted && (n.constructor === vl || n.constructor === Pi) && n._start !== null)
          e = n._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = e.parent._item;
      while (e !== null && (e.deleted || !this._filter(e.content.type)));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: e.content.type, done: !1 });
  }
}
class Pi extends ot {
  constructor() {
    super(), this._prelimContent = [];
  }
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  _integrate(e, n) {
    super._integrate(e, n), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new Pi();
  }
  clone() {
    const e = new Pi();
    return e.insert(0, this.toArray().map((n) => n instanceof ot ? n.clone() : n)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  createTreeWalker(e) {
    return new pf(this, e);
  }
  querySelector(e) {
    e = e.toUpperCase();
    const r = new pf(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return r.done ? null : r.value;
  }
  querySelectorAll(e) {
    return e = e.toUpperCase(), Xr(new pf(this, (n) => n.nodeName && n.nodeName.toUpperCase() === e));
  }
  _callObserver(e, n) {
    iu(this, e, new uL(this, n, e));
  }
  toString() {
    return g_(this, (e) => e.toString()).join("");
  }
  toJSON() {
    return this.toString();
  }
  toDOM(e = document, n = {}, r) {
    const i = e.createDocumentFragment();
    return r !== void 0 && r._createAssociation(i, this), xl(this, (s) => {
      i.insertBefore(s.toDOM(e, n, r), null);
    }), i;
  }
  insert(e, n) {
    this.doc !== null ? ye(this.doc, (r) => {
      b_(r, this, e, n);
    }) : this._prelimContent.splice(e, 0, ...n);
  }
  insertAfter(e, n) {
    if (this.doc !== null)
      ye(this.doc, (r) => {
        const i = e && e instanceof ot ? e._item : e;
        nh(r, this, i, n);
      });
    else {
      const r = this._prelimContent, i = e === null ? 0 : r.findIndex((s) => s === e) + 1;
      if (i === 0 && e !== null)
        throw Wr("Reference item not found");
      r.splice(i, 0, ...n);
    }
  }
  delete(e, n = 1) {
    this.doc !== null ? ye(this.doc, (r) => {
      y_(r, this, e, n);
    }) : this._prelimContent.splice(e, n);
  }
  toArray() {
    return p_(this);
  }
  push(e) {
    this.insert(this.length, e);
  }
  unshift(e) {
    this.insert(0, e);
  }
  get(e) {
    return m_(this, e);
  }
  slice(e = 0, n = this.length) {
    return d_(this, e, n);
  }
  forEach(e) {
    xl(this, e);
  }
  _write(e) {
    e.writeTypeRef($L);
  }
}
const cL = (t) => new Pi();
class vl extends Pi {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? e.content.type : null;
  }
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? e.content.type : null;
  }
  _integrate(e, n) {
    super._integrate(e, n), this._prelimAttrs.forEach((r, i) => {
      this.setAttribute(i, r);
    }), this._prelimAttrs = null;
  }
  _copy() {
    return new vl(this.nodeName);
  }
  clone() {
    const e = new vl(this.nodeName), n = this.getAttributes();
    return $Z(n, (r, i) => {
      typeof r == "string" && e.setAttribute(i, r);
    }), e.insert(0, this.toArray().map((r) => r instanceof ot ? r.clone() : r)), e;
  }
  toString() {
    const e = this.getAttributes(), n = [], r = [];
    for (const l in e)
      r.push(l);
    r.sort();
    const i = r.length;
    for (let l = 0; l < i; l++) {
      const a = r[l];
      n.push(a + '="' + e[a] + '"');
    }
    const s = this.nodeName.toLocaleLowerCase(), o = n.length > 0 ? " " + n.join(" ") : "";
    return `<${s}${o}>${super.toString()}</${s}>`;
  }
  removeAttribute(e) {
    this.doc !== null ? ye(this.doc, (n) => {
      rh(n, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  setAttribute(e, n) {
    this.doc !== null ? ye(this.doc, (r) => {
      dm(r, this, e, n);
    }) : this._prelimAttrs.set(e, n);
  }
  getAttribute(e) {
    return pm(this, e);
  }
  hasAttribute(e) {
    return k_(this, e);
  }
  getAttributes(e) {
    return e ? KI(this, e) : w_(this);
  }
  toDOM(e = document, n = {}, r) {
    const i = e.createElement(this.nodeName), s = this.getAttributes();
    for (const o in s) {
      const l = s[o];
      typeof l == "string" && i.setAttribute(o, l);
    }
    return xl(this, (o) => {
      i.appendChild(o.toDOM(e, n, r));
    }), r !== void 0 && r._createAssociation(i, this), i;
  }
  _write(e) {
    e.writeTypeRef(AL), e.writeKey(this.nodeName);
  }
}
const hL = (t) => new vl(t.readKey());
class uL extends nu {
  constructor(e, n, r) {
    super(e, r), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class ih extends ar {
  constructor(e) {
    super(), this.hookName = e;
  }
  _copy() {
    return new ih(this.hookName);
  }
  clone() {
    const e = new ih(this.hookName);
    return this.forEach((n, r) => {
      e.set(r, n);
    }), e;
  }
  toDOM(e = document, n = {}, r) {
    const i = n[this.hookName];
    let s;
    return i !== void 0 ? s = i.createDom(this) : s = document.createElement(this.hookName), s.setAttribute("data-yjs-hook", this.hookName), r !== void 0 && r._createAssociation(s, this), s;
  }
  _write(e) {
    e.writeTypeRef(PL), e.writeKey(this.hookName);
  }
}
const fL = (t) => new ih(t.readKey());
class sh extends Ms {
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? e.content.type : null;
  }
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? e.content.type : null;
  }
  _copy() {
    return new sh();
  }
  clone() {
    const e = new sh();
    return e.applyDelta(this.toDelta()), e;
  }
  toDOM(e = document, n, r) {
    const i = e.createTextNode(this.toString());
    return r !== void 0 && r._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const n = [];
      for (const i in e.attributes) {
        const s = [];
        for (const o in e.attributes[i])
          s.push({ key: o, value: e.attributes[i][o] });
        s.sort((o, l) => o.key < l.key ? -1 : 1), n.push({ nodeName: i, attrs: s });
      }
      n.sort((i, s) => i.nodeName < s.nodeName ? -1 : 1);
      let r = "";
      for (let i = 0; i < n.length; i++) {
        const s = n[i];
        r += `<${s.nodeName}`;
        for (let o = 0; o < s.attrs.length; o++) {
          const l = s.attrs[o];
          r += ` ${l.key}="${l.value}"`;
        }
        r += ">";
      }
      r += e.insert;
      for (let i = n.length - 1; i >= 0; i--)
        r += `</${n[i].nodeName}>`;
      return r;
    }).join("");
  }
  toJSON() {
    return this.toString();
  }
  _write(e) {
    e.writeTypeRef(TL);
  }
}
const dL = (t) => new sh();
class gm {
  constructor(e, n) {
    this.id = e, this.length = n;
  }
  get deleted() {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  write(e, n, r) {
    throw Bn();
  }
  integrate(e, n) {
    throw Bn();
  }
}
const pL = 0;
class jt extends gm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  integrate(e, n) {
    n > 0 && (this.id.clock += n, this.length -= n), l_(e.doc.store, this);
  }
  write(e, n) {
    e.writeInfo(pL), e.writeLen(this.length - n);
  }
  getMissing(e, n) {
    return null;
  }
}
class Gl {
  constructor(e) {
    this.content = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.content];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Gl(this.content);
  }
  splice(e) {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, n) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    e.writeBuf(this.content);
  }
  getRef() {
    return 3;
  }
}
const gL = (t) => new Gl(t.readBuf());
class Sl {
  constructor(e) {
    this.len = e;
  }
  getLength() {
    return this.len;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new Sl(this.len);
  }
  splice(e) {
    const n = new Sl(this.len - e);
    return this.len = e, n;
  }
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  integrate(e, n) {
    bl(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    e.writeLen(this.len - n);
  }
  getRef() {
    return 1;
  }
}
const mL = (t) => new Sl(t.readLen()), C_ = (t, e) => new Js({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class Hl {
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const n = {};
    this.opts = n, e.gc || (n.gc = !1), e.autoLoad && (n.autoLoad = !0), e.meta !== null && (n.meta = e.meta);
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.doc];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Hl(C_(this.doc.guid, this.opts));
  }
  splice(e) {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, n) {
    this.doc._item = n, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  gc(e) {
  }
  write(e, n) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  getRef() {
    return 9;
  }
}
const OL = (t) => new Hl(C_(t.readString(), t.readAny()));
class Ri {
  constructor(e) {
    this.embed = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.embed];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Ri(this.embed);
  }
  splice(e) {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, n) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    e.writeJSON(this.embed);
  }
  getRef() {
    return 5;
  }
}
const bL = (t) => new Ri(t.readJSON());
class Ue {
  constructor(e, n) {
    this.key = e, this.value = n;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new Ue(this.key, this.value);
  }
  splice(e) {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, n) {
    const r = n.parent;
    r._searchMarker = null, r._hasFormatting = !0;
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  getRef() {
    return 6;
  }
}
const yL = (t) => new Ue(t.readKey(), t.readJSON());
class oh {
  constructor(e) {
    this.arr = e;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new oh(this.arr);
  }
  splice(e) {
    const n = new oh(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  integrate(e, n) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      e.writeString(s === void 0 ? "undefined" : JSON.stringify(s));
    }
  }
  getRef() {
    return 2;
  }
}
const wL = (t) => {
  const e = t.readLen(), n = [];
  for (let r = 0; r < e; r++) {
    const i = t.readString();
    i === "undefined" ? n.push(void 0) : n.push(JSON.parse(i));
  }
  return new oh(n);
};
class Ti {
  constructor(e) {
    this.arr = e;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Ti(this.arr);
  }
  splice(e) {
    const n = new Ti(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), n;
  }
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  integrate(e, n) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    const r = this.arr.length;
    e.writeLen(r - n);
    for (let i = n; i < r; i++) {
      const s = this.arr[i];
      e.writeAny(s);
    }
  }
  getRef() {
    return 8;
  }
}
const kL = (t) => {
  const e = t.readLen(), n = [];
  for (let r = 0; r < e; r++)
    n.push(t.readAny());
  return new Ti(n);
};
class Wn {
  constructor(e) {
    this.str = e;
  }
  getLength() {
    return this.str.length;
  }
  getContent() {
    return this.str.split("");
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Wn(this.str);
  }
  splice(e) {
    const n = new Wn(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const r = this.str.charCodeAt(e - 1);
    return r >= 55296 && r <= 56319 && (this.str = this.str.slice(0, e - 1) + "\uFFFD", n.str = "\uFFFD" + n.str.slice(1)), n;
  }
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  integrate(e, n) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, n) {
    e.writeString(n === 0 ? this.str : this.str.slice(n));
  }
  getRef() {
    return 4;
  }
}
const xL = (t) => new Wn(t.readString()), vL = [
  tL,
  rL,
  aL,
  hL,
  cL,
  fL,
  dL
], SL = 0, _L = 1, CL = 2, AL = 3, $L = 4, PL = 5, TL = 6;
class Fn {
  constructor(e) {
    this.type = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.type];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Fn(this.type._copy());
  }
  splice(e) {
    throw Bn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, n) {
    this.type._integrate(e.doc, n);
  }
  delete(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e), n = n.right;
    this.type._map.forEach((r) => {
      r.deleted ? r.id.clock < (e.beforeState.get(r.id.client) || 0) && e._mergeStructs.push(r) : r.delete(e);
    }), e.changed.delete(this.type);
  }
  gc(e) {
    let n = this.type._start;
    for (; n !== null; )
      n.gc(e, !0), n = n.right;
    this.type._start = null, this.type._map.forEach((r) => {
      for (; r !== null; )
        r.gc(e, !0), r = r.left;
    }), this.type._map = /* @__PURE__ */ new Map();
  }
  write(e, n) {
    this.type._write(e);
  }
  getRef() {
    return 7;
  }
}
const QL = (t) => new Fn(vL[t.readTypeRef()](t)), _p = (t, e) => {
  let n = e, r = 0, i;
  do
    r > 0 && (n = ee(n.client, n.clock + r)), i = yc(t, n), r = n.clock - i.id.clock, n = i.redone;
  while (n !== null && i instanceof we);
  return {
    item: i,
    diff: r
  };
}, mm = (t, e) => {
  for (; t !== null && t.keep !== e; )
    t.keep = e, t = t.parent._item;
}, lh = (t, e, n) => {
  const { client: r, clock: i } = e.id, s = new we(
    ee(r, i + n),
    e,
    ee(r, i + n - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(n)
  );
  return e.deleted && s.markDeleted(), e.keep && (s.keep = !0), e.redone !== null && (s.redone = ee(e.redone.client, e.redone.clock + n)), e.right = s, s.right !== null && (s.right.left = s), t._mergeStructs.push(s), s.parentSub !== null && s.right === null && s.parent._map.set(s.parentSub, s), e.length = n, s;
}, fb = (t, e) => XR(t, (n) => Ul(n.deletions, e)), A_ = (t, e, n, r, i, s) => {
  const o = t.doc, l = o.store, a = o.clientID, c = e.redone;
  if (c !== null)
    return Ct(t, c);
  let h = e.parent._item, u = null, f;
  if (h !== null && h.deleted === !0) {
    if (h.redone === null && (!n.has(h) || A_(t, h, n, r, i, s) === null))
      return null;
    for (; h.redone !== null; )
      h = Ct(t, h.redone);
  }
  const d = h === null ? e.parent : h.content.type;
  if (e.parentSub === null) {
    for (u = e.left, f = e; u !== null; ) {
      let O = u;
      for (; O !== null && O.parent._item !== h; )
        O = O.redone === null ? null : Ct(t, O.redone);
      if (O !== null && O.parent._item === h) {
        u = O;
        break;
      }
      u = u.left;
    }
    for (; f !== null; ) {
      let O = f;
      for (; O !== null && O.parent._item !== h; )
        O = O.redone === null ? null : Ct(t, O.redone);
      if (O !== null && O.parent._item === h) {
        f = O;
        break;
      }
      f = f.right;
    }
  } else if (f = null, e.right && !i) {
    for (u = e; u !== null && u.right !== null && (u.right.redone || Ul(r, u.right.id) || fb(s.undoStack, u.right.id) || fb(s.redoStack, u.right.id)); )
      for (u = u.right; u.redone; )
        u = Ct(t, u.redone);
    if (u && u.right !== null)
      return null;
  } else
    u = d._map.get(e.parentSub) || null;
  const p = Ne(l, a), g = ee(a, p), m = new we(
    g,
    u,
    u && u.lastId,
    f,
    f && f.id,
    d,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = g, mm(m, !0), m.integrate(t, 0), m;
};
class we extends gm {
  constructor(e, n, r, i, s, o, l, a) {
    super(e, a.getLength()), this.origin = r, this.left = n, this.right = i, this.rightOrigin = s, this.parent = o, this.parentSub = l, this.redone = null, this.content = a, this.info = this.content.isCountable() ? B1 : 0;
  }
  set marker(e) {
    (this.info & af) > 0 !== e && (this.info ^= af);
  }
  get marker() {
    return (this.info & af) > 0;
  }
  get keep() {
    return (this.info & q1) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= q1);
  }
  get countable() {
    return (this.info & B1) > 0;
  }
  get deleted() {
    return (this.info & lf) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= lf);
  }
  markDeleted() {
    this.info |= lf;
  }
  getMissing(e, n) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Ne(n, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Ne(n, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === hs && this.id.client !== this.parent.client && this.parent.clock >= Ne(n, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = rb(e, n, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Ct(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === jt || this.right && this.right.constructor === jt)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === we && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === we && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === hs) {
      const r = yc(n, this.parent);
      r.constructor === jt ? this.parent = null : this.parent = r.content.type;
    }
    return null;
  }
  integrate(e, n) {
    if (n > 0 && (this.id.clock += n, this.left = rb(e, e.doc.store, ee(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(n), this.length -= n), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let r = this.left, i;
        if (r !== null)
          i = r.right;
        else if (this.parentSub !== null)
          for (i = this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = this.parent._start;
        const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), s.add(i), ts(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              r = i, s.clear();
            else if (ts(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has(yc(e.doc.store, i.origin)))
            s.has(yc(e.doc.store, i.origin)) || (r = i, s.clear());
          else
            break;
          i = i.right;
        }
        this.left = r;
      }
      if (this.left !== null) {
        const r = this.left.right;
        this.right = r, this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null)
          for (r = this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = this.parent._start, this.parent._start = this;
        this.right = r;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), l_(e.doc.store, this), this.content.integrate(e, this), sb(e, this.parent, this.parentSub), (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new jt(this.id, this.length).integrate(e, 0);
  }
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  get lastId() {
    return this.length === 1 ? this.id : ee(this.id.client, this.id.clock + this.length - 1);
  }
  mergeWith(e) {
    if (this.constructor === e.constructor && ts(e.origin, this.lastId) && this.right === e && ts(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const n = this.parent._searchMarker;
      return n && n.forEach((r) => {
        r.p === e && (r.p = this, !this.deleted && this.countable && (r.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  delete(e) {
    if (!this.deleted) {
      const n = this.parent;
      this.countable && this.parentSub === null && (n._length -= this.length), this.markDeleted(), bl(e.deleteSet, this.id.client, this.id.clock, this.length), sb(e, n, this.parentSub), this.content.delete(e);
    }
  }
  gc(e, n) {
    if (!this.deleted)
      throw On();
    this.content.gc(e), n ? ZI(e, this, new jt(this.id, this.length)) : this.content = new Sl(this.length);
  }
  write(e, n) {
    const r = n > 0 ? ee(this.id.client, this.id.clock + n - 1) : this.origin, i = this.rightOrigin, s = this.parentSub, o = this.content.getRef() & Jh | (r === null ? 0 : qt) | (i === null ? 0 : lr) | (s === null ? 0 : pl);
    if (e.writeInfo(o), r !== null && e.writeLeftID(r), i !== null && e.writeRightID(i), r === null && i === null) {
      const l = this.parent;
      if (l._item !== void 0) {
        const a = l._item;
        if (a === null) {
          const c = i_(l);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(a.id);
      } else
        l.constructor === String ? (e.writeParentInfo(!0), e.writeString(l)) : l.constructor === hs ? (e.writeParentInfo(!1), e.writeLeftID(l)) : On();
      s !== null && e.writeString(s);
    }
    this.content.write(e, n);
  }
}
const $_ = (t, e) => EL[e & Jh](t), EL = [
  () => {
    On();
  },
  mL,
  wL,
  gL,
  xL,
  bL,
  yL,
  QL,
  kL,
  OL,
  () => {
    On();
  }
], DL = 10;
class Xt extends gm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  integrate(e, n) {
    On();
  }
  write(e, n) {
    e.writeInfo(DL), U(e.restEncoder, this.length - n);
  }
  getMissing(e, n) {
    return null;
  }
}
const P_ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}, T_ = "__ $YJS$ __";
P_[T_] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
P_[T_] = !0;
class Om {
  constructor(e, n) {
    this.yanchor = e, this.yhead = n;
  }
  toJSON() {
    return {
      yanchor: tb(this.yanchor),
      yhead: tb(this.yhead)
    };
  }
  static fromJSON(e) {
    return new Om(yl(e.yanchor), yl(e.yhead));
  }
}
class ML {
  constructor(e, n) {
    this.ytext = e, this.awareness = n, this.undoManager = new am(e);
  }
  toYPos(e, n = 0) {
    return wl(this.ytext, e, n);
  }
  fromYPos(e) {
    const n = kp(yl(e), this.ytext.doc);
    if (n == null || n.type !== this.ytext)
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    return {
      pos: n.index,
      assoc: n.assoc
    };
  }
  toYRange(e) {
    const n = e.assoc, r = this.toYPos(e.anchor, n), i = this.toYPos(e.head, n);
    return new Om(r, i);
  }
  fromYRange(e) {
    const n = this.fromYPos(e.yanchor), r = this.fromYPos(e.yhead);
    return n.pos === r.pos ? C.cursor(r.pos, r.assoc) : C.range(n.pos, r.pos);
  }
}
const su = L.define({
  combine(t) {
    return t[t.length - 1];
  }
}), Cp = wn.define();
class RL {
  constructor(e) {
    this.view = e, this.conf = e.state.facet(su), this._observer = (n, r) => {
      if (r.origin !== this.conf) {
        const i = n.delta, s = [];
        let o = 0;
        for (let l = 0; l < i.length; l++) {
          const a = i[l];
          a.insert != null ? s.push({ from: o, to: o, insert: a.insert }) : a.delete != null ? (s.push({ from: o, to: o + a.delete, insert: "" }), o += a.delete) : o += a.retain;
        }
        e.dispatch({ changes: s, annotations: [Cp.of(this.conf)] });
      }
    }, this._ytext = this.conf.ytext, this._ytext.observe(this._observer);
  }
  update(e) {
    if (!e.docChanged || e.transactions.length > 0 && e.transactions[0].annotation(Cp) === this.conf)
      return;
    const n = this.conf.ytext;
    n.doc.transact(() => {
      let r = 0;
      e.changes.iterChanges((i, s, o, l, a) => {
        const c = a.sliceString(0, a.length, `
`);
        i !== s && n.delete(i + r, s - i), c.length > 0 && n.insert(i + r, c), r += c.length - (s - i);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
}
const ZL = ke.fromClass(RL), IL = T.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
}), LL = wn.define();
class NL extends Tt {
  constructor(e, n) {
    super(), this.color = e, this.name = n;
  }
  toDOM() {
    return uf("span", [Rt("class", "cm-ySelectionCaret"), Rt("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
      Ma("\u2060"),
      uf("div", [
        Rt("class", "cm-ySelectionCaretDot")
      ]),
      Ma("\u2060"),
      uf("div", [
        Rt("class", "cm-ySelectionInfo")
      ], [
        Ma(this.name)
      ]),
      Ma("\u2060")
    ]);
  }
  eq(e) {
    return e.color === this.color;
  }
  compare(e) {
    return e.color === this.color;
  }
  updateDOM() {
    return !1;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return !0;
  }
}
class qL {
  constructor(e) {
    this.conf = e.state.facet(su), this._listener = ({ added: n, updated: r, removed: i }, s, o) => {
      n.concat(r).concat(i).findIndex((a) => a !== this.conf.awareness.doc.clientID) >= 0 && e.dispatch({ annotations: [LL.of([])] });
    }, this._awareness = this.conf.awareness, this._awareness.on("change", this._listener), this.decorations = oe.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  update(e) {
    const n = this.conf.ytext, r = n.doc, i = this.conf.awareness, s = [], o = this.conf.awareness.getLocalState();
    if (o != null) {
      const l = e.view.hasFocus && e.view.dom.ownerDocument.hasFocus(), a = l ? e.state.selection.main : null, c = o.cursor == null ? null : yl(o.cursor.anchor), h = o.cursor == null ? null : yl(o.cursor.head);
      if (a != null) {
        const u = wl(n, a.anchor), f = wl(n, a.head);
        (o.cursor == null || !nb(c, u) || !nb(h, f)) && i.setLocalStateField("cursor", {
          anchor: u,
          head: f
        });
      } else
        o.cursor != null && l && i.setLocalStateField("cursor", null);
    }
    i.getStates().forEach((l, a) => {
      if (a === i.doc.clientID)
        return;
      const c = l.cursor;
      if (c == null || c.anchor == null || c.head == null)
        return;
      const h = kp(c.anchor, r), u = kp(c.head, r);
      if (h == null || u == null || h.type !== n || u.type !== n)
        return;
      const { color: f = "#30bced", name: d = "Anonymous" } = l.user || {}, p = l.user && l.user.colorLight || f + "33", g = Hh(h.index, u.index), m = Gr(h.index, u.index), O = e.view.state.doc.lineAt(g), b = e.view.state.doc.lineAt(m);
      if (O.number === b.number)
        s.push({
          from: g,
          to: m,
          value: I.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        });
      else {
        s.push({
          from: g,
          to: O.from + O.length,
          value: I.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        }), s.push({
          from: b.from,
          to: m,
          value: I.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        });
        for (let y = O.number + 1; y < b.number; y++) {
          const w = e.view.state.doc.line(y).from;
          s.push({
            from: w,
            to: w,
            value: I.line({
              attributes: { style: `background-color: ${p}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      s.push({
        from: u.index,
        to: u.index,
        value: I.widget({
          side: u.index - h.index > 0 ? -1 : 1,
          block: !1,
          widget: new NL(f, d)
        })
      });
    }), this.decorations = I.set(s, !0);
  }
}
const BL = ke.fromClass(qL, {
  decorations: (t) => t.decorations
}), YL = () => {
  let t = !0;
  return (e, n) => {
    if (t) {
      t = !1;
      try {
        e();
      } finally {
        t = !0;
      }
    } else
      n !== void 0 && n();
  };
};
class jL {
  constructor(e) {
    this.undoManager = e;
  }
  addTrackedOrigin(e) {
    this.undoManager.addTrackedOrigin(e);
  }
  removeTrackedOrigin(e) {
    this.undoManager.removeTrackedOrigin(e);
  }
  undo() {
    return this.undoManager.undo() != null;
  }
  redo() {
    return this.undoManager.redo() != null;
  }
}
const ou = L.define({
  combine(t) {
    return t[t.length - 1];
  }
});
class XL {
  constructor(e) {
    this.view = e, this.conf = e.state.facet(ou), this._undoManager = this.conf.undoManager, this.syncConf = e.state.facet(su), this._beforeChangeSelection = null, this._mux = YL(), this._onStackItemAdded = ({ stackItem: n, changedParentTypes: r }) => {
      r.has(this.syncConf.ytext) && this._beforeChangeSelection && !n.meta.has(this) && n.meta.set(this, this._beforeChangeSelection);
    }, this._onStackItemPopped = ({ stackItem: n }) => {
      const r = n.meta.get(this);
      if (r) {
        const i = this.syncConf.fromYRange(r);
        e.dispatch(e.state.update({ selection: i })), this._storeSelection();
      }
    }, this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    }, this._undoManager.on("stack-item-added", this._onStackItemAdded), this._undoManager.on("stack-item-popped", this._onStackItemPopped), this._undoManager.addTrackedOrigin(this.syncConf);
  }
  update(e) {
    e.selectionSet && (e.transactions.length === 0 || e.transactions[0].annotation(Cp) !== this.syncConf) && this._storeSelection();
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded), this._undoManager.off("stack-item-popped", this._onStackItemPopped), this._undoManager.removeTrackedOrigin(this.syncConf);
  }
}
const WL = ke.fromClass(XL), zL = ({ state: t, dispatch: e }) => t.facet(ou).undo() || !0, VL = ({ state: t, dispatch: e }) => t.facet(ou).redo() || !0, UL = (t, e, { undoManager: n = new am(t) } = {}) => {
  const r = new ML(t, e), i = [
    su.of(r),
    ZL
  ];
  return e && i.push(
    IL,
    BL
  ), n !== !1 && i.push(
    ou.of(new jL(n)),
    WL,
    T.domEventHandlers({
      beforeinput(s, o) {
        return s.inputType === "historyUndo" ? zL(o) : s.inputType === "historyRedo" ? VL(o) : !1;
      }
    })
  ), i;
};
class ah {
  static create(e, n, r, i, s) {
    let o = i + (i << 8) + e + (n << 4) | 0;
    return new ah(e, n, r, o, s, [], []);
  }
  constructor(e, n, r, i, s, o, l) {
    this.type = e, this.value = n, this.from = r, this.hash = i, this.end = s, this.children = o, this.positions = l, this.hashProp = [[K.contextHash, i]];
  }
  addChild(e, n) {
    e.prop(K.contextHash) != this.hash && (e = new pe(e.type, e.children, e.positions, e.length, this.hashProp)), this.children.push(e), this.positions.push(n);
  }
  toTree(e, n = this.end) {
    let r = this.children.length - 1;
    return r >= 0 && (n = Math.max(n, this.positions[r] + this.children[r].length + this.from)), new pe(e.types[this.type], this.children, this.positions, n - this.from).balance({
      makeTree: (i, s, o) => new pe(Ve.none, i, s, o, this.hashProp)
    });
  }
}
var E;
(function(t) {
  t[t.Document = 1] = "Document", t[t.CodeBlock = 2] = "CodeBlock", t[t.FencedCode = 3] = "FencedCode", t[t.Blockquote = 4] = "Blockquote", t[t.HorizontalRule = 5] = "HorizontalRule", t[t.BulletList = 6] = "BulletList", t[t.OrderedList = 7] = "OrderedList", t[t.ListItem = 8] = "ListItem", t[t.ATXHeading1 = 9] = "ATXHeading1", t[t.ATXHeading2 = 10] = "ATXHeading2", t[t.ATXHeading3 = 11] = "ATXHeading3", t[t.ATXHeading4 = 12] = "ATXHeading4", t[t.ATXHeading5 = 13] = "ATXHeading5", t[t.ATXHeading6 = 14] = "ATXHeading6", t[t.SetextHeading1 = 15] = "SetextHeading1", t[t.SetextHeading2 = 16] = "SetextHeading2", t[t.HTMLBlock = 17] = "HTMLBlock", t[t.LinkReference = 18] = "LinkReference", t[t.Paragraph = 19] = "Paragraph", t[t.CommentBlock = 20] = "CommentBlock", t[t.ProcessingInstructionBlock = 21] = "ProcessingInstructionBlock", t[t.Escape = 22] = "Escape", t[t.Entity = 23] = "Entity", t[t.HardBreak = 24] = "HardBreak", t[t.Emphasis = 25] = "Emphasis", t[t.StrongEmphasis = 26] = "StrongEmphasis", t[t.Link = 27] = "Link", t[t.Image = 28] = "Image", t[t.InlineCode = 29] = "InlineCode", t[t.HTMLTag = 30] = "HTMLTag", t[t.Comment = 31] = "Comment", t[t.ProcessingInstruction = 32] = "ProcessingInstruction", t[t.URL = 33] = "URL", t[t.HeaderMark = 34] = "HeaderMark", t[t.QuoteMark = 35] = "QuoteMark", t[t.ListMark = 36] = "ListMark", t[t.LinkMark = 37] = "LinkMark", t[t.EmphasisMark = 38] = "EmphasisMark", t[t.CodeMark = 39] = "CodeMark", t[t.CodeText = 40] = "CodeText", t[t.CodeInfo = 41] = "CodeInfo", t[t.LinkTitle = 42] = "LinkTitle", t[t.LinkLabel = 43] = "LinkLabel";
})(E || (E = {}));
class FL {
  constructor(e, n) {
    this.start = e, this.content = n, this.marks = [], this.parsers = [];
  }
}
class GL {
  constructor() {
    this.text = "", this.baseIndent = 0, this.basePos = 0, this.depth = 0, this.markers = [], this.pos = 0, this.indent = 0, this.next = -1;
  }
  forward() {
    this.basePos > this.pos && this.forwardInner();
  }
  forwardInner() {
    let e = this.skipSpace(this.basePos);
    this.indent = this.countIndent(e, this.pos, this.indent), this.pos = e, this.next = e == this.text.length ? -1 : this.text.charCodeAt(e);
  }
  skipSpace(e) {
    return Bo(this.text, e);
  }
  reset(e) {
    for (this.text = e, this.baseIndent = this.basePos = this.pos = this.indent = 0, this.forwardInner(), this.depth = 1; this.markers.length; )
      this.markers.pop();
  }
  moveBase(e) {
    this.basePos = e, this.baseIndent = this.countIndent(e, this.pos, this.indent);
  }
  moveBaseColumn(e) {
    this.baseIndent = e, this.basePos = this.findColumn(e);
  }
  addMarker(e) {
    this.markers.push(e);
  }
  countIndent(e, n = 0, r = 0) {
    for (let i = n; i < e; i++)
      r += this.text.charCodeAt(i) == 9 ? 4 - r % 4 : 1;
    return r;
  }
  findColumn(e) {
    let n = 0;
    for (let r = 0; n < this.text.length && r < e; n++)
      r += this.text.charCodeAt(n) == 9 ? 4 - r % 4 : 1;
    return n;
  }
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let e = "";
    for (let n = 0; n < this.basePos; n++)
      e += " ";
    return e + this.text.slice(this.basePos);
  }
}
function db(t, e, n) {
  if (n.pos == n.text.length || t != e.block && n.indent >= e.stack[n.depth + 1].value + n.baseIndent)
    return !0;
  if (n.indent >= n.baseIndent + 4)
    return !1;
  let r = (t.type == E.OrderedList ? wm : ym)(n, e, !1);
  return r > 0 && (t.type != E.BulletList || bm(n, e, !1) < 0) && n.text.charCodeAt(n.pos + r - 1) == t.value;
}
const Q_ = {
  [E.Blockquote](t, e, n) {
    return n.next != 62 ? !1 : (n.markers.push(he(E.QuoteMark, e.lineStart + n.pos, e.lineStart + n.pos + 1)), n.moveBase(n.pos + (nn(n.text.charCodeAt(n.pos + 1)) ? 2 : 1)), t.end = e.lineStart + n.text.length, !0);
  },
  [E.ListItem](t, e, n) {
    return n.indent < n.baseIndent + t.value && n.next > -1 ? !1 : (n.moveBaseColumn(n.baseIndent + t.value), !0);
  },
  [E.OrderedList]: db,
  [E.BulletList]: db,
  [E.Document]() {
    return !0;
  }
};
function nn(t) {
  return t == 32 || t == 9 || t == 10 || t == 13;
}
function Bo(t, e = 0) {
  for (; e < t.length && nn(t.charCodeAt(e)); )
    e++;
  return e;
}
function pb(t, e, n) {
  for (; e > n && nn(t.charCodeAt(e - 1)); )
    e--;
  return e;
}
function E_(t) {
  if (t.next != 96 && t.next != 126)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  if (e < t.pos + 3)
    return -1;
  if (t.next == 96) {
    for (let n = e; n < t.text.length; n++)
      if (t.text.charCodeAt(n) == 96)
        return -1;
  }
  return e;
}
function D_(t) {
  return t.next != 62 ? -1 : t.text.charCodeAt(t.pos + 1) == 32 ? 2 : 1;
}
function bm(t, e, n) {
  if (t.next != 42 && t.next != 45 && t.next != 95)
    return -1;
  let r = 1;
  for (let i = t.pos + 1; i < t.text.length; i++) {
    let s = t.text.charCodeAt(i);
    if (s == t.next)
      r++;
    else if (!nn(s))
      return -1;
  }
  return n && t.next == 45 && Z_(t) > -1 && t.depth == e.stack.length || r < 3 ? -1 : 1;
}
function M_(t, e) {
  for (let n = t.stack.length - 1; n >= 0; n--)
    if (t.stack[n].type == e)
      return !0;
  return !1;
}
function ym(t, e, n) {
  return (t.next == 45 || t.next == 43 || t.next == 42) && (t.pos == t.text.length - 1 || nn(t.text.charCodeAt(t.pos + 1))) && (!n || M_(e, E.BulletList) || t.skipSpace(t.pos + 2) < t.text.length) ? 1 : -1;
}
function wm(t, e, n) {
  let r = t.pos, i = t.next;
  for (; i >= 48 && i <= 57; ) {
    r++;
    if (r == t.text.length)
      return -1;
    i = t.text.charCodeAt(r);
  }
  return r == t.pos || r > t.pos + 9 || i != 46 && i != 41 || r < t.text.length - 1 && !nn(t.text.charCodeAt(r + 1)) || n && !M_(e, E.OrderedList) && (t.skipSpace(r + 1) == t.text.length || r > t.pos + 1 || t.next != 49) ? -1 : r + 1 - t.pos;
}
function R_(t) {
  if (t.next != 35)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == 35; )
    e++;
  if (e < t.text.length && t.text.charCodeAt(e) != 32)
    return -1;
  let n = e - t.pos;
  return n > 6 ? -1 : n;
}
function Z_(t) {
  if (t.next != 45 && t.next != 61 || t.indent >= t.baseIndent + 4)
    return -1;
  let e = t.pos + 1;
  for (; e < t.text.length && t.text.charCodeAt(e) == t.next; )
    e++;
  let n = e;
  for (; e < t.text.length && nn(t.text.charCodeAt(e)); )
    e++;
  return e == t.text.length ? n : -1;
}
const Ap = /^[ \t]*$/, I_ = /-->/, L_ = /\?>/, $p = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, I_],
  [/^\s*<\?/, L_],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, Ap],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, Ap]
];
function N_(t, e, n) {
  if (t.next != 60)
    return -1;
  let r = t.text.slice(t.pos);
  for (let i = 0, s = $p.length - (n ? 1 : 0); i < s; i++)
    if ($p[i][0].test(r))
      return i;
  return -1;
}
function gb(t, e) {
  let n = t.countIndent(e, t.pos, t.indent), r = t.countIndent(t.skipSpace(e), e, n);
  return r >= n + 5 ? n + 1 : r;
}
function ti(t, e, n) {
  let r = t.length - 1;
  r >= 0 && t[r].to == e && t[r].type == E.CodeText ? t[r].to = n : t.push(he(E.CodeText, e, n));
}
const La = {
  LinkReference: void 0,
  IndentedCode(t, e) {
    let n = e.baseIndent + 4;
    if (e.indent < n)
      return !1;
    let r = e.findColumn(n), i = t.lineStart + r, s = t.lineStart + e.text.length, o = [], l = [];
    for (ti(o, i, s); t.nextLine() && e.depth >= t.stack.length; )
      if (e.pos == e.text.length) {
        ti(l, t.lineStart - 1, t.lineStart);
        for (let a of e.markers)
          l.push(a);
      } else {
        if (e.indent < n)
          break;
        {
          if (l.length) {
            for (let c of l)
              c.type == E.CodeText ? ti(o, c.from, c.to) : o.push(c);
            l = [];
          }
          ti(o, t.lineStart - 1, t.lineStart);
          for (let c of e.markers)
            o.push(c);
          s = t.lineStart + e.text.length;
          let a = t.lineStart + e.findColumn(e.baseIndent + 4);
          a < s && ti(o, a, s);
        }
      }
    return l.length && (l = l.filter((a) => a.type != E.CodeText), l.length && (e.markers = l.concat(e.markers))), t.addNode(t.buffer.writeElements(o, -i).finish(E.CodeBlock, s - i), i), !0;
  },
  FencedCode(t, e) {
    let n = E_(e);
    if (n < 0)
      return !1;
    let r = t.lineStart + e.pos, i = e.next, s = n - e.pos, o = e.skipSpace(n), l = pb(e.text, e.text.length, o), a = [he(E.CodeMark, r, r + s)];
    o < l && a.push(he(E.CodeInfo, t.lineStart + o, t.lineStart + l));
    for (let c = !0; t.nextLine() && e.depth >= t.stack.length; c = !1) {
      let h = e.pos;
      if (e.indent - e.baseIndent < 4)
        for (; h < e.text.length && e.text.charCodeAt(h) == i; )
          h++;
      if (h - e.pos >= s && e.skipSpace(h) == e.text.length) {
        for (let u of e.markers)
          a.push(u);
        a.push(he(E.CodeMark, t.lineStart + e.pos, t.lineStart + h)), t.nextLine();
        break;
      } else {
        c || ti(a, t.lineStart - 1, t.lineStart);
        for (let d of e.markers)
          a.push(d);
        let u = t.lineStart + e.basePos, f = t.lineStart + e.text.length;
        u < f && ti(a, u, f);
      }
    }
    return t.addNode(t.buffer.writeElements(a, -r).finish(E.FencedCode, t.prevLineEnd() - r), r), !0;
  },
  Blockquote(t, e) {
    let n = D_(e);
    return n < 0 ? !1 : (t.startContext(E.Blockquote, e.pos), t.addNode(E.QuoteMark, t.lineStart + e.pos, t.lineStart + e.pos + 1), e.moveBase(e.pos + n), null);
  },
  HorizontalRule(t, e) {
    if (bm(e, t, !1) < 0)
      return !1;
    let n = t.lineStart + e.pos;
    return t.nextLine(), t.addNode(E.HorizontalRule, n), !0;
  },
  BulletList(t, e) {
    let n = ym(e, t, !1);
    if (n < 0)
      return !1;
    t.block.type != E.BulletList && t.startContext(E.BulletList, e.basePos, e.next);
    let r = gb(e, e.pos + 1);
    return t.startContext(E.ListItem, e.basePos, r - e.baseIndent), t.addNode(E.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n), e.moveBaseColumn(r), null;
  },
  OrderedList(t, e) {
    let n = wm(e, t, !1);
    if (n < 0)
      return !1;
    t.block.type != E.OrderedList && t.startContext(E.OrderedList, e.basePos, e.text.charCodeAt(e.pos + n - 1));
    let r = gb(e, e.pos + n);
    return t.startContext(E.ListItem, e.basePos, r - e.baseIndent), t.addNode(E.ListMark, t.lineStart + e.pos, t.lineStart + e.pos + n), e.moveBaseColumn(r), null;
  },
  ATXHeading(t, e) {
    let n = R_(e);
    if (n < 0)
      return !1;
    let r = e.pos, i = t.lineStart + r, s = pb(e.text, e.text.length, r), o = s;
    for (; o > r && e.text.charCodeAt(o - 1) == e.next; )
      o--;
    (o == s || o == r || !nn(e.text.charCodeAt(o - 1))) && (o = e.text.length);
    let l = t.buffer.write(E.HeaderMark, 0, n).writeElements(t.parser.parseInline(e.text.slice(r + n + 1, o), i + n + 1), -i);
    o < e.text.length && l.write(E.HeaderMark, o - r, s - r);
    let a = l.finish(E.ATXHeading1 - 1 + n, e.text.length - r);
    return t.nextLine(), t.addNode(a, i), !0;
  },
  HTMLBlock(t, e) {
    let n = N_(e, t, !1);
    if (n < 0)
      return !1;
    let r = t.lineStart + e.pos, i = $p[n][1], s = [], o = i != Ap;
    for (; !i.test(e.text) && t.nextLine(); ) {
      if (e.depth < t.stack.length) {
        o = !1;
        break;
      }
      for (let c of e.markers)
        s.push(c);
    }
    o && t.nextLine();
    let l = i == I_ ? E.CommentBlock : i == L_ ? E.ProcessingInstructionBlock : E.HTMLBlock, a = t.prevLineEnd();
    return t.addNode(t.buffer.writeElements(s, -r).finish(l, a - r), r), !0;
  },
  SetextHeading: void 0
};
class HL {
  constructor(e) {
    this.stage = 0, this.elts = [], this.pos = 0, this.start = e.start, this.advance(e.content);
  }
  nextLine(e, n, r) {
    if (this.stage == -1)
      return !1;
    let i = r.content + `
` + n.scrub(), s = this.advance(i);
    return s > -1 && s < i.length ? this.complete(e, r, s) : !1;
  }
  finish(e, n) {
    return (this.stage == 2 || this.stage == 3) && Bo(n.content, this.pos) == n.content.length ? this.complete(e, n, n.content.length) : !1;
  }
  complete(e, n, r) {
    return e.addLeafElement(n, he(E.LinkReference, this.start, this.start + r, this.elts)), !0;
  }
  nextStage(e) {
    return e ? (this.pos = e.to - this.start, this.elts.push(e), this.stage++, !0) : (e === !1 && (this.stage = -1), !1);
  }
  advance(e) {
    for (; ; ) {
      if (this.stage == -1)
        return -1;
      if (this.stage == 0) {
        if (!this.nextStage(U_(e, this.pos, this.start, !0)))
          return -1;
        if (e.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(he(E.LinkMark, this.pos + this.start, this.pos + this.start + 1)), this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(z_(e, Bo(e, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let n = Bo(e, this.pos), r = 0;
        if (n > this.pos) {
          let i = V_(e, n, this.start);
          if (i) {
            let s = gf(e, i.to - this.start);
            s > 0 && (this.nextStage(i), r = s);
          }
        }
        return r || (r = gf(e, this.pos)), r > 0 && r < e.length ? r : -1;
      } else
        return gf(e, this.pos);
    }
  }
}
function gf(t, e) {
  for (; e < t.length; e++) {
    let n = t.charCodeAt(e);
    if (n == 10)
      break;
    if (!nn(n))
      return -1;
  }
  return e;
}
class JL {
  nextLine(e, n, r) {
    let i = n.depth < e.stack.length ? -1 : Z_(n), s = n.next;
    if (i < 0)
      return !1;
    let o = he(E.HeaderMark, e.lineStart + n.pos, e.lineStart + i);
    return e.nextLine(), e.addLeafElement(r, he(s == 61 ? E.SetextHeading1 : E.SetextHeading2, r.start, e.prevLineEnd(), [
      ...e.parser.parseInline(r.content, r.start),
      o
    ])), !0;
  }
  finish() {
    return !1;
  }
}
const KL = {
  LinkReference(t, e) {
    return e.content.charCodeAt(0) == 91 ? new HL(e) : null;
  },
  SetextHeading() {
    return new JL();
  }
}, e3 = [
  (t, e) => R_(e) >= 0,
  (t, e) => E_(e) >= 0,
  (t, e) => D_(e) >= 0,
  (t, e) => ym(e, t, !0) >= 0,
  (t, e) => wm(e, t, !0) >= 0,
  (t, e) => bm(e, t, !0) >= 0,
  (t, e) => N_(e, t, !0) >= 0
], t3 = { text: "", end: 0 };
class n3 {
  constructor(e, n, r, i) {
    this.parser = e, this.input = n, this.ranges = i, this.line = new GL(), this.atEnd = !1, this.reusePlaceholders = /* @__PURE__ */ new Map(), this.stoppedAt = null, this.rangeI = 0, this.to = i[i.length - 1].to, this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = i[0].from, this.block = ah.create(E.Document, 0, this.lineStart, 0, 0), this.stack = [this.block], this.fragments = r.length ? new o3(r, n) : null, this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: e } = this;
    for (; ; ) {
      for (let r = 0; ; ) {
        let i = e.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        for (; r < e.markers.length && (!i || e.markers[r].from < i.end); ) {
          let s = e.markers[r++];
          this.addNode(s.type, s.from, s.to);
        }
        if (!i)
          break;
        this.finishContext();
      }
      if (e.pos < e.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(e.basePos))
      return null;
    e:
      for (; ; ) {
        for (let r of this.parser.blockParsers)
          if (r) {
            let i = r(this, e);
            if (i != !1) {
              if (i == !0)
                return null;
              e.forward();
              continue e;
            }
          }
        break;
      }
    let n = new FL(this.lineStart + e.pos, e.text.slice(e.pos));
    for (let r of this.parser.leafBlockParsers)
      if (r) {
        let i = r(this, n);
        i && n.parsers.push(i);
      }
    e:
      for (; this.nextLine() && e.pos != e.text.length; ) {
        if (e.indent < e.baseIndent + 4) {
          for (let r of this.parser.endLeafBlock)
            if (r(this, e, n))
              break e;
        }
        for (let r of n.parsers)
          if (r.nextLine(this, e, n))
            return null;
        n.content += `
` + e.scrub();
        for (let r of e.markers)
          n.marks.push(r);
      }
    return this.finishLeaf(n), null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  reuseFragment(e) {
    if (!this.fragments.moveTo(this.absoluteLineStart + e, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return !1;
    let n = this.fragments.takeNodes(this);
    return n ? (this.absoluteLineStart += n, this.lineStart = F_(this.absoluteLineStart, this.ranges), this.moveRangeI(), this.absoluteLineStart < this.to ? (this.lineStart++, this.absoluteLineStart++, this.readLine()) : (this.atEnd = !0, this.readLine()), !0) : !1;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(e = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[e].type];
  }
  nextLine() {
    return this.lineStart += this.line.text.length, this.absoluteLineEnd >= this.to ? (this.absoluteLineStart = this.absoluteLineEnd, this.atEnd = !0, this.readLine(), !1) : (this.lineStart++, this.absoluteLineStart = this.absoluteLineEnd + 1, this.moveRangeI(), this.readLine(), !0);
  }
  moveRangeI() {
    for (; this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to; )
      this.rangeI++, this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
  }
  scanLine(e) {
    let n = t3;
    if (n.end = e, e >= this.to)
      n.text = "";
    else if (n.text = this.lineChunkAt(e), n.end += n.text.length, this.ranges.length > 1) {
      let r = this.absoluteLineStart, i = this.rangeI;
      for (; this.ranges[i].to < n.end; ) {
        i++;
        let s = this.ranges[i].from, o = this.lineChunkAt(s);
        n.end = s + o.length, n.text = n.text.slice(0, this.ranges[i - 1].to - r) + o, r = n.end - n.text.length;
      }
    }
    return n;
  }
  readLine() {
    let { line: e } = this, { text: n, end: r } = this.scanLine(this.absoluteLineStart);
    for (this.absoluteLineEnd = r, e.reset(n); e.depth < this.stack.length; e.depth++) {
      let i = this.stack[e.depth], s = this.parser.skipContextMarkup[i.type];
      if (!s)
        throw new Error("Unhandled block context " + E[i.type]);
      if (!s(i, this, e))
        break;
      e.forward();
    }
  }
  lineChunkAt(e) {
    let n = this.input.chunk(e), r;
    if (this.input.lineChunks)
      r = n == `
` ? "" : n;
    else {
      let i = n.indexOf(`
`);
      r = i < 0 ? n : n.slice(0, i);
    }
    return e + r.length > this.to ? r.slice(0, this.to - e) : r;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(e, n, r = 0) {
    this.block = ah.create(e, r, this.lineStart + n, this.block.hash, this.lineStart + this.line.text.length), this.stack.push(this.block);
  }
  startComposite(e, n, r = 0) {
    this.startContext(this.parser.getNodeType(e), n, r);
  }
  addNode(e, n, r) {
    typeof e == "number" && (e = new pe(this.parser.nodeSet.types[e], Rs, Rs, (r != null ? r : this.prevLineEnd()) - n)), this.block.addChild(e, n - this.block.from);
  }
  addElement(e) {
    this.block.addChild(e.toTree(this.parser.nodeSet), e.from - this.block.from);
  }
  addLeafElement(e, n) {
    this.addNode(this.buffer.writeElements(Tp(n.children, e.marks), -n.from).finish(n.type, n.to - n.from), n.from);
  }
  finishContext() {
    let e = this.stack.pop(), n = this.stack[this.stack.length - 1];
    n.addChild(e.toTree(this.parser.nodeSet), e.from - n.from), this.block = n;
  }
  finish() {
    for (; this.stack.length > 1; )
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(e) {
    return this.ranges.length > 1 ? q_(this.ranges, 0, e.topNode, this.ranges[0].from, this.reusePlaceholders) : e;
  }
  finishLeaf(e) {
    for (let r of e.parsers)
      if (r.finish(this, e))
        return;
    let n = Tp(this.parser.parseInline(e.content, e.start), e.marks);
    this.addNode(this.buffer.writeElements(n, -e.start).finish(E.Paragraph, e.content.length), e.start);
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? he(this.parser.getNodeType(e), n, r, i) : new j_(e, n);
  }
  get buffer() {
    return new Y_(this.parser.nodeSet);
  }
}
function q_(t, e, n, r, i) {
  let s = t[e].to, o = [], l = [], a = n.from + r;
  function c(h, u) {
    for (; u ? h >= s : h > s; ) {
      let f = t[e + 1].from - s;
      r += f, h += f, e++, s = t[e].to;
    }
  }
  for (let h = n.firstChild; h; h = h.nextSibling) {
    c(h.from + r, !0);
    let u = h.from + r, f, d = i.get(h.tree);
    d ? f = d : h.to + r > s ? (f = q_(t, e, h, r, i), c(h.to + r, !1)) : f = h.toTree(), o.push(f), l.push(u - a);
  }
  return c(n.to + r, !1), new pe(n.type, o, l, n.to + r - a, n.tree ? n.tree.propValues : void 0);
}
class lu extends Pg {
  constructor(e, n, r, i, s, o, l, a, c) {
    super(), this.nodeSet = e, this.blockParsers = n, this.leafBlockParsers = r, this.blockNames = i, this.endLeafBlock = s, this.skipContextMarkup = o, this.inlineParsers = l, this.inlineNames = a, this.wrappers = c, this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let h of e.types)
      this.nodeTypes[h.name] = h.id;
  }
  createParse(e, n, r) {
    let i = new n3(this, e, n, r);
    for (let s of this.wrappers)
      i = s(i, e, n, r);
    return i;
  }
  configure(e) {
    let n = Pp(e);
    if (!n)
      return this;
    let { nodeSet: r, skipContextMarkup: i } = this, s = this.blockParsers.slice(), o = this.leafBlockParsers.slice(), l = this.blockNames.slice(), a = this.inlineParsers.slice(), c = this.inlineNames.slice(), h = this.endLeafBlock.slice(), u = this.wrappers;
    if (go(n.defineNodes)) {
      i = Object.assign({}, i);
      let f = r.types.slice(), d;
      for (let p of n.defineNodes) {
        let { name: g, block: m, composite: O, style: b } = typeof p == "string" ? { name: p } : p;
        if (f.some((S) => S.name == g))
          continue;
        O && (i[f.length] = (S, x, v) => O(x, v, S.value));
        let y = f.length, w = O ? ["Block", "BlockContext"] : m ? y >= E.ATXHeading1 && y <= E.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"] : void 0;
        f.push(Ve.define({
          id: y,
          name: g,
          props: w && [[K.group, w]]
        })), b && (d || (d = {}), Array.isArray(b) || b instanceof an ? d[g] = b : Object.assign(d, b));
      }
      r = new ql(f), d && (r = r.extend(Ws(d)));
    }
    if (go(n.props) && (r = r.extend(...n.props)), go(n.remove))
      for (let f of n.remove) {
        let d = this.blockNames.indexOf(f), p = this.inlineNames.indexOf(f);
        d > -1 && (s[d] = o[d] = void 0), p > -1 && (a[p] = void 0);
      }
    if (go(n.parseBlock))
      for (let f of n.parseBlock) {
        let d = l.indexOf(f.name);
        if (d > -1)
          s[d] = f.parse, o[d] = f.leaf;
        else {
          let p = f.before ? Na(l, f.before) : f.after ? Na(l, f.after) + 1 : l.length - 1;
          s.splice(p, 0, f.parse), o.splice(p, 0, f.leaf), l.splice(p, 0, f.name);
        }
        f.endLeaf && h.push(f.endLeaf);
      }
    if (go(n.parseInline))
      for (let f of n.parseInline) {
        let d = c.indexOf(f.name);
        if (d > -1)
          a[d] = f.parse;
        else {
          let p = f.before ? Na(c, f.before) : f.after ? Na(c, f.after) + 1 : c.length - 1;
          a.splice(p, 0, f.parse), c.splice(p, 0, f.name);
        }
      }
    return n.wrap && (u = u.concat(n.wrap)), new lu(r, s, o, l, h, i, a, c, u);
  }
  getNodeType(e) {
    let n = this.nodeTypes[e];
    if (n == null)
      throw new RangeError(`Unknown node type '${e}'`);
    return n;
  }
  parseInline(e, n) {
    let r = new i3(this, e, n);
    e:
      for (let i = n; i < r.end; ) {
        let s = r.char(i);
        for (let o of this.inlineParsers)
          if (o) {
            let l = o(r, s, i);
            if (l >= 0) {
              i = l;
              continue e;
            }
          }
        i++;
      }
    return r.resolveMarkers(0);
  }
}
function go(t) {
  return t != null && t.length > 0;
}
function Pp(t) {
  if (!Array.isArray(t))
    return t;
  if (t.length == 0)
    return null;
  let e = Pp(t[0]);
  if (t.length == 1)
    return e;
  let n = Pp(t.slice(1));
  if (!n || !e)
    return e || n;
  let r = (o, l) => (o || Rs).concat(l || Rs), i = e.wrap, s = n.wrap;
  return {
    props: r(e.props, n.props),
    defineNodes: r(e.defineNodes, n.defineNodes),
    parseBlock: r(e.parseBlock, n.parseBlock),
    parseInline: r(e.parseInline, n.parseInline),
    remove: r(e.remove, n.remove),
    wrap: i ? s ? (o, l, a, c) => i(s(o, l, a, c), l, a, c) : i : s
  };
}
function Na(t, e) {
  let n = t.indexOf(e);
  if (n < 0)
    throw new RangeError(`Position specified relative to unknown parser ${e}`);
  return n;
}
let B_ = [Ve.none];
for (let t = 1, e; e = E[t]; t++)
  B_[t] = Ve.define({
    id: t,
    name: e,
    props: t >= E.Escape ? [] : [[K.group, t in Q_ ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: e == "Document"
  });
const Rs = [];
class Y_ {
  constructor(e) {
    this.nodeSet = e, this.content = [], this.nodes = [];
  }
  write(e, n, r, i = 0) {
    return this.content.push(e, n, r, 4 + i * 4), this;
  }
  writeElements(e, n = 0) {
    for (let r of e)
      r.writeTo(this, n);
    return this;
  }
  finish(e, n) {
    return pe.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: e,
      length: n
    });
  }
}
class _l {
  constructor(e, n, r, i = Rs) {
    this.type = e, this.from = n, this.to = r, this.children = i;
  }
  writeTo(e, n) {
    let r = e.content.length;
    e.writeElements(this.children, n), e.content.push(this.type, this.from + n, this.to + n, e.content.length + 4 - r);
  }
  toTree(e) {
    return new Y_(e).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}
class j_ {
  constructor(e, n) {
    this.tree = e, this.from = n;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return Rs;
  }
  writeTo(e, n) {
    e.nodes.push(this.tree), e.content.push(e.nodes.length - 1, this.from + n, this.to + n, -1);
  }
  toTree() {
    return this.tree;
  }
}
function he(t, e, n, r) {
  return new _l(t, e, n, r);
}
const X_ = { resolve: "Emphasis", mark: "EmphasisMark" }, W_ = { resolve: "Emphasis", mark: "EmphasisMark" }, mo = {}, mb = {};
class cn {
  constructor(e, n, r, i) {
    this.type = e, this.from = n, this.to = r, this.side = i;
  }
}
const Ob = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Cl = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Cl = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch {
}
const mf = {
  Escape(t, e, n) {
    if (e != 92 || n == t.end - 1)
      return -1;
    let r = t.char(n + 1);
    for (let i = 0; i < Ob.length; i++)
      if (Ob.charCodeAt(i) == r)
        return t.append(he(E.Escape, n, n + 2));
    return -1;
  },
  Entity(t, e, n) {
    if (e != 38)
      return -1;
    let r = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(t.slice(n + 1, n + 31));
    return r ? t.append(he(E.Entity, n, n + 1 + r[0].length)) : -1;
  },
  InlineCode(t, e, n) {
    if (e != 96 || n && t.char(n - 1) == 96)
      return -1;
    let r = n + 1;
    for (; r < t.end && t.char(r) == 96; )
      r++;
    let i = r - n, s = 0;
    for (; r < t.end; r++)
      if (t.char(r) == 96) {
        if (s++, s == i && t.char(r + 1) != 96)
          return t.append(he(E.InlineCode, n, r + 1, [
            he(E.CodeMark, n, n + i),
            he(E.CodeMark, r + 1 - i, r + 1)
          ]));
      } else
        s = 0;
    return -1;
  },
  HTMLTag(t, e, n) {
    if (e != 60 || n == t.end - 1)
      return -1;
    let r = t.slice(n + 1, t.end), i = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(r);
    if (i)
      return t.append(he(E.URL, n, n + 1 + i[0].length));
    let s = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(r);
    if (s)
      return t.append(he(E.Comment, n, n + 1 + s[0].length));
    let o = /^\?[^]*?\?>/.exec(r);
    if (o)
      return t.append(he(E.ProcessingInstruction, n, n + 1 + o[0].length));
    let l = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(r);
    return l ? t.append(he(E.HTMLTag, n, n + 1 + l[0].length)) : -1;
  },
  Emphasis(t, e, n) {
    if (e != 95 && e != 42)
      return -1;
    let r = n + 1;
    for (; t.char(r) == e; )
      r++;
    let i = t.slice(n - 1, n), s = t.slice(r, r + 1), o = Cl.test(i), l = Cl.test(s), a = /\s|^$/.test(i), c = /\s|^$/.test(s), h = !c && (!l || a || o), u = !a && (!o || c || l), f = h && (e == 42 || !u || o), d = u && (e == 42 || !h || l);
    return t.append(new cn(e == 95 ? X_ : W_, n, r, (f ? 1 : 0) | (d ? 2 : 0)));
  },
  HardBreak(t, e, n) {
    if (e == 92 && t.char(n + 1) == 10)
      return t.append(he(E.HardBreak, n, n + 2));
    if (e == 32) {
      let r = n + 1;
      for (; t.char(r) == 32; )
        r++;
      if (t.char(r) == 10 && r >= n + 2)
        return t.append(he(E.HardBreak, n, r + 1));
    }
    return -1;
  },
  Link(t, e, n) {
    return e == 91 ? t.append(new cn(mo, n, n + 1, 1)) : -1;
  },
  Image(t, e, n) {
    return e == 33 && t.char(n + 1) == 91 ? t.append(new cn(mb, n, n + 2, 1)) : -1;
  },
  LinkEnd(t, e, n) {
    if (e != 93)
      return -1;
    for (let r = t.parts.length - 1; r >= 0; r--) {
      let i = t.parts[r];
      if (i instanceof cn && (i.type == mo || i.type == mb)) {
        if (!i.side || t.skipSpace(i.to) == n && !/[(\[]/.test(t.slice(n + 1, n + 2)))
          return t.parts[r] = null, -1;
        let s = t.takeContent(r), o = t.parts[r] = r3(t, s, i.type == mo ? E.Link : E.Image, i.from, n + 1);
        if (i.type == mo)
          for (let l = 0; l < r; l++) {
            let a = t.parts[l];
            a instanceof cn && a.type == mo && (a.side = 0);
          }
        return o.to;
      }
    }
    return -1;
  }
};
function r3(t, e, n, r, i) {
  let { text: s } = t, o = t.char(i), l = i;
  if (e.unshift(he(E.LinkMark, r, r + (n == E.Image ? 2 : 1))), e.push(he(E.LinkMark, i - 1, i)), o == 40) {
    let a = t.skipSpace(i + 1), c = z_(s, a - t.offset, t.offset), h;
    c && (a = t.skipSpace(c.to), h = V_(s, a - t.offset, t.offset), h && (a = t.skipSpace(h.to))), t.char(a) == 41 && (e.push(he(E.LinkMark, i, i + 1)), l = a + 1, c && e.push(c), h && e.push(h), e.push(he(E.LinkMark, a, l)));
  } else if (o == 91) {
    let a = U_(s, i - t.offset, t.offset, !1);
    a && (e.push(a), l = a.to);
  }
  return he(n, r, l, e);
}
function z_(t, e, n) {
  if (t.charCodeAt(e) == 60) {
    for (let i = e + 1; i < t.length; i++) {
      let s = t.charCodeAt(i);
      if (s == 62)
        return he(E.URL, e + n, i + 1 + n);
      if (s == 60 || s == 10)
        return !1;
    }
    return null;
  } else {
    let i = 0, s = e;
    for (let o = !1; s < t.length; s++) {
      let l = t.charCodeAt(s);
      if (nn(l))
        break;
      if (o)
        o = !1;
      else if (l == 40)
        i++;
      else if (l == 41) {
        if (!i)
          break;
        i--;
      } else
        l == 92 && (o = !0);
    }
    return s > e ? he(E.URL, e + n, s + n) : s == t.length ? null : !1;
  }
}
function V_(t, e, n) {
  let r = t.charCodeAt(e);
  if (r != 39 && r != 34 && r != 40)
    return !1;
  let i = r == 40 ? 41 : r;
  for (let s = e + 1, o = !1; s < t.length; s++) {
    let l = t.charCodeAt(s);
    if (o)
      o = !1;
    else {
      if (l == i)
        return he(E.LinkTitle, e + n, s + 1 + n);
      l == 92 && (o = !0);
    }
  }
  return null;
}
function U_(t, e, n, r) {
  for (let i = !1, s = e + 1, o = Math.min(t.length, s + 999); s < o; s++) {
    let l = t.charCodeAt(s);
    if (i)
      i = !1;
    else {
      if (l == 93)
        return r ? !1 : he(E.LinkLabel, e + n, s + 1 + n);
      if (r && !nn(l) && (r = !1), l == 91)
        return !1;
      l == 92 && (i = !0);
    }
  }
  return null;
}
class i3 {
  constructor(e, n, r) {
    this.parser = e, this.text = n, this.offset = r, this.parts = [];
  }
  char(e) {
    return e >= this.end ? -1 : this.text.charCodeAt(e - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(e, n) {
    return this.text.slice(e - this.offset, n - this.offset);
  }
  append(e) {
    return this.parts.push(e), e.to;
  }
  addDelimiter(e, n, r, i, s) {
    return this.append(new cn(e, n, r, (i ? 1 : 0) | (s ? 2 : 0)));
  }
  addElement(e) {
    return this.append(e);
  }
  resolveMarkers(e) {
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      if (!(i instanceof cn && i.type.resolve && i.side & 2))
        continue;
      let s = i.type == X_ || i.type == W_, o = i.to - i.from, l, a = r - 1;
      for (; a >= e; a--) {
        let g = this.parts[a];
        if (g instanceof cn && g.side & 1 && g.type == i.type && !(s && (i.side & 1 || g.side & 2) && (g.to - g.from + o) % 3 == 0 && ((g.to - g.from) % 3 || o % 3))) {
          l = g;
          break;
        }
      }
      if (!l)
        continue;
      let c = i.type.resolve, h = [], u = l.from, f = i.to;
      if (s) {
        let g = Math.min(2, l.to - l.from, o);
        u = l.to - g, f = i.from + g, c = g == 1 ? "Emphasis" : "StrongEmphasis";
      }
      l.type.mark && h.push(this.elt(l.type.mark, u, l.to));
      for (let g = a + 1; g < r; g++)
        this.parts[g] instanceof _l && h.push(this.parts[g]), this.parts[g] = null;
      i.type.mark && h.push(this.elt(i.type.mark, i.from, f));
      let d = this.elt(c, u, f, h);
      this.parts[a] = s && l.from != u ? new cn(l.type, l.from, u, l.side) : null, (this.parts[r] = s && i.to != f ? new cn(i.type, f, i.to, i.side) : null) ? this.parts.splice(r, 0, d) : this.parts[r] = d;
    }
    let n = [];
    for (let r = e; r < this.parts.length; r++) {
      let i = this.parts[r];
      i instanceof _l && n.push(i);
    }
    return n;
  }
  findOpeningDelimiter(e) {
    for (let n = this.parts.length - 1; n >= 0; n--) {
      let r = this.parts[n];
      if (r instanceof cn && r.type == e)
        return n;
    }
    return null;
  }
  takeContent(e) {
    let n = this.resolveMarkers(e);
    return this.parts.length = e, n;
  }
  skipSpace(e) {
    return Bo(this.text, e - this.offset) + this.offset;
  }
  elt(e, n, r, i) {
    return typeof e == "string" ? he(this.parser.getNodeType(e), n, r, i) : new j_(e, n);
  }
}
function Tp(t, e) {
  if (!e.length)
    return t;
  if (!t.length)
    return e;
  let n = t.slice(), r = 0;
  for (let i of e) {
    for (; r < n.length && n[r].to < i.to; )
      r++;
    if (r < n.length && n[r].from < i.from) {
      let s = n[r];
      s instanceof _l && (n[r] = new _l(s.type, s.from, s.to, Tp(s.children, [i])));
    } else
      n.splice(r++, 0, i);
  }
  return n;
}
const s3 = [E.CodeBlock, E.ListItem, E.OrderedList, E.BulletList];
class o3 {
  constructor(e, n) {
    this.fragments = e, this.input = n, this.i = 0, this.fragment = null, this.fragmentEnd = -1, this.cursor = null, e.length && (this.fragment = e[this.i++]);
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null, this.cursor = null, this.fragmentEnd = -1;
  }
  moveTo(e, n) {
    for (; this.fragment && this.fragment.to <= e; )
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (e ? e - 1 : 0))
      return !1;
    if (this.fragmentEnd < 0) {
      let s = this.fragment.to;
      for (; s > 0 && this.input.read(s - 1, s) != `
`; )
        s--;
      this.fragmentEnd = s ? s - 1 : 0;
    }
    let r = this.cursor;
    r || (r = this.cursor = this.fragment.tree.cursor(), r.firstChild());
    let i = e + this.fragment.offset;
    for (; r.to <= i; )
      if (!r.parent())
        return !1;
    for (; ; ) {
      if (r.from >= i)
        return this.fragment.from <= n;
      if (!r.childAfter(i))
        return !1;
    }
  }
  matches(e) {
    let n = this.cursor.tree;
    return n && n.prop(K.contextHash) == e;
  }
  takeNodes(e) {
    let n = this.cursor, r = this.fragment.offset, i = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0), s = e.absoluteLineStart, o = s, l = e.block.children.length, a = o, c = l;
    for (; ; ) {
      if (n.to - r > i) {
        if (n.type.isAnonymous && n.firstChild())
          continue;
        break;
      }
      let h = F_(n.from - r, e.ranges);
      if (n.to - r <= e.ranges[e.rangeI].to)
        e.addNode(n.tree, h);
      else {
        let u = new pe(e.parser.nodeSet.types[E.Paragraph], [], [], 0, e.block.hashProp);
        e.reusePlaceholders.set(u, n.tree), e.addNode(u, h);
      }
      if (n.type.is("Block") && (s3.indexOf(n.type.id) < 0 ? (o = n.to - r, l = e.block.children.length) : (o = a, l = c, a = n.to - r, c = e.block.children.length)), !n.nextSibling())
        break;
    }
    for (; e.block.children.length > l; )
      e.block.children.pop(), e.block.positions.pop();
    return o - s;
  }
}
function F_(t, e) {
  let n = t;
  for (let r = 1; r < e.length; r++) {
    let i = e[r - 1].to, s = e[r].from;
    i < t && (n -= s - i);
  }
  return n;
}
const l3 = Ws({
  "Blockquote/...": k.quote,
  HorizontalRule: k.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": k.heading1,
  "ATXHeading2/... SetextHeading2/...": k.heading2,
  "ATXHeading3/...": k.heading3,
  "ATXHeading4/...": k.heading4,
  "ATXHeading5/...": k.heading5,
  "ATXHeading6/...": k.heading6,
  "Comment CommentBlock": k.comment,
  Escape: k.escape,
  Entity: k.character,
  "Emphasis/...": k.emphasis,
  "StrongEmphasis/...": k.strong,
  "Link/... Image/...": k.link,
  "OrderedList/... BulletList/...": k.list,
  "BlockQuote/...": k.quote,
  "InlineCode CodeText": k.monospace,
  URL: k.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": k.processingInstruction,
  "CodeInfo LinkLabel": k.labelName,
  LinkTitle: k.string,
  Paragraph: k.content
}), a3 = new lu(new ql(B_).extend(l3), Object.keys(La).map((t) => La[t]), Object.keys(La).map((t) => KL[t]), Object.keys(La), e3, Q_, Object.keys(mf).map((t) => mf[t]), Object.keys(mf), []);
function c3(t, e, n) {
  let r = [];
  for (let i = t.firstChild, s = e; ; i = i.nextSibling) {
    let o = i ? i.from : n;
    if (o > s && r.push({ from: s, to: o }), !i)
      break;
    s = i.to;
  }
  return r;
}
function h3(t) {
  let { codeParser: e, htmlParser: n } = t;
  return { wrap: tv((i, s) => {
    let o = i.type.id;
    if (e && (o == E.CodeBlock || o == E.FencedCode)) {
      let l = "";
      if (o == E.FencedCode) {
        let c = i.node.getChild(E.CodeInfo);
        c && (l = s.read(c.from, c.to));
      }
      let a = e(l);
      if (a)
        return { parser: a, overlay: (c) => c.type.id == E.CodeText };
    } else if (n && (o == E.HTMLBlock || o == E.HTMLTag))
      return { parser: n, overlay: c3(i.node, i.from, i.to) };
    return null;
  }) };
}
const u3 = { resolve: "Strikethrough", mark: "StrikethroughMark" }, f3 = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": k.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: k.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(t, e, n) {
      if (e != 126 || t.char(n + 1) != 126 || t.char(n + 2) == 126)
        return -1;
      let r = t.slice(n - 1, n), i = t.slice(n + 2, n + 3), s = /\s|^$/.test(r), o = /\s|^$/.test(i), l = Cl.test(r), a = Cl.test(i);
      return t.addDelimiter(u3, n, n + 2, !o && (!a || s || l), !s && (!l || o || a));
    },
    after: "Emphasis"
  }]
};
function Yo(t, e, n = 0, r, i = 0) {
  let s = 0, o = !0, l = -1, a = -1, c = !1, h = () => {
    r.push(t.elt("TableCell", i + l, i + a, t.parser.parseInline(e.slice(l, a), i + l)));
  };
  for (let u = n; u < e.length; u++) {
    let f = e.charCodeAt(u);
    f == 124 && !c ? ((!o || l > -1) && s++, o = !1, r && (l > -1 && h(), r.push(t.elt("TableDelimiter", u + i, u + i + 1))), l = a = -1) : (c || f != 32 && f != 9) && (l < 0 && (l = u), a = u + 1), c = !c && f == 92;
  }
  return l > -1 && (s++, r && h()), s;
}
function bb(t, e) {
  for (let n = e; n < t.length; n++) {
    let r = t.charCodeAt(n);
    if (r == 124)
      return !0;
    r == 92 && n++;
  }
  return !1;
}
const G_ = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class yb {
  constructor() {
    this.rows = null;
  }
  nextLine(e, n, r) {
    if (this.rows == null) {
      this.rows = !1;
      let i;
      if ((n.next == 45 || n.next == 58 || n.next == 124) && G_.test(i = n.text.slice(n.pos))) {
        let s = [];
        Yo(e, r.content, 0, s, r.start) == Yo(e, i, n.pos) && (this.rows = [
          e.elt("TableHeader", r.start, r.start + r.content.length, s),
          e.elt("TableDelimiter", e.lineStart + n.pos, e.lineStart + n.text.length)
        ]);
      }
    } else if (this.rows) {
      let i = [];
      Yo(e, n.text, n.pos, i, e.lineStart), this.rows.push(e.elt("TableRow", e.lineStart + n.pos, e.lineStart + n.text.length, i));
    }
    return !1;
  }
  finish(e, n) {
    return this.rows ? (e.addLeafElement(n, e.elt("Table", n.start, n.start + n.content.length, this.rows)), !0) : !1;
  }
}
const d3 = {
  defineNodes: [
    { name: "Table", block: !0 },
    { name: "TableHeader", style: { "TableHeader/...": k.heading } },
    "TableRow",
    { name: "TableCell", style: k.content },
    { name: "TableDelimiter", style: k.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(t, e) {
      return bb(e.content, 0) ? new yb() : null;
    },
    endLeaf(t, e, n) {
      if (n.parsers.some((i) => i instanceof yb) || !bb(e.text, e.basePos))
        return !1;
      let r = t.scanLine(t.absoluteLineEnd + 1).text;
      return G_.test(r) && Yo(t, e.text, e.basePos) == Yo(t, r, e.basePos);
    },
    before: "SetextHeading"
  }]
};
class p3 {
  nextLine() {
    return !1;
  }
  finish(e, n) {
    return e.addLeafElement(n, e.elt("Task", n.start, n.start + n.content.length, [
      e.elt("TaskMarker", n.start, n.start + 3),
      ...e.parser.parseInline(n.content.slice(3), n.start + 3)
    ])), !0;
  }
}
const g3 = {
  defineNodes: [
    { name: "Task", block: !0, style: k.list },
    { name: "TaskMarker", style: k.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(t, e) {
      return /^\[[ xX]\][ \t]/.test(e.content) && t.parentType().name == "ListItem" ? new p3() : null;
    },
    after: "SetextHeading"
  }]
}, wb = /(www\.)|(https?:\/\/)|([\w.+-]+@)|(mailto:|xmpp:)/gy, kb = /[\w-]+(\.[\w-]+)+(\/[^\s<]*)?/gy, m3 = /[\w-]+\.[\w-]+($|\/)/, xb = /[\w.+-]+@[\w-]+(\.[\w.-]+)+/gy, vb = /\/[a-zA-Z\d@.]+/gy;
function Sb(t, e, n, r) {
  let i = 0;
  for (let s = e; s < n; s++)
    t[s] == r && i++;
  return i;
}
function O3(t, e) {
  kb.lastIndex = e;
  let n = kb.exec(t);
  if (!n || m3.exec(n[0])[0].indexOf("_") > -1)
    return -1;
  let r = e + n[0].length;
  for (; ; ) {
    let i = t[r - 1], s;
    if (/[?!.,:*_~]/.test(i) || i == ")" && Sb(t, e, r, ")") > Sb(t, e, r, "("))
      r--;
    else if (i == ";" && (s = /&(?:#\d+|#x[a-f\d]+|\w+);$/.exec(t.slice(e, r))))
      r = e + s.index;
    else
      break;
  }
  return r;
}
function _b(t, e) {
  xb.lastIndex = e;
  let n = xb.exec(t);
  if (!n)
    return -1;
  let r = n[0][n[0].length - 1];
  return r == "_" || r == "-" ? -1 : e + n[0].length - (r == "." ? 1 : 0);
}
const b3 = {
  parseInline: [{
    name: "Autolink",
    parse(t, e, n) {
      let r = n - t.offset;
      wb.lastIndex = r;
      let i = wb.exec(t.text), s = -1;
      return !i || (i[1] || i[2] ? s = O3(t.text, r + i[0].length) : i[3] ? s = _b(t.text, r) : (s = _b(t.text, r + i[0].length), s > -1 && i[0] == "xmpp:" && (vb.lastIndex = s, i = vb.exec(t.text), i && (s = i.index + i[0].length))), s < 0) ? -1 : (t.addElement(t.elt("URL", n, s + t.offset)), s + t.offset);
    }
  }]
}, y3 = [d3, g3, f3, b3];
function H_(t, e, n) {
  return (r, i, s) => {
    if (i != t || r.char(s + 1) == t)
      return -1;
    let o = [r.elt(n, s, s + 1)];
    for (let l = s + 1; l < r.end; l++) {
      let a = r.char(l);
      if (a == t)
        return r.addElement(r.elt(e, s, l + 1, o.concat(r.elt(n, l, l + 1))));
      if (a == 92 && o.push(r.elt("Escape", l, l++ + 2)), nn(a))
        break;
    }
    return -1;
  };
}
const w3 = {
  defineNodes: [
    { name: "Superscript", style: k.special(k.content) },
    { name: "SuperscriptMark", style: k.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: H_(94, "Superscript", "SuperscriptMark")
  }]
}, k3 = {
  defineNodes: [
    { name: "Subscript", style: k.special(k.content) },
    { name: "SubscriptMark", style: k.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: H_(126, "Subscript", "SubscriptMark")
  }]
}, x3 = {
  defineNodes: [{ name: "Emoji", style: k.character }],
  parseInline: [{
    name: "Emoji",
    parse(t, e, n) {
      let r;
      return e != 58 || !(r = /^[a-zA-Z_0-9]+:/.exec(t.slice(n + 1, t.end))) ? -1 : t.addElement(t.elt("Emoji", n, n + 1 + r[0].length));
    }
  }]
};
class ch {
  constructor(e, n, r, i, s, o, l, a, c, h = 0, u) {
    this.p = e, this.stack = n, this.state = r, this.reducePos = i, this.pos = s, this.score = o, this.buffer = l, this.bufferBase = a, this.curContext = c, this.lookAhead = h, this.parent = u;
  }
  toString() {
    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(e, n, r = 0) {
    let i = e.parser.context;
    return new ch(e, [], n, r, r, 0, [], 0, i ? new Cb(i, i.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(e, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;
  }
  reduce(e) {
    var n;
    let r = e >> 19, i = e & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(i);
    if (o && (this.score += o), r == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let l = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), a = l ? this.stack[l - 2] : this.p.ranges[0].from, c = this.reducePos - a;
    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (a == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = a, this.p.lastBigReductionSize = c));
    let h = l ? this.stack[l - 1] : 0, u = this.bufferBase + this.buffer.length - h;
    if (i < s.minRepeatTerm || e & 131072) {
      let f = s.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, a, f, u + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[l];
    else {
      let f = this.stack[l - 3];
      this.state = s.getGoto(f, i, !0);
    }
    for (; this.stack.length > l; )
      this.stack.pop();
    this.reduceContext(i, a);
  }
  storeNode(e, n, r, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, l = this.buffer.length;
      if (l == 0 && o.parent && (l = o.bufferBase - o.parent.bufferBase, o = o.parent), l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1) {
        if (n == r)
          return;
        if (o.buffer[l - 2] >= n) {
          o.buffer[l - 2] = r;
          return;
        }
      }
    }
    if (!s || this.pos == r)
      this.buffer.push(e, n, r, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > r; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, i > 4 && (i -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = n, this.buffer[o + 2] = r, this.buffer[o + 3] = i;
    }
  }
  shift(e, n, r, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if ((e & 262144) == 0) {
      let s = e, { parser: o } = this.p;
      (i > this.pos || n <= o.maxNode) && (this.pos = i, o.stateFlag(s, 1) || (this.reducePos = i)), this.pushState(s, r), this.shiftContext(n, r), n <= o.maxNode && this.buffer.push(n, r, i, 4);
    } else
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
  }
  apply(e, n, r, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);
  }
  useNode(e, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(n, i), this.buffer.push(r, i, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  split() {
    let e = this, n = e.buffer.length;
    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )
      n -= 4;
    let r = e.buffer.slice(n), i = e.bufferBase + n;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new ch(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);
  }
  recoverByDelete(e, n) {
    let r = e <= this.p.parser.maxNode;
    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  canShift(e) {
    for (let n = new v3(this); ; ) {
      let r = this.p.parser.stateSlot(n.state, 4) || this.p.parser.hasAction(n.state, e);
      if (r == 0)
        return !1;
      if ((r & 65536) == 0)
        return !0;
      n.reduce(r);
    }
  }
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 4 << 1 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < n.length; s += 2)
        (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(n[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 4 << 1 && s < n.length; s += 2) {
          let o = n[s + 1];
          i.some((l, a) => a & 1 && l == o) || i.push(n[s], o);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let s = n[i + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(n[i], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);
    }
    return r;
  }
  forceReduce() {
    let { parser: e } = this.p, n = e.stateSlot(this.state, 5);
    if ((n & 65536) == 0)
      return !1;
    if (!e.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, s = this.stack.length - r * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        n = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  findForcedReduction() {
    let { parser: e } = this.p, n = [], r = (i, s) => {
      if (!n.includes(i))
        return n.push(i), e.allActions(i, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let l = (o >> 19) - s;
              if (l > 1) {
                let a = o & 65535, c = this.stack.length - l * 3;
                if (c >= 0 && e.getGoto(this.stack[c], a, !1) >= 0)
                  return l << 19 | 65536 | a;
              }
            } else {
              let l = r(o, s + 1);
              if (l != null)
                return l;
            }
        });
    };
    return r(this.state, 0);
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(this.state, 1)] == 65535 && !e.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != e.stack[n])
        return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  reduceContext(e, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));
  }
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let n = new Cb(this.curContext.tracker, e);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class Cb {
  constructor(e, n) {
    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;
  }
}
class v3 {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let n = e & 65535, r = e >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class hh {
  constructor(e, n, r) {
    this.stack = e, this.pos = n, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, n = e.bufferBase + e.buffer.length) {
    return new hh(e, n, n - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new hh(this.stack, this.pos, this.index);
  }
}
function $o(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let n = null;
  for (let r = 0, i = 0; r < t.length; ) {
    let s = 0;
    for (; ; ) {
      let o = t.charCodeAt(r++), l = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let a = o - 32;
      if (a >= 46 && (a -= 46, l = !0), s += a, l)
        break;
      s *= 46;
    }
    n ? n[i++] = s : n = new e(s);
  }
  return n;
}
class kc {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Ab = new kc();
class S3 {
  constructor(e, n) {
    this.input = e, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Ab, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  resolveOffset(e, n) {
    let r = this.range, i = this.rangeIndex, s = this.pos + e;
    for (; s < r.from; ) {
      if (!i)
        return null;
      let o = this.ranges[--i];
      s -= r.from - o.to, r = o;
    }
    for (; n < 0 ? s > r.to : s >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let o = this.ranges[++i];
      s += o.from - r.to, r = o;
    }
    return s;
  }
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let n of this.ranges)
      if (n.to > e)
        return Math.max(e, n.from);
    return this.end;
  }
  peek(e) {
    let n = this.chunkOff + e, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + e, i = this.chunk.charCodeAt(n);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (r = s, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let o = this.rangeIndex, l = this.range;
        for (; l.to <= r; )
          l = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  acceptToken(e, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), n = this.pos + e.length;
      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  reset(e, n) {
    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = Ab, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  read(e, n) {
    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);
    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);
    if (e >= this.range.from && n <= this.range.to)
      return this.input.read(e, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));
    }
    return r;
  }
}
class fs {
  constructor(e, n) {
    this.data = e, this.id = n;
  }
  token(e, n) {
    let { parser: r } = n.p;
    J_(this.data, e, n, this.id, r.data, r.tokenPrecTable);
  }
}
fs.prototype.contextual = fs.prototype.fallback = fs.prototype.extend = !1;
class uh {
  constructor(e, n, r) {
    this.precTable = n, this.elseToken = r, this.data = typeof e == "string" ? $o(e) : e;
  }
  token(e, n) {
    let r = e.pos, i = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (J_(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || i++, o == null)
        break;
      e.reset(o, e.token);
    }
    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));
  }
}
uh.prototype.contextual = fs.prototype.fallback = fs.prototype.extend = !1;
class xn {
  constructor(e, n = {}) {
    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;
  }
}
function J_(t, e, n, r, i, s) {
  let o = 0, l = 1 << r, { dialect: a } = n.p.parser;
  e:
    for (; (l & t[o]) != 0; ) {
      let c = t[o + 1];
      for (let d = o + 3; d < c; d += 2)
        if ((t[d + 1] & l) > 0) {
          let p = t[d];
          if (a.allows(p) && (e.token.value == -1 || e.token.value == p || _3(p, e.token.value, i, s))) {
            e.acceptToken(p);
            break;
          }
        }
      let h = e.next, u = 0, f = t[o + 2];
      if (e.next < 0 && f > u && t[c + f * 3 - 3] == 65535) {
        o = t[c + f * 3 - 1];
        continue e;
      }
      for (; u < f; ) {
        let d = u + f >> 1, p = c + d + (d << 1), g = t[p], m = t[p + 1] || 65536;
        if (h < g)
          f = d;
        else if (h >= m)
          u = d + 1;
        else {
          o = t[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function $b(t, e, n) {
  for (let r = e, i; (i = t[r]) != 65535; r++)
    if (i == n)
      return r - e;
  return -1;
}
function _3(t, e, n, r) {
  let i = $b(n, r, e);
  return i < 0 || $b(n, r, t) < i;
}
const Dt = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let Of = null;
function Pb(t, e, n) {
  let r = t.cursor(ve.IncludeAnonymous);
  for (r.moveTo(e); ; )
    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))
      for (; ; ) {
        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(r.to - 1, e - 25)) : Math.min(t.length, Math.max(r.from + 1, e + 25));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : t.length;
      }
}
class C3 {
  constructor(e, n) {
    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Pb(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Pb(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = r.children[i], o = this.start[n] + r.positions[i];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof pe) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let l = o + s.length;
          if (l <= this.safeTo) {
            let a = s.prop(K.lookAhead);
            if (!a || l + a < this.fragment.to)
              return s;
          }
        }
        this.index[n]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = o + s.length;
    }
  }
}
class A3 {
  constructor(e, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new kc());
  }
  getActions(e) {
    let n = 0, r = null, { parser: i } = e.p, { tokenizers: s } = i, o = i.stateSlot(e.state, 3), l = e.curContext ? e.curContext.hash : 0, a = 0;
    for (let c = 0; c < s.length; c++) {
      if ((1 << c & o) == 0)
        continue;
      let h = s[c], u = this.tokens[c];
      if (!(r && !h.fallback) && ((h.contextual || u.start != e.pos || u.mask != o || u.context != l) && (this.updateCachedToken(u, h, e), u.mask = o, u.context = l), u.lookAhead > u.end + 25 && (a = Math.max(u.lookAhead, a)), u.value != 0)) {
        let f = n;
        if (u.extended > -1 && (n = this.addActions(e, u.extended, u.end, n)), n = this.addActions(e, u.value, u.end, n), !h.extend && (r = u, n > f))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return a && e.setLookAhead(a), !r && e.pos == this.stream.end && (r = new kc(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, n = this.addActions(e, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let n = new kc(), { pos: r, p: i } = e;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(e, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, e), r), e.value > -1) {
      let { parser: s } = r.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let l = s.specializers[o](this.stream.read(e.start, e.end), r);
          if (l >= 0 && r.p.parser.dialect.allows(l >> 1)) {
            (l & 1) == 0 ? e.value = l >> 1 : e.extended = l >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, n, r, i) {
    for (let s = 0; s < i; s += 3)
      if (this.actions[s] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(e, n, r, i) {
    let { state: s } = e, { parser: o } = e.p, { data: l } = o;
    for (let a = 0; a < 2; a++)
      for (let c = o.stateSlot(s, a ? 2 : 1); ; c += 3) {
        if (l[c] == 65535)
          if (l[c + 1] == 1)
            c = nr(l, c + 2);
          else {
            i == 0 && l[c + 1] == 2 && (i = this.putAction(nr(l, c + 2), n, r, i));
            break;
          }
        l[c] == n && (i = this.putAction(nr(l, c + 1), n, r, i));
      }
    return i;
  }
}
class $3 {
  constructor(e, n, r, i) {
    this.parser = e, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new S3(n, i), this.tokens = new A3(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = i[0];
    this.stacks = [ch.start(this, e.top[0], s)], this.fragments = r.length && this.stream.end - s > e.bufferLength * 4 ? new C3(r, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let e = this.stacks, n = this.minStackPos, r = this.stacks = [], i, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > n)
          r.push(l);
        else {
          if (this.advanceStack(l, r, e))
            continue;
          {
            i || (i = [], s = []), i.push(l);
            let a = this.tokens.getMainToken(l);
            s.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let o = i && T3(i);
      if (o)
        return Dt && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw Dt && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, r);
      if (o)
        return Dt && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > o)
        for (r.sort((l, a) => a.score - l.score); r.length > o; )
          r.pop();
      r.some((l) => l.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e:
        for (let o = 0; o < r.length - 1; o++) {
          let l = r[o];
          for (let a = o + 1; a < r.length; a++) {
            let c = r[a];
            if (l.sameState(c) || l.buffer.length > 500 && c.buffer.length > 500)
              if ((l.score - c.score || l.buffer.length - c.buffer.length) > 0)
                r.splice(a--, 1);
              else {
                r.splice(o--, 1);
                continue e;
              }
          }
        }
      r.length > 12 && r.splice(12, r.length - 12);
    }
    this.minStackPos = r[0].pos;
    for (let o = 1; o < r.length; o++)
      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  advanceStack(e, n, r) {
    let i = e.pos, { parser: s } = this, o = Dt ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, h = c ? e.curContext.hash : 0;
      for (let u = this.fragments.nodeAt(i); u; ) {
        let f = this.parser.nodeSet.types[u.type.id] == u.type ? s.getGoto(e.state, u.type.id) : -1;
        if (f > -1 && u.length && (!c || (u.prop(K.contextHash) || 0) == h))
          return e.useNode(u, f), Dt && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(u.type.id)})`), !0;
        if (!(u instanceof pe) || u.children.length == 0 || u.positions[0] > 0)
          break;
        let d = u.children[0];
        if (d instanceof pe && u.positions[0] == 0)
          u = d;
        else
          break;
      }
    }
    let l = s.stateSlot(e.state, 4);
    if (l > 0)
      return e.reduce(l), Dt && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(l & 65535)})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let a = this.tokens.getActions(e);
    for (let c = 0; c < a.length; ) {
      let h = a[c++], u = a[c++], f = a[c++], d = c == a.length || !r, p = d ? e : e.split(), g = this.tokens.mainToken;
      if (p.apply(h, u, g ? g.start : p.pos, f), Dt && console.log(o + this.stackID(p) + ` (via ${(h & 65536) == 0 ? "shift" : `reduce of ${s.getName(h & 65535)}`} for ${s.getName(u)} @ ${i}${p == e ? "" : ", split"})`), d)
        return !0;
      p.pos > i ? n.push(p) : r.push(p);
    }
    return !1;
  }
  advanceFully(e, n) {
    let r = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > r)
        return Tb(e, n), !0;
    }
  }
  runRecovery(e, n, r) {
    let i = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o], a = n[o << 1], c = n[(o << 1) + 1], h = Dt ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (s || (s = !0, l.restart(), Dt && console.log(h + this.stackID(l) + " (restarted)"), this.advanceFully(l, r))))
        continue;
      let u = l.split(), f = h;
      for (let d = 0; u.forceReduce() && d < 10 && (Dt && console.log(f + this.stackID(u) + " (via force-reduce)"), !this.advanceFully(u, r)); d++)
        Dt && (f = this.stackID(u) + " -> ");
      for (let d of l.recoverByInsert(a))
        Dt && console.log(h + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, r);
      this.stream.end > l.pos ? (c == l.pos && (c++, a = 0), l.recoverByDelete(a, c), Dt && console.log(h + this.stackID(l) + ` (via recover-delete ${this.parser.getName(a)})`), Tb(l, r)) : (!i || i.score < l.score) && (i = l);
    }
    return i;
  }
  stackToTree(e) {
    return e.close(), pe.build({
      buffer: hh.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let n = (Of || (Of = /* @__PURE__ */ new WeakMap())).get(e);
    return n || Of.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;
  }
}
function Tb(t, e) {
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    if (r.pos == t.pos && r.sameState(t)) {
      e[n].score < t.score && (e[n] = t);
      return;
    }
  }
  e.push(t);
}
class P3 {
  constructor(e, n, r) {
    this.source = e, this.flags = n, this.disabled = r;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const bf = (t) => t;
class K_ {
  constructor(e) {
    this.start = e.start, this.shift = e.shift || bf, this.reduce = e.reduce || bf, this.reuse = e.reuse || bf, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Zs extends Pg {
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (${14})`);
    let n = e.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let l = 0; l < e.repeatNodeCount; l++)
      n.push("");
    let r = Object.keys(e.topRules).map((l) => e.topRules[l][1]), i = [];
    for (let l = 0; l < n.length; l++)
      i.push([]);
    function s(l, a, c) {
      i[l].push([a, a.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let l of e.nodeProps) {
        let a = l[0];
        typeof a == "string" && (a = K[a]);
        for (let c = 1; c < l.length; ) {
          let h = l[c++];
          if (h >= 0)
            s(h, a, l[c++]);
          else {
            let u = l[c + -h];
            for (let f = -h; f > 0; f--)
              s(l[c++], a, u);
            c++;
          }
        }
      }
    this.nodeSet = new ql(n.map((l, a) => Ve.define({
      name: a >= this.minRepeatTerm ? void 0 : l,
      id: a,
      props: i[a],
      top: r.indexOf(a) > -1,
      error: a == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Gx;
    let o = $o(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(Qb), this.states = $o(e.states, Uint32Array), this.data = $o(e.stateData), this.goto = $o(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((l) => typeof l == "number" ? new fs(o, l) : l), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, n, r) {
    let i = new $3(this, e, n, r);
    for (let s of this.wrappers)
      i = s(i, e, n, r);
    return i;
  }
  getGoto(e, n, r = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let s = i[n + 1]; ; ) {
      let o = i[s++], l = o & 1, a = i[s++];
      if (l && r)
        return a;
      for (let c = s + (o >> 1); s < c; s++)
        if (i[s] == e)
          return a;
      if (l)
        return -1;
    }
  }
  hasAction(e, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(e, i ? 2 : 1), o; ; s += 3) {
        if ((o = r[s]) == 65535)
          if (r[s + 1] == 1)
            o = r[s = nr(r, s + 2)];
          else {
            if (r[s + 1] == 2)
              return nr(r, s + 2);
            break;
          }
        if (o == n || o == 0)
          return nr(r, s + 1);
      }
    return 0;
  }
  stateSlot(e, n) {
    return this.states[e * 6 + n];
  }
  stateFlag(e, n) {
    return (this.stateSlot(e, 0) & n) > 0;
  }
  validAction(e, n) {
    return !!this.allActions(e, (r) => r == n ? !0 : null);
  }
  allActions(e, n) {
    let r = this.stateSlot(e, 4), i = r ? n(r) : void 0;
    for (let s = this.stateSlot(e, 1); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = nr(this.data, s + 2);
        else
          break;
      i = n(nr(this.data, s + 1));
    }
    return i;
  }
  nextStates(e) {
    let n = [];
    for (let r = this.stateSlot(e, 1); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = nr(this.data, r + 2);
        else
          break;
      if ((this.data[r + 2] & 1) == 0) {
        let i = this.data[r + 1];
        n.some((s, o) => o & 1 && s == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  configure(e) {
    let n = Object.assign(Object.create(Zs.prototype), this);
    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let r = this.topRules[e.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      n.top = r;
    }
    return e.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = e.tokenizers.find((s) => s.from == r);
      return i ? i.to : r;
    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let s = e.specializers.find((l) => l.from == r.external);
      if (!s)
        return r;
      let o = Object.assign(Object.assign({}, r), { external: s.to });
      return n.specializers[i] = Qb(o), o;
    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(e) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[e] || 0;
  }
  parseDialect(e) {
    let n = Object.keys(this.dialects), r = n.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = n.indexOf(s);
        o >= 0 && (r[o] = !0);
      }
    let i = null;
    for (let s = 0; s < n.length; s++)
      if (!r[s])
        for (let o = this.dialects[n[s]], l; (l = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new P3(e, r, i);
  }
  static deserialize(e) {
    return new Zs(e);
  }
}
function nr(t, e) {
  return t[e] | t[e + 1] << 16;
}
function T3(t) {
  let e = null;
  for (let n of t) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(n.state, 2) && (!e || e.score < n.score) && (e = n);
  }
  return e;
}
function Qb(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (n, r) => t.external(n, r) << 1 | e;
  }
  return t.get;
}
const Q3 = 54, E3 = 1, D3 = 55, M3 = 2, R3 = 56, Z3 = 3, Eb = 4, I3 = 5, fh = 6, eC = 7, tC = 8, nC = 9, rC = 10, L3 = 11, N3 = 12, q3 = 13, yf = 57, B3 = 14, Db = 58, iC = 20, Y3 = 22, sC = 23, j3 = 24, Qp = 26, oC = 27, X3 = 28, W3 = 31, z3 = 34, V3 = 36, U3 = 37, F3 = 0, G3 = 1, H3 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, J3 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Mb = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function K3(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function lC(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let Rb = null, Zb = null, Ib = 0;
function Ep(t, e) {
  let n = t.pos + e;
  if (Ib == n && Zb == t)
    return Rb;
  let r = t.peek(e);
  for (; lC(r); )
    r = t.peek(++e);
  let i = "";
  for (; K3(r); )
    i += String.fromCharCode(r), r = t.peek(++e);
  return Zb = t, Ib = n, Rb = i ? i.toLowerCase() : r == eN || r == tN ? void 0 : null;
}
const aC = 60, dh = 62, km = 47, eN = 63, tN = 33, nN = 45;
function Lb(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let n = 0; n < t.length; n++)
    this.hash += (this.hash << 4) + t.charCodeAt(n) + (t.charCodeAt(n) << 8);
}
const rN = [fh, rC, eC, tC, nC], iN = new K_({
  start: null,
  shift(t, e, n, r) {
    return rN.indexOf(e) > -1 ? new Lb(Ep(r, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == iC && t ? t.parent : t;
  },
  reuse(t, e, n, r) {
    let i = e.type.id;
    return i == fh || i == V3 ? new Lb(Ep(r, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: !1
}), sN = new xn((t, e) => {
  if (t.next != aC) {
    t.next < 0 && e.context && t.acceptToken(yf);
    return;
  }
  t.advance();
  let n = t.next == km;
  n && t.advance();
  let r = Ep(t, 0);
  if (r === void 0)
    return;
  if (!r)
    return t.acceptToken(n ? B3 : fh);
  let i = e.context ? e.context.name : null;
  if (n) {
    if (r == i)
      return t.acceptToken(L3);
    if (i && J3[i])
      return t.acceptToken(yf, -2);
    if (e.dialectEnabled(F3))
      return t.acceptToken(N3);
    for (let s = e.context; s; s = s.parent)
      if (s.name == r)
        return;
    t.acceptToken(q3);
  } else {
    if (r == "script")
      return t.acceptToken(eC);
    if (r == "style")
      return t.acceptToken(tC);
    if (r == "textarea")
      return t.acceptToken(nC);
    if (H3.hasOwnProperty(r))
      return t.acceptToken(rC);
    i && Mb[i] && Mb[i][r] ? t.acceptToken(yf, -1) : t.acceptToken(fh);
  }
}, { contextual: !0 }), oN = new xn((t) => {
  for (let e = 0, n = 0; ; n++) {
    if (t.next < 0) {
      n && t.acceptToken(Db);
      break;
    }
    if (t.next == nN)
      e++;
    else if (t.next == dh && e >= 2) {
      n >= 3 && t.acceptToken(Db, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function lN(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return !0;
  return !1;
}
const aN = new xn((t, e) => {
  if (t.next == km && t.peek(1) == dh) {
    let n = e.dialectEnabled(G3) || lN(e.context);
    t.acceptToken(n ? I3 : Eb, 2);
  } else
    t.next == dh && t.acceptToken(Eb, 1);
});
function xm(t, e, n) {
  let r = 2 + t.length;
  return new xn((i) => {
    for (let s = 0, o = 0, l = 0; ; l++) {
      if (i.next < 0) {
        l && i.acceptToken(e);
        break;
      }
      if (s == 0 && i.next == aC || s == 1 && i.next == km || s >= 2 && s < r && i.next == t.charCodeAt(s - 2))
        s++, o++;
      else if ((s == 2 || s == r) && lC(i.next))
        o++;
      else if (s == r && i.next == dh) {
        l > o ? i.acceptToken(e, -o) : i.acceptToken(n, -(o - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && l) {
        i.acceptToken(e, 1);
        break;
      } else
        s = o = 0;
      i.advance();
    }
  });
}
const cN = xm("script", Q3, E3), hN = xm("style", D3, M3), uN = xm("textarea", R3, Z3), fN = Ws({
  "Text RawText": k.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": k.angleBracket,
  TagName: k.tagName,
  "MismatchedCloseTag/TagName": [k.tagName, k.invalid],
  AttributeName: k.attributeName,
  "AttributeValue UnquotedAttributeValue": k.attributeValue,
  Is: k.definitionOperator,
  "EntityReference CharacterReference": k.character,
  Comment: k.blockComment,
  ProcessingInst: k.processingInstruction,
  DoctypeDecl: k.documentMeta
}), dN = Zs.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: iN,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [fN],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [cN, hN, uN, aN, sN, oN, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function cC(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r of t.getChildren(sC)) {
    let i = r.getChild(j3), s = r.getChild(Qp) || r.getChild(oC);
    i && (n[e.read(i.from, i.to)] = s ? s.type.id == Qp ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return n;
}
function Nb(t, e) {
  let n = t.getChild(Y3);
  return n ? e.read(n.from, n.to) : " ";
}
function wf(t, e, n) {
  let r;
  for (let i of n)
    if (!i.attrs || i.attrs(r || (r = cC(t.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function hC(t = [], e = []) {
  let n = [], r = [], i = [], s = [];
  for (let l of t)
    (l.tag == "script" ? n : l.tag == "style" ? r : l.tag == "textarea" ? i : s).push(l);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let l of e)
    (o[l.name] || (o[l.name] = [])).push(l);
  return tv((l, a) => {
    let c = l.type.id;
    if (c == X3)
      return wf(l, a, n);
    if (c == W3)
      return wf(l, a, r);
    if (c == z3)
      return wf(l, a, i);
    if (c == iC && s.length) {
      let h = l.node, u = h.firstChild, f = u && Nb(u, a), d;
      if (f) {
        for (let p of s)
          if (p.tag == f && (!p.attrs || p.attrs(d || (d = cC(h, a))))) {
            let g = h.lastChild, m = g.type.id == U3 ? g.from : h.to;
            if (m > u.to)
              return { parser: p.parser, overlay: [{ from: u.to, to: m }] };
          }
      }
    }
    if (o && c == sC) {
      let h = l.node, u;
      if (u = h.firstChild) {
        let f = o[a.read(u.from, u.to)];
        if (f)
          for (let d of f) {
            if (d.tagName && d.tagName != Nb(h.parent, a))
              continue;
            let p = h.lastChild;
            if (p.type.id == Qp) {
              let g = p.from + 1, m = p.lastChild, O = p.to - (m && m.isError ? 0 : 1);
              if (O > g)
                return { parser: d.parser, overlay: [{ from: g, to: O }] };
            } else if (p.type.id == oC)
              return { parser: d.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const pN = 96, qb = 1, gN = 97, mN = 98, Bb = 2, uC = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ON = 58, bN = 40, fC = 95, yN = 91, xc = 45, wN = 46, kN = 35, xN = 37, vN = 38, SN = 92, _N = 10;
function ph(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function CN(t) {
  return t >= 48 && t <= 57;
}
const AN = new xn((t, e) => {
  for (let n = !1, r = 0, i = 0; ; i++) {
    let { next: s } = t;
    if (ph(s) || s == xc || s == fC || n && CN(s))
      !n && (s != xc || i > 0) && (n = !0), r === i && s == xc && r++, t.advance();
    else if (s == SN && t.peek(1) != _N)
      t.advance(), t.next > -1 && t.advance(), n = !0;
    else {
      n && t.acceptToken(s == bN ? gN : r == 2 && e.canShift(Bb) ? Bb : mN);
      break;
    }
  }
}), $N = new xn((t) => {
  if (uC.includes(t.peek(-1))) {
    let { next: e } = t;
    (ph(e) || e == fC || e == kN || e == wN || e == yN || e == ON || e == xc || e == vN) && t.acceptToken(pN);
  }
}), PN = new xn((t) => {
  if (!uC.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == xN && (t.advance(), t.acceptToken(qb)), ph(e)) {
      do
        t.advance();
      while (ph(t.next));
      t.acceptToken(qb);
    }
  }
}), TN = Ws({
  "AtKeyword import charset namespace keyframes media supports": k.definitionKeyword,
  "from to selector": k.keyword,
  NamespaceName: k.namespace,
  KeyframeName: k.labelName,
  KeyframeRangeName: k.operatorKeyword,
  TagName: k.tagName,
  ClassName: k.className,
  PseudoClassName: k.constant(k.className),
  IdName: k.labelName,
  "FeatureName PropertyName": k.propertyName,
  AttributeName: k.attributeName,
  NumberLiteral: k.number,
  KeywordQuery: k.keyword,
  UnaryQueryOp: k.operatorKeyword,
  "CallTag ValueName": k.atom,
  VariableName: k.variableName,
  Callee: k.operatorKeyword,
  Unit: k.unit,
  "UniversalSelector NestingSelector": k.definitionOperator,
  MatchOp: k.compareOperator,
  "ChildOp SiblingOp, LogicOp": k.logicOperator,
  BinOp: k.arithmeticOperator,
  Important: k.modifier,
  Comment: k.blockComment,
  ColorLiteral: k.color,
  "ParenthesizedContent StringLiteral": k.string,
  ":": k.punctuation,
  "PseudoOp #": k.derefOperator,
  "; ,": k.separator,
  "( )": k.paren,
  "[ ]": k.squareBracket,
  "{ }": k.brace
}), QN = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, EN = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, DN = { __proto__: null, not: 128, only: 128 }, MN = Zs.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [TN],
  skippedNodes: [0, 3, 85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [$N, PN, AN, 1, 2, 3, 4, new uh("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 97, get: (t) => QN[t] || -1 }, { term: 56, get: (t) => EN[t] || -1 }, { term: 98, get: (t) => DN[t] || -1 }],
  tokenPrec: 1169
});
let kf = null;
function xf() {
  if (!kf && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], n = /* @__PURE__ */ new Set();
    for (let r in t)
      r != "cssText" && r != "cssFloat" && typeof t[r] == "string" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), n.has(r) || (e.push(r), n.add(r)));
    kf = e.sort().map((r) => ({ type: "property", label: r }));
  }
  return kf || [];
}
const Yb = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), jb = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), RN = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), wr = /^(\w[\w-]*|-\w[\w-]*|)$/, ZN = /^-(-[\w-]*)?$/;
function IN(t, e) {
  var n;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let r = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;
  return (r == null ? void 0 : r.name) != "Callee" ? !1 : e.sliceString(r.from, r.to) == "var";
}
const Xb = /* @__PURE__ */ new ev(), LN = ["Declaration"];
function NN(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function dC(t, e, n) {
  if (e.to - e.from > 4096) {
    let r = Xb.get(e);
    if (r)
      return r;
    let i = [], s = /* @__PURE__ */ new Set(), o = e.cursor(ve.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let l of dC(t, o.node, n))
          s.has(l.label) || (s.add(l.label), i.push(l));
      while (o.nextSibling());
    return Xb.set(e, i), i;
  } else {
    let r = [], i = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var o;
      if (n(s) && s.matchContext(LN) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let l = t.sliceString(s.from, s.to);
        i.has(l) || (i.add(l), r.push({ label: l, type: "variable" }));
      }
    }), r;
  }
}
const qN = (t) => (e) => {
  let { state: n, pos: r } = e, i = Se(n).resolveInner(r, -1), s = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (s || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: xf(), validFor: wr };
  if (i.name == "ValueName")
    return { from: i.from, options: jb, validFor: wr };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: Yb, validFor: wr };
  if (t(i) || (e.explicit || s) && IN(i, n.doc))
    return {
      from: t(i) || s ? i.from : r,
      options: dC(n.doc, NN(i), t),
      validFor: ZN
    };
  if (i.name == "TagName") {
    for (let { parent: a } = i; a; a = a.parent)
      if (a.name == "Block")
        return { from: i.from, options: xf(), validFor: wr };
    return { from: i.from, options: RN, validFor: wr };
  }
  if (!e.explicit)
    return null;
  let o = i.resolve(r), l = o.childBefore(r);
  return l && l.name == ":" && o.name == "PseudoClassSelector" ? { from: r, options: Yb, validFor: wr } : l && l.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: r, options: jb, validFor: wr } : o.name == "Block" || o.name == "Styles" ? { from: r, options: xf(), validFor: wr } : null;
}, BN = /* @__PURE__ */ qN((t) => t.name == "VariableName"), gh = /* @__PURE__ */ Cs.define({
  name: "css",
  parser: /* @__PURE__ */ MN.configure({
    props: [
      /* @__PURE__ */ Yl.add({
        Declaration: /* @__PURE__ */ gc()
      }),
      /* @__PURE__ */ zs.add({
        "Block KeyframeList": av
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function YN() {
  return new al(gh, gh.data.of({ autocomplete: BN }));
}
const jN = 309, Wb = 1, XN = 2, WN = 3, zN = 310, VN = 312, UN = 313, FN = 4, GN = 5, HN = 0, Dp = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], pC = 125, JN = 59, Mp = 47, KN = 42, e7 = 43, t7 = 45, n7 = 60, r7 = 44, i7 = new K_({
  start: !1,
  shift(t, e) {
    return e == FN || e == GN || e == VN ? t : e == UN;
  },
  strict: !1
}), s7 = new xn((t, e) => {
  let { next: n } = t;
  (n == pC || n == -1 || e.context) && t.acceptToken(zN);
}, { contextual: !0, fallback: !0 }), o7 = new xn((t, e) => {
  let { next: n } = t, r;
  Dp.indexOf(n) > -1 || n == Mp && ((r = t.peek(1)) == Mp || r == KN) || n != pC && n != JN && n != -1 && !e.context && t.acceptToken(jN);
}, { contextual: !0 }), l7 = new xn((t, e) => {
  let { next: n } = t;
  if ((n == e7 || n == t7) && (t.advance(), n == t.next)) {
    t.advance();
    let r = !e.context && e.canShift(Wb);
    t.acceptToken(r ? Wb : XN);
  }
}, { contextual: !0 });
function vf(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const a7 = new xn((t, e) => {
  if (t.next != n7 || !e.dialectEnabled(HN) || (t.advance(), t.next == Mp))
    return;
  let n = 0;
  for (; Dp.indexOf(t.next) > -1; )
    t.advance(), n++;
  if (vf(t.next, !0)) {
    for (t.advance(), n++; vf(t.next, !1); )
      t.advance(), n++;
    for (; Dp.indexOf(t.next) > -1; )
      t.advance(), n++;
    if (t.next == r7)
      return;
    for (let r = 0; ; r++) {
      if (r == 7) {
        if (!vf(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(r))
        break;
      t.advance(), n++;
    }
  }
  t.acceptToken(WN, -n);
}), c7 = Ws({
  "get set async static": k.modifier,
  "for while do if else switch try catch finally return throw break continue default case": k.controlKeyword,
  "in of await yield void typeof delete instanceof": k.operatorKeyword,
  "let var const using function class extends": k.definitionKeyword,
  "import export from": k.moduleKeyword,
  "with debugger as new": k.keyword,
  TemplateString: k.special(k.string),
  super: k.atom,
  BooleanLiteral: k.bool,
  this: k.self,
  null: k.null,
  Star: k.modifier,
  VariableName: k.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": k.function(k.variableName),
  VariableDefinition: k.definition(k.variableName),
  Label: k.labelName,
  PropertyName: k.propertyName,
  PrivatePropertyName: k.special(k.propertyName),
  "CallExpression/MemberExpression/PropertyName": k.function(k.propertyName),
  "FunctionDeclaration/VariableDefinition": k.function(k.definition(k.variableName)),
  "ClassDeclaration/VariableDefinition": k.definition(k.className),
  PropertyDefinition: k.definition(k.propertyName),
  PrivatePropertyDefinition: k.definition(k.special(k.propertyName)),
  UpdateOp: k.updateOperator,
  "LineComment Hashbang": k.lineComment,
  BlockComment: k.blockComment,
  Number: k.number,
  String: k.string,
  Escape: k.escape,
  ArithOp: k.arithmeticOperator,
  LogicOp: k.logicOperator,
  BitOp: k.bitwiseOperator,
  CompareOp: k.compareOperator,
  RegExp: k.regexp,
  Equals: k.definitionOperator,
  Arrow: k.function(k.punctuation),
  ": Spread": k.punctuation,
  "( )": k.paren,
  "[ ]": k.squareBracket,
  "{ }": k.brace,
  "InterpolationStart InterpolationEnd": k.special(k.brace),
  ".": k.derefOperator,
  ", ;": k.separator,
  "@": k.meta,
  TypeName: k.typeName,
  TypeDefinition: k.definition(k.typeName),
  "type enum interface implements namespace module declare": k.definitionKeyword,
  "abstract global Privacy readonly override": k.modifier,
  "is keyof unique infer": k.operatorKeyword,
  JSXAttributeValue: k.attributeValue,
  JSXText: k.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": k.angleBracket,
  "JSXIdentifier JSXNameSpacedName": k.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": k.attributeName,
  "JSXBuiltin/JSXIdentifier": k.standard(k.tagName)
}), h7 = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, u7 = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, f7 = { __proto__: null, "<": 143 }, d7 = Zs.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>pQ08SO1G0{O#>wQ08SO1G0{O#@oQ08SO1G0{O#CoQ(CYO'#ChO#EmQ(CYO1G1^O#EtQ(CYO'#JjO!,lQWO1G1dO#FUQ08SO,5?TOOQ07`-E<g-E<gO#FxQ08SO1G0{OOQ07b1G0{1G0{O#ITQ08SO1G1aO#IwQ&jO,5<TO#JPQ&jO,5<UO#JXQ&jO'#FlO#JpQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#JuQ&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#KWQ(CYO'#JiO#KbQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KgQ`O'#J}OOQ07b,5<a,5<aO#KoQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KtO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LPQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LoQ7[O,5=RO!(SQ7[O'#IpO#MbQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MlQpO'#CqO#NPQpO,5<nO#NWQWO'#KRO9aQWO'#KRO#NfQWO,5<pO!(SQ7[O,5<oO#NkQWO'#GUO#NvQWO,5<oO#N{QpO'#GRO$ YQpO'#KSO$ dQWO'#KSO!&dQ7[O'#KSO$ iQWO,5<sO$ nQ`O'#G^O!4eQ`O'#G^O$!PQWO'#G`O$!UQWO'#GbO!3fQWO'#GeO$!ZQ07hO'#ImO$!fQ`O,5<wOOQ07f,5<w,5<wO$!mQ`O'#G^O$!{Q`O'#G_O$#TQ`O'#G_O$#YQ7[O,5=RO$#jQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$#zQWO'#IrO$$VQWO,5?|O$$_QWO,59`O$%OQ7[O,59qOOQ07b,59q,59qO$%qQ7[O,5<fO$&dQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&nQWO,5<qO$&sQ7[O,5<vO$'TQWO'#JuO!$aQ^O1G1}O$'YQWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'_Q07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)dQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+hQ7[O'#EgOOQ07`,5?{,5?{O$+rQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,TQWO1G0qO$,YQWO'#ChO$,eQWO'#K[O$,mQWO,5=uO$,rQWO'#K[O$,wQWO'#K[O$-VQWO'#IzO$-eQWO,5@uO$-mQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-tQWO1G3`O$-yQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.OQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.TQWO1G2|O$.]Q`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.eQ7[O,5=nO9aQWO,5=nO$!UQWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.sQWO'#KYO$/OQWO,5=qOOQU1G.j1G.jO$/TQ07hO1G.jO@bQWO1G.jO$/`QWO1G.jO9kQ07hO1G.jO$1eQrO,5@wO$1uQWO,5@wO9ZQWO,5@wO$2QQ^O,5=xO$2XQWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2^Q^O1G3nO$6bQ^O'#HmOOQU1G3q1G3qO$6oQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6wQ^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;OQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;TQ(CYO,5:UOOQO,5;[,5;[O$;_Q`O'#I^O$;uQWO,5@WOOQ07b1G/o1G/oO$;}Q`O'#IdO$<XQWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<aQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<hQ07hO1G0iO$<sQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=RQ07hO1G0iOOQO1G0]1G0]O$=gQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=qQpO,5<eO$=yQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>TQWO1G5qO$>]QWO1G6OO$>eQrO1G6PO9ZQWO,5>}O$>oQ08SO1G5|O%[Q^O1G5|O$?PQ07hO1G5|O$?bQWO1G5{O$?bQWO1G5{O9ZQWO1G5{O$?jQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@OQWO,5?QO$'TQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@^QWO7+(_O$@iQ7[O7+(_O$@wQ08SO,5=RO$CSQ08SO,5=TO$E_Q08SO,5=RO$GpQ08SO,5=TO$JRQ08SO,59qO$LZQ08SO,5<fO$NfQ08SO,5<hO%!qQ08SO,5<vOOQ07b7+&]7+&]O%%SQ08SO7+&]O%%vQ7[O'#I_O%&QQWO,5@YOOQ07b1G/y1G/yO%&YQ^O'#I`O%&gQWO,5@ZO%&oQrO,5@ZOOQ07b1G0O1G0OO%&yQWO7+&fOOQ07b7+&f7+&fO%'OQ(CYO,5:eO%[Q^O7+&xO%'YQ(CYO,5:]O%'gQ(CYO,5:iO%'qQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%'{QtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(WQWO1G1yOOQ07b1G1{1G1{O%(]QpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(dQ08SO7+'hOOQ07b,5?V,5?VO%)WQpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)vQ7[O,5?YOOQ07b-E<l-E<lO%*iQ7[O,5?[OOQ07b-E<n-E<nO%*sQpO1G2qOOQ07b1G2Y1G2YO%*zQWO'#IjO%+YQWO,5@mO%+YQWO,5@mO%+bQWO,5@mO%+mQWO,5@mOOQO1G2[1G2[O%+{Q7[O1G2ZO!(SQ7[O1G2ZO%,]Q!LQO'#IlO%,mQWO,5@nO!&dQ7[O,5@nO%,uQpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'TQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-PQWO,5<zOOQ07`,5<|,5<|O$'TQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-XQWO,5<yO$!PQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%-{Q7[O1G2mO!(SQ7[O'#IpO%.nQ7[O1G2oO%.xQ7[O1G5iO%/SQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/aQWO1G2UO!(SQ7[O1G2]O%/fQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0YQWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0_QpO'#KTO#%sQWO7+(_O%0iQrO7+(_O$@aQWO7+(_O%0pQ08QO'#ChO%1TQ08QO,5<}O%1uQWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%1zQWO'#IyO%2cQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2cQWO,5@vO%2kQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2pQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2uQ08QO7+(gO!&dQ7[O7+(gO%3PQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3WQWO'#KXO%3cQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4rQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%4yQWO1G3YO%5UQ7[O1G3YO9kQ07hO1G3[O$!UQWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5dQWO'#IxO%5xQWO,5@tO%6QQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6]QWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6bQ07hO1G6cO%6lQ^O1G3dO%6sQWO1G3dO%6xQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7PQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7^QWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7cQ`O1G5sO%7wQ(CYO1G0vO%8RQWO1G0vOOQO1G/p1G/pO%8^Q(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=gQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8hQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8sQ07hO7+&TO%9RQ08SO7++hO%[Q^O7++hO%9cQWO7++gO%9cQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9kQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0iQrO<<KyO%9yQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:RQWO<<KyO%:^Q08SO,5?YO%<iQ08SO,5?[O%>tQ08SO1G2ZO%AVQ08SO1G2mO%CbQ08SO1G2oO%EmQ7[O,5>yOOQO-E<]-E<]O%EwQrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FRQWO1G5uOOQ07b<<JQ<<JQO%FZQ(CYO1G0qO%HeQ(CYO1G0{O%HlQ(CYO1G0{O%JpQ(CYO1G0{O%JwQ(CYO1G0{O%LlQ(CYO1G0{O%MSQ(CYO1G0{O& gQ(CYO1G0{O& nQ(CYO1G0{O&#rQ(CYO1G0{O&#yQ(CYO1G0{O&%qQ(CYO1G0{O&&UQ08SO<<JdO&'ZQ(CYO1G0{O&)PQ(CYO'#JdO&+SQ(CYO1G1aO&+aQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+kQWO1G1qO&+pQ(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&+zQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,YQWO1G6XO&,YQWO1G6XO&,bQWO1G6XO&,mQ7[O7+'uO&,}QpO,5?WO&-XQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-^QpO1G6YO&-hQWO1G6YOOQ07`1G2e1G2eO$'TQWO1G2eOOQ07`1G2d1G2dO&-pQWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&-uQWO1G2fO&-}QWO1G2eO&.qQ7[O,5?YOOQ07b-E<m-E<mO&/dQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/nQWO1G/_OOQ07b7+'p7+'pO&/sQ7[O7+'wO&0TQ08SO<<KTOOQ07b<<KT<<KTO&0wQWO1G0vO!&dQ7[O'#IsO&0|QWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1UQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&1xQWO,5?eO&1}QWO,5?eOOQO-E<w-E<wO&2]QWO1G6bO&2]QWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2eQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2uQ08QO<<LROOQU<<LS<<LSO%3PQpO<<LSO&2jQ`O'#IuO&2uQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&2}Q^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3XQ`O,5=oOOQU,5=o,5=oO&3`Q`O'#EcO&3tQWO7+(tO&3yQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4RQWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$!UQWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4^QWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4iQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4qQWO7++}O&4vQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&4{QWO7+)OO&5QQ^O7+)OO&5XQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5^QWO,5>YOOQU,5>[,5>[O&5cQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5hQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=gQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&5rQ07hO<<IoO&5}Q08SO<= SO&6_QWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6gQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0iQrOANAeO%[Q^OANAeO&6oQ08SO7+'uO&9QQ08SO,5?YO&;]Q08SO,5?[O&=hQ08SO7+'wO&?yQrO1G4fO&@TQ(CYO7+&]O&BXQ(CYO,5=RO&D`Q(CYO,5=TO&DpQ(CYO,5=RO&EQQ(CYO,5=TO&EbQ(CYO,59qO&GeQ(CYO,5<fO&IhQ(CYO,5<hO&KkQ(CYO,5<vO&MaQ(CYO7+'hO&MnQ(CYO7+'iO&M{QWO,5<YOOQO7+']7+']O&NQQ7[O<<KwOOQO1G4p1G4pO&NXQWO1G4pO&NdQWO1G4pO&NrQWO7++sO&NrQWO7++sO!&dQ7[O1G4rO&NzQpO1G4rO' UQWO7++tOOQ07`7+(P7+(PO$'TQWO7+(QO' ^QpO7+(QOOQ07`7+(O7+(OO$'TQWO7+(PO' eQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' jQ7[O<<NoOOQ07b7+$y7+$yO' tQpO,5?_OOQO-E<q-E<qO'!OQ08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!`QWO1G5PO'!eQWO7++|O'!eQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!mQWO,5?aOOQO-E<s-E<sO'!xQ(CYO1G6_O'%YQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&2}Q^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&3tQWO<<L`O'%dQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$!UQWO<<LbO9UQWO<<LbO'%lQ`O1G5OO'%wQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&PQWO<= iO'&UQWO<= jOOQU<<Lj<<LjO'&ZQWO<<LjO'&`Q^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&gQWO<<I|O'&rQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=gQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO'&|QWOG27PO%0iQrOG27PO''UQ(CYO<<JdO''cQ(CYO1G2ZO')XQ(CYO,5?YO'+[Q(CYO,5?[O'-_Q(CYO1G2mO'/bQ(CYO1G2oO'1eQ(CYO<<KTO'1rQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2PQWO7+*[O'2[QWO<= _O'2dQpO7+*^OOQ07`<<Kl<<KlO$'TQWO<<KlOOQ07`<<Kk<<KkO'2nQpO<<KlO$'TQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'2uQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'2}QWO7++yO&3tQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3VQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$!UQWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3_QWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=gQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3dQWOLD,kO'3lQ(CYO7+'uO'5bQ(CYO,5?YO'7eQ(CYO,5?[O'9hQ(CYO7+'wO';^Q7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'TQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';nQ(CYO7+*gOOQUG27fG27fO&3tQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO';xQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<SQ08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&3tQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>eQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@ZQrO'#JiO!*fQ^O'#DqO'@bQ^O'#D}O'@iQrO'#ChO'CPQrO'#ChO!*fQ^O'#EPO'CaQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EdQWO,5<eO'ElQ7[O,5;aO'GVQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ElQ7[O'#GgO!&dQ7[O'#GiO'ElQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ElQ7[O'#FzO!&dQ7[O'#F|O'ElQ7[O'#F|O!&dQ7[O'#G[O'ElQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CaQ^O1G0qO'G^Q(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O,5<oO'ElQ7[O,5<oO'CaQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ElQ7[O1G2ZO!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O1G2]O'ElQ7[O1G2]O'CaQ^O7+'iO'CaQ^O7+&]O!&dQ7[OANAcO'ElQ7[OANAcO'GhQWO'#EkO'GmQWO'#EkO'GuQWO'#FZO'GzQWO'#EuO'HPQWO'#JyO'H[QWO'#JwO'HgQWO,5;VO'HlQ7[O,5<bO'HsQWO'#GTO'HxQWO'#GTO'H}QWO,5<cO'IVQWO,5;VO'I_Q(CYO1G1^O'IfQWO,5<oO'IkQWO,5<oO'IpQWO,5<qO'IuQWO,5<qO'IzQWO1G1}O'JPQWO1G0qO'JUQ7[O<<KwO'J]Q7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*sQpO1G2qO%*sQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Ka~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#v#ii#x#ii#y#ii'r#ii(h#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(o#ii~P#9lO(o#|O~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO(XVO(o#|O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(p#ii~P#<^O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?OOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AiOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#CvO#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#CvO!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#LWO(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#LyO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$dO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%YO|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$%{O#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'jOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*TO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/kO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#CvOo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#LWO#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#LyO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$dO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%YO#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$%{O#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#CvO#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)_O|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*QO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-dO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.VOf(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3hOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#CvO#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#CvO`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)_O#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*QO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-dO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.VOf'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#CvOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FhO#j:lO~P%FhOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HsOn:nO~P%HsOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KOOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KOOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#v#ii#x#ii#y#ii#|#ii(h#ii(p#ii!Y#ii!Z#ii~O(o#ii~P%MjO(o#|O~P%MjOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO(XVO(o#|O#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O(p#ii~P& uO(p#}O~P& uOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$QO`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&&xO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#CvO#|!qi!Z!qi~P$'jO!Z6|O~O!Y']a!Z']a~P#CvO!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.YO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&.{O!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3hOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#CvO`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.YO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&.{O#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#CvO(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@bO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BiOj<gO|)zO!P){O(p%PO~P&@bOj<gO|)zO!P){O(o$}O~P&BiO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&&xO#|$jq!Y$jq!Z$jq~P#CvO#|$kq!Y$kq!Z$kq~P#CvO!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#CvOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#SO![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#CvO!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#CvOP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&&xO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#CvO#|#_y!Y#_y!Z#_y~P#CvO!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&&xO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&&xOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#CvO!Y#d!Z!Z#d!Z~P#CvO#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&&xOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#SOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'@vOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ElO!Z[X!ZeX~P'@vO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#CvO#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AuPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!f$Uc#X%n'|(S(n(u)U)V)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:r)Z)l-O.t2W2Z3_3g3h3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!b$Wc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:t)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "\u26A0 ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: i7,
  nodeProps: [
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [c7],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [o7, l7, a7, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, s7, new uh("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new uh("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14602 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (t) => h7[t] || -1 }, { term: 334, get: (t) => u7[t] || -1 }, { term: 70, get: (t) => f7[t] || -1 }],
  tokenPrec: 14626
}), gC = [
  /* @__PURE__ */ St("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ St("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ St("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ St("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ St("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ St(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ St("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ St(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ St(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ St('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ St('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], p7 = /* @__PURE__ */ gC.concat([
  /* @__PURE__ */ St("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ St("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ St("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), zb = /* @__PURE__ */ new ev(), mC = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Oo(t) {
  return (e, n) => {
    let r = e.node.getChild("VariableDefinition");
    return r && n(r, t), !0;
  };
}
const g7 = ["FunctionDeclaration"], m7 = {
  FunctionDeclaration: /* @__PURE__ */ Oo("function"),
  ClassDeclaration: /* @__PURE__ */ Oo("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Oo("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Oo("type"),
  NamespaceDeclaration: /* @__PURE__ */ Oo("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(g7) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function OC(t, e) {
  let n = zb.get(e);
  if (n)
    return n;
  let r = [], i = !0;
  function s(o, l) {
    let a = t.sliceString(o.from, o.to);
    r.push({ label: a, type: l });
  }
  return e.cursor(ve.IncludeAnonymous).iterate((o) => {
    if (i)
      i = !1;
    else if (o.name) {
      let l = m7[o.name];
      if (l && l(o, s) || mC.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let l of OC(t, o.node))
        r.push(l);
      return !1;
    }
  }), zb.set(e, r), r;
}
const Vb = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, bC = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function O7(t) {
  let e = Se(t.state).resolveInner(t.pos, -1);
  if (bC.indexOf(e.name) > -1)
    return null;
  let n = e.name == "VariableName" || e.to - e.from < 20 && Vb.test(t.state.sliceDoc(e.from, e.to));
  if (!n && !t.explicit)
    return null;
  let r = [];
  for (let i = e; i; i = i.parent)
    mC.has(i.name) && (r = r.concat(OC(t.state.doc, i)));
  return {
    options: r,
    from: n ? e.from : t.pos,
    validFor: Vb
  };
}
const Yn = /* @__PURE__ */ Cs.define({
  name: "javascript",
  parser: /* @__PURE__ */ d7.configure({
    props: [
      /* @__PURE__ */ Yl.add({
        IfStatement: /* @__PURE__ */ gc({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ gc({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: xD,
        SwitchBody: (t) => {
          let e = t.textAfter, n = /^\s*\}/.test(e), r = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (n ? 0 : r ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ kD({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ gc({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ zs.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": av,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), yC = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ Tg({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, wC = /* @__PURE__ */ Yn.configure({ dialect: "ts" }, "typescript"), kC = /* @__PURE__ */ Yn.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ Qg.add((t) => t.isTop ? [yC] : void 0)]
}), xC = /* @__PURE__ */ Yn.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ Qg.add((t) => t.isTop ? [yC] : void 0)]
}, "typescript");
let vC = (t) => ({ label: t, type: "keyword" });
const SC = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(vC), b7 = /* @__PURE__ */ SC.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(vC));
function y7(t = {}) {
  let e = t.jsx ? t.typescript ? xC : kC : t.typescript ? wC : Yn, n = t.typescript ? p7.concat(b7) : gC.concat(SC);
  return new al(e, [
    Yn.data.of({
      autocomplete: M5(bC, dS(n))
    }),
    Yn.data.of({
      autocomplete: O7
    }),
    t.jsx ? x7 : []
  ]);
}
function w7(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function Ub(t, e, n = t.length) {
  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)
    if (r.name == "JSXIdentifier" || r.name == "JSXBuiltin" || r.name == "JSXNamespacedName" || r.name == "JSXMemberExpression")
      return t.sliceString(r.from, Math.min(r.to, n));
  return "";
}
const k7 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), x7 = /* @__PURE__ */ T.inputHandler.of((t, e, n, r, i) => {
  if ((k7 ? t.composing : t.compositionStarted) || t.state.readOnly || e != n || r != ">" && r != "/" || !Yn.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: o } = s, l = o.changeByRange((a) => {
    var c;
    let { head: h } = a, u = Se(o).resolveInner(h - 1, -1), f;
    if (u.name == "JSXStartTag" && (u = u.parent), !(o.doc.sliceString(h - 1, h) != r || u.name == "JSXAttributeValue" && u.to > h)) {
      if (r == ">" && u.name == "JSXFragmentTag")
        return { range: a, changes: { from: h, insert: "</>" } };
      if (r == "/" && u.name == "JSXStartCloseTag") {
        let d = u.parent, p = d.parent;
        if (p && d.from == h - 2 && ((f = Ub(o.doc, p.firstChild, h)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let g = `${f}>`;
          return { range: C.cursor(h + g.length, -1), changes: { from: h, insert: g } };
        }
      } else if (r == ">") {
        let d = w7(u);
        if (d && !/^\/?>|^<\//.test(o.doc.sliceString(h, h + 2)) && (f = Ub(o.doc, d, h)))
          return { range: a, changes: { from: h, insert: `</${f}>` } };
      }
    }
    return { range: a };
  });
  return l.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(l, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), bo = ["_blank", "_self", "_top", "_parent"], Sf = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], _f = ["get", "post", "put", "delete"], Cf = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Mt = ["true", "false"], B = {}, v7 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: bo,
      hreflang: null
    }
  },
  abbr: B,
  address: B,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: B,
  aside: B,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: B,
  base: { attrs: { href: null, target: bo } },
  bdi: B,
  bdo: B,
  blockquote: { attrs: { cite: null } },
  body: B,
  br: B,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Cf,
      formmethod: _f,
      formnovalidate: ["novalidate"],
      formtarget: bo,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: B,
  center: B,
  cite: B,
  code: B,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: B,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: B,
  div: B,
  dl: B,
  dt: B,
  em: B,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: B,
  figure: B,
  footer: B,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Sf,
      autocomplete: ["on", "off"],
      enctype: Cf,
      method: _f,
      novalidate: ["novalidate"],
      target: bo
    }
  },
  h1: B,
  h2: B,
  h3: B,
  h4: B,
  h5: B,
  h6: B,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: B,
  hgroup: B,
  hr: B,
  html: {
    attrs: { manifest: null }
  },
  i: B,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Cf,
      formmethod: _f,
      formnovalidate: ["novalidate"],
      formtarget: bo,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: B,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: B,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: B,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Sf,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: B,
  noscript: B,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: B,
  param: { attrs: { name: null, value: null } },
  pre: B,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: B,
  rt: B,
  ruby: B,
  samp: B,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Sf
    }
  },
  section: B,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: B,
  source: { attrs: { src: null, type: null, media: null } },
  span: B,
  strong: B,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: B,
  summary: B,
  sup: B,
  table: B,
  tbody: B,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: B,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: B,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: B,
  time: { attrs: { datetime: null } },
  title: B,
  tr: B,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: B,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: B
}, _C = {
  accesskey: null,
  class: null,
  contenteditable: Mt,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Mt,
  autocorrect: Mt,
  autocapitalize: Mt,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Mt,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Mt,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Mt,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Mt,
  "aria-hidden": Mt,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Mt,
  "aria-multiselectable": Mt,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Mt,
  "aria-relevant": null,
  "aria-required": Mt,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, CC = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of CC)
  _C[t] = null;
class Al {
  constructor(e, n) {
    this.tags = Object.assign(Object.assign({}, v7), e), this.globalAttrs = Object.assign(Object.assign({}, _C), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Al.default = /* @__PURE__ */ new Al();
function Is(t, e, n = t.length) {
  if (!e)
    return "";
  let r = e.firstChild, i = r && r.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, n)) : "";
}
function Ls(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function AC(t, e, n) {
  let r = n.tags[Is(t, Ls(e))];
  return (r == null ? void 0 : r.children) || n.allTags;
}
function vm(t, e) {
  let n = [];
  for (let r = Ls(e); r && !r.type.isTop; r = Ls(r.parent)) {
    let i = Is(t, r);
    if (i && r.lastChild.name == "CloseTag")
      break;
    i && n.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= r.firstChild.to) && n.push(i);
  }
  return n;
}
const $C = /^[:\-\.\w\u00b7-\uffff]*$/;
function Fb(t, e, n, r, i) {
  let s = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">", o = Ls(n, !0);
  return {
    from: r,
    to: i,
    options: AC(t.doc, o, e).map((l) => ({ label: l, type: "type" })).concat(vm(t.doc, n).map((l, a) => ({
      label: "/" + l,
      apply: "/" + l + s,
      type: "type",
      boost: 99 - a
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function Gb(t, e, n, r) {
  let i = /\s*>/.test(t.sliceDoc(r, r + 5)) ? "" : ">";
  return {
    from: n,
    to: r,
    options: vm(t.doc, e).map((s, o) => ({ label: s, apply: s + i, type: "type", boost: 99 - o })),
    validFor: $C
  };
}
function S7(t, e, n, r) {
  let i = [], s = 0;
  for (let o of AC(t.doc, n, e))
    i.push({ label: "<" + o, type: "type" });
  for (let o of vm(t.doc, n))
    i.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: r, to: r, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function _7(t, e, n, r, i) {
  let s = Ls(n), o = s ? e.tags[Is(t.doc, s)] : null, l = o && o.attrs ? Object.keys(o.attrs) : [], a = o && o.globalAttrs === !1 ? l : l.length ? l.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: r,
    to: i,
    options: a.map((c) => ({ label: c, type: "property" })),
    validFor: $C
  };
}
function C7(t, e, n, r, i) {
  var s;
  let o = (s = n.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), l = [], a;
  if (o) {
    let c = t.sliceDoc(o.from, o.to), h = e.globalAttrs[c];
    if (!h) {
      let u = Ls(n), f = u ? e.tags[Is(t.doc, u)] : null;
      h = (f == null ? void 0 : f.attrs) && f.attrs[c];
    }
    if (h) {
      let u = t.sliceDoc(r, i).toLowerCase(), f = '"', d = '"';
      /^['"]/.test(u) ? (a = u[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", d = t.sliceDoc(i, i + 1) == u[0] ? "" : u[0], u = u.slice(1), r++) : a = /^[^\s<>='"]*$/;
      for (let p of h)
        l.push({ label: p, apply: f + p + d, type: "constant" });
    }
  }
  return { from: r, to: i, options: l, validFor: a };
}
function PC(t, e) {
  let { state: n, pos: r } = e, i = Se(n).resolveInner(r, -1), s = i.resolve(r);
  for (let o = r, l; s == i && (l = i.childBefore(o)); ) {
    let a = l.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    s = i = l, o = a.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? Gb(n, i, i.from, r) : Fb(n, t, i, i.from, r) : i.name == "StartTag" ? Fb(n, t, i, r, r) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? Gb(n, i, r, r) : e.explicit && (i.name == "OpenTag" || i.name == "SelfClosingTag") || i.name == "AttributeName" ? _7(n, t, i, i.name == "AttributeName" ? i.from : r, r) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? C7(n, t, i, i.name == "Is" ? r : i.from, r) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? S7(n, t, i, r) : null;
}
function A7(t) {
  return PC(Al.default, t);
}
function $7(t) {
  let { extraTags: e, extraGlobalAttributes: n } = t, r = n || e ? new Al(e, n) : Al.default;
  return (i) => PC(r, i);
}
const P7 = /* @__PURE__ */ Yn.parser.configure({ top: "SingleExpression" }), TC = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: wC.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: kC.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: xC.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: P7
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: Yn.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: gh.parser
  }
], QC = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ gh.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ CC.map((t) => ({ name: t, parser: Yn.parser }))), EC = /* @__PURE__ */ Cs.define({
  name: "html",
  parser: /* @__PURE__ */ dN.configure({
    props: [
      /* @__PURE__ */ Yl.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, n;
          for (let r = t.node; ; ) {
            let i = r.lastChild;
            if (!i || i.name != "Element" || i.to != r.to)
              break;
            e = r = i;
          }
          return e && !((n = e.lastChild) && (n.name == "CloseTag" || n.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ zs.add({
        Element(t) {
          let e = t.firstChild, n = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: n.name == "CloseTag" ? n.from : t.to };
        }
      }),
      /* @__PURE__ */ kv.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), vc = /* @__PURE__ */ EC.configure({
  wrap: /* @__PURE__ */ hC(TC, QC)
});
function T7(t = {}) {
  let e = "", n;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (n = hC((t.nestedLanguages || []).concat(TC), (t.nestedAttributes || []).concat(QC)));
  let r = n ? EC.configure({ wrap: n, dialect: e }) : e ? vc.configure({ dialect: e }) : vc;
  return new al(r, [
    vc.data.of({ autocomplete: $7(t) }),
    t.autoCloseTags !== !1 ? Q7 : [],
    y7().support,
    YN().support
  ]);
}
const Hb = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), Q7 = /* @__PURE__ */ T.inputHandler.of((t, e, n, r, i) => {
  if (t.composing || t.state.readOnly || e != n || r != ">" && r != "/" || !vc.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: o } = s, l = o.changeByRange((a) => {
    var c, h, u;
    let f = o.doc.sliceString(a.from - 1, a.to) == r, { head: d } = a, p = Se(o).resolveInner(d - 1, -1), g;
    if ((p.name == "TagName" || p.name == "StartTag") && (p = p.parent), f && r == ">" && p.name == "OpenTag") {
      if (((h = (c = p.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || h === void 0 ? void 0 : h.name) != "CloseTag" && (g = Is(o.doc, p.parent, d)) && !Hb.has(g)) {
        let m = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), O = `</${g}>`;
        return { range: a, changes: { from: d, to: m, insert: O } };
      }
    } else if (f && r == "/" && p.name == "IncompleteCloseTag") {
      let m = p.parent;
      if (p.from == d - 2 && ((u = m.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (g = Is(o.doc, m, d)) && !Hb.has(g)) {
        let O = d + (o.doc.sliceString(d, d + 1) === ">" ? 1 : 0), b = `${g}>`;
        return {
          range: C.cursor(d + b.length, -1),
          changes: { from: d, to: O, insert: b }
        };
      }
    }
    return { range: a };
  });
  return l.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(l, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), DC = /* @__PURE__ */ Tg({ commentTokens: { block: { open: "<!--", close: "-->" } } }), MC = /* @__PURE__ */ new K(), RC = /* @__PURE__ */ a3.configure({
  props: [
    /* @__PURE__ */ zs.add((t) => !t.is("Block") || t.is("Document") || Rp(t) != null ? void 0 : (e, n) => ({ from: n.doc.lineAt(e.from).to, to: e.to })),
    /* @__PURE__ */ MC.add(Rp),
    /* @__PURE__ */ Yl.add({
      Document: () => null
    }),
    /* @__PURE__ */ fi.add({
      Document: DC
    })
  ]
});
function Rp(t) {
  let e = /^(?:ATX|Setext)Heading(\d)$/.exec(t.name);
  return e ? +e[1] : void 0;
}
function E7(t, e) {
  let n = t;
  for (; ; ) {
    let r = n.nextSibling, i;
    if (!r || (i = Rp(r.type)) != null && i <= e)
      break;
    n = r;
  }
  return n.to;
}
const D7 = /* @__PURE__ */ lv.of((t, e, n) => {
  for (let r = Se(t).resolveInner(n, -1); r && !(r.from < e); r = r.parent) {
    let i = r.type.prop(MC);
    if (i == null)
      continue;
    let s = E7(r, i);
    if (s > n)
      return { from: n, to: s };
  }
  return null;
});
function Sm(t) {
  return new zt(DC, t, [D7], "markdown");
}
const M7 = /* @__PURE__ */ Sm(RC), R7 = /* @__PURE__ */ RC.configure([y3, k3, w3, x3, {
  props: [
    /* @__PURE__ */ zs.add({
      Table: (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })
    })
  ]
}]), ZC = /* @__PURE__ */ Sm(R7);
function Z7(t, e) {
  return (n) => {
    if (n && t) {
      let r = null;
      if (n = /\S*/.exec(n)[0], typeof t == "function" ? r = t(n) : r = qc.matchLanguageName(t, n, !0), r instanceof qc)
        return r.support ? r.support.language.parser : ll.getSkippingParser(r.load());
      if (r)
        return r.parser;
    }
    return e ? e.parser : null;
  };
}
class qa {
  constructor(e, n, r, i, s, o, l) {
    this.node = e, this.from = n, this.to = r, this.spaceBefore = i, this.spaceAfter = s, this.type = o, this.item = l;
  }
  blank(e, n = !0) {
    let r = this.spaceBefore + (this.node.name == "Blockquote" ? ">" : "");
    if (e != null) {
      for (; r.length < e; )
        r += " ";
      return r;
    } else {
      for (let i = this.to - this.from - r.length - this.spaceAfter.length; i > 0; i--)
        r += " ";
      return r + (n ? this.spaceAfter : "");
    }
  }
  marker(e, n) {
    let r = this.node.name == "OrderedList" ? String(+LC(this.item, e)[2] + n) : "";
    return this.spaceBefore + r + this.type + this.spaceAfter;
  }
}
function IC(t, e) {
  let n = [];
  for (let i = t; i && i.name != "Document"; i = i.parent)
    (i.name == "ListItem" || i.name == "Blockquote" || i.name == "FencedCode") && n.push(i);
  let r = [];
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i], o, l = e.lineAt(s.from), a = s.from - l.from;
    if (s.name == "FencedCode")
      r.push(new qa(s, a, a, "", "", "", null));
    else if (s.name == "Blockquote" && (o = /^ *>( ?)/.exec(l.text.slice(a))))
      r.push(new qa(s, a, a + o[0].length, "", o[1], ">", null));
    else if (s.name == "ListItem" && s.parent.name == "OrderedList" && (o = /^( *)\d+([.)])( *)/.exec(l.text.slice(a)))) {
      let c = o[3], h = o[0].length;
      c.length >= 4 && (c = c.slice(0, c.length - 4), h -= 4), r.push(new qa(s.parent, a, a + h, o[1], c, o[2], s));
    } else if (s.name == "ListItem" && s.parent.name == "BulletList" && (o = /^( *)([-+*])( {1,4}\[[ xX]\])?( +)/.exec(l.text.slice(a)))) {
      let c = o[4], h = o[0].length;
      c.length > 4 && (c = c.slice(0, c.length - 4), h -= 4);
      let u = o[2];
      o[3] && (u += o[3].replace(/[xX]/, " ")), r.push(new qa(s.parent, a, a + h, o[1], c, u, s));
    }
  }
  return r;
}
function LC(t, e) {
  return /^(\s*)(\d+)(?=[.)])/.exec(e.sliceString(t.from, t.from + 10));
}
function Af(t, e, n, r = 0) {
  for (let i = -1, s = t; ; ) {
    if (s.name == "ListItem") {
      let l = LC(s, e), a = +l[2];
      if (i >= 0) {
        if (a != i + 1)
          return;
        n.push({ from: s.from + l[1].length, to: s.from + l[0].length, insert: String(i + 2 + r) });
      }
      i = a;
    }
    let o = s.nextSibling;
    if (!o)
      break;
    s = o;
  }
}
function Zp(t, e) {
  let n = /^[ \t]*/.exec(t)[0].length;
  if (!n || e.facet(Bl) != "	")
    return t;
  let r = pn(t, 4, n), i = "";
  for (let s = r; s > 0; )
    s >= 4 ? (i += "	", s -= 4) : (i += " ", s--);
  return i + t.slice(n);
}
const I7 = ({ state: t, dispatch: e }) => {
  let n = Se(t), { doc: r } = t, i = null, s = t.changeByRange((o) => {
    if (!o.empty || !ZC.isActiveAt(t, o.from))
      return i = { range: o };
    let l = o.from, a = r.lineAt(l), c = IC(n.resolveInner(l, -1), r);
    for (; c.length && c[c.length - 1].from > l - a.from; )
      c.pop();
    if (!c.length)
      return i = { range: o };
    let h = c[c.length - 1];
    if (h.to - h.spaceAfter.length > l - a.from)
      return i = { range: o };
    let u = l >= h.to - h.spaceAfter.length && !/\S/.test(a.text.slice(h.to));
    if (h.item && u)
      if (h.node.firstChild.to >= l || a.from > 0 && !/[^\s>]/.test(r.lineAt(a.from - 1).text)) {
        let m = c.length > 1 ? c[c.length - 2] : null, O, b = "";
        m && m.item ? (O = a.from + m.from, b = m.marker(r, 1)) : O = a.from + (m ? m.to : 0);
        let y = [{ from: O, to: l, insert: b }];
        return h.node.name == "OrderedList" && Af(h.item, r, y, -2), m && m.node.name == "OrderedList" && Af(m.item, r, y), { range: C.cursor(O + b.length), changes: y };
      } else {
        let m = "";
        for (let O = 0, b = c.length - 2; O <= b; O++)
          m += c[O].blank(O < b ? pn(a.text, 4, c[O + 1].from) - m.length : null, O < b);
        return m = Zp(m, t), {
          range: C.cursor(l + m.length + 1),
          changes: { from: a.from, insert: m + t.lineBreak }
        };
      }
    if (h.node.name == "Blockquote" && u && a.from) {
      let m = r.lineAt(a.from - 1), O = />\s*$/.exec(m.text);
      if (O && O.index == h.from) {
        let b = t.changes([
          { from: m.from + O.index, to: m.to },
          { from: a.from + h.from, to: a.to }
        ]);
        return { range: o.map(b), changes: b };
      }
    }
    let f = [];
    h.node.name == "OrderedList" && Af(h.item, r, f);
    let d = h.item && h.item.from < a.from, p = "";
    if (!d || /^[\s\d.)\-+*>]*/.exec(a.text)[0].length >= h.to)
      for (let m = 0, O = c.length - 1; m <= O; m++)
        p += m == O && !d ? c[m].marker(r, 1) : c[m].blank(m < O ? pn(a.text, 4, c[m + 1].from) - p.length : null);
    let g = l;
    for (; g > a.from && /\s/.test(a.text.charAt(g - a.from - 1)); )
      g--;
    return p = Zp(p, t), f.push({ from: g, to: l, insert: t.lineBreak + p }), { range: C.cursor(g + p.length + 1), changes: f };
  });
  return i ? !1 : (e(t.update(s, { scrollIntoView: !0, userEvent: "input" })), !0);
};
function Jb(t) {
  return t.name == "QuoteMark" || t.name == "ListMark";
}
function L7(t, e) {
  let n = t.resolveInner(e, -1), r = e;
  Jb(n) && (r = n.from, n = n.parent);
  for (let i; i = n.childBefore(r); )
    if (Jb(i))
      r = i.from;
    else if (i.name == "OrderedList" || i.name == "BulletList")
      n = i.lastChild, r = n.to;
    else
      break;
  return n;
}
const N7 = ({ state: t, dispatch: e }) => {
  let n = Se(t), r = null, i = t.changeByRange((s) => {
    let o = s.from, { doc: l } = t;
    if (s.empty && ZC.isActiveAt(t, s.from)) {
      let a = l.lineAt(o), c = IC(L7(n, o), l);
      if (c.length) {
        let h = c[c.length - 1], u = h.to - h.spaceAfter.length + (h.spaceAfter ? 1 : 0);
        if (o - a.from > u && !/\S/.test(a.text.slice(u, o - a.from)))
          return {
            range: C.cursor(a.from + u),
            changes: { from: a.from + u, to: o }
          };
        if (o - a.from == u && (!h.item || a.from <= h.item.from || !/\S/.test(a.text.slice(0, h.to)))) {
          let f = a.from + h.from;
          if (h.item && h.node.from < h.item.from && /\S/.test(a.text.slice(h.from, h.to))) {
            let d = h.blank(pn(a.text, 4, h.to) - pn(a.text, 4, h.from));
            return f == a.from && (d = Zp(d, t)), {
              range: C.cursor(f + d.length),
              changes: { from: f, to: a.from + h.to, insert: d }
            };
          }
          if (f < o)
            return { range: C.cursor(f), changes: { from: f, to: o } };
        }
      }
    }
    return r = { range: s };
  });
  return r ? !1 : (e(t.update(i, { scrollIntoView: !0, userEvent: "delete" })), !0);
}, q7 = [
  { key: "Enter", run: I7 },
  { key: "Backspace", run: N7 }
], Ip = /* @__PURE__ */ T7({ matchClosingTags: !1 });
function B7(t = {}) {
  let { codeLanguages: e, defaultCodeLanguage: n, addKeymap: r = !0, base: { parser: i } = M7, completeHTMLTags: s = !0 } = t;
  if (!(i instanceof lu))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let o = t.extensions ? [t.extensions] : [], l = [Ip.support], a;
  n instanceof al ? (l.push(n.support), a = n.language) : n && (a = n);
  let c = e || a ? Z7(e, a) : void 0;
  o.push(h3({ codeParser: c, htmlParser: Ip.language.parser })), r && l.push(yn.high(sr.of(q7)));
  let h = Sm(i.configure(o));
  return s && l.push(h.data.of({ autocomplete: Y7 })), new al(h, l);
}
function Y7(t) {
  let { state: e, pos: n } = t, r = /<[:\-\.\w\u00b7-\uffff]*$/.exec(e.sliceDoc(n - 25, n));
  if (!r)
    return null;
  let i = Se(e).resolveInner(n, -1);
  for (; i && !i.type.isTop; ) {
    if (i.name == "CodeBlock" || i.name == "FencedCode" || i.name == "ProcessingInstructionBlock" || i.name == "CommentBlock" || i.name == "Link" || i.name == "Image")
      return null;
    i = i.parent;
  }
  return {
    from: n - r[0].length,
    to: n,
    options: j7(),
    validFor: /^<[:\-\.\w\u00b7-\uffff]*$/
  };
}
let $f = null;
function j7() {
  if ($f)
    return $f;
  let t = A7(new jg(re.create({ extensions: Ip }), 0, !0));
  return $f = t ? t.options : [];
}
function X7(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var NC = { exports: {} };
const W7 = {}, z7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: W7
}, Symbol.toStringTag, { value: "Module" })), V7 = /* @__PURE__ */ tk(z7);
(function(t) {
  var e;
  (function() {
    e = function(n, r, i, s) {
      s = s || {}, this.dictionary = null, this.rules = {}, this.dictionaryTable = {}, this.compoundRules = [], this.compoundRuleCodes = {}, this.replacementTable = [], this.flags = s.flags || {}, this.memoized = {}, this.loaded = !1;
      var o = this, l, a, c, h, u;
      n && (o.dictionary = n, r && i ? g() : typeof window < "u" && "chrome" in window && "extension" in window.chrome && "getURL" in window.chrome.extension ? (s.dictionaryPath ? l = s.dictionaryPath : l = "typo/dictionaries", r || f(chrome.extension.getURL(l + "/" + n + "/" + n + ".aff"), d), i || f(chrome.extension.getURL(l + "/" + n + "/" + n + ".dic"), p)) : (s.dictionaryPath ? l = s.dictionaryPath : typeof __dirname < "u" ? l = __dirname + "/dictionaries" : l = "./dictionaries", r || f(l + "/" + n + "/" + n + ".aff", d), i || f(l + "/" + n + "/" + n + ".dic", p)));
      function f(m, O) {
        var b = o._readFile(m, null, s.asyncLoad);
        s.asyncLoad ? b.then(function(y) {
          O(y);
        }) : O(b);
      }
      function d(m) {
        r = m, i && g();
      }
      function p(m) {
        i = m, r && g();
      }
      function g() {
        for (o.rules = o._parseAFF(r), o.compoundRuleCodes = {}, a = 0, h = o.compoundRules.length; a < h; a++) {
          var m = o.compoundRules[a];
          for (c = 0, u = m.length; c < u; c++)
            o.compoundRuleCodes[m[c]] = [];
        }
        "ONLYINCOMPOUND" in o.flags && (o.compoundRuleCodes[o.flags.ONLYINCOMPOUND] = []), o.dictionaryTable = o._parseDIC(i);
        for (a in o.compoundRuleCodes)
          o.compoundRuleCodes[a].length === 0 && delete o.compoundRuleCodes[a];
        for (a = 0, h = o.compoundRules.length; a < h; a++) {
          var O = o.compoundRules[a], b = "";
          for (c = 0, u = O.length; c < u; c++) {
            var y = O[c];
            y in o.compoundRuleCodes ? b += "(" + o.compoundRuleCodes[y].join("|") + ")" : b += y;
          }
          o.compoundRules[a] = new RegExp(b, "i");
        }
        o.loaded = !0, s.asyncLoad && s.loadedCallback && s.loadedCallback(o);
      }
      return this;
    }, e.prototype = {
      load: function(n) {
        for (var r in n)
          n.hasOwnProperty(r) && (this[r] = n[r]);
        return this;
      },
      _readFile: function(n, r, i) {
        if (r = r || "utf8", typeof XMLHttpRequest < "u") {
          var s, o = new XMLHttpRequest();
          return o.open("GET", n, i), i && (s = new Promise(function(a, c) {
            o.onload = function() {
              o.status === 200 ? a(o.responseText) : c(o.statusText);
            }, o.onerror = function() {
              c(o.statusText);
            };
          })), o.overrideMimeType && o.overrideMimeType("text/plain; charset=" + r), o.send(null), i ? s : o.responseText;
        } else if (typeof X7 < "u") {
          var l = V7;
          try {
            if (l.existsSync(n))
              return l.readFileSync(n, r);
            console.log("Path " + n + " does not exist.");
          } catch (a) {
            return console.log(a), "";
          }
        }
      },
      _parseAFF: function(n) {
        var r = {}, i, s, o, l, a, c, h, u, f = n.split(/\r?\n/);
        for (a = 0, h = f.length; a < h; a++)
          if (i = this._removeAffixComments(f[a]), i = i.trim(), !!i) {
            var d = i.split(/\s+/), p = d[0];
            if (p == "PFX" || p == "SFX") {
              var g = d[1], m = d[2];
              o = parseInt(d[3], 10);
              var O = [];
              for (c = a + 1, u = a + 1 + o; c < u; c++) {
                s = f[c], l = s.split(/\s+/);
                var b = l[2], y = l[3].split("/"), w = y[0];
                w === "0" && (w = "");
                var S = this.parseRuleCodes(y[1]), x = l[4], v = {};
                v.add = w, S.length > 0 && (v.continuationClasses = S), x !== "." && (p === "SFX" ? v.match = new RegExp(x + "$") : v.match = new RegExp("^" + x)), b != "0" && (p === "SFX" ? v.remove = new RegExp(b + "$") : v.remove = b), O.push(v);
              }
              r[g] = { type: p, combineable: m == "Y", entries: O }, a += o;
            } else if (p === "COMPOUNDRULE") {
              for (o = parseInt(d[1], 10), c = a + 1, u = a + 1 + o; c < u; c++)
                i = f[c], l = i.split(/\s+/), this.compoundRules.push(l[1]);
              a += o;
            } else
              p === "REP" ? (l = i.split(/\s+/), l.length === 3 && this.replacementTable.push([l[1], l[2]])) : this.flags[p] = d[1];
          }
        return r;
      },
      _removeAffixComments: function(n) {
        return n.match(/^\s*#/, "") ? "" : n;
      },
      _parseDIC: function(n) {
        n = this._removeDicComments(n);
        var r = n.split(/\r?\n/), i = {};
        function s(R, N) {
          i.hasOwnProperty(R) || (i[R] = null), N.length > 0 && (i[R] === null && (i[R] = []), i[R].push(N));
        }
        for (var o = 1, l = r.length; o < l; o++) {
          var a = r[o];
          if (!!a) {
            var c = a.split("/", 2), h = c[0];
            if (c.length > 1) {
              var u = this.parseRuleCodes(c[1]);
              (!("NEEDAFFIX" in this.flags) || u.indexOf(this.flags.NEEDAFFIX) == -1) && s(h, u);
              for (var f = 0, d = u.length; f < d; f++) {
                var p = u[f], g = this.rules[p];
                if (g)
                  for (var m = this._applyRule(h, g), O = 0, b = m.length; O < b; O++) {
                    var y = m[O];
                    if (s(y, []), g.combineable)
                      for (var w = f + 1; w < d; w++) {
                        var S = u[w], x = this.rules[S];
                        if (x && x.combineable && g.type != x.type)
                          for (var v = this._applyRule(y, x), P = 0, D = v.length; P < D; P++) {
                            var Q = v[P];
                            s(Q, []);
                          }
                      }
                  }
                p in this.compoundRuleCodes && this.compoundRuleCodes[p].push(h);
              }
            } else
              s(h.trim(), []);
          }
        }
        return i;
      },
      _removeDicComments: function(n) {
        return n = n.replace(/^\t.*$/mg, ""), n;
      },
      parseRuleCodes: function(n) {
        if (n)
          if ("FLAG" in this.flags)
            if (this.flags.FLAG === "long") {
              for (var r = [], i = 0, s = n.length; i < s; i += 2)
                r.push(n.substr(i, 2));
              return r;
            } else
              return this.flags.FLAG === "num" ? n.split(",") : this.flags.FLAG === "UTF-8" ? Array.from(n) : n.split("");
          else
            return n.split("");
        else
          return [];
      },
      _applyRule: function(n, r) {
        for (var i = r.entries, s = [], o = 0, l = i.length; o < l; o++) {
          var a = i[o];
          if (!a.match || n.match(a.match)) {
            var c = n;
            if (a.remove && (c = c.replace(a.remove, "")), r.type === "SFX" ? c = c + a.add : c = a.add + c, s.push(c), "continuationClasses" in a)
              for (var h = 0, u = a.continuationClasses.length; h < u; h++) {
                var f = this.rules[a.continuationClasses[h]];
                f && (s = s.concat(this._applyRule(c, f)));
              }
          }
        }
        return s;
      },
      check: function(n) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        var r = n.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
        if (this.checkExact(r))
          return !0;
        if (r.toUpperCase() === r) {
          var i = r[0] + r.substring(1).toLowerCase();
          if (this.hasFlag(i, "KEEPCASE"))
            return !1;
          if (this.checkExact(i) || this.checkExact(r.toLowerCase()))
            return !0;
        }
        var s = r[0].toLowerCase() + r.substring(1);
        if (s !== r) {
          if (this.hasFlag(s, "KEEPCASE"))
            return !1;
          if (this.checkExact(s))
            return !0;
        }
        return !1;
      },
      checkExact: function(n) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        var r = this.dictionaryTable[n], i, s;
        if (typeof r > "u") {
          if ("COMPOUNDMIN" in this.flags && n.length >= this.flags.COMPOUNDMIN) {
            for (i = 0, s = this.compoundRules.length; i < s; i++)
              if (n.match(this.compoundRules[i]))
                return !0;
          }
        } else {
          if (r === null)
            return !0;
          if (typeof r == "object") {
            for (i = 0, s = r.length; i < s; i++)
              if (!this.hasFlag(n, "ONLYINCOMPOUND", r[i]))
                return !0;
          }
        }
        return !1;
      },
      hasFlag: function(n, r, i) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        return !!(r in this.flags && (typeof i > "u" && (i = Array.prototype.concat.apply([], this.dictionaryTable[n])), i && i.indexOf(this.flags[r]) !== -1));
      },
      alphabet: "",
      suggest: function(n, r) {
        if (!this.loaded)
          throw "Dictionary not loaded.";
        if (r = r || 5, this.memoized.hasOwnProperty(n)) {
          var i = this.memoized[n].limit;
          if (r <= i || this.memoized[n].suggestions.length < i)
            return this.memoized[n].suggestions.slice(0, r);
        }
        if (this.check(n))
          return [];
        for (var s = 0, o = this.replacementTable.length; s < o; s++) {
          var l = this.replacementTable[s];
          if (n.indexOf(l[0]) !== -1) {
            var a = n.replace(l[0], l[1]);
            if (this.check(a))
              return [a];
          }
        }
        if (!this.alphabet) {
          this.alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "TRY" in this.flags && (this.alphabet += this.flags.TRY), "WORDCHARS" in this.flags && (this.alphabet += this.flags.WORDCHARS);
          var c = this.alphabet.split("");
          c.sort();
          for (var h = {}, s = 0; s < c.length; s++)
            h[c[s]] = !0;
          this.alphabet = "";
          for (var s in h)
            this.alphabet += s;
        }
        var u = this;
        function f(p, g) {
          var m = {}, O, b, y, w, S = u.alphabet.length;
          if (typeof p == "string") {
            var x = p;
            p = {}, p[x] = !0;
          }
          for (var x in p)
            for (O = 0, y = x.length + 1; O < y; O++) {
              var v = [x.substring(0, O), x.substring(O)];
              if (v[1] && (w = v[0] + v[1].substring(1), (!g || u.check(w)) && (w in m ? m[w] += 1 : m[w] = 1)), v[1].length > 1 && v[1][1] !== v[1][0] && (w = v[0] + v[1][1] + v[1][0] + v[1].substring(2), (!g || u.check(w)) && (w in m ? m[w] += 1 : m[w] = 1)), v[1]) {
                var P = v[1].substring(0, 1).toUpperCase() === v[1].substring(0, 1) ? "uppercase" : "lowercase";
                for (b = 0; b < S; b++) {
                  var D = u.alphabet[b];
                  P === "uppercase" && (D = D.toUpperCase()), D != v[1].substring(0, 1) && (w = v[0] + D + v[1].substring(1), (!g || u.check(w)) && (w in m ? m[w] += 1 : m[w] = 1));
                }
              }
              if (v[1])
                for (b = 0; b < S; b++) {
                  var P = v[0].substring(-1).toUpperCase() === v[0].substring(-1) && v[1].substring(0, 1).toUpperCase() === v[1].substring(0, 1) ? "uppercase" : "lowercase", D = u.alphabet[b];
                  P === "uppercase" && (D = D.toUpperCase()), w = v[0] + D + v[1], (!g || u.check(w)) && (w in m ? m[w] += 1 : m[w] = 1);
                }
            }
          return m;
        }
        function d(p) {
          var g = f(p), m = f(g, !0), O = m;
          for (var b in g)
            !u.check(b) || (b in O ? O[b] += g[b] : O[b] = g[b]);
          var y, w = [];
          for (y in O)
            O.hasOwnProperty(y) && w.push([y, O[y]]);
          function S(D, Q) {
            var R = D[1], N = Q[1];
            return R < N ? -1 : R > N ? 1 : Q[0].localeCompare(D[0]);
          }
          w.sort(S).reverse();
          var x = [], v = "lowercase";
          p.toUpperCase() === p ? v = "uppercase" : p.substr(0, 1).toUpperCase() + p.substr(1).toLowerCase() === p && (v = "capitalized");
          var P = r;
          for (y = 0; y < Math.min(P, w.length); y++)
            v === "uppercase" ? w[y][0] = w[y][0].toUpperCase() : v === "capitalized" && (w[y][0] = w[y][0].substr(0, 1).toUpperCase() + w[y][0].substr(1)), !u.hasFlag(w[y][0], "NOSUGGEST") && x.indexOf(w[y][0]) == -1 ? x.push(w[y][0]) : P++;
          return x;
        }
        return this.memoized[n] = {
          suggestions: d(n),
          limit: r
        }, this.memoized[n].suggestions;
      }
    };
  })(), t.exports = e;
})(NC);
const U7 = NC.exports, qC = L.define({
  combine: (t) => t[t.length - 1]
}), F7 = I.mark({
  class: "cm-error"
}), G7 = (t) => Object.keys(t.rules).length > 0;
function Kb(t) {
  var s, o;
  let e = ((s = t.visibleRanges[0]) == null ? void 0 : s.from) || 0, n = ((o = t.visibleRanges[0]) == null ? void 0 : o.to) || void 0;
  const r = new et(), i = t.state.facet(qC);
  return G7(i) && t.state.doc.sliceString(e, n).replaceAll(/\w+/g, (l, a) => !i.check(l) && r.add(e + a, e + a + l.length, F7)), r.finish();
}
const H7 = ke.fromClass(class {
  constructor(t) {
    this.decorations = Kb(t);
  }
  update(t) {
    (t.docChanged || t.viewportChanged) && (this.decorations = Kb(t.view));
  }
}, {
  decorations: (t) => t.decorations
});
function J7(t) {
  if (!t)
    return [];
  let {
    dict: e = "en_US",
    dictionaryPath: n = "/dictionaries"
  } = t;
  return [qC.of(new U7(e, null, null, {
    dictionaryPath: n
  })), H7];
}
const K7 = "cm-link", e4 = [{
  target: /`[^`\n]+`/g,
  cssClass: "cm-mono"
}];
function ey(t, e, n, r) {
  var a, c;
  let i = ((a = t.visibleRanges[0]) == null ? void 0 : a.from) || 0, s = ((c = t.visibleRanges[0]) == null ? void 0 : c.to) || void 0;
  const o = new et(), l = t.state.doc.sliceString(i, s);
  return e.flatMap((h) => {
    const u = h.id ? t.state.doc.line(parseInt(r.get(h.id))).text : l, f = h.id ? t.state.doc.line(parseInt(r.get(h.id))).from : i;
    return [...u.matchAll(h.target)].map((d) => ({
      match: d,
      hl: {
        ...h,
        from: f
      }
    }));
  }).sort((h, u) => h.hl.from + h.match.index - (u.hl.from + u.match.index)).forEach(({
    hl: h,
    match: u
  }) => {
    let f = {
      class: K7
    };
    h.cssClass && (f.class = h.cssClass);
    let d;
    n && (d = n({
      builder: o,
      from: h.from,
      match: u,
      hl: h,
      markParams: f,
      view: t
    })), o.add(h.from + u.index, h.from + u.index + u[0].length, I.mark(f)), d == null || d();
  }), o.finish();
}
const _m = (t, e, n) => {
  t || (t = []);
  const r = t.concat(e4);
  return ke.fromClass(class {
    constructor(i) {
      this.decorations = ey(i, r, e, n);
    }
    update(i) {
      (i.docChanged || i.viewportChanged) && (this.decorations = ey(i.view, r, e, n));
    }
  }, {
    decorations: (i) => i.decorations
  });
}, BC = /* @__PURE__ */ new Map();
class t4 {
  constructor(e) {
    this.room = e, this.onmessage = null, this._onChange = (n) => n.key === e && this.onmessage !== null && this.onmessage({ data: zZ(n.newValue || "") }), SZ(this._onChange);
  }
  postMessage(e) {
    IS.setItem(this.room, WZ(qZ(e)));
  }
  close() {
    _Z(this._onChange);
  }
}
const n4 = typeof BroadcastChannel > "u" ? t4 : BroadcastChannel, Cm = (t) => mr(BC, t, () => {
  const e = Ai(), n = new n4(t);
  return n.onmessage = (r) => e.forEach((i) => i(r.data, "broadcastchannel")), {
    bc: n,
    subs: e
  };
}), r4 = (t, e) => (Cm(t).subs.add(e), e), i4 = (t, e) => {
  const n = Cm(t), r = n.subs.delete(e);
  return r && n.subs.size === 0 && (n.bc.close(), BC.delete(t)), r;
}, Hi = (t, e, n = null) => {
  const r = Cm(t);
  r.bc.postMessage(e), r.subs.forEach((i) => i(e, n));
}, YC = 0, Am = 1, jC = 2, Lp = (t, e) => {
  U(t, YC);
  const n = PI(e);
  Re(t, n);
}, XC = (t, e, n) => {
  U(t, Am), Re(t, _I(e, n));
}, s4 = (t, e, n) => XC(e, n, ct(t)), WC = (t, e, n) => {
  try {
    xI(e, ct(t), n);
  } catch (r) {
    console.error("Caught error while handling a Yjs update", r);
  }
}, o4 = (t, e) => {
  U(t, jC), Re(t, e);
}, l4 = WC, a4 = (t, e, n, r) => {
  const i = J(t);
  switch (i) {
    case YC:
      s4(t, e, n);
      break;
    case Am:
      WC(t, n, r);
      break;
    case jC:
      l4(t, n, r);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return i;
}, c4 = 0, h4 = (t, e, n) => {
  switch (J(t)) {
    case c4:
      n(e, Zr(t));
  }
}, Pf = 3e4;
class zC extends Gh {
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = setInterval(() => {
      const n = zr();
      this.getLocalState() !== null && Pf / 2 <= n - this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const r = [];
      this.meta.forEach((i, s) => {
        s !== this.clientID && Pf <= n - i.lastUpdated && this.states.has(s) && r.push(s);
      }), r.length > 0 && $m(this, r, "timeout");
    }, pr(Pf / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  setLocalState(e) {
    const n = this.clientID, r = this.meta.get(n), i = r === void 0 ? 0 : r.clock + 1, s = this.states.get(n);
    e === null ? this.states.delete(n) : this.states.set(n, e), this.meta.set(n, {
      clock: i,
      lastUpdated: zr()
    });
    const o = [], l = [], a = [], c = [];
    e === null ? c.push(n) : s == null ? e != null && o.push(n) : (l.push(n), qo(s, e) || a.push(n)), (o.length > 0 || a.length > 0 || c.length > 0) && this.emit("change", [{ added: o, updated: a, removed: c }, "local"]), this.emit("update", [{ added: o, updated: l, removed: c }, "local"]);
  }
  setLocalStateField(e, n) {
    const r = this.getLocalState();
    r !== null && this.setLocalState({
      ...r,
      [e]: n
    });
  }
  getStates() {
    return this.states;
  }
}
const $m = (t, e, n) => {
  const r = [];
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (t.states.has(s)) {
      if (t.states.delete(s), s === t.clientID) {
        const o = t.meta.get(s);
        t.meta.set(s, {
          clock: o.clock + 1,
          lastUpdated: zr()
        });
      }
      r.push(s);
    }
  }
  r.length > 0 && (t.emit("change", [{ added: [], updated: [], removed: r }, n]), t.emit("update", [{ added: [], updated: [], removed: r }, n]));
}, jo = (t, e, n = t.states) => {
  const r = e.length, i = ht();
  U(i, r);
  for (let s = 0; s < r; s++) {
    const o = e[s], l = n.get(o) || null, a = t.meta.get(o).clock;
    U(i, o), U(i, a), yi(i, JSON.stringify(l));
  }
  return Qe(i);
}, u4 = (t, e, n) => {
  const r = Hr(e), i = zr(), s = [], o = [], l = [], a = [], c = J(r);
  for (let h = 0; h < c; h++) {
    const u = J(r);
    let f = J(r);
    const d = JSON.parse(Zr(r)), p = t.meta.get(u), g = t.states.get(u), m = p === void 0 ? 0 : p.clock;
    (m < f || m === f && d === null && t.states.has(u)) && (d === null ? u === t.clientID && t.getLocalState() != null ? f++ : t.states.delete(u) : t.states.set(u, d), t.meta.set(u, {
      clock: f,
      lastUpdated: i
    }), p === void 0 && d !== null ? s.push(u) : p !== void 0 && d === null ? a.push(u) : d !== null && (qo(d, g) || l.push(u), o.push(u)));
  }
  (s.length > 0 || l.length > 0 || a.length > 0) && t.emit("change", [{
    added: s,
    updated: l,
    removed: a
  }, n]), (s.length > 0 || o.length > 0 || a.length > 0) && t.emit("update", [{
    added: s,
    updated: o,
    removed: a
  }, n]);
}, f4 = (t) => PZ(t, (e, n) => `${encodeURIComponent(n)}=${encodeURIComponent(e)}`).join("&"), pi = 0, VC = 3, ds = 1, d4 = 2, Jl = [];
Jl[pi] = (t, e, n, r, i) => {
  U(t, pi);
  const s = a4(
    e,
    t,
    n.doc,
    n
  );
  r && s === Am && !n.synced && (n.synced = !0);
};
Jl[VC] = (t, e, n, r, i) => {
  U(t, ds), Re(
    t,
    jo(
      n.awareness,
      Array.from(n.awareness.getStates().keys())
    )
  );
};
Jl[ds] = (t, e, n, r, i) => {
  u4(
    n.awareness,
    ct(e),
    n
  );
};
Jl[d4] = (t, e, n, r, i) => {
  h4(
    e,
    n.doc,
    (s, o) => p4(n, o)
  );
};
const ty = 3e4, p4 = (t, e) => console.warn(`Permission denied to access ${t.url}.
${e}`), UC = (t, e, n) => {
  const r = Hr(e), i = ht(), s = J(r), o = t.messageHandlers[s];
  return o ? o(i, r, t, n, s) : console.error("Unable to compute message"), i;
}, FC = (t) => {
  if (t.shouldConnect && t.ws === null) {
    const e = new t._WS(t.url);
    e.binaryType = "arraybuffer", t.ws = e, t.wsconnecting = !0, t.wsconnected = !1, t.synced = !1, e.onmessage = (n) => {
      t.wsLastMessageReceived = zr();
      const r = UC(t, new Uint8Array(n.data), !0);
      Gg(r) > 1 && e.send(Qe(r));
    }, e.onerror = (n) => {
      t.emit("connection-error", [n, t]);
    }, e.onclose = (n) => {
      t.emit("connection-close", [n, t]), t.ws = null, t.wsconnecting = !1, t.wsconnected ? (t.wsconnected = !1, t.synced = !1, $m(
        t.awareness,
        Array.from(t.awareness.getStates().keys()).filter(
          (r) => r !== t.doc.clientID
        ),
        t
      ), t.emit("status", [{
        status: "disconnected"
      }])) : t.wsUnsuccessfulReconnects++, setTimeout(
        FC,
        Hh(
          WR(2, t.wsUnsuccessfulReconnects) * 100,
          t.maxBackoffTime
        ),
        t
      );
    }, e.onopen = () => {
      t.wsLastMessageReceived = zr(), t.wsconnecting = !1, t.wsconnected = !0, t.wsUnsuccessfulReconnects = 0, t.emit("status", [{
        status: "connected"
      }]);
      const n = ht();
      if (U(n, pi), Lp(n, t.doc), e.send(Qe(n)), t.awareness.getLocalState() !== null) {
        const r = ht();
        U(r, ds), Re(
          r,
          jo(t.awareness, [
            t.doc.clientID
          ])
        ), e.send(Qe(r));
      }
    }, t.emit("status", [{
      status: "connecting"
    }]);
  }
}, Tf = (t, e) => {
  const n = t.ws;
  t.wsconnected && n && n.readyState === n.OPEN && n.send(e), t.bcconnected && Hi(t.bcChannel, e, t);
};
class GC extends Gh {
  constructor(e, n, r, {
    connect: i = !0,
    awareness: s = new zC(r),
    params: o = {},
    WebSocketPolyfill: l = WebSocket,
    resyncInterval: a = -1,
    maxBackoffTime: c = 2500,
    disableBc: h = !1
  } = {}) {
    for (super(); e[e.length - 1] === "/"; )
      e = e.slice(0, e.length - 1);
    const u = f4(o);
    this.maxBackoffTime = c, this.bcChannel = e + "/" + n, this.url = e + "/" + n + (u.length === 0 ? "" : "?" + u), this.roomname = n, this.doc = r, this._WS = l, this.awareness = s, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = h, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = Jl.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = i, this._resyncInterval = 0, a > 0 && (this._resyncInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        const f = ht();
        U(f, pi), Lp(f, r), this.ws.send(Qe(f));
      }
    }, a)), this._bcSubscriber = (f, d) => {
      if (d !== this) {
        const p = UC(this, new Uint8Array(f), !1);
        Gg(p) > 1 && Hi(this.bcChannel, Qe(p), this);
      }
    }, this._updateHandler = (f, d) => {
      if (d !== this) {
        const p = ht();
        U(p, pi), o4(p, f), Tf(this, Qe(p));
      }
    }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({ added: f, updated: d, removed: p }, g) => {
      const m = f.concat(d).concat(p), O = ht();
      U(O, ds), Re(
        O,
        jo(s, m)
      ), Tf(this, Qe(O));
    }, this._unloadHandler = () => {
      $m(
        this.awareness,
        [r.clientID],
        "window unload"
      );
    }, typeof window < "u" ? window.addEventListener("unload", this._unloadHandler) : typeof process < "u" && process.on("exit", this._unloadHandler), s.on("update", this._awarenessUpdateHandler), this._checkInterval = setInterval(() => {
      this.wsconnected && ty < zr() - this.wsLastMessageReceived && this.ws.close();
    }, ty / 10), i && this.connect();
  }
  get synced() {
    return this._synced;
  }
  set synced(e) {
    this._synced !== e && (this._synced = e, this.emit("synced", [e]), this.emit("sync", [e]));
  }
  destroy() {
    this._resyncInterval !== 0 && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), typeof window < "u" ? window.removeEventListener("unload", this._unloadHandler) : typeof process < "u" && process.off("exit", this._unloadHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy();
  }
  connectBc() {
    if (this.disableBc)
      return;
    this.bcconnected || (r4(this.bcChannel, this._bcSubscriber), this.bcconnected = !0);
    const e = ht();
    U(e, pi), Lp(e, this.doc), Hi(this.bcChannel, Qe(e), this);
    const n = ht();
    U(n, pi), XC(n, this.doc), Hi(this.bcChannel, Qe(n), this);
    const r = ht();
    U(r, VC), Hi(
      this.bcChannel,
      Qe(r),
      this
    );
    const i = ht();
    U(i, ds), Re(
      i,
      jo(this.awareness, [
        this.doc.clientID
      ])
    ), Hi(
      this.bcChannel,
      Qe(i),
      this
    );
  }
  disconnectBc() {
    const e = ht();
    U(e, ds), Re(
      e,
      jo(this.awareness, [
        this.doc.clientID
      ], /* @__PURE__ */ new Map())
    ), Tf(this, Qe(e)), this.bcconnected && (i4(this.bcChannel, this._bcSubscriber), this.bcconnected = !1);
  }
  disconnect() {
    this.shouldConnect = !1, this.disconnectBc(), this.ws !== null && this.ws.close();
  }
  connect() {
    this.shouldConnect = !0, !this.wsconnected && this.ws === null && (FC(this), this.connectBc());
  }
}
G.define();
const HC = new Mi();
function g4(t) {
  return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function m4({
  commentId: t,
  text: e,
  color: n
}) {
  const r = [];
  for (; e !== ""; ) {
    e = e.slice(e.indexOf("|") + 1);
    const i = e.indexOf("|");
    if (i === -1)
      break;
    let s = e.slice(0, i), o = "";
    s.includes("->") && (o = s.slice(s.indexOf("->") + 2).trimStart(), s = s.slice(0, s.indexOf("->")).trimEnd()), s.length !== 0 && r.push({
      targetRegexSrc: `(?<=^|[ \\t\\r\\.]|\\b)${g4(s)}(?=$|[\\s\\.]|\\b)`,
      targetRegexFlags: "gm",
      id: t,
      cssClass: "cm-suggestion",
      replacement: o,
      color: n
    }), e = e.slice(i + 1);
  }
  return r;
}
function O4({
  builder: t,
  from: e,
  match: n,
  hl: r,
  markParams: i,
  view: s
}) {
  if (r.color && (i.attributes = {
    style: `color: ${r.color}`
  }), r.replacement)
    return i.class += " replaced", () => {
      t.add(e + n.index + n[0].length, e + n.index + n[0].length, I.widget({
        widget: new b4({
          text: r.replacement,
          color: r.color,
          from: e + n.index,
          to: e + n.index + n[0].length,
          view: s
        })
      }));
    };
}
class b4 extends Tt {
  constructor({
    text: e,
    color: n,
    from: r,
    to: i,
    view: s
  }) {
    super(), this.text = e, this.color = n, this.from = r, this.to = i, this.view = s;
  }
  toDOM() {
    const e = document.createElement("span");
    return e.innerText = this.text, e.style.color = this.color, e.classList.add("cm-replacement"), e.title = "Accept suggestion", e.addEventListener("mouseup", () => {
      this.view.dispatch({
        changes: {
          from: this.from,
          to: this.to,
          insert: this.text
        }
      });
    }), e;
  }
}
const y4 = () => "comment-" + Math.random().toString().replace(".", "");
class w4 {
  constructor(e, n, r, i) {
    this.user = n.awareness.getLocalState().user, this.lineAuthors = e.getArray(i + "/commentLineAuthors"), this.ydoc = e, this.getAvatar = r, this.commentId = i;
  }
  get(e) {
    var r;
    const n = (r = this.lineAuthors.get(e - 1)) == null ? void 0 : r.get("author");
    if (!!n)
      return n.avatar = this.getAvatar(n.name), n;
  }
  appendFrom(e) {
    this.lineAuthors.length !== 0 && this.lineAuthors.delete(this.lineAuthors.length - 1), this.lineAuthors.push(e.toArray().map((n) => n.clone()));
  }
  delete() {
    this.lineAuthors.delete(0, this.lineAuthors.length);
  }
  mark(e) {
    for (; e >= this.lineAuthors.length; )
      this.lineAuthors.push([new ar()]);
    this.lineAuthors.get(e - 1).set("author", this.user);
  }
  remove(e, n) {
    this.lineAuthors.delete(e - 1, n);
  }
  insert(e, n) {
    e - 1 > this.lineAuthors.length && this.lineAuthors.push(
      [...Array(e - 1 - this.lineAuthors.length).keys()].map((r) => new ar())
    ), this.lineAuthors.insert(e - 1, [...Array(n).keys()].map((r) => new ar([["author", this.user]])));
  }
  firstLineOfSection(e) {
    const n = this.get(e).name;
    return this.lineAuthors.slice(0, e).map((r, i) => ({
      ...r.get("author"),
      lineNumber: i + 1
    })).reduceRight(
      (r, {
        name: i,
        lineNumber: s
      }) => i == n && s == r - 1 ? s : r,
      e
    );
  }
}
class k4 {
  constructor(e, n) {
    this.commentPositions = e.getMap(Xo.dataPath), this.ycomments = n;
  }
  iter() {
    return [...this.commentPositions.entries()].map(([e, n]) => ({
      commentId: e,
      lineNumber: parseInt(n)
    }));
  }
  move(e, n, r = !0) {
    n > 0 && !this.isOccupied(n) && this.commentPositions.set(e, n), r && this.ycomments.syncSuggestions(e);
  }
  shift(e, n, r, i) {
    n < 0 && this.iter().filter((o) => e + n < o.lineNumber && o.lineNumber <= e).forEach((o) => this.del(o.commentId));
    const s = this.iter().filter((o) => i ? o.lineNumber > e : o.lineNumber >= e).filter((o) => o.lineNumber + n <= r);
    s.forEach((o) => this.move(o.commentId, o.lineNumber + n, !1)), this.ycomments.syncSuggestions(...s.map((o) => o.commentId));
  }
  isOccupied(e) {
    return this.iter().some((n) => n.lineNumber == e);
  }
  get(e) {
    return this.commentPositions.get(e);
  }
  set(e, n) {
    return this.commentPositions.set(e, n);
  }
  del(e) {
    this.commentPositions.delete(e);
  }
}
class x4 {
  constructor() {
    this.comments = {}, this._onUpdate = () => {
    };
  }
  onUpdate(e) {
    this._onUpdate = e;
  }
  switchVisibility(e) {
    const r = !this.isShown(e);
    return this.setVisibility(e, r), r;
  }
  setVisibility(e, n) {
    this.update((r) => (r[e] || (r[e] = {}), r[e].isShown = n, r));
  }
  setHeight(e, n) {
    this.update((r) => (r[e] || (r[e] = {}), r[e].height = n, r));
  }
  offset(e) {
    return this.comments[e].top;
  }
  isShown(e) {
    return this.comments[e] ? this.comments[e].isShown && this.comments[e].top : !0;
  }
  del(e) {
    this.update((n) => (delete n[e], n));
  }
  new(e) {
    this.update((n) => (n[e] = {
      height: 18,
      isShown: !1
    }, n));
  }
  update(e) {
    e && (this.comments = e(this.comments)), this._onUpdate();
  }
  show(e) {
    this.setVisibility(e, !0);
  }
}
class v4 {
  constructor(e, n) {
    this.user = e.awareness.getLocalState().user, this.resolvedComments = n.getMap("resolved-comments");
  }
  resolve(e, n, r, i) {
    this.resolvedComments.set(e, JSON.stringify({
      resolvedLine: n,
      lineNumber: r,
      resolvedBy: this.user,
      resolvedDate: Date.now(),
      pos: i
    }));
  }
  delete(e) {
    this.resolvedComments.delete(e);
  }
  resolved() {
    return [...this.resolvedComments.entries()].map(([e, n]) => ({
      commentId: e,
      ...JSON.parse(n)
    }));
  }
  updateComment(e, n) {
    this.resolvedComments.set(e, JSON.stringify({
      ...JSON.parse(this.resolvedComments.get(e)),
      ...n
    }));
  }
  onUpdate(e) {
    this.resolvedComments.observe(() => e(this.resolved()));
  }
}
const Jm = class {
  constructor(e, n, r) {
    this.ydoc = e, this.provider = n, this.getAvatar = r, this.mainCodeMirror = null, this.newLocalComment = !1, this.positionManager = new k4(e, this), this.displayManager = new x4(n), this.commentResolver = new v4(n, e), this.draggedComment = null, this.commentWithPopup = null, this.suggestions = e.getMap("suggestions"), this.suggestions.observe(() => {
      if (!this.mainCodeMirror)
        return;
      const i = [...this.suggestions.values()].flat().map((s) => ({
        ...s,
        target: new RegExp(s.targetRegexSrc, s.targetRegexFlags)
      }));
      this.mainCodeMirror.dispatch({
        effects: HC.reconfigure(_m(i, O4, this.positions())),
        annotations: je.userEvent.of("suggestion")
      });
    }), this.positionManager.commentPositions.observeDeep(() => this.updateMainCodeMirror());
  }
  lineAuthors(e) {
    return new w4(this.ydoc, this.provider, this.getAvatar, e);
  }
  positions() {
    return this.positionManager;
  }
  display() {
    return this.displayManager;
  }
  resolver() {
    return this.commentResolver;
  }
  registerCodeMirror(e) {
    this.mainCodeMirror = e;
  }
  marginLeft() {
    return this.mainCodeMirror.dom.querySelector(".cm-gutters").offsetWidth;
  }
  getTextForComment(e) {
    return this.ydoc.getText(Jm.commentsPrefix + e);
  }
  delText(e) {
    let n = this.getTextForComment(e);
    n != null && n.parent && n.delete();
  }
  newComment(e) {
    const n = y4();
    return this.positions().set(n, e.toString()), this.display().new(n), this.lineAuthors(n).mark(1), this.newLocalComment = !0, n;
  }
  deleteComment(e) {
    this.positions().del(e), this.display().del(e), this.delText(e), this.suggestions.set(e, []);
  }
  resolveComment(e) {
    const n = this.positions().get(e), r = this.mainCodeMirror.state.doc.line(n).from;
    this.positions().del(e), this.display().del(e);
    const i = this.mainCodeMirror.state.doc.line(n);
    this.resolver().resolve(e, i.text, n, r);
  }
  isEmpty(e) {
    return this.getTextForComment(e).length === 0;
  }
  findCommentOn(e) {
    return this.positions().iter().find((n) => n.lineNumber == e);
  }
  parentLineHeight(e) {
    var i, s;
    let n = (i = this.mainCodeMirror.dom.querySelector("#" + e)) == null ? void 0 : i.previousSibling;
    if (n)
      return n.clientHeight;
    let r = this.positionManager.get(e);
    return (s = [...this.mainCodeMirror.dom.querySelectorAll(".cm-gutterElement")].find((o) => o.textContent == r)) == null ? void 0 : s.clientHeight;
  }
  updateHeight(e, n) {
    this.display().setHeight(e, n), this.updateMainCodeMirror();
  }
  syncCommentLocations(e) {
    this.display().update(
      (n) => (e.view.dom.querySelectorAll(".comment-box").forEach((r) => {
        var i;
        n[i = r.id] || (n[i] = {}), n[r.id].top = r.offsetTop;
      }), n)
    );
  }
  syncRemoteComments() {
    this.display().update((e) => (this.positions().iter().filter((n) => !e[n.commentId] || e[n.commentId].isShown == null).forEach((n) => {
      e[n.commentId] = {
        isShown: !0,
        height: 17
      }, this.updateMainCodeMirror();
    }), e));
  }
  removeLocalComments() {
    let e = this.positions().iter().map((n) => n.commentId);
    this.display().update((n) => {
      for (let r in n)
        e.includes(r) || (delete n[r], this.suggestions.set(r, []));
      return n;
    });
  }
  syncComments(e) {
    e.transactions.some((n) => n.isUserEvent("suggestion")) || (this.syncCommentLocations(e), this.syncRemoteComments(), this.removeLocalComments(), this.syncResolvedComments(e));
  }
  iterComments() {
    const e = ({
      lineNumber: n,
      commentId: r
    }) => ({
      ...this.displayManager.comments[r],
      lineNumber: n,
      commentId: r
    });
    return this.positions().iter().map(e);
  }
  syncSuggestions(...e) {
    let n = {};
    for (const r of e) {
      const i = this.getTextForComment(r).toString();
      parseInt(this.positions().get(r));
      const s = this.lineAuthors(r), o = i.split(`
`).map((l, a) => {
        var c, h;
        return {
          text: l,
          commentId: r,
          color: (h = (c = s.get(a + 1)) == null ? void 0 : c.color) != null ? h : "#111"
        };
      });
      n[r] = o.flatMap(m4);
    }
    this.suggestions.doc.transact(() => {
      for (const [r, i] of Object.entries(n))
        this.suggestions.set(r, i);
    });
  }
  updateMainCodeMirror() {
    this.mainCodeMirror ? this.mainCodeMirror.dispatch({
      effects: $l.of(null)
    }) : console.warn("[YComments] Failed to update the main CodeMirror instance since it doesn't exist.");
  }
  syncResolvedComments(e) {
    if (!e.docChanged && !e.transactions.some((r) => r.effects.some((i) => i.is($l))))
      return;
    const n = this.resolver().resolved();
    for (const r of n) {
      let i = !0;
      if (e.changes.iterChanges((h) => {
        e.startState.doc.lineAt(h).number <= r.lineNumber && (i = !1);
      }), r.occupied !== this.positions().isOccupied(r.lineNumber) && (i = !1), i)
        continue;
      const s = e.startState.doc.line(r.lineNumber).from, o = e.changes.mapPos(s, 1), l = e.state.doc.lineAt(o).number, a = e.changes.mapPos(s, 1, We.TrackDel) == null, c = e.changes.mapPos(s, 1, We.TrackBefore) == null && e.startState.doc.line(r.lineNumber).text == "";
      if (a || c) {
        this.resolver().updateComment(r.commentId, {
          orphaned: !0
        });
        continue;
      }
      if (this.resolver().updateComment(r.commentId, {
        occupied: this.positions().isOccupied(l)
      }), !r.orphaned) {
        this.resolver().updateComment(r.commentId, {
          lineNumber: l
        });
        const h = e.state.doc.line(l).text;
        this.resolver().updateComment(r.commentId, {
          resolvedLine: h
        });
      }
    }
  }
  restoreComment(e) {
    const n = this.lineAuthors(e.commentId), r = this.getTextForComment(e.commentId), i = e.orphaned ? this.mainCodeMirror.state.doc.lines : e.lineNumber;
    if (this.resolver().delete(e.commentId), this.positions().isOccupied(i)) {
      const s = this.findCommentOn(i).commentId;
      this.lineAuthors(s).appendFrom(n.lineAuthors);
      const o = this.getTextForComment(s);
      o.insert(o.length, `
` + r.toString()), this.display().setVisibility(s, !0);
    } else {
      const s = this.newComment(i);
      this.lineAuthors(s).delete(), this.lineAuthors(s).appendFrom(n.lineAuthors), this.getTextForComment(s).insert(0, r.toString()), this.display().setVisibility(s, !0);
    }
  }
  moveOrMerge(e, n) {
    if (!this.positions().isOccupied(n))
      this.positions().move(e, n);
    else {
      const r = this.findCommentOn(n).commentId;
      this.lineAuthors(r).appendFrom(this.lineAuthors(e).lineAuthors);
      const i = this.getTextForComment(r);
      i.insert(i.length, `
` + this.getTextForComment(e).toString()), this.deleteComment(e), this.display().setVisibility(r, !0);
    }
  }
};
let Xo = Jm;
lo(Xo, "commentsPrefix", "comments/");
const au = L.define({
  combine: (t) => t[t.length - 1],
  static: !0
}), $l = G.define();
class S4 extends Tt {
  constructor(e, n, r) {
    super(), this.height = e, this.commentId = n, this.isShown = r;
  }
  toDOM() {
    const e = document.createElement("div");
    return e.id = this.commentId, e.classList = "comment-box", this.isShown || (e.classList += " comment-box-hidden"), e.style.height = this.height + "px", e;
  }
}
const _4 = (t, e, n) => I.widget({
  widget: new S4(t, e, n),
  side: 1e4,
  inlineOrder: !1,
  block: n
}), C4 = (t, e) => t.lineNumber - e.lineNumber, A4 = (t) => t.docChanged || t.effects.some((e) => e.is($l)), $4 = (t) => [(e, {
  commentId: n,
  lineNumber: r,
  height: i,
  isShown: s
}) => {
  try {
    const o = t.newDoc.line(r).to;
    e.add(o, o, _4(i, n, s));
  } catch (o) {
    console.warn(o), console.warn(`An error occured when rendering comment ${n}. Comment will not be shown.`);
  }
  return e;
}, new et()], P4 = (t, e) => {
  if (t.isUserEvent("input") || t.isUserEvent("delete")) {
    const n = t.state.doc.lines - t.startState.doc.lines;
    if (n != 0 && t.selection != null) {
      const r = t.state.doc.lines, i = t.state.doc.lineAt(t.selection.main.from).number - n, s = t.selection.main.from === t.state.doc.lineAt(t.selection.main.from).to;
      e.positions().shift(i, n, r, s);
    }
  }
}, T4 = Me.define({
  create() {
    return new et().finish();
  },
  update(t, e) {
    if (A4(e)) {
      const n = e.state.facet(au);
      return P4(e, n), n.iterComments().sort(C4).reduce(...$4(e)).finish();
    }
    return t;
  },
  provide(t) {
    return T.decorations.from(t);
  }
}), ci = class extends Ht {
  constructor(e, n) {
    var r;
    super(), this.gutterMarker = null, this.icon = null, n && e && (this.ycomments = n.state.facet(au), this.lineNumber = n.state.doc.lineAt(e.to).number, this.commentId = (r = this.ycomments.findCommentOn(this.lineNumber)) == null ? void 0 : r.commentId);
  }
  hasComments() {
    return Boolean(this.commentId);
  }
  createGutterMarker() {
    this.gutterMarker = document.createElement("div"), this.gutterMarker.classList.add(ci.MAIN_CLASS), this.lineNumber && (this.gutterMarker.style.width = this.lineNumber.toString().length * 7 + "px", this.gutterMarker.ondrop = () => this.ycomments.moveOrMerge(this.ycomments.draggedComment, this.lineNumber), this.gutterMarker.ondragover = (e) => e.preventDefault());
  }
  createPopupIcon() {
    this.icon = document.createElement("section"), this.icon.classList = ci.ICON_CLASS, !this.draggedComment && !this.commentId ? (this.icon.onmouseenter = () => this.icon.classList.add(ci.COMMENT_IMAGE_CLASS), this.icon.onmouseleave = () => this.icon.classList.remove(ci.COMMENT_IMAGE_CLASS)) : (this.icon.onmouseup = () => this.ycomments.display().switchVisibility(this.commentId), this.icon.onmouseenter = () => {
      this.ycomments.commentWithPopup = this.commentId, this.ycomments.updateMainCodeMirror();
    });
  }
  markHasComments() {
    this.icon.classList.add(ci.COMMENT_IMAGE_CLASS);
  }
  toDOM() {
    return this.createGutterMarker(), this.createPopupIcon(), this.hasComments() && this.markHasComments(), this.gutterMarker.appendChild(this.icon), this.gutterMarker;
  }
};
let ai = ci;
lo(ai, "MAIN_CLASS", "comment-gutter"), lo(ai, "ICON_CLASS", "comment-gutter-icon"), lo(ai, "COMMENT_IMAGE_CLASS", "comment-image");
const Q4 = (t, e, n) => {
  var s;
  const r = t.state.doc.lineAt(e.to).number, i = (s = n.findCommentOn(r)) == null ? void 0 : s.commentId;
  return i || n.newComment(r);
}, E4 = qh({
  lineMarker(t, e) {
    return new ai(e, t);
  },
  lineMarkerChange: (t) => t.transactions.some((e) => e.effects.some((n) => n.is($l))),
  initialSpacer: () => new ai(null, null),
  domEventHandlers: {
    mouseup(t, e) {
      let n = t.state.facet(au.reader), r = Q4(t, e, n);
      n.display().switchVisibility(r), t.dispatch({
        effects: $l.of(null)
      });
    }
  }
}), D4 = (t) => [au.of(t), T4, E4, T.updateListener.of((e) => t.syncComments(e))], M4 = (t) => ["input", "delete", "undo", "redo"].some((e) => t.isUserEvent(e)), Pl = L.define({
  combine: (t) => t[t.length - 1],
  static: !0
}), R4 = ke.fromClass(class {
  constructor(t) {
    this.decorations = this.colorEditorLines(t);
  }
  markAuthor(t, e) {
    return I.line({
      attributes: {
        "data-line-number": e,
        style: `
            --bg: ${t.color + "99"};
            border-left: 2px solid ${t.color};
            position: relative;
          `
      },
      class: "cm-comment-author-colored"
    });
  }
  colorEditorLines(t) {
    const e = t.state.facet(Pl), n = new et();
    for (let r = 1; r <= t.state.doc.lines; r++) {
      const i = t.state.doc.line(r), s = e.get(r);
      s && n.add(i.from, i.from, this.markAuthor(s, r));
    }
    return n.finish();
  }
  markLinesEditedInTransaction(t) {
    const e = t.state.facet(Pl);
    t.changes.iterChangedRanges((n, r, i, s) => {
      const o = t.newDoc.lineAt(i), l = t.newDoc.lineAt(s), a = t.newDoc.slice(i, s).toString().trim().length == 0, c = t.state.doc.lines - t.startState.doc.lines;
      if (c > 0 && (a && !l.length ? e.insert(o.number + 1, c) : o.from == i ? e.insert(o.number, c) : (e.insert(o.number, c), e.mark(l.number))), c < 0) {
        const h = t.startState.doc.length > s ? t.startState.doc.lineAt(s) : null;
        a && l.to == i ? e.remove(o.number + 1, -c) : a && !(h != null && h.length) ? e.remove(o.number, -c) : (e.remove(o.number + 1, -c), e.mark(o.number));
      }
      c == 0 && !e.get(o.number) && e.mark(o.number);
    });
  }
  update(t) {
    (t.docChanged || t.viewportChanged) && (t.transactions.filter(M4).forEach((e) => this.markLinesEditedInTransaction(e)), this.decorations = this.colorEditorLines(t.view)), t.view.dom.onmouseleave = () => t.view.dispatch({
      effects: Np.of(null)
    }), t.view.dom.querySelectorAll(".cm-line").forEach((e) => {
      e.onmouseenter = (n) => t.view.dispatch({
        effects: Np.of(parseInt(n.target.dataset.lineNumber))
      });
    });
  }
}, {
  decorations: (t) => t.decorations
}), Np = G.define(), mh = Me.define({
  create() {
    return null;
  },
  update(t, e) {
    var i;
    const n = e.state.facet(Pl), r = (i = e.effects.find((s) => s.is(Np))) == null ? void 0 : i.value;
    return r ? n.firstLineOfSection(r) : null;
  }
});
class ny extends Ht {
  constructor(e, n) {
    super(), n && e && (this.lineNumber = n.state.doc.lineAt(e.to).number, this.lineAuthors = n.state.facet(Pl), this.selectedLine = n.state.facet(mh));
  }
  authorAvatar() {
    const {
      avatar: e
    } = this.lineAuthors.get(this.lineNumber);
    let n = document.createElement("img");
    return n.classList.add("author-avatar"), n.src = e, n;
  }
  toDOM() {
    return this.selectedLine && this.selectedLine == this.lineNumber ? this.authorAvatar() : document.createElement("div");
  }
}
const Z4 = qh({
  lineMarker: (t, e) => new ny(e, t),
  lineMarkerChange: (t) => t.startState.field(mh) != t.state.field(mh),
  initialSpacer: () => new ny(null, null)
}), I4 = (t) => [Pl.of(t), mh.init(null), Z4, R4], L4 = NR.filter((t, e) => e != 3), N4 = qR.filter((t, e) => e != 1), q4 = (t) => {
  const {
    from: e
  } = t.state.selection.main, n = t.state.doc.lineAt(e);
  return {
    line: n.number - 1,
    ch: e - n.from
  };
}, B4 = (t, e) => {
  const {
    line: n,
    ch: r
  } = e, i = t.state.doc.line(n + 1).from + r;
  t.dispatch({
    selection: {
      anchor: i,
      head: i
    },
    scrollIntoView: !0
  });
};
class Ir {
  constructor(e = []) {
    this.important = [re.lineSeparator.of(`
`)], this.base = e, this.extensions = Ir.defaultPlugins();
  }
  static minimalSetup() {
    return new Ir(N4);
  }
  static basicSetup() {
    return new Ir(L4);
  }
  static defaultPlugins() {
    return [T.lineWrapping, B7(), Xx(), sr.of([s5, {
      key: "Mod-Z",
      run: Xc
    }])];
  }
  disable(e) {
    return this.base.push(yn.highest(sr.of(e.map((n) => ({
      key: n,
      run: () => !0
    }))))), this;
  }
  addUpdateListener(e) {
    return this.extensions.push(T.updateListener.of(e)), this;
  }
  useSpellcheck(e) {
    return this.extensions.push(J7(e)), this;
  }
  useHighlighter(e) {
    return this.extensions.push(_m(e)), this;
  }
  useCompartment(e, n) {
    return this.extensions.push(e.of(n)), this;
  }
  useComments({
    enabled: e,
    ycomments: n
  }) {
    return e ? (this.important.push(D4(n)), this) : this;
  }
  useRemoveSelectionOnBlur(e, n) {
    return this.base.push(T.domEventHandlers({
      blur(r, i) {
        const s = i.state.selection.main.head;
        n.awareness.setLocalStateField("cursor", {
          anchor: wl(e, s),
          head: wl(e, s)
        }), setTimeout(() => {
          i.dispatch({
            selection: C.create([C.range(s, s)])
          });
        }, 0);
      }
    })), this;
  }
  showCommentLineAuthors(e) {
    return this.important.push(I4(e)), this;
  }
  readonly() {
    return this.extensions.push(T.editable.of(!1), re.readOnly.of(!0)), this;
  }
  useDefaultHistory() {
    return this.base.push(Ig()), this;
  }
  useCollaboration({
    enabled: e = !0,
    ytext: n,
    provider: r,
    undoManager: i,
    editorRef: s
  }) {
    return e ? (this.extensions.push(UL(n, r.awareness, {
      undoManager: i
    })), i && (i.on("stack-item-added", (o) => {
      o.stackItem.meta.set("cursor-location", q4(s.current));
    }), i.on("stack-item-popped", (o) => {
      B4(s.current, o.stackItem.meta.get("cursor-location"));
    }), this.extensions.push(sr.of([{
      key: "Mod-z",
      run: () => i.undo(),
      preventDefault: !0
    }, {
      key: "Mod-y",
      run: () => i.redo(),
      preventDefault: !0
    }, {
      key: "Mod-Z",
      run: () => i.redo(),
      preventDefault: !0
    }]))), this) : this;
  }
  create() {
    return [...this.important, ...this.base, ...this.extensions];
  }
}
const Y4 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAyIDIwIDEyIiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjM4NDk2IDUuMDkxNzRDNS45MDUwNyA1LjA5MTc0IDUuNTE0NjUgNS40ODIxNiA1LjUxNDY1IDUuOTYyMDVDNS41MTQ2NSA2LjE4OTc5IDUuNjA0MTIgNi40MTc1NCA1Ljc2Njc5IDYuNTgwMjFDNS45Mjk0NyA2Ljc0Mjg5IDYuMTQ5MDggNi44MzIzNiA2LjM4NDk2IDYuODMyMzZDNi42MjA4NCA2LjgzMjM2IDYuODQwNDUgNi43NDI4OSA3LjAwMzEzIDYuNTgwMjFDNy4xNjU4IDYuNDE3NTQgNy4yNTUyNyA2LjE5NzkzIDcuMjU1MjcgNS45NjIwNUM3LjI1NTI3IDUuNDgyMTYgNi44NjQ4NSA1LjA5MTc0IDYuMzg0OTYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljk5NjI5IDUuMDkxNzRDOC41MTY0IDUuMDkxNzQgOC4xMjU5OCA1LjQ4MjE2IDguMTI1OTggNS45NjIwNUM4LjEyNTk4IDYuMTg5NzkgOC4yMTU0NSA2LjQxNzU0IDguMzc4MTIgNi41ODAyMUM4LjU0MDggNi43NDI4OSA4Ljc2MDQxIDYuODMyMzYgOC45OTYyOSA2LjgzMjM2QzkuMjMyMTcgNi44MzIzNiA5LjQ1MTc4IDYuNzQyODkgOS42MTQ0NSA2LjU4MDIxQzkuNzc3MTMgNi40MTc1NCA5Ljg2NjYgNi4xOTc5MyA5Ljg2NjYgNS45NjIwNUM5Ljg2NjYgNS40ODIxNiA5LjQ3NjE4IDUuMDkxNzQgOC45OTYyOSA1LjA5MTc0WiIgZmlsbD0iIzMzMkQzNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjYwNjYgNS4wOTE3NEMxMS4xMjY3IDUuMDkxNzQgMTAuNzM2MyA1LjQ4MjE2IDEwLjczNjMgNS45NjIwNUMxMC43MzYzIDYuMTg5NzkgMTAuODI1OCA2LjQxNzU0IDEwLjk4ODUgNi41ODAyMUMxMS4xNTExIDYuNzQyODkgMTEuMzcwOCA2LjgzMjM2IDExLjYwNjYgNi44MzIzNkMxMS44NDI1IDYuODMyMzYgMTIuMDYyMSA2Ljc0Mjg5IDEyLjIyNDggNi41ODAyMUMxMi4zODc1IDYuNDE3NTQgMTIuNDc3IDYuMTk3OTMgMTIuNDc3IDUuOTYyMDVDMTIuNDc3IDUuNDgyMTYgMTIuMDg2NSA1LjA5MTc0IDExLjYwNjYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZD0iTTE3LjEyOTggMTEuMDM3NVYwLjg2MjE4M0gwLjg2MjMwNVYxMC44NzQ4TDUuMTE2MjYgMTAuOTE1NUw5LjA1MyAxNC44NTIyTDEyLjg4NCAxMS4wMjk0TDE3LjEyOTggMTEuMDM3NVoiIHN0cm9rZT0iIzMzMkQzNyIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPC9zdmc+", j4 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUiIGhlaWdodD0iMjYiIHZpZXdCb3g9IjAgMCAyNiAyMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik03LjcxMzg3IDYuMTQyOTRWMTIuNTcxNSIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0xMC4yODUyIDYuMTQyODhWMTIuNTcxNSIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik02LjQyODcxIDFIMTEuNTcxNiIgc3Ryb2tlPSIjRTc0NzNDIiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0wIDIuMjg1NjRIMTgiIHN0cm9rZT0iI0U3NDczQyIgc3Ryb2tlLXdpZHRoPSIxLjc1Ii8+CiAgICA8cGF0aCBkPSJNMS45Mjg3MSAyLjI4NTY0TDMuODU3MjggMTguMzU3MUgxNC4xNDNMMTYuMDcxNiAyLjI4NTY0IiBzdHJva2U9IiNFNzQ3M0MiIHN0cm9rZS13aWR0aD0iMS43NSIvPgo8L3N2Zz4K", X4 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIHZpZXdCb3g9IjAgMCAyNSAyMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xNC40NzI3IDcuMTE3MTlMOC43MTUxOCAxMi44NzQ3TDUuNTE3NTggOS42NzcwNyIgc3Ryb2tlPSIjMzMyRDM3IiBzdHJva2Utd2lkdGg9IjEuNzUiLz4KICAgIDxwYXRoIGQ9Ik0xMCAxOUMxNC45NzA2IDE5IDE5IDE0Ljk3MDYgMTkgMTBDMTkgNS4wMjk0NCAxNC45NzA2IDEgMTAgMUM1LjAyOTQ0IDEgMSA1LjAyOTQ0IDEgMTBDMSAxNC45NzA2IDUuMDI5NDQgMTkgMTAgMTlaIiBzdHJva2U9IiMzMzJEMzciIHN0cm9rZS13aWR0aD0iMS43NSIvPgo8L3N2Zz4K", W4 = H.div`
  position: absolute;
  top: ${(t) => t.top + 20}px;
  left: ${(t) => t.left + 19}px;

  z-index: 3;
  right: 0px;
  background-color: var(--gray-500);

  ${(t) => t.fade ? "opacity: 0.4;" : ""}

  .cm-editor {
    background-color: var(--gray-500);
  }

  .cm-ySelectionInfo {
    z-index: 1004;
  }

  .cm-yLineSelection {
    margin: 0 !important;
    padding: 0 2px 0 6px;
  }

  .cm-gutters {
    border-width: 0;
  }

  .cm-content {
    padding: 0px;
  }
  .cm-line {
    line-height: 1.5em;
  }

  .cm-scroller {
    overflow-x: unset;
  }

  .cm-comment-author-colored {
    &::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: var(--bg);
      z-index: -3;
    }
  }

  .author-avatar {
    border-radius: 50%;
    height: 24px;
    width: 24px;
    box-shadow: rgba(0, 0, 0, 0.3) 0px 0px 4px;
    position: absolute;
    transform: translateX(-30px);
  }
`, z4 = ({
  ycomments: t,
  commentId: e,
  collaboration: n
}) => {
  let r = hn(null);
  const i = Le(() => t.lineAuthors(e), [e]), s = ig((a) => a.heightChanged && a.view.requestMeasure({
    read: (c) => t.updateHeight(e, c.dom.clientHeight)
  }), [e]), o = t.parentLineHeight(e) + 3.8;
  Ke(() => {
    if (!r.current)
      return;
    const a = t.getTextForComment(e), c = new T({
      state: re.create({
        doc: a.toString(),
        extensions: Ir.minimalSetup().disable(["Mod-z", "Mod-y", "Mod-Z"]).useCollaboration({
          ytext: a,
          provider: t.provider
        }).useDefaultHistory().addUpdateListener(s).showCommentLineAuthors(i).useRemoveSelectionOnBlur(a, t.provider).create()
      }),
      parent: r.current
    });
    return t.syncSuggestions(e), a.observe((h, u) => {
      !u.local || t.syncSuggestions(e);
    }), t.newLocalComment && (c.focus(), t.newLocalComment = !1), () => {
      c.destroy();
    };
  }, [r]);
  const l = hn(null);
  return Ke(() => {
    !l.current || (l.current.onmouseup = () => {
      t.display().switchVisibility(e), t.updateMainCodeMirror();
    }, l.current.ondragstart = () => {
      t.draggedComment = e, t.display().update();
    }, l.current.ondragend = () => {
      t.draggedComment = null, t.display().update();
    });
  }, [l.current, t.commentWithPopup]), j` <${W4}
    left=${t.marginLeft()}
    top=${t.display().offset(e)}
    fade=${t.draggedComment == e}
  >
    <div class="comment-wrapper" style="position:relative">
      ${t.commentWithPopup == e && j`
        <${V4}
          left=${t.marginLeft()}
          shift=${o}
          onMouseLeave=${() => {
    t.commentWithPopup = null, t.updateMainCodeMirror();
  }}
        >
          <img class="comment-icon" ref=${l} src=${Y4} />

          <svg width="3" height="22" viewBox="0 10 2 19" fill="none">
            <path d="M1 1V25" stroke="#DDDDDD" stroke-width="0.75" stroke-linecap="round" />
          </svg>

          <${ry} icon=${j4} bgOnHover=${"#e7473c15"} text="DELETE" onClick=${() => t.deleteComment(e)} />
          ${n.resolvingCommentsEnabled && j`<${ry} icon=${X4} bgOnHover=${"#AAE17320"} text="RESOLVE" onClick=${() => t.resolveComment(e)} />`}
        <//>
      `}

      <div style="display: ${t.display().isShown(e) ? "block" : "none"}" ref=${r}></div>
    </div>
  <//>`;
}, V4 = H.div`
  width: fit-content;
  height: 25px;
  border-radius: 2px;
  position: absolute;
  background-color: white;
  border: 1px solid var(--icon-border);
  z-index: 30000000;
  left: ${(t) => -t.left - 13}px;
  top: ${(t) => -t.shift}px;
  box-shadow: 0 0 3px #ccc;
  box-sizing: content-box;

  .comment-icon {
    height: 20px;
    padding: 3px;
    margin-left: 10px;
    margin-right: 10px;
  }

  .resolve-icon {
    height: 20px;
    padding: 3px;
  }

  svg {
    box-sizing: content-box;
  }
`, U4 = H.div`
  display: inline-flex;
  cursor: pointer;
  padding-left: 5px;
  padding-right: 5px;

  &:hover {
    background-color: ${(t) => t.bgOnHover};
  }

  img {
    height: 20px;
  }

  .delete-btn,
  .resolve-btn {
    color: #e7473c;
    line-height: 25px;
    font-size: 10px;
    margin-left: 5px;
    margin-right: 5px;
    box-sizing: content-box;
  }

  .delete-icon,
  resolve-icon {
    width: 11px;
    margin-top: 2px;
    margin-left: 5px;
    box-sizing: content-box;
  }
`, ry = ({
  icon: t,
  onClick: e,
  text: n,
  bgOnHover: r
}) => j`
    <${U4} bgOnHover=${r} onClick=${e}>
      <img class="resolve-icon" src=${t} />
      <span class="resolve-btn"> ${n} </span>
    <//>
  `, F4 = ({
  ycomments: t,
  collaboration: e
}) => {
  let n = ({
    commentId: o
  }) => j`<${z4} ...${{
    key: o,
    commentId: o,
    ycomments: t,
    collaboration: e
  }} />`, r = () => t.iterComments().map(n), [i, s] = Ee(r());
  return t.display().onUpdate(() => s(r())), j` ${i} `;
}, G4 = `<svg xmlns="http://www.w3.org/2000/svg" width="15" height="20" viewBox="0 2 20 12" fill="none">
<path fill-rule="evenodd" clip-rule="evenodd" d="M6.38496 5.09174C5.90507 5.09174 5.51465 5.48216 5.51465 5.96205C5.51465 6.18979 5.60412 6.41754 5.76679 6.58021C5.92947 6.74289 6.14908 6.83236 6.38496 6.83236C6.62084 6.83236 6.84045 6.74289 7.00313 6.58021C7.1658 6.41754 7.25527 6.19793 7.25527 5.96205C7.25527 5.48216 6.86485 5.09174 6.38496 5.09174Z" fill="#332D37"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M8.99629 5.09174C8.5164 5.09174 8.12598 5.48216 8.12598 5.96205C8.12598 6.18979 8.21545 6.41754 8.37812 6.58021C8.5408 6.74289 8.76041 6.83236 8.99629 6.83236C9.23217 6.83236 9.45178 6.74289 9.61445 6.58021C9.77713 6.41754 9.8666 6.19793 9.8666 5.96205C9.8666 5.48216 9.47618 5.09174 8.99629 5.09174Z" fill="#332D37"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M11.6066 5.09174C11.1267 5.09174 10.7363 5.48216 10.7363 5.96205C10.7363 6.18979 10.8258 6.41754 10.9885 6.58021C11.1511 6.74289 11.3708 6.83236 11.6066 6.83236C11.8425 6.83236 12.0621 6.74289 12.2248 6.58021C12.3875 6.41754 12.477 6.19793 12.477 5.96205C12.477 5.48216 12.0865 5.09174 11.6066 5.09174Z" fill="#332D37"/>
<path d="M17.1298 11.0375V0.862183H0.862305V10.8748L5.11626 10.9155L9.053 14.8522L12.884 11.0294L17.1298 11.0375Z" stroke="#332D37" stroke-width="1.5"/>
</svg>`, JC = H.div`
  border-radius: var(--border-radius);
  background: var(--gray-200);
  font-family: monospace;
  font-size: 0.94em;
  resize: none;
  border: 0;
  padding: 20px;
  min-height: 500px;
  color: black;
  position: relative;
  box-shadow: inset 0px 0px 4px rgba(0, 0, 0, 0.15);

  .cm-gutters {
    background-color: var(--gray-200);
  }

  .comment-gutter-icon {
    height: 17px;
    width: 17px;
    cursor: pointer;
  }

  .comment-image {
    position: absolute;
    display: inline;
    background-color: var(--gray-200);
    background-image: url("data:image/svg+xml;charset=UTF-8,${(t) => encodeURIComponent(G4)}");
    background-repeat: no-repeat;
  }

  .comment-box {
    width: 95%;
    display: flex;
    margin: 0px;
    padding: 0px;
  }

  .comment-box-hidden {
    position: absolute;
    pointer-events: none;
    margin-top: -5px;
  }

  @media print {
    & {
      display: none;
    }
  }

  .cm-ySelectionInfo {
    opacity: 1 !important;
    font-size: 0.6rem;
    padding: 0.25rem 0.5rem !important;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
    border-bottom-right-radius: 10px;
    font-family: "Lato" !important;
    font-weight: 600 !important;
  }

  .cm-widgetBuffer {
    margin-bottom: 0;
  }

  .cm-ySelectionCaretDot {
    display: none;
  }

  .cm-yLineSelection {
    margin: 0 2px 0 6px;
  }

  .cm-editor {
    outline: 0;
  }

  .cm-scroller {
    overflow: visible;
  }

  .cm-error {
    text-decoration: underline red;
  }

  .cm-link {
    color: var(--blue-500);

    .cm-error {
      text-decoration: unset;
    }

    .6.5 {
      color: unset;
    }
  }

  .cm-mono {
    color: #219;
  }

  [title="Fold line"] {
    user-select: none;
  }

  .cm-panels-bottom {
    z-index: 3;
  }

  .cm-suggestion {
    font-weight: 700;

    &.replaced {
      font-weight: initial;
      color: initial !important;
      text-decoration: line-through;
    }

    & * {
      color: inherit;
    }
  }

  .cm-replacement {
    font-weight: 700;
    display: inline-block;
    margin-left: 4px;
    cursor: pointer;
  }
`, H4 = H.textarea`
  display: none;
`, J4 = (t, e) => {
  t.dispatch({
    changes: {
      from: 0,
      to: t.state.doc.length,
      insert: e
    }
  });
}, K4 = ({
  text: t,
  id: e,
  name: n,
  mode: r,
  spellcheckOpts: i,
  highlights: s,
  collaboration: o
}) => {
  const l = hn(null), a = hn(null);
  return Ke(() => {
    var c;
    if (o.opts.enabled && o.error) {
      t.readyToRender(), (c = l.current) == null || c.destroy();
      const h = new T({
        state: re.create({
          doc: t.get(),
          extensions: Ir.basicSetup().useHighlighter(s).useSpellcheck(i).readonly().create()
        }),
        parent: a.current
      });
      h.dom.style.opacity = "0.5";
    }
  }, [o.error]), Ke(() => {
    var u, f, d;
    if (o.opts.enabled && !o.ready || l.current || o.error)
      return;
    ((u = o.ytext) == null ? void 0 : u.toString().length) === 0 && t.get().length > 0 && (console.warn("[Collaboration] Remote state is empty, overriding with local state"), o.ytext.insert(0, t.get())), o.opts.enabled && t.set(o.ytext.toString()), t.readyToRender();
    const c = re.create({
      doc: o.opts.enabled ? o.ytext.toString() : t.get(),
      extensions: Ir.basicSetup().useHighlighter(s).useCompartment(HC, _m([])).useSpellcheck(i).useCollaboration({
        enabled: o.opts.enabled || !1,
        ytext: o.ytext,
        undoManager: o.undoManager,
        provider: o.provider,
        editorRef: l
      }).useComments({
        enabled: o.opts.commentsEnabled,
        ycomments: o.ycomments
      }).addUpdateListener((p) => p.docChanged && t.set(h.state.doc.toString())).useRemoveSelectionOnBlur(o.ytext, o.provider).create()
    }), h = new T({
      state: c,
      parent: a.current
    });
    return l.current = h, window.myst_editor.main_editor = h, (f = o.ycomments) == null || f.registerCodeMirror(h), (d = o.provider) == null || d.watchCollabolators(o.setUsers), t.onSync((p) => J4(h, p)), () => {
      o.opts.enabled && (o.provider.disconnect(), o.ydoc.destroy()), h.destroy();
    };
  }, [o.ready]), j`
    <${JC} className="myst-main-editor" ref=${a} $mode=${r} id="${e}-editor">
      ${o.opts.commentsEnabled && !o.error && j`<${F4} ycomments=${o.ycomments} collaboration=${o.opts} />`}
    <//>
    <${H4} value=${t.get()} name=${n} id=${e}><//>
  `;
}, KC = H.div`
  background-color: white;
  padding: 20px;
  min-height: 150px;
  border: 1px solid var(--gray-400);
  border-left: 1px solid var(--gray-600);
  box-shadow: inset 0px 0px 4px var(--gray-600);
  border-radius: var(--border-radius);
  vertical-align: top;
  color: var(--gray-900);
  word-break: unset;

  @media print {
    & {
      display: block !important;
      border: 0px !important;
      box-shadow: none !important;
      border-radius: 0px !important;
      word-break: unset !important;
    }
  }

  p {
    margin-top: 0px;
    line-height: 1.3em;
    display: block;

    a {
      display: inline;
    }

    @media print {
      break-inside: avoid !important;
      text-align: justify !important;
      text-justify: inter-word !important;
    }
  }

  a {
    color: var(--blue-500);
    word-break: break-word;

    @media print {
      &::after {
        content: "(" attr(href) ")" !important;
      }
    }
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: bold;
    line-height: 1.5;
    margin: 1em 0;
  }
  h1 {
    font-size: 1.8em;
  }
  h2 {
    font-size: 1.5em;
  }
  h3 {
    font-size: 1.25em;
  }
  h4 {
    font-size: 1.15em;
  }
  h5 {
    font-size: 1.1em;
  }
  h6 {
    font-size: 1em;
  }

  hr {
    height: 1px;
    margin: 16px 0;
    background-color: var(--gray-500);
    border: 0 none;
  }

  code,
  pre {
    border-radius: var(--border-radius);
    background-color: var(--gray-200);
  }
  code {
    padding: 0.1em 0.4em;
    font-family: "Source Code Pro";
    font-size: 0.9em;
    color: var(--black);
    border: none;
  }
  pre {
    white-space: pre-wrap;
    padding: 16px;
    & > code {
      padding: 0px;
    }
  }
  details > summary {
    display: list-item;
    cursor: pointer;
  }
  aside {
    border-radius: var(--border-radius);

    &.admonition {
      border: var(--border-2) solid var(--green-500);
      margin-bottom: 1rem;

      .admonition {
        margin: 0rem 1.4rem 0.9rem 1.4rem;
      }

      & > header,
      p {
        padding: 10px;
      }
      & > p {
        margin-bottom: 0;
      }
      & > header {
        color: var(--white);
        font-weight: bold;
        background: var(--green-500);
      }
    }

    &[class="admonition"] {
      .admonition {
        margin-top: 0.9rem;
      }
    }

    &.note,
    &.important,
    &.tip,
    &.hint,
    &.directive-unhandled,
    &.warning {
      border: 3px solid var(--blue-200);

      & > header {
        background-color: var(--blue-200);
        display: flex;

        &::before {
          padding-right: 5px;
          display: flex;
          align-items: center;
        }
      }
    }

    &.warning {
      border: 3px solid var(--orange-500);

      & > header {
        background-color: var(--orange-500);

        &::before {
          content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-exclamation-triangle' viewBox='0 0 16 16'%3E%3Cpath d='M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z' fill='white'%3E%3C/path%3E%3Cpath d='M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z' fill='white'%3E%3C/path%3E%3C/svg%3E%0A");
        }
      }
    }

    &.tip,
    &.hint {
      & > header::before {
        content: url("data:image/svg+xml,%3Csvg style='color: white' width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 0V2H8V0H7Z' fill='white'%3E%3C/path%3E%3Cpath d='M3.35355 3.64645L1.85355 2.14645L1.14645 2.85355L2.64645 4.35355L3.35355 3.64645Z' fill='white'%3E%3C/path%3E%3Cpath d='M12.3536 4.35355L13.8536 2.85355L13.1464 2.14645L11.6464 3.64645L12.3536 4.35355Z' fill='white'%3E%3C/path%3E%3Cpath d='M7.49998 3C5.52977 3 3.85938 4.44872 3.58075 6.39913L3.5707 6.46949C3.41148 7.58398 3.73042 8.64543 4.36009 9.45895C4.74345 9.95426 5 10.427 5 10.9013V12.5C5 12.7761 5.22386 13 5.5 13H9.5C9.77614 13 10 12.7761 10 12.5V10.9013C10 10.427 10.2565 9.95423 10.6399 9.45893C11.2696 8.64541 11.5885 7.58397 11.4293 6.4695L11.4192 6.39914C11.1406 4.44873 9.4702 3 7.49998 3Z' fill='white'%3E%3C/path%3E%3Cpath d='M0 8H2V7H0V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M13 8H15V7H13V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M6 15H9V14H6V15Z' fill='white'%3E%3C/path%3E%3C/svg%3E");
      }
    }

    &.note > header::before {
      content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-pencil' viewBox='0 0 16 16'%3E%3Cpath d='M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z' fill='white'%3E%3C/path%3E%3C/svg%3E");
    }

    &.important > header::before {
      content: url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath d='M18 16v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-5 0h-2v-2h2v2zm0-4h-2V8h2v4zm-1 10c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2z' fill='white'%3E%3C/path%3E%3C/svg%3E");
    }

    &.directive-unhandled,
    &.directive-error {
      margin-bottom: 1em;

      & > header {
        padding: 10px;
        color: var(--white);

        mark {
          background: transparent;
          font-weight: bold;
          color: inherit;
        }

        code {
          background: transparent;
          font-family: "Lato", sans-serif;
          font-weight: bold;
          padding: 0;
          margin-left: 0.3em;
        }
      }

      pre {
        background-color: var(--white);
        margin: 0;
        font-family: "Lato", sans-serif;
      }
    }

    &.directive-unhandled {
      border: 3px solid var(--gray-700);
      & > header {
        background-color: var(--gray-700);
      }
    }

    &.directive-error {
      border: 3px solid var(--red-500);
      & > header {
        background-color: var(--red-500);
      }
    }
  }

  sup,
  sub,
  numref {
    line-height: 0;
  }

  abbr {
    letter-spacing: 0.1em;
    font-weight: bold;
  }

  img {
    max-width: 100%;
    height: auto;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }

  li {
    margin-bottom: 0.5em;
    line-height: 1.3em;
    p {
      padding: 0px;
    }
  }
  ul,
  ol {
    list-style: revert;
    padding-left: 40px;
    padding-top: 0.5em;
  }
  /* Add some padding to the outermost ul */
  &[class^="Preview"] > ul {
    padding-top: 0.5em;
    padding-bottom: 0.5em;
  }

  blockquote {
    border-left: 5px solid var(--green-500);
    margin-left: 0;
    margin-top: 0;
    padding-left: 0.75rem;
  }

  table {
    border-spacing: 0;
    margin: 20px 0 20px 0;
  }
  th,
  td {
    padding: 20px;
    text-align: left;
    border-right: 1px solid var(--gray-500);
    border-bottom: 1px solid var(--gray-500);
  }
  th {
    background: var(--gray-900);
    border-top: 1px solid var(--gray-500);
    color: var(--white);

    &:first-of-type {
      border-top-left-radius: var(--border-radius);
      border-left: 1px solid var(--gray-500);
    }

    &:last-of-type {
      border-top-right-radius: var(--border-radius);
    }
  }
  td {
    &:first-of-type {
      border-left: 1px solid var(--gray-500);
    }

    p:last-of-type {
      margin-bottom: 0;
    }
  }
  tr {
    &:nth-child(2n + 2) {
      background: var(--gray-100);
    }

    &:last-of-type {
      td {
        &:first-of-type {
          border-bottom-left-radius: var(--border-radius);
        }

        &:last-of-type {
          border-bottom-right-radius: var(--border-radius);
        }
      }
    }
  }
`;
KC.defaultProps = {
  className: "myst-preview"
};
class Ie {
  constructor(e, n, r, i) {
    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;
  }
  offset(e, n) {
    return new Ie(this.fromA + e, this.toA + e, this.fromB + n, this.toB + n);
  }
}
function Qi(t, e, n, r, i, s) {
  if (t == r)
    return [];
  let o = Pm(t, e, n, r, i, s), l = Tm(t, e + o, n, r, i + o, s);
  e += o, n -= l, i += o, s -= l;
  let a = n - e, c = s - i;
  if (!a || !c)
    return [new Ie(e, n, i, s)];
  if (a > c) {
    let u = t.slice(e, n).indexOf(r.slice(i, s));
    if (u > -1)
      return [
        new Ie(e, e + u, i, i),
        new Ie(e + u + c, n, s, s)
      ];
  } else if (c > a) {
    let u = r.slice(i, s).indexOf(t.slice(e, n));
    if (u > -1)
      return [
        new Ie(e, e, i, i + u),
        new Ie(n, n, i + u + a, s)
      ];
  }
  if (a == 1 || c == 1)
    return [new Ie(e, n, i, s)];
  let h = nA(t, e, n, r, i, s);
  if (h) {
    let [u, f, d] = h;
    return Qi(t, e, u, r, i, f).concat(Qi(t, u + d, n, r, f + d, s));
  }
  return eq(t, e, n, r, i, s);
}
let Po = 1e9;
function eq(t, e, n, r, i, s) {
  let o = n - e, l = s - i;
  if (Po < 1e9 && Math.min(o, l) > Po * 16)
    return Math.min(o, l) > Po * 64 ? [new Ie(e, n, i, s)] : iy(t, e, n, r, i, s);
  let a = Math.ceil((o + l) / 2);
  Qf.reset(a), Ef.reset(a);
  let c = (d, p) => t.charCodeAt(e + d) == r.charCodeAt(i + p), h = (d, p) => t.charCodeAt(n - d - 1) == r.charCodeAt(s - p - 1), u = (o - l) % 2 != 0 ? Ef : null, f = u ? null : Qf;
  for (let d = 0; d < a; d++) {
    if (d > Po)
      return iy(t, e, n, r, i, s);
    let p = Qf.advance(d, o, l, a, u, !1, c) || Ef.advance(d, o, l, a, f, !0, h);
    if (p)
      return tq(t, e, n, e + p[0], r, i, s, i + p[1]);
  }
  return [new Ie(e, n, i, s)];
}
class eA {
  constructor() {
    this.vec = [];
  }
  reset(e) {
    this.len = e << 1;
    for (let n = 0; n < this.len; n++)
      this.vec[n] = -1;
    this.vec[e + 1] = 0, this.start = this.end = 0;
  }
  advance(e, n, r, i, s, o, l) {
    for (let a = -e + this.start; a <= e - this.end; a += 2) {
      let c = i + a, h = a == -e || a != e && this.vec[c - 1] < this.vec[c + 1] ? this.vec[c + 1] : this.vec[c - 1] + 1, u = h - a;
      for (; h < n && u < r && l(h, u); )
        h++, u++;
      if (this.vec[c] = h, h > n)
        this.end += 2;
      else if (u > r)
        this.start += 2;
      else if (s) {
        let f = i + (n - r) - a;
        if (f >= 0 && f < this.len && s.vec[f] != -1)
          if (o) {
            let d = s.vec[f];
            if (d >= n - h)
              return [d, i + d - f];
          } else {
            let d = n - s.vec[f];
            if (h >= d)
              return [h, u];
          }
      }
    }
    return null;
  }
}
const Qf = /* @__PURE__ */ new eA(), Ef = /* @__PURE__ */ new eA();
function tq(t, e, n, r, i, s, o, l) {
  let a = !1;
  return !Ns(t, r) && ++r == n && (a = !0), !Ns(i, l) && ++l == o && (a = !0), a ? [new Ie(e, n, s, o)] : Qi(t, e, r, i, s, l).concat(Qi(t, r, n, i, l, o));
}
function tA(t, e) {
  let n = 1, r = Math.min(t, e);
  for (; n < r; )
    n = n << 1;
  return n;
}
function Pm(t, e, n, r, i, s) {
  if (e == n || e == s || t.charCodeAt(e) != r.charCodeAt(i))
    return 0;
  let o = tA(n - e, s - i);
  for (let l = e, a = i; ; ) {
    let c = l + o, h = a + o;
    if (c > n || h > s || t.slice(l, c) != r.slice(a, h)) {
      if (o == 1)
        return l - e - (Ns(t, l) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == n || h == s)
        return c - e;
      l = c, a = h;
    }
  }
}
function Tm(t, e, n, r, i, s) {
  if (e == n || i == s || t.charCodeAt(n - 1) != r.charCodeAt(s - 1))
    return 0;
  let o = tA(n - e, s - i);
  for (let l = n, a = s; ; ) {
    let c = l - o, h = a - o;
    if (c < e || h < i || t.slice(c, l) != r.slice(h, a)) {
      if (o == 1)
        return n - l - (Ns(t, l) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == e || h == i)
        return n - c;
      l = c, a = h;
    }
  }
}
function qp(t, e, n, r, i, s, o, l) {
  let a = r.slice(i, s), c = null;
  for (; ; ) {
    if (c || o < l)
      return c;
    for (let h = e + o; ; ) {
      Ns(t, h) || h++;
      let u = h + o;
      if (Ns(t, u) || (u += u == h + 1 ? 1 : -1), u >= n)
        break;
      let f = t.slice(h, u), d = -1;
      for (; (d = a.indexOf(f, d + 1)) != -1; ) {
        let p = Pm(t, u, n, r, i + d + f.length, s), g = Tm(t, e, h, r, i, i + d), m = f.length + p + g;
        (!c || c[2] < m) && (c = [h - g, i + d - g, m]);
      }
      h = u;
    }
    if (l < 0)
      return c;
    o = o >> 1;
  }
}
function nA(t, e, n, r, i, s) {
  let o = n - e, l = s - i;
  if (o < l) {
    let a = nA(r, i, s, t, e, n);
    return a && [a[1], a[0], a[2]];
  }
  return o < 4 || l * 2 < o ? null : qp(t, e, n, r, i, s, Math.floor(o / 4), -1);
}
function iy(t, e, n, r, i, s) {
  let o = n - e, l = s - i, a;
  if (o < l) {
    let f = qp(r, i, s, t, e, n, Math.floor(o / 6), 50);
    a = f && [f[1], f[0], f[2]];
  } else
    a = qp(t, e, n, r, i, s, Math.floor(l / 6), 50);
  if (!a)
    return [new Ie(e, n, i, s)];
  let [c, h, u] = a;
  return Qi(t, e, c, r, i, h).concat(Qi(t, c + u, n, r, h + u, s));
}
function rA(t, e) {
  for (let n = 1; n < t.length; n++) {
    let r = t[n - 1], i = t[n];
    r.toA > i.fromA - e && r.toB > i.fromB - e && (t[n - 1] = new Ie(r.fromA, i.toA, r.fromB, i.toB), t.splice(n--, 1));
  }
}
function nq(t, e, n) {
  for (; ; ) {
    rA(n, 1);
    let r = !1;
    for (let i = 0; i < n.length; i++) {
      let s = n[i], o, l;
      (o = Pm(t, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = n[i] = new Ie(s.fromA + o, s.toA, s.fromB + o, s.toB)), (l = Tm(t, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = n[i] = new Ie(s.fromA, s.toA - l, s.fromB, s.toB - l));
      let a = s.toA - s.fromA, c = s.toB - s.fromB;
      if (a && c)
        continue;
      let h = s.fromA - (i ? n[i - 1].toA : 0), u = (i < n.length - 1 ? n[i + 1].fromA : t.length) - s.toA;
      if (!h || !u)
        continue;
      let f = a ? t.slice(s.fromA, s.toA) : e.slice(s.fromB, s.toB);
      h <= f.length && t.slice(s.fromA - h, s.fromA) == f.slice(f.length - h) ? (n[i] = new Ie(s.fromA - h, s.toA - h, s.fromB - h, s.toB - h), r = !0) : u <= f.length && t.slice(s.toA, s.toA + u) == f.slice(0, u) && (n[i] = new Ie(s.fromA + u, s.toA + u, s.fromB + u, s.toB + u), r = !0);
    }
    if (!r)
      break;
  }
  return n;
}
function rq(t, e, n) {
  for (let r = 0, i = 0; i < t.length; i++) {
    let s = t[i], o = s.toA - s.fromA, l = s.toB - s.fromB;
    if (o && l || o > 3 || l > 3) {
      let a = i == t.length - 1 ? e.length : t[i + 1].fromA, c = s.fromA - r, h = a - s.toA, u = oy(e, s.fromA, Math.min(c, 5)), f = sy(e, s.toA, Math.min(h, 5)), d = s.fromA - u, p = f - s.toA;
      if (!o || !l) {
        let g = Math.max(o, l), [m, O, b] = o ? [e, s.fromA, s.toA] : [n, s.fromB, s.toB], y, w;
        d && p ? (g > d && e.slice(u, s.fromA) == m.slice(b - d, b) ? (s = t[i] = new Ie(u, u + o, s.fromB - d, s.toB - d), u = s.fromA, f = sy(e, s.toA, Math.min(a - s.toA, 5))) : g > p && e.slice(s.toA, f) == m.slice(O, O + p) && (s = t[i] = new Ie(f - o, f, s.fromB + p, s.toB + p), f = s.toA, u = oy(e, s.fromA, Math.min(s.fromA - r, 5))), d = s.fromA - u, p = f - s.toA) : !d && !p && (w = s.fromA - (y = iq(e, s.fromA, c))) && e.slice(y, s.fromA) == m.slice(b - w, b) && (s = t[i] = new Ie(y, y + o, s.fromB - w, s.toB - w));
      }
      (d || p) && (s = t[i] = new Ie(s.fromA - d, s.toA + p, s.fromB - d, s.toB + p)), r = s.toA;
    }
  }
  return rA(t, 3), t;
}
let wi;
try {
  wi = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch {
}
function iA(t) {
  return t > 48 && t < 58 || t > 64 && t < 91 || t > 96 && t < 123;
}
function sA(t, e) {
  if (e == t.length)
    return 0;
  let n = t.charCodeAt(e);
  return n < 192 ? iA(n) ? 1 : 0 : wi ? !lA(n) || e == t.length - 1 ? wi.test(String.fromCharCode(n)) ? 1 : 0 : wi.test(t.slice(e, e + 2)) ? 2 : 0 : 0;
}
function oA(t, e) {
  if (!e)
    return 0;
  let n = t.charCodeAt(e - 1);
  return n < 192 ? iA(n) ? 1 : 0 : wi ? !aA(n) || e == 1 ? wi.test(String.fromCharCode(n)) ? 1 : 0 : wi.test(t.slice(e - 2, e)) ? 2 : 0 : 0;
}
function sy(t, e, n) {
  if (e == t.length || !oA(t, e))
    return e;
  for (let r = e, i = e + n; ; ) {
    let s = sA(t, r);
    if (!s)
      return r;
    if (r += s, r > i)
      return e;
  }
}
function oy(t, e, n) {
  if (!e || !sA(t, e))
    return e;
  for (let r = e, i = e - n; ; ) {
    let s = oA(t, r);
    if (!s)
      return r;
    if (r -= s, r < i)
      return e;
  }
}
function iq(t, e, n) {
  for (let r = e, i = e - n; ; ) {
    let s = r ? t.charCodeAt(r - 1) : 10;
    if (s == 10)
      return r;
    if (r--, r < i || s != 32 && s != 9)
      return e;
  }
}
const lA = (t) => t >= 55296 && t <= 56319, aA = (t) => t >= 56320 && t <= 57343;
function Ns(t, e) {
  return !e || e == t.length || !lA(t.charCodeAt(e - 1)) || !aA(t.charCodeAt(e));
}
function sq(t, e, n) {
  var r;
  return Po = ((r = n == null ? void 0 : n.scanLimit) !== null && r !== void 0 ? r : 1e9) >> 1, nq(t, e, Qi(t, 0, t.length, e, 0, e.length));
}
function cA(t, e, n) {
  return rq(sq(t, e, n), t, e);
}
const Dn = /* @__PURE__ */ L.define({
  combine: (t) => t[0]
}), Bp = /* @__PURE__ */ G.define(), qs = /* @__PURE__ */ Me.define({
  create(t) {
    return null;
  },
  update(t, e) {
    for (let n of e.effects)
      n.is(Bp) && (t = n.value);
    return t;
  }
});
class ps {
  constructor(e, n, r, i, s) {
    this.changes = e, this.fromA = n, this.toA = r, this.fromB = i, this.toB = s;
  }
  offset(e, n) {
    return e || n ? new ps(this.changes, this.fromA + e, this.toA + e, this.fromB + n, this.toB + n) : this;
  }
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  static build(e, n, r) {
    return hA(cA(e.toString(), n.toString(), r), e, n, 0, 0);
  }
  static updateA(e, n, r, i, s) {
    return uy(hy(e, i, !0, r.length), e, n, r, s);
  }
  static updateB(e, n, r, i, s) {
    return uy(hy(e, i, !1, n.length), e, n, r, s);
  }
}
function ly(t, e, n, r) {
  let i = n.lineAt(t), s = r.lineAt(e);
  return i.to == t && s.to == e && t < n.length && e < r.length ? [t + 1, e + 1] : [i.from, s.from];
}
function ay(t, e, n, r) {
  let i = n.lineAt(t), s = r.lineAt(e);
  return i.from == t && s.from == e ? [t, e] : [i.to + 1, s.to + 1];
}
function hA(t, e, n, r, i) {
  let s = [];
  for (let o = 0; o < t.length; o++) {
    let l = t[o], [a, c] = ly(l.fromA + r, l.fromB + i, e, n), [h, u] = ay(l.toA + r, l.toB + i, e, n), f = [l.offset(-a + r, -c + i)];
    for (; o < t.length - 1; ) {
      let d = t[o + 1], [p, g] = ly(d.fromA + r, d.fromB + i, e, n);
      if (p > h + 1 && g > u + 1)
        break;
      f.push(d.offset(-a + r, -c + i)), [h, u] = ay(d.toA + r, d.toB + i, e, n), o++;
    }
    s.push(new ps(f, a, Math.max(a, h), c, Math.max(c, u)));
  }
  return s;
}
const Ba = 1e3;
function cy(t, e, n, r) {
  let i = 0, s = t.length;
  for (; ; ) {
    if (i == s) {
      let h = 0, u = 0;
      i && ({ toA: h, toB: u } = t[i - 1]);
      let f = e - (n ? h : u);
      return [h + f, u + f];
    }
    let o = i + s >> 1, l = t[o], [a, c] = n ? [l.fromA, l.toA] : [l.fromB, l.toB];
    if (a > e)
      s = o;
    else if (c <= e)
      i = o + 1;
    else
      return r ? [l.fromA, l.fromB] : [l.toA, l.toB];
  }
}
function hy(t, e, n, r) {
  let i = [];
  return e.iterChangedRanges((s, o, l, a) => {
    let c = 0, h = n ? e.length : r, u = 0, f = n ? r : e.length;
    s > Ba && ([c, u] = cy(t, s - Ba, n, !0)), o < e.length - Ba && ([h, f] = cy(t, o + Ba, n, !1));
    let d = a - l - (o - s), p, [g, m] = n ? [d, 0] : [0, d];
    i.length && (p = i[i.length - 1]).toA >= c ? i[i.length - 1] = {
      fromA: p.fromA,
      fromB: p.fromB,
      toA: h,
      toB: f,
      diffA: p.diffA + g,
      diffB: p.diffB + m
    } : i.push({ fromA: c, toA: h, fromB: u, toB: f, diffA: g, diffB: m });
  }), i;
}
function uy(t, e, n, r, i) {
  if (!t.length)
    return e;
  let s = 0, o = 0, l = 0, a = [];
  for (let c of t) {
    let h = c.fromA + o, u = c.toA + o + c.diffA, f = c.fromB + l, d = c.toB + l + c.diffB;
    for (; s < e.length; ) {
      let p = e[s];
      if (p.toA + o <= h && p.toB + l <= f)
        a.push(p.offset(o, l));
      else if (p.fromA + o > u)
        break;
      s++;
    }
    for (let p of hA(cA(n.sliceString(h, u), r.sliceString(f, d), i), n, r, h, f))
      a.push(p);
    o += c.diffA, l += c.diffB;
  }
  for (; s < e.length; )
    a.push(e[s++].offset(o, l));
  return a;
}
const uA = /* @__PURE__ */ ke.fromClass(class {
  constructor(t) {
    ({ deco: this.deco, gutter: this.gutter } = py(t));
  }
  update(t) {
    (t.docChanged || t.viewportChanged || oq(t.startState, t.state) || lq(t.startState, t.state)) && ({ deco: this.deco, gutter: this.gutter } = py(t.view));
  }
}, {
  decorations: (t) => t.deco
}), Ya = /* @__PURE__ */ yn.low(/* @__PURE__ */ qh({
  class: "cm-changeGutter",
  markers: (t) => {
    var e;
    return ((e = t.plugin(uA)) === null || e === void 0 ? void 0 : e.gutter) || oe.empty;
  }
}));
function oq(t, e) {
  return t.field(qs, !1) != e.field(qs, !1);
}
function lq(t, e) {
  return t.facet(Dn) != e.facet(Dn);
}
const fy = /* @__PURE__ */ I.line({ class: "cm-changedLine" }), aq = /* @__PURE__ */ I.mark({ class: "cm-changedText" }), cq = /* @__PURE__ */ I.mark({ tagName: "ins", class: "cm-insertedLine" }), hq = /* @__PURE__ */ I.mark({ tagName: "del", class: "cm-deletedLine" }), dy = /* @__PURE__ */ new class extends Ht {
  constructor() {
    super(...arguments), this.elementClass = "cm-changedLineGutter";
  }
}();
function uq(t, e, n, r, i, s) {
  let o = n ? t.fromA : t.fromB, l = n ? t.toA : t.toB, a = 0;
  if (o != l) {
    i.add(o, o, fy), i.add(o, l, n ? hq : cq), s && s.add(o, o, dy);
    for (let c = e.iterRange(o, l - 1), h = o; !c.next().done; ) {
      if (c.lineBreak) {
        h++, i.add(h, h, fy), s && s.add(h, h, dy);
        continue;
      }
      let u = h + c.value.length;
      if (r)
        for (; a < t.changes.length; ) {
          let f = t.changes[a], d = o + (n ? f.fromA : f.fromB), p = o + (n ? f.toA : f.toB), g = Math.max(h, d), m = Math.min(u, p);
          if (g < m && i.add(g, m, aq), p < u)
            a++;
          else
            break;
        }
      h = u;
    }
  }
}
function py(t) {
  let e = t.state.field(qs), { side: n, highlightChanges: r, markGutter: i } = t.state.facet(Dn), s = n == "a", o = new et(), l = i ? new et() : null, { from: a, to: c } = t.viewport;
  for (let h of e) {
    if ((s ? h.fromA : h.fromB) >= c)
      break;
    (s ? h.toA : h.toB) > a && uq(h, t.state.doc, s, r, o, l);
  }
  return { deco: o.finish(), gutter: l && l.finish() };
}
class ja extends Tt {
  constructor(e) {
    super(), this.height = e;
  }
  eq(e) {
    return this.height == e.height;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-mergeSpacer", e.style.height = this.height + "px", e;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
const Oh = /* @__PURE__ */ G.define({
  map: (t, e) => t.map(e)
}), To = /* @__PURE__ */ Me.define({
  create: () => I.none,
  update: (t, e) => {
    for (let n of e.effects)
      if (n.is(Oh))
        return n.value;
    return t.map(e.changes);
  },
  provide: (t) => T.decorations.from(t)
}), Xa = 0.01;
function fq(t, e, n) {
  let r = new et(), i = new et(), s = t.state.field(To).iter(), o = e.state.field(To).iter(), l = 0, a = 0, c = 0, h = 0;
  for (let p = 0; ; p++) {
    let g = p < n.length ? n[p] : null;
    if (l < (g ? g.fromA : t.state.doc.length)) {
      let m = t.lineBlockAt(l).top + c, O = e.lineBlockAt(a).top + h, b = m - O;
      b < -Xa ? (c -= b, r.add(l, l, I.widget({
        widget: new ja(-b),
        block: !0,
        side: -1
      }))) : b > Xa && (h += b, i.add(a, a, I.widget({
        widget: new ja(b),
        block: !0,
        side: -1
      })));
    }
    if (!g)
      break;
    for (l = g.toA, a = g.toB; s.value && s.from < l; )
      c -= s.value.spec.widget.height, s.next();
    for (; o.value && o.from < a; )
      h -= o.value.spec.widget.height, o.next();
  }
  for (; s.value; )
    c -= s.value.spec.widget.height, s.next();
  for (; o.value; )
    h -= o.value.spec.widget.height, o.next();
  let u = t.contentHeight + c - (e.contentHeight + h);
  u < Xa ? r.add(t.state.doc.length, t.state.doc.length, I.widget({
    widget: new ja(-u),
    block: !0,
    side: 1
  })) : u > Xa && i.add(e.state.doc.length, e.state.doc.length, I.widget({
    widget: new ja(u),
    block: !0,
    side: 1
  }));
  let f = r.finish(), d = i.finish();
  oe.eq([f], [t.state.field(To)]) || t.dispatch({ effects: Oh.of(f) }), oe.eq([d], [e.state.field(To)]) || e.dispatch({ effects: Oh.of(d) });
}
const Yp = /* @__PURE__ */ G.define({
  map: (t, e) => e.mapPos(t)
});
class dq extends Tt {
  constructor(e) {
    super(), this.lines = e;
  }
  eq(e) {
    return this.lines == e.lines;
  }
  toDOM(e) {
    let n = document.createElement("div");
    return n.className = "cm-collapsedLines", n.textContent = "\u299A " + e.state.phrase("$ unchanged lines", this.lines) + " \u299A", n.addEventListener("click", (r) => {
      let i = e.posAtDOM(r.target);
      e.dispatch({ effects: Yp.of(i) });
      let { side: s, sibling: o } = e.state.facet(Dn);
      o && o().dispatch({ effects: Yp.of(pq(i, e.state.field(qs), s == "a")) });
    }), n;
  }
  ignoreEvent(e) {
    return e instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
}
function pq(t, e, n) {
  let r = 0, i = 0;
  for (let s = 0; ; s++) {
    let o = s < e.length ? e[s] : null;
    if (!o || (n ? o.fromA : o.fromB) >= t)
      return i + (t - r);
    [r, i] = n ? [o.toA, o.toB] : [o.toB, o.toA];
  }
}
const gq = /* @__PURE__ */ Me.define({
  create(t) {
    return I.none;
  },
  update(t, e) {
    t = t.map(e.changes);
    for (let n of e.effects)
      n.is(Yp) && (t = t.update({ filter: (r) => r != n.value }));
    return t;
  },
  provide: (t) => T.decorations.from(t)
});
function gy({ margin: t = 3, minSize: e = 4 }) {
  return gq.init((n) => mq(n, t, e));
}
function mq(t, e, n) {
  let r = new et(), i = t.facet(Dn).side == "a", s = t.field(qs), o = 1;
  for (let l = 0; ; l++) {
    let a = l < s.length ? s[l] : null, c = l ? o + e : 1, h = a ? t.doc.lineAt(i ? a.fromA : a.fromB).number - 1 - e : t.doc.lines, u = h - c + 1;
    if (u >= n && r.add(t.doc.line(c).from, t.doc.line(h).to, I.replace({
      widget: new dq(u),
      block: !0
    })), !a)
      break;
    o = t.doc.lineAt(Math.min(t.doc.length, i ? a.toA : a.toB)).number;
  }
  return r.finish();
}
const Oq = /* @__PURE__ */ T.styleModule.of(/* @__PURE__ */ new hr({
  ".cm-mergeView": {
    overflowY: "auto"
  },
  ".cm-mergeViewEditors": {
    display: "flex",
    alignItems: "stretch"
  },
  ".cm-mergeViewEditor": {
    flexGrow: 1,
    flexBasis: 0,
    overflow: "hidden"
  },
  ".cm-merge-revert": {
    width: "1.6em",
    flexGrow: 0,
    flexShrink: 0,
    position: "relative"
  },
  ".cm-merge-revert button": {
    position: "absolute",
    display: "block",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "center",
    background: "none",
    border: "none",
    font: "inherit",
    cursor: "pointer"
  }
})), bq = /* @__PURE__ */ T.baseTheme({
  ".cm-mergeView & .cm-scroller, .cm-mergeView &": {
    height: "auto !important",
    overflowY: "visible !important"
  },
  "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": {
    backgroundColor: "rgba(160, 128, 100, .08)"
  },
  "&.cm-merge-b .cm-changedLine": {
    backgroundColor: "rgba(100, 160, 128, .08)"
  },
  "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat"
  },
  "&light.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat"
  },
  ".cm-insertedLine, .cm-deletedLine": {
    textDecoration: "none"
  },
  ".cm-deletedChunk": {
    paddingLeft: "6px",
    "& .cm-chunkButtons": {
      position: "absolute",
      insetInlineEnd: "5px"
    },
    "& button": {
      border: "none",
      cursor: "pointer",
      color: "white",
      margin: "0 2px",
      borderRadius: "3px",
      "&[name=accept]": { background: "#2a2" },
      "&[name=reject]": { background: "#d43" }
    }
  },
  ".cm-collapsedLines": {
    padding: "5px 5px 5px 10px",
    cursor: "pointer"
  },
  "&light .cm-collapsedLines": {
    color: "#444",
    background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)"
  },
  "&dark .cm-collapsedLines": {
    color: "#ddd",
    background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)"
  },
  ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
  "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
  "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
  "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
  "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" }
}), my = /* @__PURE__ */ new Mi(), Wa = /* @__PURE__ */ new Mi();
class yq {
  constructor(e) {
    this.revertDOM = null, this.revertToA = !1, this.revertToLeft = !1, this.measuring = -1, this.diffConf = e.diffConfig;
    let n = [
      yn.low(uA),
      bq,
      Oq,
      To,
      T.updateListener.of((u) => {
        this.measuring < 0 && (u.heightChanged || u.viewportChanged) && !u.transactions.some((f) => f.effects.some((d) => d.is(Oh))) && this.measure();
      })
    ], r = [Dn.of({
      side: "a",
      sibling: () => this.b,
      highlightChanges: e.highlightChanges !== !1,
      markGutter: e.gutter !== !1
    })];
    e.gutter !== !1 && r.push(Ya);
    let i = re.create({
      doc: e.a.doc,
      selection: e.a.selection,
      extensions: [
        e.a.extensions || [],
        T.editorAttributes.of({ class: "cm-merge-a" }),
        Wa.of(r),
        n
      ]
    }), s = [Dn.of({
      side: "b",
      sibling: () => this.a,
      highlightChanges: e.highlightChanges !== !1,
      markGutter: e.gutter !== !1
    })];
    e.gutter !== !1 && s.push(Ya);
    let o = re.create({
      doc: e.b.doc,
      selection: e.b.selection,
      extensions: [
        e.b.extensions || [],
        T.editorAttributes.of({ class: "cm-merge-b" }),
        Wa.of(s),
        n
      ]
    });
    this.chunks = ps.build(i.doc, o.doc, this.diffConf);
    let l = [
      qs.init(() => this.chunks),
      my.of(e.collapseUnchanged ? gy(e.collapseUnchanged) : [])
    ];
    i = i.update({ effects: G.appendConfig.of(l) }).state, o = o.update({ effects: G.appendConfig.of(l) }).state, this.dom = document.createElement("div"), this.dom.className = "cm-mergeView", this.editorDOM = this.dom.appendChild(document.createElement("div")), this.editorDOM.className = "cm-mergeViewEditors";
    let a = e.orientation || "a-b", c = document.createElement("div");
    c.className = "cm-mergeViewEditor";
    let h = document.createElement("div");
    h.className = "cm-mergeViewEditor", this.editorDOM.appendChild(a == "a-b" ? c : h), this.editorDOM.appendChild(a == "a-b" ? h : c), this.a = new T({
      state: i,
      parent: c,
      root: e.root,
      dispatchTransactions: (u) => this.dispatch(u, this.a)
    }), this.b = new T({
      state: o,
      parent: h,
      root: e.root,
      dispatchTransactions: (u) => this.dispatch(u, this.b)
    }), this.setupRevertControls(!!e.revertControls, e.revertControls == "b-to-a", e.renderRevertControl), e.parent && e.parent.appendChild(this.dom), this.scheduleMeasure();
  }
  dispatch(e, n) {
    if (e.some((r) => r.docChanged)) {
      let r = e[e.length - 1], i = e.reduce((o, l) => o.compose(l.changes), qe.empty(e[0].startState.doc.length));
      this.chunks = n == this.a ? ps.updateA(this.chunks, r.newDoc, this.b.state.doc, i, this.diffConf) : ps.updateB(this.chunks, this.a.state.doc, r.newDoc, i, this.diffConf), n.update([...e, r.state.update({ effects: Bp.of(this.chunks) })]);
      let s = n == this.a ? this.b : this.a;
      s.update([s.state.update({ effects: Bp.of(this.chunks) })]), this.scheduleMeasure();
    } else
      n.update(e);
  }
  reconfigure(e) {
    if ("diffConfig" in e && (this.diffConf = e.diffConfig), "orientation" in e) {
      let s = e.orientation != "b-a";
      if (s != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let o = this.a.dom.parentNode, l = this.b.dom.parentNode;
        o.remove(), l.remove(), this.editorDOM.insertBefore(s ? o : l, this.editorDOM.firstChild), this.editorDOM.appendChild(s ? l : o), this.revertToLeft = !this.revertToLeft, this.revertDOM && (this.revertDOM.textContent = "");
      }
    }
    if ("revertControls" in e || "renderRevertControl" in e) {
      let s = !!this.revertDOM, o = this.revertToA, l = this.renderRevert;
      "revertControls" in e && (s = !!e.revertControls, o = e.revertControls == "b-to-a"), "renderRevertControl" in e && (l = e.renderRevertControl), this.setupRevertControls(s, o, l);
    }
    let n = "highlightChanges" in e, r = "gutter" in e, i = "collapseUnchanged" in e;
    if (n || r || i) {
      let s = [], o = [];
      if (n || r) {
        let l = this.a.state.facet(Dn), a = r ? e.gutter !== !1 : l.markGutter, c = n ? e.highlightChanges !== !1 : l.highlightChanges;
        s.push(Wa.reconfigure([
          Dn.of({ side: "a", sibling: () => this.b, highlightChanges: c, markGutter: a }),
          a ? Ya : []
        ])), o.push(Wa.reconfigure([
          Dn.of({ side: "b", sibling: () => this.a, highlightChanges: c, markGutter: a }),
          a ? Ya : []
        ]));
      }
      if (i) {
        let l = my.reconfigure(e.collapseUnchanged ? gy(e.collapseUnchanged) : []);
        s.push(l), o.push(l);
      }
      this.a.dispatch({ effects: s }), this.b.dispatch({ effects: o });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(e, n, r) {
    this.revertToA = n, this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode), this.renderRevert = r, !e && this.revertDOM ? (this.revertDOM.remove(), this.revertDOM = null) : e && !this.revertDOM ? (this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling), this.revertDOM.addEventListener("mousedown", (i) => this.revertClicked(i)), this.revertDOM.className = "cm-merge-revert") : this.revertDOM && (this.revertDOM.textContent = "");
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let e = this.dom.ownerDocument.defaultView || window;
      this.measuring = e.requestAnimationFrame(() => {
        this.measuring = -1, this.measure();
      });
    }
  }
  measure() {
    fq(this.a, this.b, this.chunks), this.revertDOM && this.updateRevertButtons();
  }
  updateRevertButtons() {
    let e = this.revertDOM, n = e.firstChild, r = this.a.viewport, i = this.b.viewport;
    for (let s = 0; s < this.chunks.length; s++) {
      let o = this.chunks[s];
      if (o.fromA > r.to || o.fromB > i.to)
        break;
      if (o.fromA < r.from || o.fromB < i.from)
        continue;
      let l = this.a.lineBlockAt(o.fromA).top + "px";
      for (; n && +n.dataset.chunk < s; )
        n = Oy(n);
      n && n.dataset.chunk == String(s) ? (n.style.top != l && (n.style.top = l), n = n.nextSibling) : e.insertBefore(this.renderRevertButton(l, s), n);
    }
    for (; n; )
      n = Oy(n);
  }
  renderRevertButton(e, n) {
    let r;
    if (this.renderRevert)
      r = this.renderRevert();
    else {
      r = document.createElement("button");
      let i = this.a.state.phrase("Revert this chunk");
      r.setAttribute("aria-label", i), r.setAttribute("title", i), r.textContent = this.revertToLeft ? "\u21DC" : "\u21DD";
    }
    return r.style.top = e, r.setAttribute("data-chunk", String(n)), r;
  }
  revertClicked(e) {
    let n = e.target, r;
    for (; n && n.parentNode != this.revertDOM; )
      n = n.parentNode;
    if (n && (r = this.chunks[n.dataset.chunk])) {
      let [i, s, o, l, a, c] = this.revertToA ? [this.b, this.a, r.fromB, r.toB, r.fromA, r.toA] : [this.a, this.b, r.fromA, r.toA, r.fromB, r.toB], h = i.state.sliceDoc(o, Math.max(o, l - 1));
      o != l && c <= s.state.doc.length && (h += i.state.lineBreak), s.dispatch({
        changes: { from: a, to: Math.min(s.state.doc.length, c), insert: h },
        userEvent: "revert"
      }), e.preventDefault();
    }
  }
  destroy() {
    this.a.destroy(), this.b.destroy(), this.measuring > -1 && (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring), this.dom.remove();
  }
}
function Oy(t) {
  let e = t.nextSibling;
  return t.remove(), e;
}
const by = H(JC)`
  width: 50%;
  display: block;
`, wq = ({
  old: t,
  current: e
}) => {
  const n = Ir.basicSetup().readonly().create();
  return new yq({
    a: {
      doc: t,
      extensions: n
    },
    b: {
      doc: e,
      extensions: n
    },
    orientation: "b-a"
  });
}, fA = ({
  oldText: t,
  text: e
}) => {
  let n = hn(null), r = hn(null), i = hn(null);
  return Ke(() => {
    if (i.current)
      return !1;
    i.current = wq({
      old: t,
      current: e.get()
    }), n.current.appendChild(i.current.b.dom), r.current.appendChild(i.current.a.dom);
  }, []), j` <div style="display:flex; width: 100%">
    <${by} ref=${n} />
    <${by} ref=${r} />
  </div>`;
};
fA.defaultProps = {
  className: "diff"
};
var dA = { exports: {} }, ue = {}, Qm = { exports: {} };
const kq = "\xC1", xq = "\xE1", vq = "\u0102", Sq = "\u0103", _q = "\u223E", Cq = "\u223F", Aq = "\u223E\u0333", $q = "\xC2", Pq = "\xE2", Tq = "\xB4", Qq = "\u0410", Eq = "\u0430", Dq = "\xC6", Mq = "\xE6", Rq = "\u2061", Zq = "\u{1D504}", Iq = "\u{1D51E}", Lq = "\xC0", Nq = "\xE0", qq = "\u2135", Bq = "\u2135", Yq = "\u0391", jq = "\u03B1", Xq = "\u0100", Wq = "\u0101", zq = "\u2A3F", Vq = "&", Uq = "&", Fq = "\u2A55", Gq = "\u2A53", Hq = "\u2227", Jq = "\u2A5C", Kq = "\u2A58", e8 = "\u2A5A", t8 = "\u2220", n8 = "\u29A4", r8 = "\u2220", i8 = "\u29A8", s8 = "\u29A9", o8 = "\u29AA", l8 = "\u29AB", a8 = "\u29AC", c8 = "\u29AD", h8 = "\u29AE", u8 = "\u29AF", f8 = "\u2221", d8 = "\u221F", p8 = "\u22BE", g8 = "\u299D", m8 = "\u2222", O8 = "\xC5", b8 = "\u237C", y8 = "\u0104", w8 = "\u0105", k8 = "\u{1D538}", x8 = "\u{1D552}", v8 = "\u2A6F", S8 = "\u2248", _8 = "\u2A70", C8 = "\u224A", A8 = "\u224B", $8 = "'", P8 = "\u2061", T8 = "\u2248", Q8 = "\u224A", E8 = "\xC5", D8 = "\xE5", M8 = "\u{1D49C}", R8 = "\u{1D4B6}", Z8 = "\u2254", I8 = "*", L8 = "\u2248", N8 = "\u224D", q8 = "\xC3", B8 = "\xE3", Y8 = "\xC4", j8 = "\xE4", X8 = "\u2233", W8 = "\u2A11", z8 = "\u224C", V8 = "\u03F6", U8 = "\u2035", F8 = "\u223D", G8 = "\u22CD", H8 = "\u2216", J8 = "\u2AE7", K8 = "\u22BD", e6 = "\u2305", t6 = "\u2306", n6 = "\u2305", r6 = "\u23B5", i6 = "\u23B6", s6 = "\u224C", o6 = "\u0411", l6 = "\u0431", a6 = "\u201E", c6 = "\u2235", h6 = "\u2235", u6 = "\u2235", f6 = "\u29B0", d6 = "\u03F6", p6 = "\u212C", g6 = "\u212C", m6 = "\u0392", O6 = "\u03B2", b6 = "\u2136", y6 = "\u226C", w6 = "\u{1D505}", k6 = "\u{1D51F}", x6 = "\u22C2", v6 = "\u25EF", S6 = "\u22C3", _6 = "\u2A00", C6 = "\u2A01", A6 = "\u2A02", $6 = "\u2A06", P6 = "\u2605", T6 = "\u25BD", Q6 = "\u25B3", E6 = "\u2A04", D6 = "\u22C1", M6 = "\u22C0", R6 = "\u290D", Z6 = "\u29EB", I6 = "\u25AA", L6 = "\u25B4", N6 = "\u25BE", q6 = "\u25C2", B6 = "\u25B8", Y6 = "\u2423", j6 = "\u2592", X6 = "\u2591", W6 = "\u2593", z6 = "\u2588", V6 = "=\u20E5", U6 = "\u2261\u20E5", F6 = "\u2AED", G6 = "\u2310", H6 = "\u{1D539}", J6 = "\u{1D553}", K6 = "\u22A5", eB = "\u22A5", tB = "\u22C8", nB = "\u29C9", rB = "\u2510", iB = "\u2555", sB = "\u2556", oB = "\u2557", lB = "\u250C", aB = "\u2552", cB = "\u2553", hB = "\u2554", uB = "\u2500", fB = "\u2550", dB = "\u252C", pB = "\u2564", gB = "\u2565", mB = "\u2566", OB = "\u2534", bB = "\u2567", yB = "\u2568", wB = "\u2569", kB = "\u229F", xB = "\u229E", vB = "\u22A0", SB = "\u2518", _B = "\u255B", CB = "\u255C", AB = "\u255D", $B = "\u2514", PB = "\u2558", TB = "\u2559", QB = "\u255A", EB = "\u2502", DB = "\u2551", MB = "\u253C", RB = "\u256A", ZB = "\u256B", IB = "\u256C", LB = "\u2524", NB = "\u2561", qB = "\u2562", BB = "\u2563", YB = "\u251C", jB = "\u255E", XB = "\u255F", WB = "\u2560", zB = "\u2035", VB = "\u02D8", UB = "\u02D8", FB = "\xA6", GB = "\u{1D4B7}", HB = "\u212C", JB = "\u204F", KB = "\u223D", eY = "\u22CD", tY = "\u29C5", nY = "\\", rY = "\u27C8", iY = "\u2022", sY = "\u2022", oY = "\u224E", lY = "\u2AAE", aY = "\u224F", cY = "\u224E", hY = "\u224F", uY = "\u0106", fY = "\u0107", dY = "\u2A44", pY = "\u2A49", gY = "\u2A4B", mY = "\u2229", OY = "\u22D2", bY = "\u2A47", yY = "\u2A40", wY = "\u2145", kY = "\u2229\uFE00", xY = "\u2041", vY = "\u02C7", SY = "\u212D", _Y = "\u2A4D", CY = "\u010C", AY = "\u010D", $Y = "\xC7", PY = "\xE7", TY = "\u0108", QY = "\u0109", EY = "\u2230", DY = "\u2A4C", MY = "\u2A50", RY = "\u010A", ZY = "\u010B", IY = "\xB8", LY = "\xB8", NY = "\u29B2", qY = "\xA2", BY = "\xB7", YY = "\xB7", jY = "\u{1D520}", XY = "\u212D", WY = "\u0427", zY = "\u0447", VY = "\u2713", UY = "\u2713", FY = "\u03A7", GY = "\u03C7", HY = "\u02C6", JY = "\u2257", KY = "\u21BA", e9 = "\u21BB", t9 = "\u229B", n9 = "\u229A", r9 = "\u229D", i9 = "\u2299", s9 = "\xAE", o9 = "\u24C8", l9 = "\u2296", a9 = "\u2295", c9 = "\u2297", h9 = "\u25CB", u9 = "\u29C3", f9 = "\u2257", d9 = "\u2A10", p9 = "\u2AEF", g9 = "\u29C2", m9 = "\u2232", O9 = "\u201D", b9 = "\u2019", y9 = "\u2663", w9 = "\u2663", k9 = ":", x9 = "\u2237", v9 = "\u2A74", S9 = "\u2254", _9 = "\u2254", C9 = ",", A9 = "@", $9 = "\u2201", P9 = "\u2218", T9 = "\u2201", Q9 = "\u2102", E9 = "\u2245", D9 = "\u2A6D", M9 = "\u2261", R9 = "\u222E", Z9 = "\u222F", I9 = "\u222E", L9 = "\u{1D554}", N9 = "\u2102", q9 = "\u2210", B9 = "\u2210", Y9 = "\xA9", j9 = "\xA9", X9 = "\u2117", W9 = "\u2233", z9 = "\u21B5", V9 = "\u2717", U9 = "\u2A2F", F9 = "\u{1D49E}", G9 = "\u{1D4B8}", H9 = "\u2ACF", J9 = "\u2AD1", K9 = "\u2AD0", ej = "\u2AD2", tj = "\u22EF", nj = "\u2938", rj = "\u2935", ij = "\u22DE", sj = "\u22DF", oj = "\u21B6", lj = "\u293D", aj = "\u2A48", cj = "\u2A46", hj = "\u224D", uj = "\u222A", fj = "\u22D3", dj = "\u2A4A", pj = "\u228D", gj = "\u2A45", mj = "\u222A\uFE00", Oj = "\u21B7", bj = "\u293C", yj = "\u22DE", wj = "\u22DF", kj = "\u22CE", xj = "\u22CF", vj = "\xA4", Sj = "\u21B6", _j = "\u21B7", Cj = "\u22CE", Aj = "\u22CF", $j = "\u2232", Pj = "\u2231", Tj = "\u232D", Qj = "\u2020", Ej = "\u2021", Dj = "\u2138", Mj = "\u2193", Rj = "\u21A1", Zj = "\u21D3", Ij = "\u2010", Lj = "\u2AE4", Nj = "\u22A3", qj = "\u290F", Bj = "\u02DD", Yj = "\u010E", jj = "\u010F", Xj = "\u0414", Wj = "\u0434", zj = "\u2021", Vj = "\u21CA", Uj = "\u2145", Fj = "\u2146", Gj = "\u2911", Hj = "\u2A77", Jj = "\xB0", Kj = "\u2207", eX = "\u0394", tX = "\u03B4", nX = "\u29B1", rX = "\u297F", iX = "\u{1D507}", sX = "\u{1D521}", oX = "\u2965", lX = "\u21C3", aX = "\u21C2", cX = "\xB4", hX = "\u02D9", uX = "\u02DD", fX = "`", dX = "\u02DC", pX = "\u22C4", gX = "\u22C4", mX = "\u22C4", OX = "\u2666", bX = "\u2666", yX = "\xA8", wX = "\u2146", kX = "\u03DD", xX = "\u22F2", vX = "\xF7", SX = "\xF7", _X = "\u22C7", CX = "\u22C7", AX = "\u0402", $X = "\u0452", PX = "\u231E", TX = "\u230D", QX = "$", EX = "\u{1D53B}", DX = "\u{1D555}", MX = "\xA8", RX = "\u02D9", ZX = "\u20DC", IX = "\u2250", LX = "\u2251", NX = "\u2250", qX = "\u2238", BX = "\u2214", YX = "\u22A1", jX = "\u2306", XX = "\u222F", WX = "\xA8", zX = "\u21D3", VX = "\u21D0", UX = "\u21D4", FX = "\u2AE4", GX = "\u27F8", HX = "\u27FA", JX = "\u27F9", KX = "\u21D2", eW = "\u22A8", tW = "\u21D1", nW = "\u21D5", rW = "\u2225", iW = "\u2913", sW = "\u2193", oW = "\u2193", lW = "\u21D3", aW = "\u21F5", cW = "\u0311", hW = "\u21CA", uW = "\u21C3", fW = "\u21C2", dW = "\u2950", pW = "\u295E", gW = "\u2956", mW = "\u21BD", OW = "\u295F", bW = "\u2957", yW = "\u21C1", wW = "\u21A7", kW = "\u22A4", xW = "\u2910", vW = "\u231F", SW = "\u230C", _W = "\u{1D49F}", CW = "\u{1D4B9}", AW = "\u0405", $W = "\u0455", PW = "\u29F6", TW = "\u0110", QW = "\u0111", EW = "\u22F1", DW = "\u25BF", MW = "\u25BE", RW = "\u21F5", ZW = "\u296F", IW = "\u29A6", LW = "\u040F", NW = "\u045F", qW = "\u27FF", BW = "\xC9", YW = "\xE9", jW = "\u2A6E", XW = "\u011A", WW = "\u011B", zW = "\xCA", VW = "\xEA", UW = "\u2256", FW = "\u2255", GW = "\u042D", HW = "\u044D", JW = "\u2A77", KW = "\u0116", ez = "\u0117", tz = "\u2251", nz = "\u2147", rz = "\u2252", iz = "\u{1D508}", sz = "\u{1D522}", oz = "\u2A9A", lz = "\xC8", az = "\xE8", cz = "\u2A96", hz = "\u2A98", uz = "\u2A99", fz = "\u2208", dz = "\u23E7", pz = "\u2113", gz = "\u2A95", mz = "\u2A97", Oz = "\u0112", bz = "\u0113", yz = "\u2205", wz = "\u2205", kz = "\u25FB", xz = "\u2205", vz = "\u25AB", Sz = "\u2004", _z = "\u2005", Cz = "\u2003", Az = "\u014A", $z = "\u014B", Pz = "\u2002", Tz = "\u0118", Qz = "\u0119", Ez = "\u{1D53C}", Dz = "\u{1D556}", Mz = "\u22D5", Rz = "\u29E3", Zz = "\u2A71", Iz = "\u03B5", Lz = "\u0395", Nz = "\u03B5", qz = "\u03F5", Bz = "\u2256", Yz = "\u2255", jz = "\u2242", Xz = "\u2A96", Wz = "\u2A95", zz = "\u2A75", Vz = "=", Uz = "\u2242", Fz = "\u225F", Gz = "\u21CC", Hz = "\u2261", Jz = "\u2A78", Kz = "\u29E5", eV = "\u2971", tV = "\u2253", nV = "\u212F", rV = "\u2130", iV = "\u2250", sV = "\u2A73", oV = "\u2242", lV = "\u0397", aV = "\u03B7", cV = "\xD0", hV = "\xF0", uV = "\xCB", fV = "\xEB", dV = "\u20AC", pV = "!", gV = "\u2203", mV = "\u2203", OV = "\u2130", bV = "\u2147", yV = "\u2147", wV = "\u2252", kV = "\u0424", xV = "\u0444", vV = "\u2640", SV = "\uFB03", _V = "\uFB00", CV = "\uFB04", AV = "\u{1D509}", $V = "\u{1D523}", PV = "\uFB01", TV = "\u25FC", QV = "\u25AA", EV = "fj", DV = "\u266D", MV = "\uFB02", RV = "\u25B1", ZV = "\u0192", IV = "\u{1D53D}", LV = "\u{1D557}", NV = "\u2200", qV = "\u2200", BV = "\u22D4", YV = "\u2AD9", jV = "\u2131", XV = "\u2A0D", WV = "\xBD", zV = "\u2153", VV = "\xBC", UV = "\u2155", FV = "\u2159", GV = "\u215B", HV = "\u2154", JV = "\u2156", KV = "\xBE", eU = "\u2157", tU = "\u215C", nU = "\u2158", rU = "\u215A", iU = "\u215D", sU = "\u215E", oU = "\u2044", lU = "\u2322", aU = "\u{1D4BB}", cU = "\u2131", hU = "\u01F5", uU = "\u0393", fU = "\u03B3", dU = "\u03DC", pU = "\u03DD", gU = "\u2A86", mU = "\u011E", OU = "\u011F", bU = "\u0122", yU = "\u011C", wU = "\u011D", kU = "\u0413", xU = "\u0433", vU = "\u0120", SU = "\u0121", _U = "\u2265", CU = "\u2267", AU = "\u2A8C", $U = "\u22DB", PU = "\u2265", TU = "\u2267", QU = "\u2A7E", EU = "\u2AA9", DU = "\u2A7E", MU = "\u2A80", RU = "\u2A82", ZU = "\u2A84", IU = "\u22DB\uFE00", LU = "\u2A94", NU = "\u{1D50A}", qU = "\u{1D524}", BU = "\u226B", YU = "\u22D9", jU = "\u22D9", XU = "\u2137", WU = "\u0403", zU = "\u0453", VU = "\u2AA5", UU = "\u2277", FU = "\u2A92", GU = "\u2AA4", HU = "\u2A8A", JU = "\u2A8A", KU = "\u2A88", eF = "\u2269", tF = "\u2A88", nF = "\u2269", rF = "\u22E7", iF = "\u{1D53E}", sF = "\u{1D558}", oF = "`", lF = "\u2265", aF = "\u22DB", cF = "\u2267", hF = "\u2AA2", uF = "\u2277", fF = "\u2A7E", dF = "\u2273", pF = "\u{1D4A2}", gF = "\u210A", mF = "\u2273", OF = "\u2A8E", bF = "\u2A90", yF = "\u2AA7", wF = "\u2A7A", kF = ">", xF = ">", vF = "\u226B", SF = "\u22D7", _F = "\u2995", CF = "\u2A7C", AF = "\u2A86", $F = "\u2978", PF = "\u22D7", TF = "\u22DB", QF = "\u2A8C", EF = "\u2277", DF = "\u2273", MF = "\u2269\uFE00", RF = "\u2269\uFE00", ZF = "\u02C7", IF = "\u200A", LF = "\xBD", NF = "\u210B", qF = "\u042A", BF = "\u044A", YF = "\u2948", jF = "\u2194", XF = "\u21D4", WF = "\u21AD", zF = "^", VF = "\u210F", UF = "\u0124", FF = "\u0125", GF = "\u2665", HF = "\u2665", JF = "\u2026", KF = "\u22B9", eG = "\u{1D525}", tG = "\u210C", nG = "\u210B", rG = "\u2925", iG = "\u2926", sG = "\u21FF", oG = "\u223B", lG = "\u21A9", aG = "\u21AA", cG = "\u{1D559}", hG = "\u210D", uG = "\u2015", fG = "\u2500", dG = "\u{1D4BD}", pG = "\u210B", gG = "\u210F", mG = "\u0126", OG = "\u0127", bG = "\u224E", yG = "\u224F", wG = "\u2043", kG = "\u2010", xG = "\xCD", vG = "\xED", SG = "\u2063", _G = "\xCE", CG = "\xEE", AG = "\u0418", $G = "\u0438", PG = "\u0130", TG = "\u0415", QG = "\u0435", EG = "\xA1", DG = "\u21D4", MG = "\u{1D526}", RG = "\u2111", ZG = "\xCC", IG = "\xEC", LG = "\u2148", NG = "\u2A0C", qG = "\u222D", BG = "\u29DC", YG = "\u2129", jG = "\u0132", XG = "\u0133", WG = "\u012A", zG = "\u012B", VG = "\u2111", UG = "\u2148", FG = "\u2110", GG = "\u2111", HG = "\u0131", JG = "\u2111", KG = "\u22B7", eH = "\u01B5", tH = "\u21D2", nH = "\u2105", rH = "\u221E", iH = "\u29DD", sH = "\u0131", oH = "\u22BA", lH = "\u222B", aH = "\u222C", cH = "\u2124", hH = "\u222B", uH = "\u22BA", fH = "\u22C2", dH = "\u2A17", pH = "\u2A3C", gH = "\u2063", mH = "\u2062", OH = "\u0401", bH = "\u0451", yH = "\u012E", wH = "\u012F", kH = "\u{1D540}", xH = "\u{1D55A}", vH = "\u0399", SH = "\u03B9", _H = "\u2A3C", CH = "\xBF", AH = "\u{1D4BE}", $H = "\u2110", PH = "\u2208", TH = "\u22F5", QH = "\u22F9", EH = "\u22F4", DH = "\u22F3", MH = "\u2208", RH = "\u2062", ZH = "\u0128", IH = "\u0129", LH = "\u0406", NH = "\u0456", qH = "\xCF", BH = "\xEF", YH = "\u0134", jH = "\u0135", XH = "\u0419", WH = "\u0439", zH = "\u{1D50D}", VH = "\u{1D527}", UH = "\u0237", FH = "\u{1D541}", GH = "\u{1D55B}", HH = "\u{1D4A5}", JH = "\u{1D4BF}", KH = "\u0408", eJ = "\u0458", tJ = "\u0404", nJ = "\u0454", rJ = "\u039A", iJ = "\u03BA", sJ = "\u03F0", oJ = "\u0136", lJ = "\u0137", aJ = "\u041A", cJ = "\u043A", hJ = "\u{1D50E}", uJ = "\u{1D528}", fJ = "\u0138", dJ = "\u0425", pJ = "\u0445", gJ = "\u040C", mJ = "\u045C", OJ = "\u{1D542}", bJ = "\u{1D55C}", yJ = "\u{1D4A6}", wJ = "\u{1D4C0}", kJ = "\u21DA", xJ = "\u0139", vJ = "\u013A", SJ = "\u29B4", _J = "\u2112", CJ = "\u039B", AJ = "\u03BB", $J = "\u27E8", PJ = "\u27EA", TJ = "\u2991", QJ = "\u27E8", EJ = "\u2A85", DJ = "\u2112", MJ = "\xAB", RJ = "\u21E4", ZJ = "\u291F", IJ = "\u2190", LJ = "\u219E", NJ = "\u21D0", qJ = "\u291D", BJ = "\u21A9", YJ = "\u21AB", jJ = "\u2939", XJ = "\u2973", WJ = "\u21A2", zJ = "\u2919", VJ = "\u291B", UJ = "\u2AAB", FJ = "\u2AAD", GJ = "\u2AAD\uFE00", HJ = "\u290C", JJ = "\u290E", KJ = "\u2772", eK = "{", tK = "[", nK = "\u298B", rK = "\u298F", iK = "\u298D", sK = "\u013D", oK = "\u013E", lK = "\u013B", aK = "\u013C", cK = "\u2308", hK = "{", uK = "\u041B", fK = "\u043B", dK = "\u2936", pK = "\u201C", gK = "\u201E", mK = "\u2967", OK = "\u294B", bK = "\u21B2", yK = "\u2264", wK = "\u2266", kK = "\u27E8", xK = "\u21E4", vK = "\u2190", SK = "\u2190", _K = "\u21D0", CK = "\u21C6", AK = "\u21A2", $K = "\u2308", PK = "\u27E6", TK = "\u2961", QK = "\u2959", EK = "\u21C3", DK = "\u230A", MK = "\u21BD", RK = "\u21BC", ZK = "\u21C7", IK = "\u2194", LK = "\u2194", NK = "\u21D4", qK = "\u21C6", BK = "\u21CB", YK = "\u21AD", jK = "\u294E", XK = "\u21A4", WK = "\u22A3", zK = "\u295A", VK = "\u22CB", UK = "\u29CF", FK = "\u22B2", GK = "\u22B4", HK = "\u2951", JK = "\u2960", KK = "\u2958", eee = "\u21BF", tee = "\u2952", nee = "\u21BC", ree = "\u2A8B", iee = "\u22DA", see = "\u2264", oee = "\u2266", lee = "\u2A7D", aee = "\u2AA8", cee = "\u2A7D", hee = "\u2A7F", uee = "\u2A81", fee = "\u2A83", dee = "\u22DA\uFE00", pee = "\u2A93", gee = "\u2A85", mee = "\u22D6", Oee = "\u22DA", bee = "\u2A8B", yee = "\u22DA", wee = "\u2266", kee = "\u2276", xee = "\u2276", vee = "\u2AA1", See = "\u2272", _ee = "\u2A7D", Cee = "\u2272", Aee = "\u297C", $ee = "\u230A", Pee = "\u{1D50F}", Tee = "\u{1D529}", Qee = "\u2276", Eee = "\u2A91", Dee = "\u2962", Mee = "\u21BD", Ree = "\u21BC", Zee = "\u296A", Iee = "\u2584", Lee = "\u0409", Nee = "\u0459", qee = "\u21C7", Bee = "\u226A", Yee = "\u22D8", jee = "\u231E", Xee = "\u21DA", Wee = "\u296B", zee = "\u25FA", Vee = "\u013F", Uee = "\u0140", Fee = "\u23B0", Gee = "\u23B0", Hee = "\u2A89", Jee = "\u2A89", Kee = "\u2A87", ete = "\u2268", tte = "\u2A87", nte = "\u2268", rte = "\u22E6", ite = "\u27EC", ste = "\u21FD", ote = "\u27E6", lte = "\u27F5", ate = "\u27F5", cte = "\u27F8", hte = "\u27F7", ute = "\u27F7", fte = "\u27FA", dte = "\u27FC", pte = "\u27F6", gte = "\u27F6", mte = "\u27F9", Ote = "\u21AB", bte = "\u21AC", yte = "\u2985", wte = "\u{1D543}", kte = "\u{1D55D}", xte = "\u2A2D", vte = "\u2A34", Ste = "\u2217", _te = "_", Cte = "\u2199", Ate = "\u2198", $te = "\u25CA", Pte = "\u25CA", Tte = "\u29EB", Qte = "(", Ete = "\u2993", Dte = "\u21C6", Mte = "\u231F", Rte = "\u21CB", Zte = "\u296D", Ite = "\u200E", Lte = "\u22BF", Nte = "\u2039", qte = "\u{1D4C1}", Bte = "\u2112", Yte = "\u21B0", jte = "\u21B0", Xte = "\u2272", Wte = "\u2A8D", zte = "\u2A8F", Vte = "[", Ute = "\u2018", Fte = "\u201A", Gte = "\u0141", Hte = "\u0142", Jte = "\u2AA6", Kte = "\u2A79", ene = "<", tne = "<", nne = "\u226A", rne = "\u22D6", ine = "\u22CB", sne = "\u22C9", one = "\u2976", lne = "\u2A7B", ane = "\u25C3", cne = "\u22B4", hne = "\u25C2", une = "\u2996", fne = "\u294A", dne = "\u2966", pne = "\u2268\uFE00", gne = "\u2268\uFE00", mne = "\xAF", One = "\u2642", bne = "\u2720", yne = "\u2720", wne = "\u21A6", kne = "\u21A6", xne = "\u21A7", vne = "\u21A4", Sne = "\u21A5", _ne = "\u25AE", Cne = "\u2A29", Ane = "\u041C", $ne = "\u043C", Pne = "\u2014", Tne = "\u223A", Qne = "\u2221", Ene = "\u205F", Dne = "\u2133", Mne = "\u{1D510}", Rne = "\u{1D52A}", Zne = "\u2127", Ine = "\xB5", Lne = "*", Nne = "\u2AF0", qne = "\u2223", Bne = "\xB7", Yne = "\u229F", jne = "\u2212", Xne = "\u2238", Wne = "\u2A2A", zne = "\u2213", Vne = "\u2ADB", Une = "\u2026", Fne = "\u2213", Gne = "\u22A7", Hne = "\u{1D544}", Jne = "\u{1D55E}", Kne = "\u2213", ere = "\u{1D4C2}", tre = "\u2133", nre = "\u223E", rre = "\u039C", ire = "\u03BC", sre = "\u22B8", ore = "\u22B8", lre = "\u2207", are = "\u0143", cre = "\u0144", hre = "\u2220\u20D2", ure = "\u2249", fre = "\u2A70\u0338", dre = "\u224B\u0338", pre = "\u0149", gre = "\u2249", mre = "\u266E", Ore = "\u2115", bre = "\u266E", yre = "\xA0", wre = "\u224E\u0338", kre = "\u224F\u0338", xre = "\u2A43", vre = "\u0147", Sre = "\u0148", _re = "\u0145", Cre = "\u0146", Are = "\u2247", $re = "\u2A6D\u0338", Pre = "\u2A42", Tre = "\u041D", Qre = "\u043D", Ere = "\u2013", Dre = "\u2924", Mre = "\u2197", Rre = "\u21D7", Zre = "\u2197", Ire = "\u2260", Lre = "\u2250\u0338", Nre = "\u200B", qre = "\u200B", Bre = "\u200B", Yre = "\u200B", jre = "\u2262", Xre = "\u2928", Wre = "\u2242\u0338", zre = "\u226B", Vre = "\u226A", Ure = `
`, Fre = "\u2204", Gre = "\u2204", Hre = "\u{1D511}", Jre = "\u{1D52B}", Kre = "\u2267\u0338", eie = "\u2271", tie = "\u2271", nie = "\u2267\u0338", rie = "\u2A7E\u0338", iie = "\u2A7E\u0338", sie = "\u22D9\u0338", oie = "\u2275", lie = "\u226B\u20D2", aie = "\u226F", cie = "\u226F", hie = "\u226B\u0338", uie = "\u21AE", fie = "\u21CE", die = "\u2AF2", pie = "\u220B", gie = "\u22FC", mie = "\u22FA", Oie = "\u220B", bie = "\u040A", yie = "\u045A", wie = "\u219A", kie = "\u21CD", xie = "\u2025", vie = "\u2266\u0338", Sie = "\u2270", _ie = "\u219A", Cie = "\u21CD", Aie = "\u21AE", $ie = "\u21CE", Pie = "\u2270", Tie = "\u2266\u0338", Qie = "\u2A7D\u0338", Eie = "\u2A7D\u0338", Die = "\u226E", Mie = "\u22D8\u0338", Rie = "\u2274", Zie = "\u226A\u20D2", Iie = "\u226E", Lie = "\u22EA", Nie = "\u22EC", qie = "\u226A\u0338", Bie = "\u2224", Yie = "\u2060", jie = "\xA0", Xie = "\u{1D55F}", Wie = "\u2115", zie = "\u2AEC", Vie = "\xAC", Uie = "\u2262", Fie = "\u226D", Gie = "\u2226", Hie = "\u2209", Jie = "\u2260", Kie = "\u2242\u0338", ese = "\u2204", tse = "\u226F", nse = "\u2271", rse = "\u2267\u0338", ise = "\u226B\u0338", sse = "\u2279", ose = "\u2A7E\u0338", lse = "\u2275", ase = "\u224E\u0338", cse = "\u224F\u0338", hse = "\u2209", use = "\u22F5\u0338", fse = "\u22F9\u0338", dse = "\u2209", pse = "\u22F7", gse = "\u22F6", mse = "\u29CF\u0338", Ose = "\u22EA", bse = "\u22EC", yse = "\u226E", wse = "\u2270", kse = "\u2278", xse = "\u226A\u0338", vse = "\u2A7D\u0338", Sse = "\u2274", _se = "\u2AA2\u0338", Cse = "\u2AA1\u0338", Ase = "\u220C", $se = "\u220C", Pse = "\u22FE", Tse = "\u22FD", Qse = "\u2280", Ese = "\u2AAF\u0338", Dse = "\u22E0", Mse = "\u220C", Rse = "\u29D0\u0338", Zse = "\u22EB", Ise = "\u22ED", Lse = "\u228F\u0338", Nse = "\u22E2", qse = "\u2290\u0338", Bse = "\u22E3", Yse = "\u2282\u20D2", jse = "\u2288", Xse = "\u2281", Wse = "\u2AB0\u0338", zse = "\u22E1", Vse = "\u227F\u0338", Use = "\u2283\u20D2", Fse = "\u2289", Gse = "\u2241", Hse = "\u2244", Jse = "\u2247", Kse = "\u2249", eoe = "\u2224", toe = "\u2226", noe = "\u2226", roe = "\u2AFD\u20E5", ioe = "\u2202\u0338", soe = "\u2A14", ooe = "\u2280", loe = "\u22E0", aoe = "\u2280", coe = "\u2AAF\u0338", hoe = "\u2AAF\u0338", uoe = "\u2933\u0338", foe = "\u219B", doe = "\u21CF", poe = "\u219D\u0338", goe = "\u219B", moe = "\u21CF", Ooe = "\u22EB", boe = "\u22ED", yoe = "\u2281", woe = "\u22E1", koe = "\u2AB0\u0338", xoe = "\u{1D4A9}", voe = "\u{1D4C3}", Soe = "\u2224", _oe = "\u2226", Coe = "\u2241", Aoe = "\u2244", $oe = "\u2244", Poe = "\u2224", Toe = "\u2226", Qoe = "\u22E2", Eoe = "\u22E3", Doe = "\u2284", Moe = "\u2AC5\u0338", Roe = "\u2288", Zoe = "\u2282\u20D2", Ioe = "\u2288", Loe = "\u2AC5\u0338", Noe = "\u2281", qoe = "\u2AB0\u0338", Boe = "\u2285", Yoe = "\u2AC6\u0338", joe = "\u2289", Xoe = "\u2283\u20D2", Woe = "\u2289", zoe = "\u2AC6\u0338", Voe = "\u2279", Uoe = "\xD1", Foe = "\xF1", Goe = "\u2278", Hoe = "\u22EA", Joe = "\u22EC", Koe = "\u22EB", ele = "\u22ED", tle = "\u039D", nle = "\u03BD", rle = "#", ile = "\u2116", sle = "\u2007", ole = "\u224D\u20D2", lle = "\u22AC", ale = "\u22AD", cle = "\u22AE", hle = "\u22AF", ule = "\u2265\u20D2", fle = ">\u20D2", dle = "\u2904", ple = "\u29DE", gle = "\u2902", mle = "\u2264\u20D2", Ole = "<\u20D2", ble = "\u22B4\u20D2", yle = "\u2903", wle = "\u22B5\u20D2", kle = "\u223C\u20D2", xle = "\u2923", vle = "\u2196", Sle = "\u21D6", _le = "\u2196", Cle = "\u2927", Ale = "\xD3", $le = "\xF3", Ple = "\u229B", Tle = "\xD4", Qle = "\xF4", Ele = "\u229A", Dle = "\u041E", Mle = "\u043E", Rle = "\u229D", Zle = "\u0150", Ile = "\u0151", Lle = "\u2A38", Nle = "\u2299", qle = "\u29BC", Ble = "\u0152", Yle = "\u0153", jle = "\u29BF", Xle = "\u{1D512}", Wle = "\u{1D52C}", zle = "\u02DB", Vle = "\xD2", Ule = "\xF2", Fle = "\u29C1", Gle = "\u29B5", Hle = "\u03A9", Jle = "\u222E", Kle = "\u21BA", eae = "\u29BE", tae = "\u29BB", nae = "\u203E", rae = "\u29C0", iae = "\u014C", sae = "\u014D", oae = "\u03A9", lae = "\u03C9", aae = "\u039F", cae = "\u03BF", hae = "\u29B6", uae = "\u2296", fae = "\u{1D546}", dae = "\u{1D560}", pae = "\u29B7", gae = "\u201C", mae = "\u2018", Oae = "\u29B9", bae = "\u2295", yae = "\u21BB", wae = "\u2A54", kae = "\u2228", xae = "\u2A5D", vae = "\u2134", Sae = "\u2134", _ae = "\xAA", Cae = "\xBA", Aae = "\u22B6", $ae = "\u2A56", Pae = "\u2A57", Tae = "\u2A5B", Qae = "\u24C8", Eae = "\u{1D4AA}", Dae = "\u2134", Mae = "\xD8", Rae = "\xF8", Zae = "\u2298", Iae = "\xD5", Lae = "\xF5", Nae = "\u2A36", qae = "\u2A37", Bae = "\u2297", Yae = "\xD6", jae = "\xF6", Xae = "\u233D", Wae = "\u203E", zae = "\u23DE", Vae = "\u23B4", Uae = "\u23DC", Fae = "\xB6", Gae = "\u2225", Hae = "\u2225", Jae = "\u2AF3", Kae = "\u2AFD", ece = "\u2202", tce = "\u2202", nce = "\u041F", rce = "\u043F", ice = "%", sce = ".", oce = "\u2030", lce = "\u22A5", ace = "\u2031", cce = "\u{1D513}", hce = "\u{1D52D}", uce = "\u03A6", fce = "\u03C6", dce = "\u03D5", pce = "\u2133", gce = "\u260E", mce = "\u03A0", Oce = "\u03C0", bce = "\u22D4", yce = "\u03D6", wce = "\u210F", kce = "\u210E", xce = "\u210F", vce = "\u2A23", Sce = "\u229E", _ce = "\u2A22", Cce = "+", Ace = "\u2214", $ce = "\u2A25", Pce = "\u2A72", Tce = "\xB1", Qce = "\xB1", Ece = "\u2A26", Dce = "\u2A27", Mce = "\xB1", Rce = "\u210C", Zce = "\u2A15", Ice = "\u{1D561}", Lce = "\u2119", Nce = "\xA3", qce = "\u2AB7", Bce = "\u2ABB", Yce = "\u227A", jce = "\u227C", Xce = "\u2AB7", Wce = "\u227A", zce = "\u227C", Vce = "\u227A", Uce = "\u2AAF", Fce = "\u227C", Gce = "\u227E", Hce = "\u2AAF", Jce = "\u2AB9", Kce = "\u2AB5", ehe = "\u22E8", the = "\u2AAF", nhe = "\u2AB3", rhe = "\u227E", ihe = "\u2032", she = "\u2033", ohe = "\u2119", lhe = "\u2AB9", ahe = "\u2AB5", che = "\u22E8", hhe = "\u220F", uhe = "\u220F", fhe = "\u232E", dhe = "\u2312", phe = "\u2313", ghe = "\u221D", mhe = "\u221D", Ohe = "\u2237", bhe = "\u221D", yhe = "\u227E", whe = "\u22B0", khe = "\u{1D4AB}", xhe = "\u{1D4C5}", vhe = "\u03A8", She = "\u03C8", _he = "\u2008", Che = "\u{1D514}", Ahe = "\u{1D52E}", $he = "\u2A0C", Phe = "\u{1D562}", The = "\u211A", Qhe = "\u2057", Ehe = "\u{1D4AC}", Dhe = "\u{1D4C6}", Mhe = "\u210D", Rhe = "\u2A16", Zhe = "?", Ihe = "\u225F", Lhe = '"', Nhe = '"', qhe = "\u21DB", Bhe = "\u223D\u0331", Yhe = "\u0154", jhe = "\u0155", Xhe = "\u221A", Whe = "\u29B3", zhe = "\u27E9", Vhe = "\u27EB", Uhe = "\u2992", Fhe = "\u29A5", Ghe = "\u27E9", Hhe = "\xBB", Jhe = "\u2975", Khe = "\u21E5", eue = "\u2920", tue = "\u2933", nue = "\u2192", rue = "\u21A0", iue = "\u21D2", sue = "\u291E", oue = "\u21AA", lue = "\u21AC", aue = "\u2945", cue = "\u2974", hue = "\u2916", uue = "\u21A3", fue = "\u219D", due = "\u291A", pue = "\u291C", gue = "\u2236", mue = "\u211A", Oue = "\u290D", bue = "\u290F", yue = "\u2910", wue = "\u2773", kue = "}", xue = "]", vue = "\u298C", Sue = "\u298E", _ue = "\u2990", Cue = "\u0158", Aue = "\u0159", $ue = "\u0156", Pue = "\u0157", Tue = "\u2309", Que = "}", Eue = "\u0420", Due = "\u0440", Mue = "\u2937", Rue = "\u2969", Zue = "\u201D", Iue = "\u201D", Lue = "\u21B3", Nue = "\u211C", que = "\u211B", Bue = "\u211C", Yue = "\u211D", jue = "\u211C", Xue = "\u25AD", Wue = "\xAE", zue = "\xAE", Vue = "\u220B", Uue = "\u21CB", Fue = "\u296F", Gue = "\u297D", Hue = "\u230B", Jue = "\u{1D52F}", Kue = "\u211C", efe = "\u2964", tfe = "\u21C1", nfe = "\u21C0", rfe = "\u296C", ife = "\u03A1", sfe = "\u03C1", ofe = "\u03F1", lfe = "\u27E9", afe = "\u21E5", cfe = "\u2192", hfe = "\u2192", ufe = "\u21D2", ffe = "\u21C4", dfe = "\u21A3", pfe = "\u2309", gfe = "\u27E7", mfe = "\u295D", Ofe = "\u2955", bfe = "\u21C2", yfe = "\u230B", wfe = "\u21C1", kfe = "\u21C0", xfe = "\u21C4", vfe = "\u21CC", Sfe = "\u21C9", _fe = "\u219D", Cfe = "\u21A6", Afe = "\u22A2", $fe = "\u295B", Pfe = "\u22CC", Tfe = "\u29D0", Qfe = "\u22B3", Efe = "\u22B5", Dfe = "\u294F", Mfe = "\u295C", Rfe = "\u2954", Zfe = "\u21BE", Ife = "\u2953", Lfe = "\u21C0", Nfe = "\u02DA", qfe = "\u2253", Bfe = "\u21C4", Yfe = "\u21CC", jfe = "\u200F", Xfe = "\u23B1", Wfe = "\u23B1", zfe = "\u2AEE", Vfe = "\u27ED", Ufe = "\u21FE", Ffe = "\u27E7", Gfe = "\u2986", Hfe = "\u{1D563}", Jfe = "\u211D", Kfe = "\u2A2E", ede = "\u2A35", tde = "\u2970", nde = ")", rde = "\u2994", ide = "\u2A12", sde = "\u21C9", ode = "\u21DB", lde = "\u203A", ade = "\u{1D4C7}", cde = "\u211B", hde = "\u21B1", ude = "\u21B1", fde = "]", dde = "\u2019", pde = "\u2019", gde = "\u22CC", mde = "\u22CA", Ode = "\u25B9", bde = "\u22B5", yde = "\u25B8", wde = "\u29CE", kde = "\u29F4", xde = "\u2968", vde = "\u211E", Sde = "\u015A", _de = "\u015B", Cde = "\u201A", Ade = "\u2AB8", $de = "\u0160", Pde = "\u0161", Tde = "\u2ABC", Qde = "\u227B", Ede = "\u227D", Dde = "\u2AB0", Mde = "\u2AB4", Rde = "\u015E", Zde = "\u015F", Ide = "\u015C", Lde = "\u015D", Nde = "\u2ABA", qde = "\u2AB6", Bde = "\u22E9", Yde = "\u2A13", jde = "\u227F", Xde = "\u0421", Wde = "\u0441", zde = "\u22A1", Vde = "\u22C5", Ude = "\u2A66", Fde = "\u2925", Gde = "\u2198", Hde = "\u21D8", Jde = "\u2198", Kde = "\xA7", epe = ";", tpe = "\u2929", npe = "\u2216", rpe = "\u2216", ipe = "\u2736", spe = "\u{1D516}", ope = "\u{1D530}", lpe = "\u2322", ape = "\u266F", cpe = "\u0429", hpe = "\u0449", upe = "\u0428", fpe = "\u0448", dpe = "\u2193", ppe = "\u2190", gpe = "\u2223", mpe = "\u2225", Ope = "\u2192", bpe = "\u2191", ype = "\xAD", wpe = "\u03A3", kpe = "\u03C3", xpe = "\u03C2", vpe = "\u03C2", Spe = "\u223C", _pe = "\u2A6A", Cpe = "\u2243", Ape = "\u2243", $pe = "\u2A9E", Ppe = "\u2AA0", Tpe = "\u2A9D", Qpe = "\u2A9F", Epe = "\u2246", Dpe = "\u2A24", Mpe = "\u2972", Rpe = "\u2190", Zpe = "\u2218", Ipe = "\u2216", Lpe = "\u2A33", Npe = "\u29E4", qpe = "\u2223", Bpe = "\u2323", Ype = "\u2AAA", jpe = "\u2AAC", Xpe = "\u2AAC\uFE00", Wpe = "\u042C", zpe = "\u044C", Vpe = "\u233F", Upe = "\u29C4", Fpe = "/", Gpe = "\u{1D54A}", Hpe = "\u{1D564}", Jpe = "\u2660", Kpe = "\u2660", ege = "\u2225", tge = "\u2293", nge = "\u2293\uFE00", rge = "\u2294", ige = "\u2294\uFE00", sge = "\u221A", oge = "\u228F", lge = "\u2291", age = "\u228F", cge = "\u2291", hge = "\u2290", uge = "\u2292", fge = "\u2290", dge = "\u2292", pge = "\u25A1", gge = "\u25A1", mge = "\u2293", Oge = "\u228F", bge = "\u2291", yge = "\u2290", wge = "\u2292", kge = "\u2294", xge = "\u25AA", vge = "\u25A1", Sge = "\u25AA", _ge = "\u2192", Cge = "\u{1D4AE}", Age = "\u{1D4C8}", $ge = "\u2216", Pge = "\u2323", Tge = "\u22C6", Qge = "\u22C6", Ege = "\u2606", Dge = "\u2605", Mge = "\u03F5", Rge = "\u03D5", Zge = "\xAF", Ige = "\u2282", Lge = "\u22D0", Nge = "\u2ABD", qge = "\u2AC5", Bge = "\u2286", Yge = "\u2AC3", jge = "\u2AC1", Xge = "\u2ACB", Wge = "\u228A", zge = "\u2ABF", Vge = "\u2979", Uge = "\u2282", Fge = "\u22D0", Gge = "\u2286", Hge = "\u2AC5", Jge = "\u2286", Kge = "\u228A", eme = "\u2ACB", tme = "\u2AC7", nme = "\u2AD5", rme = "\u2AD3", ime = "\u2AB8", sme = "\u227B", ome = "\u227D", lme = "\u227B", ame = "\u2AB0", cme = "\u227D", hme = "\u227F", ume = "\u2AB0", fme = "\u2ABA", dme = "\u2AB6", pme = "\u22E9", gme = "\u227F", mme = "\u220B", Ome = "\u2211", bme = "\u2211", yme = "\u266A", wme = "\xB9", kme = "\xB2", xme = "\xB3", vme = "\u2283", Sme = "\u22D1", _me = "\u2ABE", Cme = "\u2AD8", Ame = "\u2AC6", $me = "\u2287", Pme = "\u2AC4", Tme = "\u2283", Qme = "\u2287", Eme = "\u27C9", Dme = "\u2AD7", Mme = "\u297B", Rme = "\u2AC2", Zme = "\u2ACC", Ime = "\u228B", Lme = "\u2AC0", Nme = "\u2283", qme = "\u22D1", Bme = "\u2287", Yme = "\u2AC6", jme = "\u228B", Xme = "\u2ACC", Wme = "\u2AC8", zme = "\u2AD4", Vme = "\u2AD6", Ume = "\u2926", Fme = "\u2199", Gme = "\u21D9", Hme = "\u2199", Jme = "\u292A", Kme = "\xDF", eOe = "	", tOe = "\u2316", nOe = "\u03A4", rOe = "\u03C4", iOe = "\u23B4", sOe = "\u0164", oOe = "\u0165", lOe = "\u0162", aOe = "\u0163", cOe = "\u0422", hOe = "\u0442", uOe = "\u20DB", fOe = "\u2315", dOe = "\u{1D517}", pOe = "\u{1D531}", gOe = "\u2234", mOe = "\u2234", OOe = "\u2234", bOe = "\u0398", yOe = "\u03B8", wOe = "\u03D1", kOe = "\u03D1", xOe = "\u2248", vOe = "\u223C", SOe = "\u205F\u200A", _Oe = "\u2009", COe = "\u2009", AOe = "\u2248", $Oe = "\u223C", POe = "\xDE", TOe = "\xFE", QOe = "\u02DC", EOe = "\u223C", DOe = "\u2243", MOe = "\u2245", ROe = "\u2248", ZOe = "\u2A31", IOe = "\u22A0", LOe = "\xD7", NOe = "\u2A30", qOe = "\u222D", BOe = "\u2928", YOe = "\u2336", jOe = "\u2AF1", XOe = "\u22A4", WOe = "\u{1D54B}", zOe = "\u{1D565}", VOe = "\u2ADA", UOe = "\u2929", FOe = "\u2034", GOe = "\u2122", HOe = "\u2122", JOe = "\u25B5", KOe = "\u25BF", e0e = "\u25C3", t0e = "\u22B4", n0e = "\u225C", r0e = "\u25B9", i0e = "\u22B5", s0e = "\u25EC", o0e = "\u225C", l0e = "\u2A3A", a0e = "\u20DB", c0e = "\u2A39", h0e = "\u29CD", u0e = "\u2A3B", f0e = "\u23E2", d0e = "\u{1D4AF}", p0e = "\u{1D4C9}", g0e = "\u0426", m0e = "\u0446", O0e = "\u040B", b0e = "\u045B", y0e = "\u0166", w0e = "\u0167", k0e = "\u226C", x0e = "\u219E", v0e = "\u21A0", S0e = "\xDA", _0e = "\xFA", C0e = "\u2191", A0e = "\u219F", $0e = "\u21D1", P0e = "\u2949", T0e = "\u040E", Q0e = "\u045E", E0e = "\u016C", D0e = "\u016D", M0e = "\xDB", R0e = "\xFB", Z0e = "\u0423", I0e = "\u0443", L0e = "\u21C5", N0e = "\u0170", q0e = "\u0171", B0e = "\u296E", Y0e = "\u297E", j0e = "\u{1D518}", X0e = "\u{1D532}", W0e = "\xD9", z0e = "\xF9", V0e = "\u2963", U0e = "\u21BF", F0e = "\u21BE", G0e = "\u2580", H0e = "\u231C", J0e = "\u231C", K0e = "\u230F", e1e = "\u25F8", t1e = "\u016A", n1e = "\u016B", r1e = "\xA8", i1e = "_", s1e = "\u23DF", o1e = "\u23B5", l1e = "\u23DD", a1e = "\u22C3", c1e = "\u228E", h1e = "\u0172", u1e = "\u0173", f1e = "\u{1D54C}", d1e = "\u{1D566}", p1e = "\u2912", g1e = "\u2191", m1e = "\u2191", O1e = "\u21D1", b1e = "\u21C5", y1e = "\u2195", w1e = "\u2195", k1e = "\u21D5", x1e = "\u296E", v1e = "\u21BF", S1e = "\u21BE", _1e = "\u228E", C1e = "\u2196", A1e = "\u2197", $1e = "\u03C5", P1e = "\u03D2", T1e = "\u03D2", Q1e = "\u03A5", E1e = "\u03C5", D1e = "\u21A5", M1e = "\u22A5", R1e = "\u21C8", Z1e = "\u231D", I1e = "\u231D", L1e = "\u230E", N1e = "\u016E", q1e = "\u016F", B1e = "\u25F9", Y1e = "\u{1D4B0}", j1e = "\u{1D4CA}", X1e = "\u22F0", W1e = "\u0168", z1e = "\u0169", V1e = "\u25B5", U1e = "\u25B4", F1e = "\u21C8", G1e = "\xDC", H1e = "\xFC", J1e = "\u29A7", K1e = "\u299C", ebe = "\u03F5", tbe = "\u03F0", nbe = "\u2205", rbe = "\u03D5", ibe = "\u03D6", sbe = "\u221D", obe = "\u2195", lbe = "\u21D5", abe = "\u03F1", cbe = "\u03C2", hbe = "\u228A\uFE00", ube = "\u2ACB\uFE00", fbe = "\u228B\uFE00", dbe = "\u2ACC\uFE00", pbe = "\u03D1", gbe = "\u22B2", mbe = "\u22B3", Obe = "\u2AE8", bbe = "\u2AEB", ybe = "\u2AE9", wbe = "\u0412", kbe = "\u0432", xbe = "\u22A2", vbe = "\u22A8", Sbe = "\u22A9", _be = "\u22AB", Cbe = "\u2AE6", Abe = "\u22BB", $be = "\u2228", Pbe = "\u22C1", Tbe = "\u225A", Qbe = "\u22EE", Ebe = "|", Dbe = "\u2016", Mbe = "|", Rbe = "\u2016", Zbe = "\u2223", Ibe = "|", Lbe = "\u2758", Nbe = "\u2240", qbe = "\u200A", Bbe = "\u{1D519}", Ybe = "\u{1D533}", jbe = "\u22B2", Xbe = "\u2282\u20D2", Wbe = "\u2283\u20D2", zbe = "\u{1D54D}", Vbe = "\u{1D567}", Ube = "\u221D", Fbe = "\u22B3", Gbe = "\u{1D4B1}", Hbe = "\u{1D4CB}", Jbe = "\u2ACB\uFE00", Kbe = "\u228A\uFE00", eye = "\u2ACC\uFE00", tye = "\u228B\uFE00", nye = "\u22AA", rye = "\u299A", iye = "\u0174", sye = "\u0175", oye = "\u2A5F", lye = "\u2227", aye = "\u22C0", cye = "\u2259", hye = "\u2118", uye = "\u{1D51A}", fye = "\u{1D534}", dye = "\u{1D54E}", pye = "\u{1D568}", gye = "\u2118", mye = "\u2240", Oye = "\u2240", bye = "\u{1D4B2}", yye = "\u{1D4CC}", wye = "\u22C2", kye = "\u25EF", xye = "\u22C3", vye = "\u25BD", Sye = "\u{1D51B}", _ye = "\u{1D535}", Cye = "\u27F7", Aye = "\u27FA", $ye = "\u039E", Pye = "\u03BE", Tye = "\u27F5", Qye = "\u27F8", Eye = "\u27FC", Dye = "\u22FB", Mye = "\u2A00", Rye = "\u{1D54F}", Zye = "\u{1D569}", Iye = "\u2A01", Lye = "\u2A02", Nye = "\u27F6", qye = "\u27F9", Bye = "\u{1D4B3}", Yye = "\u{1D4CD}", jye = "\u2A06", Xye = "\u2A04", Wye = "\u25B3", zye = "\u22C1", Vye = "\u22C0", Uye = "\xDD", Fye = "\xFD", Gye = "\u042F", Hye = "\u044F", Jye = "\u0176", Kye = "\u0177", ewe = "\u042B", twe = "\u044B", nwe = "\xA5", rwe = "\u{1D51C}", iwe = "\u{1D536}", swe = "\u0407", owe = "\u0457", lwe = "\u{1D550}", awe = "\u{1D56A}", cwe = "\u{1D4B4}", hwe = "\u{1D4CE}", uwe = "\u042E", fwe = "\u044E", dwe = "\xFF", pwe = "\u0178", gwe = "\u0179", mwe = "\u017A", Owe = "\u017D", bwe = "\u017E", ywe = "\u0417", wwe = "\u0437", kwe = "\u017B", xwe = "\u017C", vwe = "\u2128", Swe = "\u200B", _we = "\u0396", Cwe = "\u03B6", Awe = "\u{1D537}", $we = "\u2128", Pwe = "\u0416", Twe = "\u0436", Qwe = "\u21DD", Ewe = "\u{1D56B}", Dwe = "\u2124", Mwe = "\u{1D4B5}", Rwe = "\u{1D4CF}", Zwe = "\u200D", Iwe = "\u200C", Lwe = {
  Aacute: kq,
  aacute: xq,
  Abreve: vq,
  abreve: Sq,
  ac: _q,
  acd: Cq,
  acE: Aq,
  Acirc: $q,
  acirc: Pq,
  acute: Tq,
  Acy: Qq,
  acy: Eq,
  AElig: Dq,
  aelig: Mq,
  af: Rq,
  Afr: Zq,
  afr: Iq,
  Agrave: Lq,
  agrave: Nq,
  alefsym: qq,
  aleph: Bq,
  Alpha: Yq,
  alpha: jq,
  Amacr: Xq,
  amacr: Wq,
  amalg: zq,
  amp: Vq,
  AMP: Uq,
  andand: Fq,
  And: Gq,
  and: Hq,
  andd: Jq,
  andslope: Kq,
  andv: e8,
  ang: t8,
  ange: n8,
  angle: r8,
  angmsdaa: i8,
  angmsdab: s8,
  angmsdac: o8,
  angmsdad: l8,
  angmsdae: a8,
  angmsdaf: c8,
  angmsdag: h8,
  angmsdah: u8,
  angmsd: f8,
  angrt: d8,
  angrtvb: p8,
  angrtvbd: g8,
  angsph: m8,
  angst: O8,
  angzarr: b8,
  Aogon: y8,
  aogon: w8,
  Aopf: k8,
  aopf: x8,
  apacir: v8,
  ap: S8,
  apE: _8,
  ape: C8,
  apid: A8,
  apos: $8,
  ApplyFunction: P8,
  approx: T8,
  approxeq: Q8,
  Aring: E8,
  aring: D8,
  Ascr: M8,
  ascr: R8,
  Assign: Z8,
  ast: I8,
  asymp: L8,
  asympeq: N8,
  Atilde: q8,
  atilde: B8,
  Auml: Y8,
  auml: j8,
  awconint: X8,
  awint: W8,
  backcong: z8,
  backepsilon: V8,
  backprime: U8,
  backsim: F8,
  backsimeq: G8,
  Backslash: H8,
  Barv: J8,
  barvee: K8,
  barwed: e6,
  Barwed: t6,
  barwedge: n6,
  bbrk: r6,
  bbrktbrk: i6,
  bcong: s6,
  Bcy: o6,
  bcy: l6,
  bdquo: a6,
  becaus: c6,
  because: h6,
  Because: u6,
  bemptyv: f6,
  bepsi: d6,
  bernou: p6,
  Bernoullis: g6,
  Beta: m6,
  beta: O6,
  beth: b6,
  between: y6,
  Bfr: w6,
  bfr: k6,
  bigcap: x6,
  bigcirc: v6,
  bigcup: S6,
  bigodot: _6,
  bigoplus: C6,
  bigotimes: A6,
  bigsqcup: $6,
  bigstar: P6,
  bigtriangledown: T6,
  bigtriangleup: Q6,
  biguplus: E6,
  bigvee: D6,
  bigwedge: M6,
  bkarow: R6,
  blacklozenge: Z6,
  blacksquare: I6,
  blacktriangle: L6,
  blacktriangledown: N6,
  blacktriangleleft: q6,
  blacktriangleright: B6,
  blank: Y6,
  blk12: j6,
  blk14: X6,
  blk34: W6,
  block: z6,
  bne: V6,
  bnequiv: U6,
  bNot: F6,
  bnot: G6,
  Bopf: H6,
  bopf: J6,
  bot: K6,
  bottom: eB,
  bowtie: tB,
  boxbox: nB,
  boxdl: rB,
  boxdL: iB,
  boxDl: sB,
  boxDL: oB,
  boxdr: lB,
  boxdR: aB,
  boxDr: cB,
  boxDR: hB,
  boxh: uB,
  boxH: fB,
  boxhd: dB,
  boxHd: pB,
  boxhD: gB,
  boxHD: mB,
  boxhu: OB,
  boxHu: bB,
  boxhU: yB,
  boxHU: wB,
  boxminus: kB,
  boxplus: xB,
  boxtimes: vB,
  boxul: SB,
  boxuL: _B,
  boxUl: CB,
  boxUL: AB,
  boxur: $B,
  boxuR: PB,
  boxUr: TB,
  boxUR: QB,
  boxv: EB,
  boxV: DB,
  boxvh: MB,
  boxvH: RB,
  boxVh: ZB,
  boxVH: IB,
  boxvl: LB,
  boxvL: NB,
  boxVl: qB,
  boxVL: BB,
  boxvr: YB,
  boxvR: jB,
  boxVr: XB,
  boxVR: WB,
  bprime: zB,
  breve: VB,
  Breve: UB,
  brvbar: FB,
  bscr: GB,
  Bscr: HB,
  bsemi: JB,
  bsim: KB,
  bsime: eY,
  bsolb: tY,
  bsol: nY,
  bsolhsub: rY,
  bull: iY,
  bullet: sY,
  bump: oY,
  bumpE: lY,
  bumpe: aY,
  Bumpeq: cY,
  bumpeq: hY,
  Cacute: uY,
  cacute: fY,
  capand: dY,
  capbrcup: pY,
  capcap: gY,
  cap: mY,
  Cap: OY,
  capcup: bY,
  capdot: yY,
  CapitalDifferentialD: wY,
  caps: kY,
  caret: xY,
  caron: vY,
  Cayleys: SY,
  ccaps: _Y,
  Ccaron: CY,
  ccaron: AY,
  Ccedil: $Y,
  ccedil: PY,
  Ccirc: TY,
  ccirc: QY,
  Cconint: EY,
  ccups: DY,
  ccupssm: MY,
  Cdot: RY,
  cdot: ZY,
  cedil: IY,
  Cedilla: LY,
  cemptyv: NY,
  cent: qY,
  centerdot: BY,
  CenterDot: YY,
  cfr: jY,
  Cfr: XY,
  CHcy: WY,
  chcy: zY,
  check: VY,
  checkmark: UY,
  Chi: FY,
  chi: GY,
  circ: HY,
  circeq: JY,
  circlearrowleft: KY,
  circlearrowright: e9,
  circledast: t9,
  circledcirc: n9,
  circleddash: r9,
  CircleDot: i9,
  circledR: s9,
  circledS: o9,
  CircleMinus: l9,
  CirclePlus: a9,
  CircleTimes: c9,
  cir: h9,
  cirE: u9,
  cire: f9,
  cirfnint: d9,
  cirmid: p9,
  cirscir: g9,
  ClockwiseContourIntegral: m9,
  CloseCurlyDoubleQuote: O9,
  CloseCurlyQuote: b9,
  clubs: y9,
  clubsuit: w9,
  colon: k9,
  Colon: x9,
  Colone: v9,
  colone: S9,
  coloneq: _9,
  comma: C9,
  commat: A9,
  comp: $9,
  compfn: P9,
  complement: T9,
  complexes: Q9,
  cong: E9,
  congdot: D9,
  Congruent: M9,
  conint: R9,
  Conint: Z9,
  ContourIntegral: I9,
  copf: L9,
  Copf: N9,
  coprod: q9,
  Coproduct: B9,
  copy: Y9,
  COPY: j9,
  copysr: X9,
  CounterClockwiseContourIntegral: W9,
  crarr: z9,
  cross: V9,
  Cross: U9,
  Cscr: F9,
  cscr: G9,
  csub: H9,
  csube: J9,
  csup: K9,
  csupe: ej,
  ctdot: tj,
  cudarrl: nj,
  cudarrr: rj,
  cuepr: ij,
  cuesc: sj,
  cularr: oj,
  cularrp: lj,
  cupbrcap: aj,
  cupcap: cj,
  CupCap: hj,
  cup: uj,
  Cup: fj,
  cupcup: dj,
  cupdot: pj,
  cupor: gj,
  cups: mj,
  curarr: Oj,
  curarrm: bj,
  curlyeqprec: yj,
  curlyeqsucc: wj,
  curlyvee: kj,
  curlywedge: xj,
  curren: vj,
  curvearrowleft: Sj,
  curvearrowright: _j,
  cuvee: Cj,
  cuwed: Aj,
  cwconint: $j,
  cwint: Pj,
  cylcty: Tj,
  dagger: Qj,
  Dagger: Ej,
  daleth: Dj,
  darr: Mj,
  Darr: Rj,
  dArr: Zj,
  dash: Ij,
  Dashv: Lj,
  dashv: Nj,
  dbkarow: qj,
  dblac: Bj,
  Dcaron: Yj,
  dcaron: jj,
  Dcy: Xj,
  dcy: Wj,
  ddagger: zj,
  ddarr: Vj,
  DD: Uj,
  dd: Fj,
  DDotrahd: Gj,
  ddotseq: Hj,
  deg: Jj,
  Del: Kj,
  Delta: eX,
  delta: tX,
  demptyv: nX,
  dfisht: rX,
  Dfr: iX,
  dfr: sX,
  dHar: oX,
  dharl: lX,
  dharr: aX,
  DiacriticalAcute: cX,
  DiacriticalDot: hX,
  DiacriticalDoubleAcute: uX,
  DiacriticalGrave: fX,
  DiacriticalTilde: dX,
  diam: pX,
  diamond: gX,
  Diamond: mX,
  diamondsuit: OX,
  diams: bX,
  die: yX,
  DifferentialD: wX,
  digamma: kX,
  disin: xX,
  div: vX,
  divide: SX,
  divideontimes: _X,
  divonx: CX,
  DJcy: AX,
  djcy: $X,
  dlcorn: PX,
  dlcrop: TX,
  dollar: QX,
  Dopf: EX,
  dopf: DX,
  Dot: MX,
  dot: RX,
  DotDot: ZX,
  doteq: IX,
  doteqdot: LX,
  DotEqual: NX,
  dotminus: qX,
  dotplus: BX,
  dotsquare: YX,
  doublebarwedge: jX,
  DoubleContourIntegral: XX,
  DoubleDot: WX,
  DoubleDownArrow: zX,
  DoubleLeftArrow: VX,
  DoubleLeftRightArrow: UX,
  DoubleLeftTee: FX,
  DoubleLongLeftArrow: GX,
  DoubleLongLeftRightArrow: HX,
  DoubleLongRightArrow: JX,
  DoubleRightArrow: KX,
  DoubleRightTee: eW,
  DoubleUpArrow: tW,
  DoubleUpDownArrow: nW,
  DoubleVerticalBar: rW,
  DownArrowBar: iW,
  downarrow: sW,
  DownArrow: oW,
  Downarrow: lW,
  DownArrowUpArrow: aW,
  DownBreve: cW,
  downdownarrows: hW,
  downharpoonleft: uW,
  downharpoonright: fW,
  DownLeftRightVector: dW,
  DownLeftTeeVector: pW,
  DownLeftVectorBar: gW,
  DownLeftVector: mW,
  DownRightTeeVector: OW,
  DownRightVectorBar: bW,
  DownRightVector: yW,
  DownTeeArrow: wW,
  DownTee: kW,
  drbkarow: xW,
  drcorn: vW,
  drcrop: SW,
  Dscr: _W,
  dscr: CW,
  DScy: AW,
  dscy: $W,
  dsol: PW,
  Dstrok: TW,
  dstrok: QW,
  dtdot: EW,
  dtri: DW,
  dtrif: MW,
  duarr: RW,
  duhar: ZW,
  dwangle: IW,
  DZcy: LW,
  dzcy: NW,
  dzigrarr: qW,
  Eacute: BW,
  eacute: YW,
  easter: jW,
  Ecaron: XW,
  ecaron: WW,
  Ecirc: zW,
  ecirc: VW,
  ecir: UW,
  ecolon: FW,
  Ecy: GW,
  ecy: HW,
  eDDot: JW,
  Edot: KW,
  edot: ez,
  eDot: tz,
  ee: nz,
  efDot: rz,
  Efr: iz,
  efr: sz,
  eg: oz,
  Egrave: lz,
  egrave: az,
  egs: cz,
  egsdot: hz,
  el: uz,
  Element: fz,
  elinters: dz,
  ell: pz,
  els: gz,
  elsdot: mz,
  Emacr: Oz,
  emacr: bz,
  empty: yz,
  emptyset: wz,
  EmptySmallSquare: kz,
  emptyv: xz,
  EmptyVerySmallSquare: vz,
  emsp13: Sz,
  emsp14: _z,
  emsp: Cz,
  ENG: Az,
  eng: $z,
  ensp: Pz,
  Eogon: Tz,
  eogon: Qz,
  Eopf: Ez,
  eopf: Dz,
  epar: Mz,
  eparsl: Rz,
  eplus: Zz,
  epsi: Iz,
  Epsilon: Lz,
  epsilon: Nz,
  epsiv: qz,
  eqcirc: Bz,
  eqcolon: Yz,
  eqsim: jz,
  eqslantgtr: Xz,
  eqslantless: Wz,
  Equal: zz,
  equals: Vz,
  EqualTilde: Uz,
  equest: Fz,
  Equilibrium: Gz,
  equiv: Hz,
  equivDD: Jz,
  eqvparsl: Kz,
  erarr: eV,
  erDot: tV,
  escr: nV,
  Escr: rV,
  esdot: iV,
  Esim: sV,
  esim: oV,
  Eta: lV,
  eta: aV,
  ETH: cV,
  eth: hV,
  Euml: uV,
  euml: fV,
  euro: dV,
  excl: pV,
  exist: gV,
  Exists: mV,
  expectation: OV,
  exponentiale: bV,
  ExponentialE: yV,
  fallingdotseq: wV,
  Fcy: kV,
  fcy: xV,
  female: vV,
  ffilig: SV,
  fflig: _V,
  ffllig: CV,
  Ffr: AV,
  ffr: $V,
  filig: PV,
  FilledSmallSquare: TV,
  FilledVerySmallSquare: QV,
  fjlig: EV,
  flat: DV,
  fllig: MV,
  fltns: RV,
  fnof: ZV,
  Fopf: IV,
  fopf: LV,
  forall: NV,
  ForAll: qV,
  fork: BV,
  forkv: YV,
  Fouriertrf: jV,
  fpartint: XV,
  frac12: WV,
  frac13: zV,
  frac14: VV,
  frac15: UV,
  frac16: FV,
  frac18: GV,
  frac23: HV,
  frac25: JV,
  frac34: KV,
  frac35: eU,
  frac38: tU,
  frac45: nU,
  frac56: rU,
  frac58: iU,
  frac78: sU,
  frasl: oU,
  frown: lU,
  fscr: aU,
  Fscr: cU,
  gacute: hU,
  Gamma: uU,
  gamma: fU,
  Gammad: dU,
  gammad: pU,
  gap: gU,
  Gbreve: mU,
  gbreve: OU,
  Gcedil: bU,
  Gcirc: yU,
  gcirc: wU,
  Gcy: kU,
  gcy: xU,
  Gdot: vU,
  gdot: SU,
  ge: _U,
  gE: CU,
  gEl: AU,
  gel: $U,
  geq: PU,
  geqq: TU,
  geqslant: QU,
  gescc: EU,
  ges: DU,
  gesdot: MU,
  gesdoto: RU,
  gesdotol: ZU,
  gesl: IU,
  gesles: LU,
  Gfr: NU,
  gfr: qU,
  gg: BU,
  Gg: YU,
  ggg: jU,
  gimel: XU,
  GJcy: WU,
  gjcy: zU,
  gla: VU,
  gl: UU,
  glE: FU,
  glj: GU,
  gnap: HU,
  gnapprox: JU,
  gne: KU,
  gnE: eF,
  gneq: tF,
  gneqq: nF,
  gnsim: rF,
  Gopf: iF,
  gopf: sF,
  grave: oF,
  GreaterEqual: lF,
  GreaterEqualLess: aF,
  GreaterFullEqual: cF,
  GreaterGreater: hF,
  GreaterLess: uF,
  GreaterSlantEqual: fF,
  GreaterTilde: dF,
  Gscr: pF,
  gscr: gF,
  gsim: mF,
  gsime: OF,
  gsiml: bF,
  gtcc: yF,
  gtcir: wF,
  gt: kF,
  GT: xF,
  Gt: vF,
  gtdot: SF,
  gtlPar: _F,
  gtquest: CF,
  gtrapprox: AF,
  gtrarr: $F,
  gtrdot: PF,
  gtreqless: TF,
  gtreqqless: QF,
  gtrless: EF,
  gtrsim: DF,
  gvertneqq: MF,
  gvnE: RF,
  Hacek: ZF,
  hairsp: IF,
  half: LF,
  hamilt: NF,
  HARDcy: qF,
  hardcy: BF,
  harrcir: YF,
  harr: jF,
  hArr: XF,
  harrw: WF,
  Hat: zF,
  hbar: VF,
  Hcirc: UF,
  hcirc: FF,
  hearts: GF,
  heartsuit: HF,
  hellip: JF,
  hercon: KF,
  hfr: eG,
  Hfr: tG,
  HilbertSpace: nG,
  hksearow: rG,
  hkswarow: iG,
  hoarr: sG,
  homtht: oG,
  hookleftarrow: lG,
  hookrightarrow: aG,
  hopf: cG,
  Hopf: hG,
  horbar: uG,
  HorizontalLine: fG,
  hscr: dG,
  Hscr: pG,
  hslash: gG,
  Hstrok: mG,
  hstrok: OG,
  HumpDownHump: bG,
  HumpEqual: yG,
  hybull: wG,
  hyphen: kG,
  Iacute: xG,
  iacute: vG,
  ic: SG,
  Icirc: _G,
  icirc: CG,
  Icy: AG,
  icy: $G,
  Idot: PG,
  IEcy: TG,
  iecy: QG,
  iexcl: EG,
  iff: DG,
  ifr: MG,
  Ifr: RG,
  Igrave: ZG,
  igrave: IG,
  ii: LG,
  iiiint: NG,
  iiint: qG,
  iinfin: BG,
  iiota: YG,
  IJlig: jG,
  ijlig: XG,
  Imacr: WG,
  imacr: zG,
  image: VG,
  ImaginaryI: UG,
  imagline: FG,
  imagpart: GG,
  imath: HG,
  Im: JG,
  imof: KG,
  imped: eH,
  Implies: tH,
  incare: nH,
  in: "\u2208",
  infin: rH,
  infintie: iH,
  inodot: sH,
  intcal: oH,
  int: lH,
  Int: aH,
  integers: cH,
  Integral: hH,
  intercal: uH,
  Intersection: fH,
  intlarhk: dH,
  intprod: pH,
  InvisibleComma: gH,
  InvisibleTimes: mH,
  IOcy: OH,
  iocy: bH,
  Iogon: yH,
  iogon: wH,
  Iopf: kH,
  iopf: xH,
  Iota: vH,
  iota: SH,
  iprod: _H,
  iquest: CH,
  iscr: AH,
  Iscr: $H,
  isin: PH,
  isindot: TH,
  isinE: QH,
  isins: EH,
  isinsv: DH,
  isinv: MH,
  it: RH,
  Itilde: ZH,
  itilde: IH,
  Iukcy: LH,
  iukcy: NH,
  Iuml: qH,
  iuml: BH,
  Jcirc: YH,
  jcirc: jH,
  Jcy: XH,
  jcy: WH,
  Jfr: zH,
  jfr: VH,
  jmath: UH,
  Jopf: FH,
  jopf: GH,
  Jscr: HH,
  jscr: JH,
  Jsercy: KH,
  jsercy: eJ,
  Jukcy: tJ,
  jukcy: nJ,
  Kappa: rJ,
  kappa: iJ,
  kappav: sJ,
  Kcedil: oJ,
  kcedil: lJ,
  Kcy: aJ,
  kcy: cJ,
  Kfr: hJ,
  kfr: uJ,
  kgreen: fJ,
  KHcy: dJ,
  khcy: pJ,
  KJcy: gJ,
  kjcy: mJ,
  Kopf: OJ,
  kopf: bJ,
  Kscr: yJ,
  kscr: wJ,
  lAarr: kJ,
  Lacute: xJ,
  lacute: vJ,
  laemptyv: SJ,
  lagran: _J,
  Lambda: CJ,
  lambda: AJ,
  lang: $J,
  Lang: PJ,
  langd: TJ,
  langle: QJ,
  lap: EJ,
  Laplacetrf: DJ,
  laquo: MJ,
  larrb: RJ,
  larrbfs: ZJ,
  larr: IJ,
  Larr: LJ,
  lArr: NJ,
  larrfs: qJ,
  larrhk: BJ,
  larrlp: YJ,
  larrpl: jJ,
  larrsim: XJ,
  larrtl: WJ,
  latail: zJ,
  lAtail: VJ,
  lat: UJ,
  late: FJ,
  lates: GJ,
  lbarr: HJ,
  lBarr: JJ,
  lbbrk: KJ,
  lbrace: eK,
  lbrack: tK,
  lbrke: nK,
  lbrksld: rK,
  lbrkslu: iK,
  Lcaron: sK,
  lcaron: oK,
  Lcedil: lK,
  lcedil: aK,
  lceil: cK,
  lcub: hK,
  Lcy: uK,
  lcy: fK,
  ldca: dK,
  ldquo: pK,
  ldquor: gK,
  ldrdhar: mK,
  ldrushar: OK,
  ldsh: bK,
  le: yK,
  lE: wK,
  LeftAngleBracket: kK,
  LeftArrowBar: xK,
  leftarrow: vK,
  LeftArrow: SK,
  Leftarrow: _K,
  LeftArrowRightArrow: CK,
  leftarrowtail: AK,
  LeftCeiling: $K,
  LeftDoubleBracket: PK,
  LeftDownTeeVector: TK,
  LeftDownVectorBar: QK,
  LeftDownVector: EK,
  LeftFloor: DK,
  leftharpoondown: MK,
  leftharpoonup: RK,
  leftleftarrows: ZK,
  leftrightarrow: IK,
  LeftRightArrow: LK,
  Leftrightarrow: NK,
  leftrightarrows: qK,
  leftrightharpoons: BK,
  leftrightsquigarrow: YK,
  LeftRightVector: jK,
  LeftTeeArrow: XK,
  LeftTee: WK,
  LeftTeeVector: zK,
  leftthreetimes: VK,
  LeftTriangleBar: UK,
  LeftTriangle: FK,
  LeftTriangleEqual: GK,
  LeftUpDownVector: HK,
  LeftUpTeeVector: JK,
  LeftUpVectorBar: KK,
  LeftUpVector: eee,
  LeftVectorBar: tee,
  LeftVector: nee,
  lEg: ree,
  leg: iee,
  leq: see,
  leqq: oee,
  leqslant: lee,
  lescc: aee,
  les: cee,
  lesdot: hee,
  lesdoto: uee,
  lesdotor: fee,
  lesg: dee,
  lesges: pee,
  lessapprox: gee,
  lessdot: mee,
  lesseqgtr: Oee,
  lesseqqgtr: bee,
  LessEqualGreater: yee,
  LessFullEqual: wee,
  LessGreater: kee,
  lessgtr: xee,
  LessLess: vee,
  lesssim: See,
  LessSlantEqual: _ee,
  LessTilde: Cee,
  lfisht: Aee,
  lfloor: $ee,
  Lfr: Pee,
  lfr: Tee,
  lg: Qee,
  lgE: Eee,
  lHar: Dee,
  lhard: Mee,
  lharu: Ree,
  lharul: Zee,
  lhblk: Iee,
  LJcy: Lee,
  ljcy: Nee,
  llarr: qee,
  ll: Bee,
  Ll: Yee,
  llcorner: jee,
  Lleftarrow: Xee,
  llhard: Wee,
  lltri: zee,
  Lmidot: Vee,
  lmidot: Uee,
  lmoustache: Fee,
  lmoust: Gee,
  lnap: Hee,
  lnapprox: Jee,
  lne: Kee,
  lnE: ete,
  lneq: tte,
  lneqq: nte,
  lnsim: rte,
  loang: ite,
  loarr: ste,
  lobrk: ote,
  longleftarrow: lte,
  LongLeftArrow: ate,
  Longleftarrow: cte,
  longleftrightarrow: hte,
  LongLeftRightArrow: ute,
  Longleftrightarrow: fte,
  longmapsto: dte,
  longrightarrow: pte,
  LongRightArrow: gte,
  Longrightarrow: mte,
  looparrowleft: Ote,
  looparrowright: bte,
  lopar: yte,
  Lopf: wte,
  lopf: kte,
  loplus: xte,
  lotimes: vte,
  lowast: Ste,
  lowbar: _te,
  LowerLeftArrow: Cte,
  LowerRightArrow: Ate,
  loz: $te,
  lozenge: Pte,
  lozf: Tte,
  lpar: Qte,
  lparlt: Ete,
  lrarr: Dte,
  lrcorner: Mte,
  lrhar: Rte,
  lrhard: Zte,
  lrm: Ite,
  lrtri: Lte,
  lsaquo: Nte,
  lscr: qte,
  Lscr: Bte,
  lsh: Yte,
  Lsh: jte,
  lsim: Xte,
  lsime: Wte,
  lsimg: zte,
  lsqb: Vte,
  lsquo: Ute,
  lsquor: Fte,
  Lstrok: Gte,
  lstrok: Hte,
  ltcc: Jte,
  ltcir: Kte,
  lt: ene,
  LT: tne,
  Lt: nne,
  ltdot: rne,
  lthree: ine,
  ltimes: sne,
  ltlarr: one,
  ltquest: lne,
  ltri: ane,
  ltrie: cne,
  ltrif: hne,
  ltrPar: une,
  lurdshar: fne,
  luruhar: dne,
  lvertneqq: pne,
  lvnE: gne,
  macr: mne,
  male: One,
  malt: bne,
  maltese: yne,
  Map: "\u2905",
  map: wne,
  mapsto: kne,
  mapstodown: xne,
  mapstoleft: vne,
  mapstoup: Sne,
  marker: _ne,
  mcomma: Cne,
  Mcy: Ane,
  mcy: $ne,
  mdash: Pne,
  mDDot: Tne,
  measuredangle: Qne,
  MediumSpace: Ene,
  Mellintrf: Dne,
  Mfr: Mne,
  mfr: Rne,
  mho: Zne,
  micro: Ine,
  midast: Lne,
  midcir: Nne,
  mid: qne,
  middot: Bne,
  minusb: Yne,
  minus: jne,
  minusd: Xne,
  minusdu: Wne,
  MinusPlus: zne,
  mlcp: Vne,
  mldr: Une,
  mnplus: Fne,
  models: Gne,
  Mopf: Hne,
  mopf: Jne,
  mp: Kne,
  mscr: ere,
  Mscr: tre,
  mstpos: nre,
  Mu: rre,
  mu: ire,
  multimap: sre,
  mumap: ore,
  nabla: lre,
  Nacute: are,
  nacute: cre,
  nang: hre,
  nap: ure,
  napE: fre,
  napid: dre,
  napos: pre,
  napprox: gre,
  natural: mre,
  naturals: Ore,
  natur: bre,
  nbsp: yre,
  nbump: wre,
  nbumpe: kre,
  ncap: xre,
  Ncaron: vre,
  ncaron: Sre,
  Ncedil: _re,
  ncedil: Cre,
  ncong: Are,
  ncongdot: $re,
  ncup: Pre,
  Ncy: Tre,
  ncy: Qre,
  ndash: Ere,
  nearhk: Dre,
  nearr: Mre,
  neArr: Rre,
  nearrow: Zre,
  ne: Ire,
  nedot: Lre,
  NegativeMediumSpace: Nre,
  NegativeThickSpace: qre,
  NegativeThinSpace: Bre,
  NegativeVeryThinSpace: Yre,
  nequiv: jre,
  nesear: Xre,
  nesim: Wre,
  NestedGreaterGreater: zre,
  NestedLessLess: Vre,
  NewLine: Ure,
  nexist: Fre,
  nexists: Gre,
  Nfr: Hre,
  nfr: Jre,
  ngE: Kre,
  nge: eie,
  ngeq: tie,
  ngeqq: nie,
  ngeqslant: rie,
  nges: iie,
  nGg: sie,
  ngsim: oie,
  nGt: lie,
  ngt: aie,
  ngtr: cie,
  nGtv: hie,
  nharr: uie,
  nhArr: fie,
  nhpar: die,
  ni: pie,
  nis: gie,
  nisd: mie,
  niv: Oie,
  NJcy: bie,
  njcy: yie,
  nlarr: wie,
  nlArr: kie,
  nldr: xie,
  nlE: vie,
  nle: Sie,
  nleftarrow: _ie,
  nLeftarrow: Cie,
  nleftrightarrow: Aie,
  nLeftrightarrow: $ie,
  nleq: Pie,
  nleqq: Tie,
  nleqslant: Qie,
  nles: Eie,
  nless: Die,
  nLl: Mie,
  nlsim: Rie,
  nLt: Zie,
  nlt: Iie,
  nltri: Lie,
  nltrie: Nie,
  nLtv: qie,
  nmid: Bie,
  NoBreak: Yie,
  NonBreakingSpace: jie,
  nopf: Xie,
  Nopf: Wie,
  Not: zie,
  not: Vie,
  NotCongruent: Uie,
  NotCupCap: Fie,
  NotDoubleVerticalBar: Gie,
  NotElement: Hie,
  NotEqual: Jie,
  NotEqualTilde: Kie,
  NotExists: ese,
  NotGreater: tse,
  NotGreaterEqual: nse,
  NotGreaterFullEqual: rse,
  NotGreaterGreater: ise,
  NotGreaterLess: sse,
  NotGreaterSlantEqual: ose,
  NotGreaterTilde: lse,
  NotHumpDownHump: ase,
  NotHumpEqual: cse,
  notin: hse,
  notindot: use,
  notinE: fse,
  notinva: dse,
  notinvb: pse,
  notinvc: gse,
  NotLeftTriangleBar: mse,
  NotLeftTriangle: Ose,
  NotLeftTriangleEqual: bse,
  NotLess: yse,
  NotLessEqual: wse,
  NotLessGreater: kse,
  NotLessLess: xse,
  NotLessSlantEqual: vse,
  NotLessTilde: Sse,
  NotNestedGreaterGreater: _se,
  NotNestedLessLess: Cse,
  notni: Ase,
  notniva: $se,
  notnivb: Pse,
  notnivc: Tse,
  NotPrecedes: Qse,
  NotPrecedesEqual: Ese,
  NotPrecedesSlantEqual: Dse,
  NotReverseElement: Mse,
  NotRightTriangleBar: Rse,
  NotRightTriangle: Zse,
  NotRightTriangleEqual: Ise,
  NotSquareSubset: Lse,
  NotSquareSubsetEqual: Nse,
  NotSquareSuperset: qse,
  NotSquareSupersetEqual: Bse,
  NotSubset: Yse,
  NotSubsetEqual: jse,
  NotSucceeds: Xse,
  NotSucceedsEqual: Wse,
  NotSucceedsSlantEqual: zse,
  NotSucceedsTilde: Vse,
  NotSuperset: Use,
  NotSupersetEqual: Fse,
  NotTilde: Gse,
  NotTildeEqual: Hse,
  NotTildeFullEqual: Jse,
  NotTildeTilde: Kse,
  NotVerticalBar: eoe,
  nparallel: toe,
  npar: noe,
  nparsl: roe,
  npart: ioe,
  npolint: soe,
  npr: ooe,
  nprcue: loe,
  nprec: aoe,
  npreceq: coe,
  npre: hoe,
  nrarrc: uoe,
  nrarr: foe,
  nrArr: doe,
  nrarrw: poe,
  nrightarrow: goe,
  nRightarrow: moe,
  nrtri: Ooe,
  nrtrie: boe,
  nsc: yoe,
  nsccue: woe,
  nsce: koe,
  Nscr: xoe,
  nscr: voe,
  nshortmid: Soe,
  nshortparallel: _oe,
  nsim: Coe,
  nsime: Aoe,
  nsimeq: $oe,
  nsmid: Poe,
  nspar: Toe,
  nsqsube: Qoe,
  nsqsupe: Eoe,
  nsub: Doe,
  nsubE: Moe,
  nsube: Roe,
  nsubset: Zoe,
  nsubseteq: Ioe,
  nsubseteqq: Loe,
  nsucc: Noe,
  nsucceq: qoe,
  nsup: Boe,
  nsupE: Yoe,
  nsupe: joe,
  nsupset: Xoe,
  nsupseteq: Woe,
  nsupseteqq: zoe,
  ntgl: Voe,
  Ntilde: Uoe,
  ntilde: Foe,
  ntlg: Goe,
  ntriangleleft: Hoe,
  ntrianglelefteq: Joe,
  ntriangleright: Koe,
  ntrianglerighteq: ele,
  Nu: tle,
  nu: nle,
  num: rle,
  numero: ile,
  numsp: sle,
  nvap: ole,
  nvdash: lle,
  nvDash: ale,
  nVdash: cle,
  nVDash: hle,
  nvge: ule,
  nvgt: fle,
  nvHarr: dle,
  nvinfin: ple,
  nvlArr: gle,
  nvle: mle,
  nvlt: Ole,
  nvltrie: ble,
  nvrArr: yle,
  nvrtrie: wle,
  nvsim: kle,
  nwarhk: xle,
  nwarr: vle,
  nwArr: Sle,
  nwarrow: _le,
  nwnear: Cle,
  Oacute: Ale,
  oacute: $le,
  oast: Ple,
  Ocirc: Tle,
  ocirc: Qle,
  ocir: Ele,
  Ocy: Dle,
  ocy: Mle,
  odash: Rle,
  Odblac: Zle,
  odblac: Ile,
  odiv: Lle,
  odot: Nle,
  odsold: qle,
  OElig: Ble,
  oelig: Yle,
  ofcir: jle,
  Ofr: Xle,
  ofr: Wle,
  ogon: zle,
  Ograve: Vle,
  ograve: Ule,
  ogt: Fle,
  ohbar: Gle,
  ohm: Hle,
  oint: Jle,
  olarr: Kle,
  olcir: eae,
  olcross: tae,
  oline: nae,
  olt: rae,
  Omacr: iae,
  omacr: sae,
  Omega: oae,
  omega: lae,
  Omicron: aae,
  omicron: cae,
  omid: hae,
  ominus: uae,
  Oopf: fae,
  oopf: dae,
  opar: pae,
  OpenCurlyDoubleQuote: gae,
  OpenCurlyQuote: mae,
  operp: Oae,
  oplus: bae,
  orarr: yae,
  Or: wae,
  or: kae,
  ord: xae,
  order: vae,
  orderof: Sae,
  ordf: _ae,
  ordm: Cae,
  origof: Aae,
  oror: $ae,
  orslope: Pae,
  orv: Tae,
  oS: Qae,
  Oscr: Eae,
  oscr: Dae,
  Oslash: Mae,
  oslash: Rae,
  osol: Zae,
  Otilde: Iae,
  otilde: Lae,
  otimesas: Nae,
  Otimes: qae,
  otimes: Bae,
  Ouml: Yae,
  ouml: jae,
  ovbar: Xae,
  OverBar: Wae,
  OverBrace: zae,
  OverBracket: Vae,
  OverParenthesis: Uae,
  para: Fae,
  parallel: Gae,
  par: Hae,
  parsim: Jae,
  parsl: Kae,
  part: ece,
  PartialD: tce,
  Pcy: nce,
  pcy: rce,
  percnt: ice,
  period: sce,
  permil: oce,
  perp: lce,
  pertenk: ace,
  Pfr: cce,
  pfr: hce,
  Phi: uce,
  phi: fce,
  phiv: dce,
  phmmat: pce,
  phone: gce,
  Pi: mce,
  pi: Oce,
  pitchfork: bce,
  piv: yce,
  planck: wce,
  planckh: kce,
  plankv: xce,
  plusacir: vce,
  plusb: Sce,
  pluscir: _ce,
  plus: Cce,
  plusdo: Ace,
  plusdu: $ce,
  pluse: Pce,
  PlusMinus: Tce,
  plusmn: Qce,
  plussim: Ece,
  plustwo: Dce,
  pm: Mce,
  Poincareplane: Rce,
  pointint: Zce,
  popf: Ice,
  Popf: Lce,
  pound: Nce,
  prap: qce,
  Pr: Bce,
  pr: Yce,
  prcue: jce,
  precapprox: Xce,
  prec: Wce,
  preccurlyeq: zce,
  Precedes: Vce,
  PrecedesEqual: Uce,
  PrecedesSlantEqual: Fce,
  PrecedesTilde: Gce,
  preceq: Hce,
  precnapprox: Jce,
  precneqq: Kce,
  precnsim: ehe,
  pre: the,
  prE: nhe,
  precsim: rhe,
  prime: ihe,
  Prime: she,
  primes: ohe,
  prnap: lhe,
  prnE: ahe,
  prnsim: che,
  prod: hhe,
  Product: uhe,
  profalar: fhe,
  profline: dhe,
  profsurf: phe,
  prop: ghe,
  Proportional: mhe,
  Proportion: Ohe,
  propto: bhe,
  prsim: yhe,
  prurel: whe,
  Pscr: khe,
  pscr: xhe,
  Psi: vhe,
  psi: She,
  puncsp: _he,
  Qfr: Che,
  qfr: Ahe,
  qint: $he,
  qopf: Phe,
  Qopf: The,
  qprime: Qhe,
  Qscr: Ehe,
  qscr: Dhe,
  quaternions: Mhe,
  quatint: Rhe,
  quest: Zhe,
  questeq: Ihe,
  quot: Lhe,
  QUOT: Nhe,
  rAarr: qhe,
  race: Bhe,
  Racute: Yhe,
  racute: jhe,
  radic: Xhe,
  raemptyv: Whe,
  rang: zhe,
  Rang: Vhe,
  rangd: Uhe,
  range: Fhe,
  rangle: Ghe,
  raquo: Hhe,
  rarrap: Jhe,
  rarrb: Khe,
  rarrbfs: eue,
  rarrc: tue,
  rarr: nue,
  Rarr: rue,
  rArr: iue,
  rarrfs: sue,
  rarrhk: oue,
  rarrlp: lue,
  rarrpl: aue,
  rarrsim: cue,
  Rarrtl: hue,
  rarrtl: uue,
  rarrw: fue,
  ratail: due,
  rAtail: pue,
  ratio: gue,
  rationals: mue,
  rbarr: Oue,
  rBarr: bue,
  RBarr: yue,
  rbbrk: wue,
  rbrace: kue,
  rbrack: xue,
  rbrke: vue,
  rbrksld: Sue,
  rbrkslu: _ue,
  Rcaron: Cue,
  rcaron: Aue,
  Rcedil: $ue,
  rcedil: Pue,
  rceil: Tue,
  rcub: Que,
  Rcy: Eue,
  rcy: Due,
  rdca: Mue,
  rdldhar: Rue,
  rdquo: Zue,
  rdquor: Iue,
  rdsh: Lue,
  real: Nue,
  realine: que,
  realpart: Bue,
  reals: Yue,
  Re: jue,
  rect: Xue,
  reg: Wue,
  REG: zue,
  ReverseElement: Vue,
  ReverseEquilibrium: Uue,
  ReverseUpEquilibrium: Fue,
  rfisht: Gue,
  rfloor: Hue,
  rfr: Jue,
  Rfr: Kue,
  rHar: efe,
  rhard: tfe,
  rharu: nfe,
  rharul: rfe,
  Rho: ife,
  rho: sfe,
  rhov: ofe,
  RightAngleBracket: lfe,
  RightArrowBar: afe,
  rightarrow: cfe,
  RightArrow: hfe,
  Rightarrow: ufe,
  RightArrowLeftArrow: ffe,
  rightarrowtail: dfe,
  RightCeiling: pfe,
  RightDoubleBracket: gfe,
  RightDownTeeVector: mfe,
  RightDownVectorBar: Ofe,
  RightDownVector: bfe,
  RightFloor: yfe,
  rightharpoondown: wfe,
  rightharpoonup: kfe,
  rightleftarrows: xfe,
  rightleftharpoons: vfe,
  rightrightarrows: Sfe,
  rightsquigarrow: _fe,
  RightTeeArrow: Cfe,
  RightTee: Afe,
  RightTeeVector: $fe,
  rightthreetimes: Pfe,
  RightTriangleBar: Tfe,
  RightTriangle: Qfe,
  RightTriangleEqual: Efe,
  RightUpDownVector: Dfe,
  RightUpTeeVector: Mfe,
  RightUpVectorBar: Rfe,
  RightUpVector: Zfe,
  RightVectorBar: Ife,
  RightVector: Lfe,
  ring: Nfe,
  risingdotseq: qfe,
  rlarr: Bfe,
  rlhar: Yfe,
  rlm: jfe,
  rmoustache: Xfe,
  rmoust: Wfe,
  rnmid: zfe,
  roang: Vfe,
  roarr: Ufe,
  robrk: Ffe,
  ropar: Gfe,
  ropf: Hfe,
  Ropf: Jfe,
  roplus: Kfe,
  rotimes: ede,
  RoundImplies: tde,
  rpar: nde,
  rpargt: rde,
  rppolint: ide,
  rrarr: sde,
  Rrightarrow: ode,
  rsaquo: lde,
  rscr: ade,
  Rscr: cde,
  rsh: hde,
  Rsh: ude,
  rsqb: fde,
  rsquo: dde,
  rsquor: pde,
  rthree: gde,
  rtimes: mde,
  rtri: Ode,
  rtrie: bde,
  rtrif: yde,
  rtriltri: wde,
  RuleDelayed: kde,
  ruluhar: xde,
  rx: vde,
  Sacute: Sde,
  sacute: _de,
  sbquo: Cde,
  scap: Ade,
  Scaron: $de,
  scaron: Pde,
  Sc: Tde,
  sc: Qde,
  sccue: Ede,
  sce: Dde,
  scE: Mde,
  Scedil: Rde,
  scedil: Zde,
  Scirc: Ide,
  scirc: Lde,
  scnap: Nde,
  scnE: qde,
  scnsim: Bde,
  scpolint: Yde,
  scsim: jde,
  Scy: Xde,
  scy: Wde,
  sdotb: zde,
  sdot: Vde,
  sdote: Ude,
  searhk: Fde,
  searr: Gde,
  seArr: Hde,
  searrow: Jde,
  sect: Kde,
  semi: epe,
  seswar: tpe,
  setminus: npe,
  setmn: rpe,
  sext: ipe,
  Sfr: spe,
  sfr: ope,
  sfrown: lpe,
  sharp: ape,
  SHCHcy: cpe,
  shchcy: hpe,
  SHcy: upe,
  shcy: fpe,
  ShortDownArrow: dpe,
  ShortLeftArrow: ppe,
  shortmid: gpe,
  shortparallel: mpe,
  ShortRightArrow: Ope,
  ShortUpArrow: bpe,
  shy: ype,
  Sigma: wpe,
  sigma: kpe,
  sigmaf: xpe,
  sigmav: vpe,
  sim: Spe,
  simdot: _pe,
  sime: Cpe,
  simeq: Ape,
  simg: $pe,
  simgE: Ppe,
  siml: Tpe,
  simlE: Qpe,
  simne: Epe,
  simplus: Dpe,
  simrarr: Mpe,
  slarr: Rpe,
  SmallCircle: Zpe,
  smallsetminus: Ipe,
  smashp: Lpe,
  smeparsl: Npe,
  smid: qpe,
  smile: Bpe,
  smt: Ype,
  smte: jpe,
  smtes: Xpe,
  SOFTcy: Wpe,
  softcy: zpe,
  solbar: Vpe,
  solb: Upe,
  sol: Fpe,
  Sopf: Gpe,
  sopf: Hpe,
  spades: Jpe,
  spadesuit: Kpe,
  spar: ege,
  sqcap: tge,
  sqcaps: nge,
  sqcup: rge,
  sqcups: ige,
  Sqrt: sge,
  sqsub: oge,
  sqsube: lge,
  sqsubset: age,
  sqsubseteq: cge,
  sqsup: hge,
  sqsupe: uge,
  sqsupset: fge,
  sqsupseteq: dge,
  square: pge,
  Square: gge,
  SquareIntersection: mge,
  SquareSubset: Oge,
  SquareSubsetEqual: bge,
  SquareSuperset: yge,
  SquareSupersetEqual: wge,
  SquareUnion: kge,
  squarf: xge,
  squ: vge,
  squf: Sge,
  srarr: _ge,
  Sscr: Cge,
  sscr: Age,
  ssetmn: $ge,
  ssmile: Pge,
  sstarf: Tge,
  Star: Qge,
  star: Ege,
  starf: Dge,
  straightepsilon: Mge,
  straightphi: Rge,
  strns: Zge,
  sub: Ige,
  Sub: Lge,
  subdot: Nge,
  subE: qge,
  sube: Bge,
  subedot: Yge,
  submult: jge,
  subnE: Xge,
  subne: Wge,
  subplus: zge,
  subrarr: Vge,
  subset: Uge,
  Subset: Fge,
  subseteq: Gge,
  subseteqq: Hge,
  SubsetEqual: Jge,
  subsetneq: Kge,
  subsetneqq: eme,
  subsim: tme,
  subsub: nme,
  subsup: rme,
  succapprox: ime,
  succ: sme,
  succcurlyeq: ome,
  Succeeds: lme,
  SucceedsEqual: ame,
  SucceedsSlantEqual: cme,
  SucceedsTilde: hme,
  succeq: ume,
  succnapprox: fme,
  succneqq: dme,
  succnsim: pme,
  succsim: gme,
  SuchThat: mme,
  sum: Ome,
  Sum: bme,
  sung: yme,
  sup1: wme,
  sup2: kme,
  sup3: xme,
  sup: vme,
  Sup: Sme,
  supdot: _me,
  supdsub: Cme,
  supE: Ame,
  supe: $me,
  supedot: Pme,
  Superset: Tme,
  SupersetEqual: Qme,
  suphsol: Eme,
  suphsub: Dme,
  suplarr: Mme,
  supmult: Rme,
  supnE: Zme,
  supne: Ime,
  supplus: Lme,
  supset: Nme,
  Supset: qme,
  supseteq: Bme,
  supseteqq: Yme,
  supsetneq: jme,
  supsetneqq: Xme,
  supsim: Wme,
  supsub: zme,
  supsup: Vme,
  swarhk: Ume,
  swarr: Fme,
  swArr: Gme,
  swarrow: Hme,
  swnwar: Jme,
  szlig: Kme,
  Tab: eOe,
  target: tOe,
  Tau: nOe,
  tau: rOe,
  tbrk: iOe,
  Tcaron: sOe,
  tcaron: oOe,
  Tcedil: lOe,
  tcedil: aOe,
  Tcy: cOe,
  tcy: hOe,
  tdot: uOe,
  telrec: fOe,
  Tfr: dOe,
  tfr: pOe,
  there4: gOe,
  therefore: mOe,
  Therefore: OOe,
  Theta: bOe,
  theta: yOe,
  thetasym: wOe,
  thetav: kOe,
  thickapprox: xOe,
  thicksim: vOe,
  ThickSpace: SOe,
  ThinSpace: _Oe,
  thinsp: COe,
  thkap: AOe,
  thksim: $Oe,
  THORN: POe,
  thorn: TOe,
  tilde: QOe,
  Tilde: EOe,
  TildeEqual: DOe,
  TildeFullEqual: MOe,
  TildeTilde: ROe,
  timesbar: ZOe,
  timesb: IOe,
  times: LOe,
  timesd: NOe,
  tint: qOe,
  toea: BOe,
  topbot: YOe,
  topcir: jOe,
  top: XOe,
  Topf: WOe,
  topf: zOe,
  topfork: VOe,
  tosa: UOe,
  tprime: FOe,
  trade: GOe,
  TRADE: HOe,
  triangle: JOe,
  triangledown: KOe,
  triangleleft: e0e,
  trianglelefteq: t0e,
  triangleq: n0e,
  triangleright: r0e,
  trianglerighteq: i0e,
  tridot: s0e,
  trie: o0e,
  triminus: l0e,
  TripleDot: a0e,
  triplus: c0e,
  trisb: h0e,
  tritime: u0e,
  trpezium: f0e,
  Tscr: d0e,
  tscr: p0e,
  TScy: g0e,
  tscy: m0e,
  TSHcy: O0e,
  tshcy: b0e,
  Tstrok: y0e,
  tstrok: w0e,
  twixt: k0e,
  twoheadleftarrow: x0e,
  twoheadrightarrow: v0e,
  Uacute: S0e,
  uacute: _0e,
  uarr: C0e,
  Uarr: A0e,
  uArr: $0e,
  Uarrocir: P0e,
  Ubrcy: T0e,
  ubrcy: Q0e,
  Ubreve: E0e,
  ubreve: D0e,
  Ucirc: M0e,
  ucirc: R0e,
  Ucy: Z0e,
  ucy: I0e,
  udarr: L0e,
  Udblac: N0e,
  udblac: q0e,
  udhar: B0e,
  ufisht: Y0e,
  Ufr: j0e,
  ufr: X0e,
  Ugrave: W0e,
  ugrave: z0e,
  uHar: V0e,
  uharl: U0e,
  uharr: F0e,
  uhblk: G0e,
  ulcorn: H0e,
  ulcorner: J0e,
  ulcrop: K0e,
  ultri: e1e,
  Umacr: t1e,
  umacr: n1e,
  uml: r1e,
  UnderBar: i1e,
  UnderBrace: s1e,
  UnderBracket: o1e,
  UnderParenthesis: l1e,
  Union: a1e,
  UnionPlus: c1e,
  Uogon: h1e,
  uogon: u1e,
  Uopf: f1e,
  uopf: d1e,
  UpArrowBar: p1e,
  uparrow: g1e,
  UpArrow: m1e,
  Uparrow: O1e,
  UpArrowDownArrow: b1e,
  updownarrow: y1e,
  UpDownArrow: w1e,
  Updownarrow: k1e,
  UpEquilibrium: x1e,
  upharpoonleft: v1e,
  upharpoonright: S1e,
  uplus: _1e,
  UpperLeftArrow: C1e,
  UpperRightArrow: A1e,
  upsi: $1e,
  Upsi: P1e,
  upsih: T1e,
  Upsilon: Q1e,
  upsilon: E1e,
  UpTeeArrow: D1e,
  UpTee: M1e,
  upuparrows: R1e,
  urcorn: Z1e,
  urcorner: I1e,
  urcrop: L1e,
  Uring: N1e,
  uring: q1e,
  urtri: B1e,
  Uscr: Y1e,
  uscr: j1e,
  utdot: X1e,
  Utilde: W1e,
  utilde: z1e,
  utri: V1e,
  utrif: U1e,
  uuarr: F1e,
  Uuml: G1e,
  uuml: H1e,
  uwangle: J1e,
  vangrt: K1e,
  varepsilon: ebe,
  varkappa: tbe,
  varnothing: nbe,
  varphi: rbe,
  varpi: ibe,
  varpropto: sbe,
  varr: obe,
  vArr: lbe,
  varrho: abe,
  varsigma: cbe,
  varsubsetneq: hbe,
  varsubsetneqq: ube,
  varsupsetneq: fbe,
  varsupsetneqq: dbe,
  vartheta: pbe,
  vartriangleleft: gbe,
  vartriangleright: mbe,
  vBar: Obe,
  Vbar: bbe,
  vBarv: ybe,
  Vcy: wbe,
  vcy: kbe,
  vdash: xbe,
  vDash: vbe,
  Vdash: Sbe,
  VDash: _be,
  Vdashl: Cbe,
  veebar: Abe,
  vee: $be,
  Vee: Pbe,
  veeeq: Tbe,
  vellip: Qbe,
  verbar: Ebe,
  Verbar: Dbe,
  vert: Mbe,
  Vert: Rbe,
  VerticalBar: Zbe,
  VerticalLine: Ibe,
  VerticalSeparator: Lbe,
  VerticalTilde: Nbe,
  VeryThinSpace: qbe,
  Vfr: Bbe,
  vfr: Ybe,
  vltri: jbe,
  vnsub: Xbe,
  vnsup: Wbe,
  Vopf: zbe,
  vopf: Vbe,
  vprop: Ube,
  vrtri: Fbe,
  Vscr: Gbe,
  vscr: Hbe,
  vsubnE: Jbe,
  vsubne: Kbe,
  vsupnE: eye,
  vsupne: tye,
  Vvdash: nye,
  vzigzag: rye,
  Wcirc: iye,
  wcirc: sye,
  wedbar: oye,
  wedge: lye,
  Wedge: aye,
  wedgeq: cye,
  weierp: hye,
  Wfr: uye,
  wfr: fye,
  Wopf: dye,
  wopf: pye,
  wp: gye,
  wr: mye,
  wreath: Oye,
  Wscr: bye,
  wscr: yye,
  xcap: wye,
  xcirc: kye,
  xcup: xye,
  xdtri: vye,
  Xfr: Sye,
  xfr: _ye,
  xharr: Cye,
  xhArr: Aye,
  Xi: $ye,
  xi: Pye,
  xlarr: Tye,
  xlArr: Qye,
  xmap: Eye,
  xnis: Dye,
  xodot: Mye,
  Xopf: Rye,
  xopf: Zye,
  xoplus: Iye,
  xotime: Lye,
  xrarr: Nye,
  xrArr: qye,
  Xscr: Bye,
  xscr: Yye,
  xsqcup: jye,
  xuplus: Xye,
  xutri: Wye,
  xvee: zye,
  xwedge: Vye,
  Yacute: Uye,
  yacute: Fye,
  YAcy: Gye,
  yacy: Hye,
  Ycirc: Jye,
  ycirc: Kye,
  Ycy: ewe,
  ycy: twe,
  yen: nwe,
  Yfr: rwe,
  yfr: iwe,
  YIcy: swe,
  yicy: owe,
  Yopf: lwe,
  yopf: awe,
  Yscr: cwe,
  yscr: hwe,
  YUcy: uwe,
  yucy: fwe,
  yuml: dwe,
  Yuml: pwe,
  Zacute: gwe,
  zacute: mwe,
  Zcaron: Owe,
  zcaron: bwe,
  Zcy: ywe,
  zcy: wwe,
  Zdot: kwe,
  zdot: xwe,
  zeetrf: vwe,
  ZeroWidthSpace: Swe,
  Zeta: _we,
  zeta: Cwe,
  zfr: Awe,
  Zfr: $we,
  ZHcy: Pwe,
  zhcy: Twe,
  zigrarr: Qwe,
  zopf: Ewe,
  Zopf: Dwe,
  Zscr: Mwe,
  zscr: Rwe,
  zwj: Zwe,
  zwnj: Iwe
};
(function(t) {
  t.exports = Lwe;
})(Qm);
var Em = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, eo = {}, yy = {};
function Nwe(t) {
  var e, n, r = yy[t];
  if (r)
    return r;
  for (r = yy[t] = [], e = 0; e < 128; e++)
    n = String.fromCharCode(e), /^[0-9a-z]$/i.test(n) ? r.push(n) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < t.length; e++)
    r[t.charCodeAt(e)] = t[e];
  return r;
}
function cu(t, e, n) {
  var r, i, s, o, l, a = "";
  for (typeof e != "string" && (n = e, e = cu.defaultChars), typeof n > "u" && (n = !0), l = Nwe(e), r = 0, i = t.length; r < i; r++) {
    if (s = t.charCodeAt(r), n && s === 37 && r + 2 < i && /^[0-9a-f]{2}$/i.test(t.slice(r + 1, r + 3))) {
      a += t.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      a += l[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < i && (o = t.charCodeAt(r + 1), o >= 56320 && o <= 57343)) {
        a += encodeURIComponent(t[r] + t[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(t[r]);
  }
  return a;
}
cu.defaultChars = ";/?:@&=+$,-_.!~*'()#";
cu.componentChars = "-_.!~*'()";
var qwe = cu, wy = {};
function Bwe(t) {
  var e, n, r = wy[t];
  if (r)
    return r;
  for (r = wy[t] = [], e = 0; e < 128; e++)
    n = String.fromCharCode(e), r.push(n);
  for (e = 0; e < t.length; e++)
    n = t.charCodeAt(e), r[n] = "%" + ("0" + n.toString(16).toUpperCase()).slice(-2);
  return r;
}
function hu(t, e) {
  var n;
  return typeof e != "string" && (e = hu.defaultChars), n = Bwe(e), t.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var i, s, o, l, a, c, h, u = "";
    for (i = 0, s = r.length; i < s; i += 3) {
      if (o = parseInt(r.slice(i + 1, i + 3), 16), o < 128) {
        u += n[o];
        continue;
      }
      if ((o & 224) === 192 && i + 3 < s && (l = parseInt(r.slice(i + 4, i + 6), 16), (l & 192) === 128)) {
        h = o << 6 & 1984 | l & 63, h < 128 ? u += "\uFFFD\uFFFD" : u += String.fromCharCode(h), i += 3;
        continue;
      }
      if ((o & 240) === 224 && i + 6 < s && (l = parseInt(r.slice(i + 4, i + 6), 16), a = parseInt(r.slice(i + 7, i + 9), 16), (l & 192) === 128 && (a & 192) === 128)) {
        h = o << 12 & 61440 | l << 6 & 4032 | a & 63, h < 2048 || h >= 55296 && h <= 57343 ? u += "\uFFFD\uFFFD\uFFFD" : u += String.fromCharCode(h), i += 6;
        continue;
      }
      if ((o & 248) === 240 && i + 9 < s && (l = parseInt(r.slice(i + 4, i + 6), 16), a = parseInt(r.slice(i + 7, i + 9), 16), c = parseInt(r.slice(i + 10, i + 12), 16), (l & 192) === 128 && (a & 192) === 128 && (c & 192) === 128)) {
        h = o << 18 & 1835008 | l << 12 & 258048 | a << 6 & 4032 | c & 63, h < 65536 || h > 1114111 ? u += "\uFFFD\uFFFD\uFFFD\uFFFD" : (h -= 65536, u += String.fromCharCode(55296 + (h >> 10), 56320 + (h & 1023))), i += 9;
        continue;
      }
      u += "\uFFFD";
    }
    return u;
  });
}
hu.defaultChars = ";/?:@&=+$,#";
hu.componentChars = "";
var Ywe = hu, jwe = function(e) {
  var n = "";
  return n += e.protocol || "", n += e.slashes ? "//" : "", n += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? n += "[" + e.hostname + "]" : n += e.hostname || "", n += e.port ? ":" + e.port : "", n += e.pathname || "", n += e.search || "", n += e.hash || "", n;
};
function bh() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var Xwe = /^([a-z0-9.+-]+:)/i, Wwe = /:[0-9]*$/, zwe = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Vwe = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Uwe = ["{", "}", "|", "\\", "^", "`"].concat(Vwe), Fwe = ["'"].concat(Uwe), ky = ["%", "/", "?", ";", "#"].concat(Fwe), xy = ["/", "?", "#"], Gwe = 255, vy = /^[+a-z0-9A-Z_-]{0,63}$/, Hwe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, Sy = {
  javascript: !0,
  "javascript:": !0
}, _y = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function Jwe(t, e) {
  if (t && t instanceof bh)
    return t;
  var n = new bh();
  return n.parse(t, e), n;
}
bh.prototype.parse = function(t, e) {
  var n, r, i, s, o, l = t;
  if (l = l.trim(), !e && t.split("#").length === 1) {
    var a = zwe.exec(l);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var c = Xwe.exec(l);
  if (c && (c = c[0], i = c.toLowerCase(), this.protocol = c, l = l.substr(c.length)), (e || c || l.match(/^\/\/[^@\/]+@[^@\/]+/)) && (o = l.substr(0, 2) === "//", o && !(c && Sy[c]) && (l = l.substr(2), this.slashes = !0)), !Sy[c] && (o || c && !_y[c])) {
    var h = -1;
    for (n = 0; n < xy.length; n++)
      s = l.indexOf(xy[n]), s !== -1 && (h === -1 || s < h) && (h = s);
    var u, f;
    for (h === -1 ? f = l.lastIndexOf("@") : f = l.lastIndexOf("@", h), f !== -1 && (u = l.slice(0, f), l = l.slice(f + 1), this.auth = u), h = -1, n = 0; n < ky.length; n++)
      s = l.indexOf(ky[n]), s !== -1 && (h === -1 || s < h) && (h = s);
    h === -1 && (h = l.length), l[h - 1] === ":" && h--;
    var d = l.slice(0, h);
    l = l.slice(h), this.parseHost(d), this.hostname = this.hostname || "";
    var p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      var g = this.hostname.split(/\./);
      for (n = 0, r = g.length; n < r; n++) {
        var m = g[n];
        if (!!m && !m.match(vy)) {
          for (var O = "", b = 0, y = m.length; b < y; b++)
            m.charCodeAt(b) > 127 ? O += "x" : O += m[b];
          if (!O.match(vy)) {
            var w = g.slice(0, n), S = g.slice(n + 1), x = m.match(Hwe);
            x && (w.push(x[1]), S.unshift(x[2])), S.length && (l = S.join(".") + l), this.hostname = w.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > Gwe && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var v = l.indexOf("#");
  v !== -1 && (this.hash = l.substr(v), l = l.slice(0, v));
  var P = l.indexOf("?");
  return P !== -1 && (this.search = l.substr(P), l = l.slice(0, P)), l && (this.pathname = l), _y[i] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
bh.prototype.parseHost = function(t) {
  var e = Wwe.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
var Kwe = Jwe;
eo.encode = qwe;
eo.decode = Ywe;
eo.format = jwe;
eo.parse = Kwe;
var ni = {}, Df, Cy;
function pA() {
  return Cy || (Cy = 1, Df = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Df;
}
var Mf, Ay;
function gA() {
  return Ay || (Ay = 1, Mf = /[\0-\x1F\x7F-\x9F]/), Mf;
}
var Rf, $y;
function eke() {
  return $y || ($y = 1, Rf = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Rf;
}
var Zf, Py;
function mA() {
  return Py || (Py = 1, Zf = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Zf;
}
var Ty;
function tke() {
  return Ty || (Ty = 1, ni.Any = pA(), ni.Cc = gA(), ni.Cf = eke(), ni.P = Em, ni.Z = mA()), ni;
}
(function(t) {
  function e(A) {
    return Object.prototype.toString.call(A);
  }
  function n(A) {
    return e(A) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function i(A, z) {
    return r.call(A, z);
  }
  function s(A) {
    var z = Array.prototype.slice.call(arguments, 1);
    return z.forEach(function(V) {
      if (!!V) {
        if (typeof V != "object")
          throw new TypeError(V + "must be object");
        Object.keys(V).forEach(function(ie) {
          A[ie] = V[ie];
        });
      }
    }), A;
  }
  function o(A, z, V) {
    return [].concat(A.slice(0, z), V, A.slice(z + 1));
  }
  function l(A) {
    return !(A >= 55296 && A <= 57343 || A >= 64976 && A <= 65007 || (A & 65535) === 65535 || (A & 65535) === 65534 || A >= 0 && A <= 8 || A === 11 || A >= 14 && A <= 31 || A >= 127 && A <= 159 || A > 1114111);
  }
  function a(A) {
    if (A > 65535) {
      A -= 65536;
      var z = 55296 + (A >> 10), V = 56320 + (A & 1023);
      return String.fromCharCode(z, V);
    }
    return String.fromCharCode(A);
  }
  var c = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, h = /&([a-z#][a-z0-9]{1,31});/gi, u = new RegExp(c.source + "|" + h.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, d = Qm.exports;
  function p(A, z) {
    var V = 0;
    return i(d, z) ? d[z] : z.charCodeAt(0) === 35 && f.test(z) && (V = z[1].toLowerCase() === "x" ? parseInt(z.slice(2), 16) : parseInt(z.slice(1), 10), l(V)) ? a(V) : A;
  }
  function g(A) {
    return A.indexOf("\\") < 0 ? A : A.replace(c, "$1");
  }
  function m(A) {
    return A.indexOf("\\") < 0 && A.indexOf("&") < 0 ? A : A.replace(u, function(z, V, ie) {
      return V || p(z, ie);
    });
  }
  var O = /[&<>"]/, b = /[&<>"]/g, y = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function w(A) {
    return y[A];
  }
  function S(A) {
    return O.test(A) ? A.replace(b, w) : A;
  }
  var x = /[.?*+^$[\]\\(){}|-]/g;
  function v(A) {
    return A.replace(x, "\\$&");
  }
  function P(A) {
    switch (A) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function D(A) {
    if (A >= 8192 && A <= 8202)
      return !0;
    switch (A) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var Q = Em;
  function R(A) {
    return Q.test(A);
  }
  function N(A) {
    switch (A) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function F(A) {
    return A = A.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (A = A.replace(//g, "\xDF")), A.toLowerCase().toUpperCase();
  }
  t.lib = {}, t.lib.mdurl = eo, t.lib.ucmicro = tke(), t.assign = s, t.isString = n, t.has = i, t.unescapeMd = g, t.unescapeAll = m, t.isValidEntityCode = l, t.fromCodePoint = a, t.escapeHtml = S, t.arrayReplaceAt = o, t.isSpace = P, t.isWhiteSpace = D, t.isMdAsciiPunct = N, t.isPunctChar = R, t.escapeRE = v, t.normalizeReference = F;
})(ue);
var uu = {}, nke = function(e, n, r) {
  var i, s, o, l, a = -1, c = e.posMax, h = e.pos;
  for (e.pos = n + 1, i = 1; e.pos < c; ) {
    if (o = e.src.charCodeAt(e.pos), o === 93 && (i--, i === 0)) {
      s = !0;
      break;
    }
    if (l = e.pos, e.md.inline.skipToken(e), o === 91) {
      if (l === e.pos - 1)
        i++;
      else if (r)
        return e.pos = h, -1;
    }
  }
  return s && (a = e.pos), e.pos = h, a;
}, Qy = ue.unescapeAll, rke = function(e, n, r) {
  var i, s, o = 0, l = n, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(n) === 60) {
    for (n++; n < r; ) {
      if (i = e.charCodeAt(n), i === 10 || i === 60)
        return a;
      if (i === 62)
        return a.pos = n + 1, a.str = Qy(e.slice(l + 1, n)), a.ok = !0, a;
      if (i === 92 && n + 1 < r) {
        n += 2;
        continue;
      }
      n++;
    }
    return a;
  }
  for (s = 0; n < r && (i = e.charCodeAt(n), !(i === 32 || i < 32 || i === 127)); ) {
    if (i === 92 && n + 1 < r) {
      if (e.charCodeAt(n + 1) === 32)
        break;
      n += 2;
      continue;
    }
    if (i === 40 && (s++, s > 32))
      return a;
    if (i === 41) {
      if (s === 0)
        break;
      s--;
    }
    n++;
  }
  return l === n || s !== 0 || (a.str = Qy(e.slice(l, n)), a.lines = o, a.pos = n, a.ok = !0), a;
}, ike = ue.unescapeAll, ske = function(e, n, r) {
  var i, s, o = 0, l = n, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (n >= r || (s = e.charCodeAt(n), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (n++, s === 40 && (s = 41); n < r; ) {
    if (i = e.charCodeAt(n), i === s)
      return a.pos = n + 1, a.lines = o, a.str = ike(e.slice(l + 1, n)), a.ok = !0, a;
    if (i === 40 && s === 41)
      return a;
    i === 10 ? o++ : i === 92 && n + 1 < r && (n++, e.charCodeAt(n) === 10 && o++), n++;
  }
  return a;
};
uu.parseLinkLabel = nke;
uu.parseLinkDestination = rke;
uu.parseLinkTitle = ske;
var oke = ue.assign, lke = ue.unescapeAll, Ei = ue.escapeHtml, Gn = {};
Gn.code_inline = function(t, e, n, r, i) {
  var s = t[e];
  return "<code" + i.renderAttrs(s) + ">" + Ei(t[e].content) + "</code>";
};
Gn.code_block = function(t, e, n, r, i) {
  var s = t[e];
  return "<pre" + i.renderAttrs(s) + "><code>" + Ei(t[e].content) + `</code></pre>
`;
};
Gn.fence = function(t, e, n, r, i) {
  var s = t[e], o = s.info ? lke(s.info).trim() : "", l = "", a = "", c, h, u, f, d;
  return o && (u = o.split(/(\s+)/g), l = u[0], a = u.slice(2).join("")), n.highlight ? c = n.highlight(s.content, l, a) || Ei(s.content) : c = Ei(s.content), c.indexOf("<pre") === 0 ? c + `
` : o ? (h = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], h < 0 ? f.push(["class", n.langPrefix + l]) : (f[h] = f[h].slice(), f[h][1] += " " + n.langPrefix + l), d = {
    attrs: f
  }, "<pre><code" + i.renderAttrs(d) + ">" + c + `</code></pre>
`) : "<pre><code" + i.renderAttrs(s) + ">" + c + `</code></pre>
`;
};
Gn.image = function(t, e, n, r, i) {
  var s = t[e];
  return s.attrs[s.attrIndex("alt")][1] = i.renderInlineAsText(s.children, n, r), i.renderToken(t, e, n);
};
Gn.hardbreak = function(t, e, n) {
  return n.xhtmlOut ? `<br />
` : `<br>
`;
};
Gn.softbreak = function(t, e, n) {
  return n.breaks ? n.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Gn.text = function(t, e) {
  return Ei(t[e].content);
};
Gn.html_block = function(t, e) {
  return t[e].content;
};
Gn.html_inline = function(t, e) {
  return t[e].content;
};
function to() {
  this.rules = oke({}, Gn);
}
to.prototype.renderAttrs = function(e) {
  var n, r, i;
  if (!e.attrs)
    return "";
  for (i = "", n = 0, r = e.attrs.length; n < r; n++)
    i += " " + Ei(e.attrs[n][0]) + '="' + Ei(e.attrs[n][1]) + '"';
  return i;
};
to.prototype.renderToken = function(e, n, r) {
  var i, s = "", o = !1, l = e[n];
  return l.hidden ? "" : (l.block && l.nesting !== -1 && n && e[n - 1].hidden && (s += `
`), s += (l.nesting === -1 ? "</" : "<") + l.tag, s += this.renderAttrs(l), l.nesting === 0 && r.xhtmlOut && (s += " /"), l.block && (o = !0, l.nesting === 1 && n + 1 < e.length && (i = e[n + 1], (i.type === "inline" || i.hidden || i.nesting === -1 && i.tag === l.tag) && (o = !1))), s += o ? `>
` : ">", s);
};
to.prototype.renderInline = function(t, e, n) {
  for (var r, i = "", s = this.rules, o = 0, l = t.length; o < l; o++)
    r = t[o].type, typeof s[r] < "u" ? i += s[r](t, o, e, n, this) : i += this.renderToken(t, o, e);
  return i;
};
to.prototype.renderInlineAsText = function(t, e, n) {
  for (var r = "", i = 0, s = t.length; i < s; i++)
    t[i].type === "text" ? r += t[i].content : t[i].type === "image" ? r += this.renderInlineAsText(t[i].children, e, n) : t[i].type === "softbreak" && (r += `
`);
  return r;
};
to.prototype.render = function(t, e, n) {
  var r, i, s, o = "", l = this.rules;
  for (r = 0, i = t.length; r < i; r++)
    s = t[r].type, s === "inline" ? o += this.renderInline(t[r].children, e, n) : typeof l[s] < "u" ? o += l[t[r].type](t, r, e, n, this) : o += this.renderToken(t, r, e, n);
  return o;
};
var ake = to;
function vn() {
  this.__rules__ = [], this.__cache__ = null;
}
vn.prototype.__find__ = function(t) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === t)
      return e;
  return -1;
};
vn.prototype.__compile__ = function() {
  var t = this, e = [""];
  t.__rules__.forEach(function(n) {
    !n.enabled || n.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), t.__cache__ = {}, e.forEach(function(n) {
    t.__cache__[n] = [], t.__rules__.forEach(function(r) {
      !r.enabled || n && r.alt.indexOf(n) < 0 || t.__cache__[n].push(r.fn);
    });
  });
};
vn.prototype.at = function(t, e, n) {
  var r = this.__find__(t), i = n || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__[r].fn = e, this.__rules__[r].alt = i.alt || [], this.__cache__ = null;
};
vn.prototype.before = function(t, e, n, r) {
  var i = this.__find__(t), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
vn.prototype.after = function(t, e, n, r) {
  var i = this.__find__(t), s = r || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + t);
  this.__rules__.splice(i + 1, 0, {
    name: e,
    enabled: !0,
    fn: n,
    alt: s.alt || []
  }), this.__cache__ = null;
};
vn.prototype.push = function(t, e, n) {
  var r = n || {};
  this.__rules__.push({
    name: t,
    enabled: !0,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
vn.prototype.enable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  var n = [];
  return t.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !0, n.push(r);
  }, this), this.__cache__ = null, n;
};
vn.prototype.enableOnly = function(t, e) {
  Array.isArray(t) || (t = [t]), this.__rules__.forEach(function(n) {
    n.enabled = !1;
  }), this.enable(t, e);
};
vn.prototype.disable = function(t, e) {
  Array.isArray(t) || (t = [t]);
  var n = [];
  return t.forEach(function(r) {
    var i = this.__find__(r);
    if (i < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[i].enabled = !1, n.push(r);
  }, this), this.__cache__ = null, n;
};
vn.prototype.getRules = function(t) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[t] || [];
};
var Dm = vn, cke = /\r\n?|\n/g, hke = /\0/g, uke = function(e) {
  var n;
  n = e.src.replace(cke, `
`), n = n.replace(hke, "\uFFFD"), e.src = n;
}, fke = function(e) {
  var n;
  e.inlineMode ? (n = new e.Token("inline", "", 0), n.content = e.src, n.map = [0, 1], n.children = [], e.tokens.push(n)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, dke = function(e) {
  var n = e.tokens, r, i, s;
  for (i = 0, s = n.length; i < s; i++)
    r = n[i], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
}, pke = ue.arrayReplaceAt;
function gke(t) {
  return /^<a[>\s]/i.test(t);
}
function mke(t) {
  return /^<\/a\s*>/i.test(t);
}
var Oke = function(e) {
  var n, r, i, s, o, l, a, c, h, u, f, d, p, g, m, O, b = e.tokens, y;
  if (!!e.md.options.linkify) {
    for (r = 0, i = b.length; r < i; r++)
      if (!(b[r].type !== "inline" || !e.md.linkify.pretest(b[r].content)))
        for (s = b[r].children, p = 0, n = s.length - 1; n >= 0; n--) {
          if (l = s[n], l.type === "link_close") {
            for (n--; s[n].level !== l.level && s[n].type !== "link_open"; )
              n--;
            continue;
          }
          if (l.type === "html_inline" && (gke(l.content) && p > 0 && p--, mke(l.content) && p++), !(p > 0) && l.type === "text" && e.md.linkify.test(l.content)) {
            for (h = l.content, y = e.md.linkify.match(h), a = [], d = l.level, f = 0, c = 0; c < y.length; c++)
              g = y[c].url, m = e.md.normalizeLink(g), e.md.validateLink(m) && (O = y[c].text, y[c].schema ? y[c].schema === "mailto:" && !/^mailto:/i.test(O) ? O = e.md.normalizeLinkText("mailto:" + O).replace(/^mailto:/, "") : O = e.md.normalizeLinkText(O) : O = e.md.normalizeLinkText("http://" + O).replace(/^http:\/\//, ""), u = y[c].index, u > f && (o = new e.Token("text", "", 0), o.content = h.slice(f, u), o.level = d, a.push(o)), o = new e.Token("link_open", "a", 1), o.attrs = [["href", m]], o.level = d++, o.markup = "linkify", o.info = "auto", a.push(o), o = new e.Token("text", "", 0), o.content = O, o.level = d, a.push(o), o = new e.Token("link_close", "a", -1), o.level = --d, o.markup = "linkify", o.info = "auto", a.push(o), f = y[c].lastIndex);
            f < h.length && (o = new e.Token("text", "", 0), o.content = h.slice(f), o.level = d, a.push(o)), b[r].children = s = pke(s, n, a);
          }
        }
  }
}, OA = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, bke = /\((c|tm|r|p)\)/i, yke = /\((c|tm|r|p)\)/ig, wke = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function kke(t, e) {
  return wke[e.toLowerCase()];
}
function xke(t) {
  var e, n, r = 0;
  for (e = t.length - 1; e >= 0; e--)
    n = t[e], n.type === "text" && !r && (n.content = n.content.replace(yke, kke)), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
function vke(t) {
  var e, n, r = 0;
  for (e = t.length - 1; e >= 0; e--)
    n = t[e], n.type === "text" && !r && OA.test(n.content) && (n.content = n.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), n.type === "link_open" && n.info === "auto" && r--, n.type === "link_close" && n.info === "auto" && r++;
}
var Ske = function(e) {
  var n;
  if (!!e.md.options.typographer)
    for (n = e.tokens.length - 1; n >= 0; n--)
      e.tokens[n].type === "inline" && (bke.test(e.tokens[n].content) && xke(e.tokens[n].children), OA.test(e.tokens[n].content) && vke(e.tokens[n].children));
}, Ey = ue.isWhiteSpace, Dy = ue.isPunctChar, My = ue.isMdAsciiPunct, _ke = /['"]/, Ry = /['"]/g, Zy = "\u2019";
function za(t, e, n) {
  return t.substr(0, e) + n + t.substr(e + 1);
}
function Cke(t, e) {
  var n, r, i, s, o, l, a, c, h, u, f, d, p, g, m, O, b, y, w, S, x;
  for (w = [], n = 0; n < t.length; n++) {
    for (r = t[n], a = t[n].level, b = w.length - 1; b >= 0 && !(w[b].level <= a); b--)
      ;
    if (w.length = b + 1, r.type !== "text")
      continue;
    i = r.content, o = 0, l = i.length;
    e:
      for (; o < l && (Ry.lastIndex = o, s = Ry.exec(i), !!s); ) {
        if (m = O = !0, o = s.index + 1, y = s[0] === "'", h = 32, s.index - 1 >= 0)
          h = i.charCodeAt(s.index - 1);
        else
          for (b = n - 1; b >= 0 && !(t[b].type === "softbreak" || t[b].type === "hardbreak"); b--)
            if (!!t[b].content) {
              h = t[b].content.charCodeAt(t[b].content.length - 1);
              break;
            }
        if (u = 32, o < l)
          u = i.charCodeAt(o);
        else
          for (b = n + 1; b < t.length && !(t[b].type === "softbreak" || t[b].type === "hardbreak"); b++)
            if (!!t[b].content) {
              u = t[b].content.charCodeAt(0);
              break;
            }
        if (f = My(h) || Dy(String.fromCharCode(h)), d = My(u) || Dy(String.fromCharCode(u)), p = Ey(h), g = Ey(u), g ? m = !1 : d && (p || f || (m = !1)), p ? O = !1 : f && (g || d || (O = !1)), u === 34 && s[0] === '"' && h >= 48 && h <= 57 && (O = m = !1), m && O && (m = f, O = d), !m && !O) {
          y && (r.content = za(r.content, s.index, Zy));
          continue;
        }
        if (O) {
          for (b = w.length - 1; b >= 0 && (c = w[b], !(w[b].level < a)); b--)
            if (c.single === y && w[b].level === a) {
              c = w[b], y ? (S = e.md.options.quotes[2], x = e.md.options.quotes[3]) : (S = e.md.options.quotes[0], x = e.md.options.quotes[1]), r.content = za(r.content, s.index, x), t[c.token].content = za(
                t[c.token].content,
                c.pos,
                S
              ), o += x.length - 1, c.token === n && (o += S.length - 1), i = r.content, l = i.length, w.length = b;
              continue e;
            }
        }
        m ? w.push({
          token: n,
          pos: s.index,
          single: y,
          level: a
        }) : O && y && (r.content = za(r.content, s.index, Zy));
      }
  }
}
var Ake = function(e) {
  var n;
  if (!!e.md.options.typographer)
    for (n = e.tokens.length - 1; n >= 0; n--)
      e.tokens[n].type !== "inline" || !_ke.test(e.tokens[n].content) || Cke(e.tokens[n].children, e);
};
function no(t, e, n) {
  this.type = t, this.tag = e, this.attrs = null, this.map = null, this.nesting = n, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
no.prototype.attrIndex = function(e) {
  var n, r, i;
  if (!this.attrs)
    return -1;
  for (n = this.attrs, r = 0, i = n.length; r < i; r++)
    if (n[r][0] === e)
      return r;
  return -1;
};
no.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
no.prototype.attrSet = function(e, n) {
  var r = this.attrIndex(e), i = [e, n];
  r < 0 ? this.attrPush(i) : this.attrs[r] = i;
};
no.prototype.attrGet = function(e) {
  var n = this.attrIndex(e), r = null;
  return n >= 0 && (r = this.attrs[n][1]), r;
};
no.prototype.attrJoin = function(e, n) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, n]) : this.attrs[r][1] = this.attrs[r][1] + " " + n;
};
var Mm = no, $ke = Mm;
function bA(t, e, n) {
  this.src = t, this.env = n, this.tokens = [], this.inlineMode = !1, this.md = e;
}
bA.prototype.Token = $ke;
var Pke = bA, Tke = Dm, If = [
  ["normalize", uke],
  ["block", fke],
  ["inline", dke],
  ["linkify", Oke],
  ["replacements", Ske],
  ["smartquotes", Ake]
];
function Rm() {
  this.ruler = new Tke();
  for (var t = 0; t < If.length; t++)
    this.ruler.push(If[t][0], If[t][1]);
}
Rm.prototype.process = function(t) {
  var e, n, r;
  for (r = this.ruler.getRules(""), e = 0, n = r.length; e < n; e++)
    r[e](t);
};
Rm.prototype.State = Pke;
var Qke = Rm, Lf = ue.isSpace;
function Nf(t, e) {
  var n = t.bMarks[e] + t.tShift[e], r = t.eMarks[e];
  return t.src.substr(n, r - n);
}
function Iy(t) {
  var e = [], n = 0, r = t.length, i, s = !1, o = 0, l = "";
  for (i = t.charCodeAt(n); n < r; )
    i === 124 && (s ? (l += t.substring(o, n - 1), o = n) : (e.push(l + t.substring(o, n)), l = "", o = n + 1)), s = i === 92, n++, i = t.charCodeAt(n);
  return e.push(l + t.substring(o)), e;
}
var Eke = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f, d, p, g, m, O, b, y, w, S, x;
  if (n + 2 > r || (h = n + 1, e.sCount[h] < e.blkIndent) || e.sCount[h] - e.blkIndent >= 4 || (l = e.bMarks[h] + e.tShift[h], l >= e.eMarks[h]) || (S = e.src.charCodeAt(l++), S !== 124 && S !== 45 && S !== 58) || l >= e.eMarks[h] || (x = e.src.charCodeAt(l++), x !== 124 && x !== 45 && x !== 58 && !Lf(x)) || S === 45 && Lf(x))
    return !1;
  for (; l < e.eMarks[h]; ) {
    if (s = e.src.charCodeAt(l), s !== 124 && s !== 45 && s !== 58 && !Lf(s))
      return !1;
    l++;
  }
  for (o = Nf(e, n + 1), u = o.split("|"), p = [], a = 0; a < u.length; a++) {
    if (g = u[a].trim(), !g) {
      if (a === 0 || a === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(g))
      return !1;
    g.charCodeAt(g.length - 1) === 58 ? p.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? p.push("left") : p.push("");
  }
  if (o = Nf(e, n).trim(), o.indexOf("|") === -1 || e.sCount[n] - e.blkIndent >= 4 || (u = Iy(o), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), f = u.length, f === 0 || f !== p.length))
    return !1;
  if (i)
    return !0;
  for (b = e.parentType, e.parentType = "table", w = e.md.block.ruler.getRules("blockquote"), d = e.push("table_open", "table", 1), d.map = m = [n, 0], d = e.push("thead_open", "thead", 1), d.map = [n, n + 1], d = e.push("tr_open", "tr", 1), d.map = [n, n + 1], a = 0; a < u.length; a++)
    d = e.push("th_open", "th", 1), p[a] && (d.attrs = [["style", "text-align:" + p[a]]]), d = e.push("inline", "", 0), d.content = u[a].trim(), d.children = [], d = e.push("th_close", "th", -1);
  for (d = e.push("tr_close", "tr", -1), d = e.push("thead_close", "thead", -1), h = n + 2; h < r && !(e.sCount[h] < e.blkIndent); h++) {
    for (y = !1, a = 0, c = w.length; a < c; a++)
      if (w[a](e, h, r, !0)) {
        y = !0;
        break;
      }
    if (y || (o = Nf(e, h).trim(), !o) || e.sCount[h] - e.blkIndent >= 4)
      break;
    for (u = Iy(o), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), h === n + 2 && (d = e.push("tbody_open", "tbody", 1), d.map = O = [n + 2, 0]), d = e.push("tr_open", "tr", 1), d.map = [h, h + 1], a = 0; a < f; a++)
      d = e.push("td_open", "td", 1), p[a] && (d.attrs = [["style", "text-align:" + p[a]]]), d = e.push("inline", "", 0), d.content = u[a] ? u[a].trim() : "", d.children = [], d = e.push("td_close", "td", -1);
    d = e.push("tr_close", "tr", -1);
  }
  return O && (d = e.push("tbody_close", "tbody", -1), O[1] = h), d = e.push("table_close", "table", -1), m[1] = h, e.parentType = b, e.line = h, !0;
}, Dke = function(e, n, r) {
  var i, s, o;
  if (e.sCount[n] - e.blkIndent < 4)
    return !1;
  for (s = i = n + 1; i < r; ) {
    if (e.isEmpty(i)) {
      i++;
      continue;
    }
    if (e.sCount[i] - e.blkIndent >= 4) {
      i++, s = i;
      continue;
    }
    break;
  }
  return e.line = s, o = e.push("code_block", "code", 0), o.content = e.getLines(n, s, 4 + e.blkIndent, !1) + `
`, o.map = [n, e.line], !0;
}, Mke = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f = !1, d = e.bMarks[n] + e.tShift[n], p = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || d + 3 > p || (s = e.src.charCodeAt(d), s !== 126 && s !== 96) || (c = d, d = e.skipChars(d, s), o = d - c, o < 3) || (u = e.src.slice(c, d), l = e.src.slice(d, p), s === 96 && l.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (i)
    return !0;
  for (a = n; a++, !(a >= r || (d = c = e.bMarks[a] + e.tShift[a], p = e.eMarks[a], d < p && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(d) === s && !(e.sCount[a] - e.blkIndent >= 4) && (d = e.skipChars(d, s), !(d - c < o) && (d = e.skipSpaces(d), !(d < p)))) {
      f = !0;
      break;
    }
  return o = e.sCount[n], e.line = a + (f ? 1 : 0), h = e.push("fence", "code", 0), h.info = l, h.content = e.getLines(n + 1, a, o, !0), h.markup = u, h.map = [n, e.line], !0;
}, Ly = ue.isSpace, Rke = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f, d, p, g, m, O, b, y, w, S, x, v, P, D = e.lineMax, Q = e.bMarks[n] + e.tShift[n], R = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(Q++) !== 62)
    return !1;
  if (i)
    return !0;
  for (a = d = e.sCount[n] + 1, e.src.charCodeAt(Q) === 32 ? (Q++, a++, d++, s = !1, w = !0) : e.src.charCodeAt(Q) === 9 ? (w = !0, (e.bsCount[n] + d) % 4 === 3 ? (Q++, a++, d++, s = !1) : s = !0) : w = !1, p = [e.bMarks[n]], e.bMarks[n] = Q; Q < R && (o = e.src.charCodeAt(Q), Ly(o)); ) {
    o === 9 ? d += 4 - (d + e.bsCount[n] + (s ? 1 : 0)) % 4 : d++;
    Q++;
  }
  for (g = [e.bsCount[n]], e.bsCount[n] = e.sCount[n] + 1 + (w ? 1 : 0), h = Q >= R, b = [e.sCount[n]], e.sCount[n] = d - a, y = [e.tShift[n]], e.tShift[n] = Q - e.bMarks[n], x = e.md.block.ruler.getRules("blockquote"), O = e.parentType, e.parentType = "blockquote", f = n + 1; f < r && (P = e.sCount[f] < e.blkIndent, Q = e.bMarks[f] + e.tShift[f], R = e.eMarks[f], !(Q >= R)); f++) {
    if (e.src.charCodeAt(Q++) === 62 && !P) {
      for (a = d = e.sCount[f] + 1, e.src.charCodeAt(Q) === 32 ? (Q++, a++, d++, s = !1, w = !0) : e.src.charCodeAt(Q) === 9 ? (w = !0, (e.bsCount[f] + d) % 4 === 3 ? (Q++, a++, d++, s = !1) : s = !0) : w = !1, p.push(e.bMarks[f]), e.bMarks[f] = Q; Q < R && (o = e.src.charCodeAt(Q), Ly(o)); ) {
        o === 9 ? d += 4 - (d + e.bsCount[f] + (s ? 1 : 0)) % 4 : d++;
        Q++;
      }
      h = Q >= R, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (w ? 1 : 0), b.push(e.sCount[f]), e.sCount[f] = d - a, y.push(e.tShift[f]), e.tShift[f] = Q - e.bMarks[f];
      continue;
    }
    if (h)
      break;
    for (S = !1, l = 0, c = x.length; l < c; l++)
      if (x[l](e, f, r, !0)) {
        S = !0;
        break;
      }
    if (S) {
      e.lineMax = f, e.blkIndent !== 0 && (p.push(e.bMarks[f]), g.push(e.bsCount[f]), y.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    p.push(e.bMarks[f]), g.push(e.bsCount[f]), y.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (m = e.blkIndent, e.blkIndent = 0, v = e.push("blockquote_open", "blockquote", 1), v.markup = ">", v.map = u = [n, 0], e.md.block.tokenize(e, n, f), v = e.push("blockquote_close", "blockquote", -1), v.markup = ">", e.lineMax = D, e.parentType = O, u[1] = e.line, l = 0; l < y.length; l++)
    e.bMarks[l + n] = p[l], e.tShift[l + n] = y[l], e.sCount[l + n] = b[l], e.bsCount[l + n] = g[l];
  return e.blkIndent = m, !0;
}, Zke = ue.isSpace, Ike = function(e, n, r, i) {
  var s, o, l, a, c = e.bMarks[n] + e.tShift[n], h = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (o = 1; c < h; ) {
    if (l = e.src.charCodeAt(c++), l !== s && !Zke(l))
      return !1;
    l === s && o++;
  }
  return o < 3 ? !1 : (i || (e.line = n + 1, a = e.push("hr", "hr", 0), a.map = [n, e.line], a.markup = Array(o + 1).join(String.fromCharCode(s))), !0);
}, yA = ue.isSpace;
function Ny(t, e) {
  var n, r, i, s;
  return r = t.bMarks[e] + t.tShift[e], i = t.eMarks[e], n = t.src.charCodeAt(r++), n !== 42 && n !== 45 && n !== 43 || r < i && (s = t.src.charCodeAt(r), !yA(s)) ? -1 : r;
}
function qy(t, e) {
  var n, r = t.bMarks[e] + t.tShift[e], i = r, s = t.eMarks[e];
  if (i + 1 >= s || (n = t.src.charCodeAt(i++), n < 48 || n > 57))
    return -1;
  for (; ; ) {
    if (i >= s)
      return -1;
    if (n = t.src.charCodeAt(i++), n >= 48 && n <= 57) {
      if (i - r >= 10)
        return -1;
      continue;
    }
    if (n === 41 || n === 46)
      break;
    return -1;
  }
  return i < s && (n = t.src.charCodeAt(i), !yA(n)) ? -1 : i;
}
function Lke(t, e) {
  var n, r, i = t.level + 2;
  for (n = e + 2, r = t.tokens.length - 2; n < r; n++)
    t.tokens[n].level === i && t.tokens[n].type === "paragraph_open" && (t.tokens[n + 2].hidden = !0, t.tokens[n].hidden = !0, n += 2);
}
var Nke = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f, d, p, g, m, O, b, y, w, S, x, v, P, D, Q, R, N, F, A, z, V, ie = !1, ae = !0;
  if (e.sCount[n] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[n] - e.listIndent >= 4 && e.sCount[n] < e.blkIndent)
    return !1;
  if (i && e.parentType === "paragraph" && e.sCount[n] >= e.blkIndent && (ie = !0), (R = qy(e, n)) >= 0) {
    if (u = !0, F = e.bMarks[n] + e.tShift[n], O = Number(e.src.slice(F, R - 1)), ie && O !== 1)
      return !1;
  } else if ((R = Ny(e, n)) >= 0)
    u = !1;
  else
    return !1;
  if (ie && e.skipSpaces(R) >= e.eMarks[n])
    return !1;
  if (m = e.src.charCodeAt(R - 1), i)
    return !0;
  for (g = e.tokens.length, u ? (V = e.push("ordered_list_open", "ol", 1), O !== 1 && (V.attrs = [["start", O]])) : V = e.push("bullet_list_open", "ul", 1), V.map = p = [n, 0], V.markup = String.fromCharCode(m), y = n, N = !1, z = e.md.block.ruler.getRules("list"), x = e.parentType, e.parentType = "list"; y < r; ) {
    for (Q = R, b = e.eMarks[y], h = w = e.sCount[y] + R - (e.bMarks[n] + e.tShift[n]); Q < b; ) {
      if (s = e.src.charCodeAt(Q), s === 9)
        w += 4 - (w + e.bsCount[y]) % 4;
      else if (s === 32)
        w++;
      else
        break;
      Q++;
    }
    if (o = Q, o >= b ? c = 1 : c = w - h, c > 4 && (c = 1), a = h + c, V = e.push("list_item_open", "li", 1), V.markup = String.fromCharCode(m), V.map = f = [n, 0], u && (V.info = e.src.slice(F, R - 1)), D = e.tight, P = e.tShift[n], v = e.sCount[n], S = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[n] = o - e.bMarks[n], e.sCount[n] = w, o >= b && e.isEmpty(n + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, n, r, !0), (!e.tight || N) && (ae = !1), N = e.line - n > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = S, e.tShift[n] = P, e.sCount[n] = v, e.tight = D, V = e.push("list_item_close", "li", -1), V.markup = String.fromCharCode(m), y = n = e.line, f[1] = y, o = e.bMarks[n], y >= r || e.sCount[y] < e.blkIndent || e.sCount[n] - e.blkIndent >= 4)
      break;
    for (A = !1, l = 0, d = z.length; l < d; l++)
      if (z[l](e, y, r, !0)) {
        A = !0;
        break;
      }
    if (A)
      break;
    if (u) {
      if (R = qy(e, y), R < 0)
        break;
      F = e.bMarks[y] + e.tShift[y];
    } else if (R = Ny(e, y), R < 0)
      break;
    if (m !== e.src.charCodeAt(R - 1))
      break;
  }
  return u ? V = e.push("ordered_list_close", "ol", -1) : V = e.push("bullet_list_close", "ul", -1), V.markup = String.fromCharCode(m), p[1] = y, e.line = y, e.parentType = x, ae && Lke(e, g), !0;
}, qke = ue.normalizeReference, Va = ue.isSpace, Bke = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f, d, p, g, m, O, b, y, w, S = 0, x = e.bMarks[n] + e.tShift[n], v = e.eMarks[n], P = n + 1;
  if (e.sCount[n] - e.blkIndent >= 4 || e.src.charCodeAt(x) !== 91)
    return !1;
  for (; ++x < v; )
    if (e.src.charCodeAt(x) === 93 && e.src.charCodeAt(x - 1) !== 92) {
      if (x + 1 === v || e.src.charCodeAt(x + 1) !== 58)
        return !1;
      break;
    }
  for (a = e.lineMax, y = e.md.block.ruler.getRules("reference"), p = e.parentType, e.parentType = "reference"; P < a && !e.isEmpty(P); P++)
    if (!(e.sCount[P] - e.blkIndent > 3) && !(e.sCount[P] < 0)) {
      for (b = !1, h = 0, u = y.length; h < u; h++)
        if (y[h](e, P, a, !0)) {
          b = !0;
          break;
        }
      if (b)
        break;
    }
  for (O = e.getLines(n, P, e.blkIndent, !1).trim(), v = O.length, x = 1; x < v; x++) {
    if (s = O.charCodeAt(x), s === 91)
      return !1;
    if (s === 93) {
      d = x;
      break;
    } else
      s === 10 ? S++ : s === 92 && (x++, x < v && O.charCodeAt(x) === 10 && S++);
  }
  if (d < 0 || O.charCodeAt(d + 1) !== 58)
    return !1;
  for (x = d + 2; x < v; x++)
    if (s = O.charCodeAt(x), s === 10)
      S++;
    else if (!Va(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(O, x, v), !g.ok || (c = e.md.normalizeLink(g.str), !e.md.validateLink(c)))
    return !1;
  for (x = g.pos, S += g.lines, o = x, l = S, m = x; x < v; x++)
    if (s = O.charCodeAt(x), s === 10)
      S++;
    else if (!Va(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(O, x, v), x < v && m !== x && g.ok ? (w = g.str, x = g.pos, S += g.lines) : (w = "", x = o, S = l); x < v && (s = O.charCodeAt(x), !!Va(s)); )
    x++;
  if (x < v && O.charCodeAt(x) !== 10 && w)
    for (w = "", x = o, S = l; x < v && (s = O.charCodeAt(x), !!Va(s)); )
      x++;
  return x < v && O.charCodeAt(x) !== 10 || (f = qke(O.slice(1, d)), !f) ? !1 : (i || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: w, href: c }), e.parentType = p, e.line = n + S + 1), !0);
}, Yke = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], fu = {}, jke = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Xke = "[^\"'=<>`\\x00-\\x20]+", Wke = "'[^']*'", zke = '"[^"]*"', Vke = "(?:" + Xke + "|" + Wke + "|" + zke + ")", Uke = "(?:\\s+" + jke + "(?:\\s*=\\s*" + Vke + ")?)", wA = "<[A-Za-z][A-Za-z0-9\\-]*" + Uke + "*\\s*\\/?>", kA = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Fke = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", Gke = "<[?][\\s\\S]*?[?]>", Hke = "<![A-Z]+\\s+[^>]*>", Jke = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", Kke = new RegExp("^(?:" + wA + "|" + kA + "|" + Fke + "|" + Gke + "|" + Hke + "|" + Jke + ")"), exe = new RegExp("^(?:" + wA + "|" + kA + ")");
fu.HTML_TAG_RE = Kke;
fu.HTML_OPEN_CLOSE_TAG_RE = exe;
var txe = Yke, nxe = fu.HTML_OPEN_CLOSE_TAG_RE, zi = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + txe.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(nxe.source + "\\s*$"), /^$/, !1]
], rxe = function(e, n, r, i) {
  var s, o, l, a, c = e.bMarks[n] + e.tShift[n], h = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(c) !== 60)
    return !1;
  for (a = e.src.slice(c, h), s = 0; s < zi.length && !zi[s][0].test(a); s++)
    ;
  if (s === zi.length)
    return !1;
  if (i)
    return zi[s][2];
  if (o = n + 1, !zi[s][1].test(a)) {
    for (; o < r && !(e.sCount[o] < e.blkIndent); o++)
      if (c = e.bMarks[o] + e.tShift[o], h = e.eMarks[o], a = e.src.slice(c, h), zi[s][1].test(a)) {
        a.length !== 0 && o++;
        break;
      }
  }
  return e.line = o, l = e.push("html_block", "", 0), l.map = [n, o], l.content = e.getLines(n, o, e.blkIndent, !0), !0;
}, By = ue.isSpace, ixe = function(e, n, r, i) {
  var s, o, l, a, c = e.bMarks[n] + e.tShift[n], h = e.eMarks[n];
  if (e.sCount[n] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c), s !== 35 || c >= h))
    return !1;
  for (o = 1, s = e.src.charCodeAt(++c); s === 35 && c < h && o <= 6; )
    o++, s = e.src.charCodeAt(++c);
  return o > 6 || c < h && !By(s) ? !1 : (i || (h = e.skipSpacesBack(h, c), l = e.skipCharsBack(h, 35, c), l > c && By(e.src.charCodeAt(l - 1)) && (h = l), e.line = n + 1, a = e.push("heading_open", "h" + String(o), 1), a.markup = "########".slice(0, o), a.map = [n, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(c, h).trim(), a.map = [n, e.line], a.children = [], a = e.push("heading_close", "h" + String(o), -1), a.markup = "########".slice(0, o)), !0);
}, sxe = function(e, n, r) {
  var i, s, o, l, a, c, h, u, f, d = n + 1, p, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[n] - e.blkIndent >= 4)
    return !1;
  for (p = e.parentType, e.parentType = "paragraph"; d < r && !e.isEmpty(d); d++)
    if (!(e.sCount[d] - e.blkIndent > 3)) {
      if (e.sCount[d] >= e.blkIndent && (c = e.bMarks[d] + e.tShift[d], h = e.eMarks[d], c < h && (f = e.src.charCodeAt(c), (f === 45 || f === 61) && (c = e.skipChars(c, f), c = e.skipSpaces(c), c >= h)))) {
        u = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[d] < 0)) {
        for (s = !1, o = 0, l = g.length; o < l; o++)
          if (g[o](e, d, r, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return u ? (i = e.getLines(n, d, e.blkIndent, !1).trim(), e.line = d + 1, a = e.push("heading_open", "h" + String(u), 1), a.markup = String.fromCharCode(f), a.map = [n, e.line], a = e.push("inline", "", 0), a.content = i, a.map = [n, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(u), -1), a.markup = String.fromCharCode(f), e.parentType = p, !0) : !1;
}, oxe = function(e, n) {
  var r, i, s, o, l, a, c = n + 1, h = e.md.block.ruler.getRules("paragraph"), u = e.lineMax;
  for (a = e.parentType, e.parentType = "paragraph"; c < u && !e.isEmpty(c); c++)
    if (!(e.sCount[c] - e.blkIndent > 3) && !(e.sCount[c] < 0)) {
      for (i = !1, s = 0, o = h.length; s < o; s++)
        if (h[s](e, c, u, !0)) {
          i = !0;
          break;
        }
      if (i)
        break;
    }
  return r = e.getLines(n, c, e.blkIndent, !1).trim(), e.line = c, l = e.push("paragraph_open", "p", 1), l.map = [n, e.line], l = e.push("inline", "", 0), l.content = r, l.map = [n, e.line], l.children = [], l = e.push("paragraph_close", "p", -1), e.parentType = a, !0;
}, xA = Mm, du = ue.isSpace;
function Hn(t, e, n, r) {
  var i, s, o, l, a, c, h, u;
  for (this.src = t, this.md = e, this.env = n, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, u = !1, o = l = c = h = 0, a = s.length; l < a; l++) {
    if (i = s.charCodeAt(l), !u)
      if (du(i)) {
        c++, i === 9 ? h += 4 - h % 4 : h++;
        continue;
      } else
        u = !0;
    (i === 10 || l === a - 1) && (i !== 10 && l++, this.bMarks.push(o), this.eMarks.push(l), this.tShift.push(c), this.sCount.push(h), this.bsCount.push(0), u = !1, c = 0, h = 0, o = l + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
Hn.prototype.push = function(t, e, n) {
  var r = new xA(t, e, n);
  return r.block = !0, n < 0 && this.level--, r.level = this.level, n > 0 && this.level++, this.tokens.push(r), r;
};
Hn.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
Hn.prototype.skipEmptyLines = function(e) {
  for (var n = this.lineMax; e < n && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
Hn.prototype.skipSpaces = function(e) {
  for (var n, r = this.src.length; e < r && (n = this.src.charCodeAt(e), !!du(n)); e++)
    ;
  return e;
};
Hn.prototype.skipSpacesBack = function(e, n) {
  if (e <= n)
    return e;
  for (; e > n; )
    if (!du(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
Hn.prototype.skipChars = function(e, n) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === n; e++)
    ;
  return e;
};
Hn.prototype.skipCharsBack = function(e, n, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (n !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
Hn.prototype.getLines = function(e, n, r, i) {
  var s, o, l, a, c, h, u, f = e;
  if (e >= n)
    return "";
  for (h = new Array(n - e), s = 0; f < n; f++, s++) {
    for (o = 0, u = a = this.bMarks[f], f + 1 < n || i ? c = this.eMarks[f] + 1 : c = this.eMarks[f]; a < c && o < r; ) {
      if (l = this.src.charCodeAt(a), du(l))
        l === 9 ? o += 4 - (o + this.bsCount[f]) % 4 : o++;
      else if (a - u < this.tShift[f])
        o++;
      else
        break;
      a++;
    }
    o > r ? h[s] = new Array(o - r + 1).join(" ") + this.src.slice(a, c) : h[s] = this.src.slice(a, c);
  }
  return h.join("");
};
Hn.prototype.Token = xA;
var lxe = Hn, axe = Dm, Ua = [
  ["table", Eke, ["paragraph", "reference"]],
  ["code", Dke],
  ["fence", Mke, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", Rke, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", Ike, ["paragraph", "reference", "blockquote", "list"]],
  ["list", Nke, ["paragraph", "reference", "blockquote"]],
  ["reference", Bke],
  ["html_block", rxe, ["paragraph", "reference", "blockquote"]],
  ["heading", ixe, ["paragraph", "reference", "blockquote"]],
  ["lheading", sxe],
  ["paragraph", oxe]
];
function pu() {
  this.ruler = new axe();
  for (var t = 0; t < Ua.length; t++)
    this.ruler.push(Ua[t][0], Ua[t][1], { alt: (Ua[t][2] || []).slice() });
}
pu.prototype.tokenize = function(t, e, n) {
  for (var r, i, s = this.ruler.getRules(""), o = s.length, l = e, a = !1, c = t.md.options.maxNesting; l < n && (t.line = l = t.skipEmptyLines(l), !(l >= n || t.sCount[l] < t.blkIndent)); ) {
    if (t.level >= c) {
      t.line = n;
      break;
    }
    for (i = 0; i < o && (r = s[i](t, l, n, !1), !r); i++)
      ;
    t.tight = !a, t.isEmpty(t.line - 1) && (a = !0), l = t.line, l < n && t.isEmpty(l) && (a = !0, l++, t.line = l);
  }
};
pu.prototype.parse = function(t, e, n, r) {
  var i;
  !t || (i = new this.State(t, e, n, r), this.tokenize(i, i.line, i.lineMax));
};
pu.prototype.State = lxe;
var cxe = pu;
function hxe(t) {
  switch (t) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var uxe = function(e, n) {
  for (var r = e.pos; r < e.posMax && !hxe(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? !1 : (n || (e.pending += e.src.slice(e.pos, r)), e.pos = r, !0);
}, fxe = ue.isSpace, dxe = function(e, n) {
  var r, i, s, o = e.pos;
  if (e.src.charCodeAt(o) !== 10)
    return !1;
  if (r = e.pending.length - 1, i = e.posMax, !n)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (o++; o < i && fxe(e.src.charCodeAt(o)); )
    o++;
  return e.pos = o, !0;
}, pxe = ue.isSpace, Zm = [];
for (var Yy = 0; Yy < 256; Yy++)
  Zm.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(t) {
  Zm[t.charCodeAt(0)] = 1;
});
var gxe = function(e, n) {
  var r, i = e.pos, s = e.posMax;
  if (e.src.charCodeAt(i) !== 92)
    return !1;
  if (i++, i < s) {
    if (r = e.src.charCodeAt(i), r < 256 && Zm[r] !== 0)
      return n || (e.pending += e.src[i]), e.pos += 2, !0;
    if (r === 10) {
      for (n || e.push("hardbreak", "br", 0), i++; i < s && (r = e.src.charCodeAt(i), !!pxe(r)); )
        i++;
      return e.pos = i, !0;
    }
  }
  return n || (e.pending += "\\"), e.pos++, !0;
}, mxe = function(e, n) {
  var r, i, s, o, l, a, c, h, u = e.pos, f = e.src.charCodeAt(u);
  if (f !== 96)
    return !1;
  for (r = u, u++, i = e.posMax; u < i && e.src.charCodeAt(u) === 96; )
    u++;
  if (s = e.src.slice(r, u), c = s.length, e.backticksScanned && (e.backticks[c] || 0) <= r)
    return n || (e.pending += s), e.pos += c, !0;
  for (l = a = u; (l = e.src.indexOf("`", a)) !== -1; ) {
    for (a = l + 1; a < i && e.src.charCodeAt(a) === 96; )
      a++;
    if (h = a - l, h === c)
      return n || (o = e.push("code_inline", "code", 0), o.markup = s, o.content = e.src.slice(u, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0;
    e.backticks[h] = l;
  }
  return e.backticksScanned = !0, n || (e.pending += s), e.pos += c, !0;
}, gu = {};
gu.tokenize = function(e, n) {
  var r, i, s, o, l, a = e.pos, c = e.src.charCodeAt(a);
  if (n || c !== 126 || (i = e.scanDelims(e.pos, !0), o = i.length, l = String.fromCharCode(c), o < 2))
    return !1;
  for (o % 2 && (s = e.push("text", "", 0), s.content = l, o--), r = 0; r < o; r += 2)
    s = e.push("text", "", 0), s.content = l + l, e.delimiters.push({
      marker: c,
      length: 0,
      token: e.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return e.pos += i.length, !0;
};
function jy(t, e) {
  var n, r, i, s, o, l = [], a = e.length;
  for (n = 0; n < a; n++)
    i = e[n], i.marker === 126 && i.end !== -1 && (s = e[i.end], o = t.tokens[i.token], o.type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", o = t.tokens[s.token], o.type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", t.tokens[s.token - 1].type === "text" && t.tokens[s.token - 1].content === "~" && l.push(s.token - 1));
  for (; l.length; ) {
    for (n = l.pop(), r = n + 1; r < t.tokens.length && t.tokens[r].type === "s_close"; )
      r++;
    r--, n !== r && (o = t.tokens[r], t.tokens[r] = t.tokens[n], t.tokens[n] = o);
  }
}
gu.postProcess = function(e) {
  var n, r = e.tokens_meta, i = e.tokens_meta.length;
  for (jy(e, e.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && jy(e, r[n].delimiters);
};
var mu = {};
mu.tokenize = function(e, n) {
  var r, i, s, o = e.pos, l = e.src.charCodeAt(o);
  if (n || l !== 95 && l !== 42)
    return !1;
  for (i = e.scanDelims(e.pos, l === 42), r = 0; r < i.length; r++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(l), e.delimiters.push({
      marker: l,
      length: i.length,
      token: e.tokens.length - 1,
      end: -1,
      open: i.can_open,
      close: i.can_close
    });
  return e.pos += i.length, !0;
};
function Xy(t, e) {
  var n, r, i, s, o, l, a = e.length;
  for (n = a - 1; n >= 0; n--)
    r = e[n], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (i = e[r.end], l = n > 0 && e[n - 1].end === r.end + 1 && e[n - 1].marker === r.marker && e[n - 1].token === r.token - 1 && e[r.end + 1].token === i.token + 1, o = String.fromCharCode(r.marker), s = t.tokens[r.token], s.type = l ? "strong_open" : "em_open", s.tag = l ? "strong" : "em", s.nesting = 1, s.markup = l ? o + o : o, s.content = "", s = t.tokens[i.token], s.type = l ? "strong_close" : "em_close", s.tag = l ? "strong" : "em", s.nesting = -1, s.markup = l ? o + o : o, s.content = "", l && (t.tokens[e[n - 1].token].content = "", t.tokens[e[r.end + 1].token].content = "", n--));
}
mu.postProcess = function(e) {
  var n, r = e.tokens_meta, i = e.tokens_meta.length;
  for (Xy(e, e.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && Xy(e, r[n].delimiters);
};
var Oxe = ue.normalizeReference, qf = ue.isSpace, bxe = function(e, n) {
  var r, i, s, o, l, a, c, h, u, f = "", d = "", p = e.pos, g = e.posMax, m = e.pos, O = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (l = e.pos + 1, o = e.md.helpers.parseLinkLabel(e, e.pos, !0), o < 0))
    return !1;
  if (a = o + 1, a < g && e.src.charCodeAt(a) === 40) {
    for (O = !1, a++; a < g && (i = e.src.charCodeAt(a), !(!qf(i) && i !== 10)); a++)
      ;
    if (a >= g)
      return !1;
    if (m = a, c = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), c.ok) {
      for (f = e.md.normalizeLink(c.str), e.md.validateLink(f) ? a = c.pos : f = "", m = a; a < g && (i = e.src.charCodeAt(a), !(!qf(i) && i !== 10)); a++)
        ;
      if (c = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < g && m !== a && c.ok)
        for (d = c.str, a = c.pos; a < g && (i = e.src.charCodeAt(a), !(!qf(i) && i !== 10)); a++)
          ;
    }
    (a >= g || e.src.charCodeAt(a) !== 41) && (O = !0), a++;
  }
  if (O) {
    if (typeof e.env.references > "u")
      return !1;
    if (a < g && e.src.charCodeAt(a) === 91 ? (m = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(m, a++) : a = o + 1) : a = o + 1, s || (s = e.src.slice(l, o)), h = e.env.references[Oxe(s)], !h)
      return e.pos = p, !1;
    f = h.href, d = h.title;
  }
  return n || (e.pos = l, e.posMax = o, u = e.push("link_open", "a", 1), u.attrs = r = [["href", f]], d && r.push(["title", d]), e.md.inline.tokenize(e), u = e.push("link_close", "a", -1)), e.pos = a, e.posMax = g, !0;
}, yxe = ue.normalizeReference, Bf = ue.isSpace, wxe = function(e, n) {
  var r, i, s, o, l, a, c, h, u, f, d, p, g, m = "", O = e.pos, b = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, l = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), l < 0))
    return !1;
  if (c = l + 1, c < b && e.src.charCodeAt(c) === 40) {
    for (c++; c < b && (i = e.src.charCodeAt(c), !(!Bf(i) && i !== 10)); c++)
      ;
    if (c >= b)
      return !1;
    for (g = c, u = e.md.helpers.parseLinkDestination(e.src, c, e.posMax), u.ok && (m = e.md.normalizeLink(u.str), e.md.validateLink(m) ? c = u.pos : m = ""), g = c; c < b && (i = e.src.charCodeAt(c), !(!Bf(i) && i !== 10)); c++)
      ;
    if (u = e.md.helpers.parseLinkTitle(e.src, c, e.posMax), c < b && g !== c && u.ok)
      for (f = u.str, c = u.pos; c < b && (i = e.src.charCodeAt(c), !(!Bf(i) && i !== 10)); c++)
        ;
    else
      f = "";
    if (c >= b || e.src.charCodeAt(c) !== 41)
      return e.pos = O, !1;
    c++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (c < b && e.src.charCodeAt(c) === 91 ? (g = c + 1, c = e.md.helpers.parseLinkLabel(e, c), c >= 0 ? o = e.src.slice(g, c++) : c = l + 1) : c = l + 1, o || (o = e.src.slice(a, l)), h = e.env.references[yxe(o)], !h)
      return e.pos = O, !1;
    m = h.href, f = h.title;
  }
  return n || (s = e.src.slice(a, l), e.md.inline.parse(
    s,
    e.md,
    e.env,
    p = []
  ), d = e.push("image", "img", 0), d.attrs = r = [["src", m], ["alt", ""]], d.children = p, d.content = s, f && r.push(["title", f])), e.pos = c, e.posMax = b, !0;
}, kxe = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, xxe = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, vxe = function(e, n) {
  var r, i, s, o, l, a, c = e.pos;
  if (e.src.charCodeAt(c) !== 60)
    return !1;
  for (l = e.pos, a = e.posMax; ; ) {
    if (++c >= a || (o = e.src.charCodeAt(c), o === 60))
      return !1;
    if (o === 62)
      break;
  }
  return r = e.src.slice(l + 1, c), xxe.test(r) ? (i = e.md.normalizeLink(r), e.md.validateLink(i) ? (n || (s = e.push("link_open", "a", 1), s.attrs = [["href", i]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : kxe.test(r) ? (i = e.md.normalizeLink("mailto:" + r), e.md.validateLink(i) ? (n || (s = e.push("link_open", "a", 1), s.attrs = [["href", i]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, !0) : !1) : !1;
}, Sxe = fu.HTML_TAG_RE;
function _xe(t) {
  var e = t | 32;
  return e >= 97 && e <= 122;
}
var Cxe = function(e, n) {
  var r, i, s, o, l = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(l) !== 60 || l + 2 >= s) || (r = e.src.charCodeAt(l + 1), r !== 33 && r !== 63 && r !== 47 && !_xe(r)) || (i = e.src.slice(l).match(Sxe), !i) ? !1 : (n || (o = e.push("html_inline", "", 0), o.content = e.src.slice(l, l + i[0].length)), e.pos += i[0].length, !0);
}, Wy = Qm.exports, Axe = ue.has, $xe = ue.isValidEntityCode, zy = ue.fromCodePoint, Pxe = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, Txe = /^&([a-z][a-z0-9]{1,31});/i, Qxe = function(e, n) {
  var r, i, s, o = e.pos, l = e.posMax;
  if (e.src.charCodeAt(o) !== 38)
    return !1;
  if (o + 1 < l) {
    if (r = e.src.charCodeAt(o + 1), r === 35) {
      if (s = e.src.slice(o).match(Pxe), s)
        return n || (i = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), e.pending += $xe(i) ? zy(i) : zy(65533)), e.pos += s[0].length, !0;
    } else if (s = e.src.slice(o).match(Txe), s && Axe(Wy, s[1]))
      return n || (e.pending += Wy[s[1]]), e.pos += s[0].length, !0;
  }
  return n || (e.pending += "&"), e.pos++, !0;
};
function Vy(t, e) {
  var n, r, i, s, o, l, a, c, h = {}, u = e.length;
  if (!!u) {
    var f = 0, d = -2, p = [];
    for (n = 0; n < u; n++)
      if (i = e[n], p.push(0), (e[f].marker !== i.marker || d !== i.token - 1) && (f = n), d = i.token, i.length = i.length || 0, !!i.close) {
        for (h.hasOwnProperty(i.marker) || (h[i.marker] = [-1, -1, -1, -1, -1, -1]), o = h[i.marker][(i.open ? 3 : 0) + i.length % 3], r = f - p[f] - 1, l = r; r > o; r -= p[r] + 1)
          if (s = e[r], s.marker === i.marker && s.open && s.end < 0 && (a = !1, (s.close || i.open) && (s.length + i.length) % 3 === 0 && (s.length % 3 !== 0 || i.length % 3 !== 0) && (a = !0), !a)) {
            c = r > 0 && !e[r - 1].open ? p[r - 1] + 1 : 0, p[n] = n - r + c, p[r] = c, i.open = !1, s.end = n, s.close = !1, l = -1, d = -2;
            break;
          }
        l !== -1 && (h[i.marker][(i.open ? 3 : 0) + (i.length || 0) % 3] = l);
      }
  }
}
var Exe = function(e) {
  var n, r = e.tokens_meta, i = e.tokens_meta.length;
  for (Vy(e, e.delimiters), n = 0; n < i; n++)
    r[n] && r[n].delimiters && Vy(e, r[n].delimiters);
}, Dxe = function(e) {
  var n, r, i = 0, s = e.tokens, o = e.tokens.length;
  for (n = r = 0; n < o; n++)
    s[n].nesting < 0 && i--, s[n].level = i, s[n].nesting > 0 && i++, s[n].type === "text" && n + 1 < o && s[n + 1].type === "text" ? s[n + 1].content = s[n].content + s[n + 1].content : (n !== r && (s[r] = s[n]), r++);
  n !== r && (s.length = r);
}, Im = Mm, Uy = ue.isWhiteSpace, Fy = ue.isPunctChar, Gy = ue.isMdAsciiPunct;
function Kl(t, e, n, r) {
  this.src = t, this.env = n, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1;
}
Kl.prototype.pushPending = function() {
  var t = new Im("text", "", 0);
  return t.content = this.pending, t.level = this.pendingLevel, this.tokens.push(t), this.pending = "", t;
};
Kl.prototype.push = function(t, e, n) {
  this.pending && this.pushPending();
  var r = new Im(t, e, n), i = null;
  return n < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, n > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], i = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(i), r;
};
Kl.prototype.scanDelims = function(t, e) {
  var n = t, r, i, s, o, l, a, c, h, u, f = !0, d = !0, p = this.posMax, g = this.src.charCodeAt(t);
  for (r = t > 0 ? this.src.charCodeAt(t - 1) : 32; n < p && this.src.charCodeAt(n) === g; )
    n++;
  return s = n - t, i = n < p ? this.src.charCodeAt(n) : 32, c = Gy(r) || Fy(String.fromCharCode(r)), u = Gy(i) || Fy(String.fromCharCode(i)), a = Uy(r), h = Uy(i), h ? f = !1 : u && (a || c || (f = !1)), a ? d = !1 : c && (h || u || (d = !1)), e ? (o = f, l = d) : (o = f && (!d || c), l = d && (!f || u)), {
    can_open: o,
    can_close: l,
    length: s
  };
};
Kl.prototype.Token = Im;
var Mxe = Kl, Hy = Dm, Yf = [
  ["text", uxe],
  ["newline", dxe],
  ["escape", gxe],
  ["backticks", mxe],
  ["strikethrough", gu.tokenize],
  ["emphasis", mu.tokenize],
  ["link", bxe],
  ["image", wxe],
  ["autolink", vxe],
  ["html_inline", Cxe],
  ["entity", Qxe]
], jf = [
  ["balance_pairs", Exe],
  ["strikethrough", gu.postProcess],
  ["emphasis", mu.postProcess],
  ["text_collapse", Dxe]
];
function ea() {
  var t;
  for (this.ruler = new Hy(), t = 0; t < Yf.length; t++)
    this.ruler.push(Yf[t][0], Yf[t][1]);
  for (this.ruler2 = new Hy(), t = 0; t < jf.length; t++)
    this.ruler2.push(jf[t][0], jf[t][1]);
}
ea.prototype.skipToken = function(t) {
  var e, n, r = t.pos, i = this.ruler.getRules(""), s = i.length, o = t.md.options.maxNesting, l = t.cache;
  if (typeof l[r] < "u") {
    t.pos = l[r];
    return;
  }
  if (t.level < o)
    for (n = 0; n < s && (t.level++, e = i[n](t, !0), t.level--, !e); n++)
      ;
  else
    t.pos = t.posMax;
  e || t.pos++, l[r] = t.pos;
};
ea.prototype.tokenize = function(t) {
  for (var e, n, r = this.ruler.getRules(""), i = r.length, s = t.posMax, o = t.md.options.maxNesting; t.pos < s; ) {
    if (t.level < o)
      for (n = 0; n < i && (e = r[n](t, !1), !e); n++)
        ;
    if (e) {
      if (t.pos >= s)
        break;
      continue;
    }
    t.pending += t.src[t.pos++];
  }
  t.pending && t.pushPending();
};
ea.prototype.parse = function(t, e, n, r) {
  var i, s, o, l = new this.State(t, e, n, r);
  for (this.tokenize(l), s = this.ruler2.getRules(""), o = s.length, i = 0; i < o; i++)
    s[i](l);
};
ea.prototype.State = Mxe;
var Rxe = ea, Xf, Jy;
function Zxe() {
  return Jy || (Jy = 1, Xf = function(t) {
    var e = {};
    e.src_Any = pA().source, e.src_Cc = gA().source, e.src_Z = mA().source, e.src_P = Em.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var n = "[><\uFF5C]";
    return e.src_pseudo_letter = "(?:(?!" + n + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + n + "|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + n + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]).|" + (t && t["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + ").|;(?!" + e.src_ZCc + ").|\\!+(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + n + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Xf;
}
function jp(t) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(n) {
    !n || Object.keys(n).forEach(function(r) {
      t[r] = n[r];
    });
  }), t;
}
function Ou(t) {
  return Object.prototype.toString.call(t);
}
function Ixe(t) {
  return Ou(t) === "[object String]";
}
function Lxe(t) {
  return Ou(t) === "[object Object]";
}
function Nxe(t) {
  return Ou(t) === "[object RegExp]";
}
function Ky(t) {
  return Ou(t) === "[object Function]";
}
function qxe(t) {
  return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var vA = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function Bxe(t) {
  return Object.keys(t || {}).reduce(function(e, n) {
    return e || vA.hasOwnProperty(n);
  }, !1);
}
var Yxe = {
  "http:": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.http || (n.re.http = new RegExp(
        "^\\/\\/" + n.re.src_auth + n.re.src_host_port_strict + n.re.src_path,
        "i"
      )), n.re.http.test(r) ? r.match(n.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.no_http || (n.re.no_http = new RegExp(
        "^" + n.re.src_auth + "(?:localhost|(?:(?:" + n.re.src_domain + ")\\.)+" + n.re.src_domain_root + ")" + n.re.src_port + n.re.src_host_terminator + n.re.src_path,
        "i"
      )), n.re.no_http.test(r) ? e >= 3 && t[e - 3] === ":" || e >= 3 && t[e - 3] === "/" ? 0 : r.match(n.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(t, e, n) {
      var r = t.slice(e);
      return n.re.mailto || (n.re.mailto = new RegExp(
        "^" + n.re.src_email_name + "@" + n.re.src_host_strict,
        "i"
      )), n.re.mailto.test(r) ? r.match(n.re.mailto)[0].length : 0;
    }
  }
}, jxe = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", Xxe = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function Wxe(t) {
  t.__index__ = -1, t.__text_cache__ = "";
}
function zxe(t) {
  return function(e, n) {
    var r = e.slice(n);
    return t.test(r) ? r.match(t)[0].length : 0;
  };
}
function ew() {
  return function(t, e) {
    e.normalize(t);
  };
}
function yh(t) {
  var e = t.re = Zxe()(t.__opts__), n = t.__tlds__.slice();
  t.onCompile(), t.__tlds_replaced__ || n.push(jxe), n.push(e.src_xn), e.src_tlds = n.join("|");
  function r(l) {
    return l.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var i = [];
  t.__compiled__ = {};
  function s(l, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + l + '": ' + a);
  }
  Object.keys(t.__schemas__).forEach(function(l) {
    var a = t.__schemas__[l];
    if (a !== null) {
      var c = { validate: null, link: null };
      if (t.__compiled__[l] = c, Lxe(a)) {
        Nxe(a.validate) ? c.validate = zxe(a.validate) : Ky(a.validate) ? c.validate = a.validate : s(l, a), Ky(a.normalize) ? c.normalize = a.normalize : a.normalize ? s(l, a) : c.normalize = ew();
        return;
      }
      if (Ixe(a)) {
        i.push(l);
        return;
      }
      s(l, a);
    }
  }), i.forEach(function(l) {
    !t.__compiled__[t.__schemas__[l]] || (t.__compiled__[l].validate = t.__compiled__[t.__schemas__[l]].validate, t.__compiled__[l].normalize = t.__compiled__[t.__schemas__[l]].normalize);
  }), t.__compiled__[""] = { validate: null, normalize: ew() };
  var o = Object.keys(t.__compiled__).filter(function(l) {
    return l.length > 0 && t.__compiled__[l];
  }).map(qxe).join("|");
  t.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + o + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + o + ")", "ig"), t.re.pretest = RegExp(
    "(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@",
    "i"
  ), Wxe(t);
}
function Vxe(t, e) {
  var n = t.__index__, r = t.__last_index__, i = t.__text_cache__.slice(n, r);
  this.schema = t.__schema__.toLowerCase(), this.index = n + e, this.lastIndex = r + e, this.raw = i, this.text = i, this.url = i;
}
function tw(t, e) {
  var n = new Vxe(t, e);
  return t.__compiled__[n.schema].normalize(n, t), n;
}
function Jt(t, e) {
  if (!(this instanceof Jt))
    return new Jt(t, e);
  e || Bxe(t) && (e = t, t = {}), this.__opts__ = jp({}, vA, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = jp({}, Yxe, t), this.__compiled__ = {}, this.__tlds__ = Xxe, this.__tlds_replaced__ = !1, this.re = {}, yh(this);
}
Jt.prototype.add = function(e, n) {
  return this.__schemas__[e] = n, yh(this), this;
};
Jt.prototype.set = function(e) {
  return this.__opts__ = jp(this.__opts__, e), this;
};
Jt.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var n, r, i, s, o, l, a, c, h;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (n = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, n[2], a.lastIndex), s) {
        this.__schema__ = n[2], this.__index__ = n.index + n[1].length, this.__last_index__ = n.index + n[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c = e.search(this.re.host_fuzzy_test), c >= 0 && (this.__index__ < 0 || c < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = r.index + r[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (h = e.indexOf("@"), h >= 0 && (i = e.match(this.re.email_fuzzy)) !== null && (o = i.index + i[1].length, l = i.index + i[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && l > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = l))), this.__index__ >= 0;
};
Jt.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Jt.prototype.testSchemaAt = function(e, n, r) {
  return this.__compiled__[n.toLowerCase()] ? this.__compiled__[n.toLowerCase()].validate(e, r, this) : 0;
};
Jt.prototype.match = function(e) {
  var n = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(tw(this, n)), n = this.__last_index__);
  for (var i = n ? e.slice(n) : e; this.test(i); )
    r.push(tw(this, n)), i = i.slice(this.__last_index__), n += this.__last_index__;
  return r.length ? r : null;
};
Jt.prototype.tlds = function(e, n) {
  return e = Array.isArray(e) ? e : [e], n ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, i, s) {
    return r !== s[i - 1];
  }).reverse(), yh(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, yh(this), this);
};
Jt.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Jt.prototype.onCompile = function() {
};
var Uxe = Jt;
const gs = 2147483647, In = 36, Lm = 1, Tl = 26, Fxe = 38, Gxe = 700, SA = 72, _A = 128, CA = "-", Hxe = /^xn--/, Jxe = /[^\0-\x7F]/, Kxe = /[\x2E\u3002\uFF0E\uFF61]/g, eve = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Wf = In - Lm, Ln = Math.floor, zf = String.fromCharCode;
function Sr(t) {
  throw new RangeError(eve[t]);
}
function tve(t, e) {
  const n = [];
  let r = t.length;
  for (; r--; )
    n[r] = e(t[r]);
  return n;
}
function AA(t, e) {
  const n = t.split("@");
  let r = "";
  n.length > 1 && (r = n[0] + "@", t = n[1]), t = t.replace(Kxe, ".");
  const i = t.split("."), s = tve(i, e).join(".");
  return r + s;
}
function Nm(t) {
  const e = [];
  let n = 0;
  const r = t.length;
  for (; n < r; ) {
    const i = t.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const s = t.charCodeAt(n++);
      (s & 64512) == 56320 ? e.push(((i & 1023) << 10) + (s & 1023) + 65536) : (e.push(i), n--);
    } else
      e.push(i);
  }
  return e;
}
const $A = (t) => String.fromCodePoint(...t), nve = function(t) {
  return t >= 48 && t < 58 ? 26 + (t - 48) : t >= 65 && t < 91 ? t - 65 : t >= 97 && t < 123 ? t - 97 : In;
}, nw = function(t, e) {
  return t + 22 + 75 * (t < 26) - ((e != 0) << 5);
}, PA = function(t, e, n) {
  let r = 0;
  for (t = n ? Ln(t / Gxe) : t >> 1, t += Ln(t / e); t > Wf * Tl >> 1; r += In)
    t = Ln(t / Wf);
  return Ln(r + (Wf + 1) * t / (t + Fxe));
}, qm = function(t) {
  const e = [], n = t.length;
  let r = 0, i = _A, s = SA, o = t.lastIndexOf(CA);
  o < 0 && (o = 0);
  for (let l = 0; l < o; ++l)
    t.charCodeAt(l) >= 128 && Sr("not-basic"), e.push(t.charCodeAt(l));
  for (let l = o > 0 ? o + 1 : 0; l < n; ) {
    const a = r;
    for (let h = 1, u = In; ; u += In) {
      l >= n && Sr("invalid-input");
      const f = nve(t.charCodeAt(l++));
      f >= In && Sr("invalid-input"), f > Ln((gs - r) / h) && Sr("overflow"), r += f * h;
      const d = u <= s ? Lm : u >= s + Tl ? Tl : u - s;
      if (f < d)
        break;
      const p = In - d;
      h > Ln(gs / p) && Sr("overflow"), h *= p;
    }
    const c = e.length + 1;
    s = PA(r - a, c, a == 0), Ln(r / c) > gs - i && Sr("overflow"), i += Ln(r / c), r %= c, e.splice(r++, 0, i);
  }
  return String.fromCodePoint(...e);
}, Bm = function(t) {
  const e = [];
  t = Nm(t);
  const n = t.length;
  let r = _A, i = 0, s = SA;
  for (const a of t)
    a < 128 && e.push(zf(a));
  const o = e.length;
  let l = o;
  for (o && e.push(CA); l < n; ) {
    let a = gs;
    for (const h of t)
      h >= r && h < a && (a = h);
    const c = l + 1;
    a - r > Ln((gs - i) / c) && Sr("overflow"), i += (a - r) * c, r = a;
    for (const h of t)
      if (h < r && ++i > gs && Sr("overflow"), h === r) {
        let u = i;
        for (let f = In; ; f += In) {
          const d = f <= s ? Lm : f >= s + Tl ? Tl : f - s;
          if (u < d)
            break;
          const p = u - d, g = In - d;
          e.push(
            zf(nw(d + p % g, 0))
          ), u = Ln(p / g);
        }
        e.push(zf(nw(u, 0))), s = PA(i, c, l === o), i = 0, ++l;
      }
    ++i, ++r;
  }
  return e.join("");
}, TA = function(t) {
  return AA(t, function(e) {
    return Hxe.test(e) ? qm(e.slice(4).toLowerCase()) : e;
  });
}, QA = function(t) {
  return AA(t, function(e) {
    return Jxe.test(e) ? "xn--" + Bm(e) : e;
  });
}, rve = {
  version: "2.3.1",
  ucs2: {
    decode: Nm,
    encode: $A
  },
  decode: qm,
  encode: Bm,
  toASCII: QA,
  toUnicode: TA
}, ive = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode: Nm,
  ucs2encode: $A,
  decode: qm,
  encode: Bm,
  toASCII: QA,
  toUnicode: TA,
  default: rve
}, Symbol.toStringTag, { value: "Module" })), sve = /* @__PURE__ */ tk(ive);
var ove = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, lve = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
}, ave = {
  options: {
    html: !0,
    xhtmlOut: !0,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
}, Wo = ue, cve = uu, hve = ake, uve = Qke, fve = cxe, dve = Rxe, pve = Uxe, gi = eo, EA = sve, gve = {
  default: ove,
  zero: lve,
  commonmark: ave
}, mve = /^(vbscript|javascript|file|data):/, Ove = /^data:image\/(gif|png|jpeg|webp);/;
function bve(t) {
  var e = t.trim().toLowerCase();
  return mve.test(e) ? !!Ove.test(e) : !0;
}
var DA = ["http:", "https:", "mailto:"];
function yve(t) {
  var e = gi.parse(t, !0);
  if (e.hostname && (!e.protocol || DA.indexOf(e.protocol) >= 0))
    try {
      e.hostname = EA.toASCII(e.hostname);
    } catch {
    }
  return gi.encode(gi.format(e));
}
function wve(t) {
  var e = gi.parse(t, !0);
  if (e.hostname && (!e.protocol || DA.indexOf(e.protocol) >= 0))
    try {
      e.hostname = EA.toUnicode(e.hostname);
    } catch {
    }
  return gi.decode(gi.format(e), gi.decode.defaultChars + "%");
}
function Kt(t, e) {
  if (!(this instanceof Kt))
    return new Kt(t, e);
  e || Wo.isString(t) || (e = t || {}, t = "default"), this.inline = new dve(), this.block = new fve(), this.core = new uve(), this.renderer = new hve(), this.linkify = new pve(), this.validateLink = bve, this.normalizeLink = yve, this.normalizeLinkText = wve, this.utils = Wo, this.helpers = Wo.assign({}, cve), this.options = {}, this.configure(t), e && this.set(e);
}
Kt.prototype.set = function(t) {
  return Wo.assign(this.options, t), this;
};
Kt.prototype.configure = function(t) {
  var e = this, n;
  if (Wo.isString(t) && (n = t, t = gve[n], !t))
    throw new Error('Wrong `markdown-it` preset "' + n + '", check name');
  if (!t)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return t.options && e.set(t.options), t.components && Object.keys(t.components).forEach(function(r) {
    t.components[r].rules && e[r].ruler.enableOnly(t.components[r].rules), t.components[r].rules2 && e[r].ruler2.enableOnly(t.components[r].rules2);
  }), this;
};
Kt.prototype.enable = function(t, e) {
  var n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.enable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.enable(t, !0));
  var r = t.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
Kt.prototype.disable = function(t, e) {
  var n = [];
  Array.isArray(t) || (t = [t]), ["core", "block", "inline"].forEach(function(i) {
    n = n.concat(this[i].ruler.disable(t, !0));
  }, this), n = n.concat(this.inline.ruler2.disable(t, !0));
  var r = t.filter(function(i) {
    return n.indexOf(i) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
Kt.prototype.use = function(t) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return t.apply(t, e), this;
};
Kt.prototype.parse = function(t, e) {
  if (typeof t != "string")
    throw new Error("Input data should be a String");
  var n = new this.core.State(t, this, e);
  return this.core.process(n), n.tokens;
};
Kt.prototype.render = function(t, e) {
  return e = e || {}, this.renderer.render(this.parse(t, e), this.options, e);
};
Kt.prototype.parseInline = function(t, e) {
  var n = new this.core.State(t, this, e);
  return n.inlineMode = !0, this.core.process(n), n.tokens;
};
Kt.prototype.renderInline = function(t, e) {
  return e = e || {}, this.renderer.render(this.parseInline(t, e), this.options, e);
};
var kve = Kt;
(function(t) {
  t.exports = kve;
})(dA);
const xve = /* @__PURE__ */ H2(dA.exports);
class br {
  constructor(e) {
    this.state = e;
  }
  run(e) {
    return [];
  }
}
class vve extends br {
  run(e) {
    const n = new this.state.Token("code_inline", "code", 0);
    return n.content = e.content, [n];
  }
}
const Sve = {
  raw: vve
}, Xp = "math_inline";
class _ve extends br {
  run(e) {
    const n = new this.state.Token(Xp, "span", 0);
    return n.attrSet("class", "math inline"), n.markup = "$", n.content = e.content, [n];
  }
}
function Cve(t, e) {
  var n;
  !(!((n = e == null ? void 0 : e.roles) === null || n === void 0) && n.math) || t.renderer.rules[Xp] || (t.renderer.rules[Xp] = (r, i) => {
    var s, o, l;
    const a = (l = (o = (s = e == null ? void 0 : e.opts) === null || s === void 0 ? void 0 : s.math) === null || o === void 0 ? void 0 : o.renderer) !== null && l !== void 0 ? l : (f) => t.utils.escapeHtml(f), c = r[i], h = c.content.trim(), u = a(h, { displayMode: !1 });
    return `<span class="${c.attrGet("class")}">${u}</span>`;
  });
}
const Ave = {
  math: _ve
};
function MA(t, e) {
  e.parseRoles && t.inline.ruler.before("backticks", "parse_roles", $ve), t.core.ruler.after(e.rolesAfter || "inline", "run_roles", Tve(e.roles || {})), t.renderer.rules.role = (n, r) => {
    const i = n[r];
    return `<span class="role-unhandled"><mark>${i.meta.name}</mark><code>${i.content}</code></span>`;
  }, Cve(t, e);
}
function $ve(t, e) {
  if (t.src.charCodeAt(t.pos - 1) === 92)
    return !1;
  const n = Pve.exec(t.src.slice(t.pos));
  if (n == null)
    return !1;
  const [r, i, , s] = n;
  if (t.pos += r.length, !e) {
    const o = t.push("role", "", 0);
    o.meta = { name: i }, o.content = s;
  }
  return !0;
}
let Wp;
try {
  Wp = new RegExp("^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)(?<!`)\\2(?!`)");
} catch {
  Wp = /^\{([a-zA-Z_\-+:]{1,36})\}(`+)(?!`)(.+?)\2(?!`)/;
}
const Pve = Wp;
function Tve(t) {
  function e(n) {
    var r;
    for (const i of n.tokens)
      if (i.type === "inline" && i.children) {
        const s = [];
        for (const o of i.children)
          if (o.type === "role" && ((r = o.meta) === null || r === void 0 ? void 0 : r.name) in t)
            try {
              const l = new t[o.meta.name](n), a = new n.Token("parsed_role_open", "", 1);
              a.content = o.content, a.hidden = !0, a.meta = { name: o.meta.name }, a.block = !1;
              const c = [a];
              c.push(...l.run({
                parentMap: i.map,
                content: o.content
              }));
              const h = new n.Token("parsed_role_close", "", -1);
              h.block = !1, h.hidden = !0, c.push(h), s.push(...c);
            } catch (l) {
              const a = new n.Token("role_error", "", 0);
              a.content = o.content, a.info = o.info, a.meta = o.meta, a.map = o.map, a.meta.error_message = l.message, a.meta.error_name = l.name, s.push(a);
            }
          else
            s.push(o);
        i.children = s;
      }
    return !0;
  }
  return e;
}
class rw extends br {
  run(e) {
    const n = new this.state.Token("sub_open", "sub", 1);
    n.markup = "~";
    const r = new this.state.Token("text", "", 0);
    r.content = e.content;
    const i = new this.state.Token("sub_close", "sub", -1);
    return i.markup = "~", [n, r, i];
  }
}
class iw extends br {
  run(e) {
    const n = new this.state.Token("sup_open", "sup", 1);
    n.markup = "~";
    const r = new this.state.Token("text", "", 0);
    r.content = e.content;
    const i = new this.state.Token("sup_close", "sup", -1);
    return i.markup = "~", [n, r, i];
  }
}
const Qve = /^(.+?)\(([^()]+)\)$/;
class sw extends br {
  run(e) {
    var n, r, i, s;
    const o = Qve.exec(e.content), l = (r = (n = o == null ? void 0 : o[1]) === null || n === void 0 ? void 0 : n.trim()) !== null && r !== void 0 ? r : e.content.trim(), a = (s = (i = o == null ? void 0 : o[2]) === null || i === void 0 ? void 0 : i.trim()) !== null && s !== void 0 ? s : null, c = new this.state.Token("abbr_open", "abbr", 1);
    a && c.attrSet("title", a);
    const h = new this.state.Token("text", "", 0);
    h.content = l;
    const u = new this.state.Token("abbr_close", "abbr", -1);
    return [c, h, u];
  }
}
const Eve = {
  subscript: rw,
  sub: rw,
  superscript: iw,
  sup: iw,
  abbreviation: sw,
  abbr: sw
};
var Ql;
(function(t) {
  t.equation = "eq", t.figure = "fig", t.table = "table", t.code = "code", t.section = "sec";
})(Ql || (Ql = {}));
function bu(t) {
  var e, n;
  const r = (n = (e = t.env) === null || e === void 0 ? void 0 : e.docutils) !== null && n !== void 0 ? n : {};
  return r.targets || (r.targets = {}), r.references || (r.references = []), r.numbering || (r.numbering = {}), t.env.docutils || (t.env.docutils = r), r;
}
function Dve(t) {
  var e, n;
  const r = (n = (e = t.meta) === null || e === void 0 ? void 0 : e.docutils) !== null && n !== void 0 ? n : {};
  return t.meta || (t.meta = {}), t.meta.docutils || (t.meta.docutils = r), r;
}
function Mve(t, e) {
  const n = bu(t);
  return n.numbering[e] == null ? n.numbering[e] = 1 : n.numbering[e] += 1, n.numbering[e];
}
function RA(t, e, n, r, i, s = !1) {
  const o = bu(t), l = Mve(t, n), a = {
    label: r,
    kind: n,
    number: l,
    title: i
  };
  if (!s) {
    const c = Dve(e);
    c.target = a, e.attrSet("id", r), o.targets[r] = a;
  }
  return a;
}
function Ym(t, e, n, r) {
  var i;
  e.open.meta = (i = e.open.meta) !== null && i !== void 0 ? i : {}, e.open.meta.kind = n.kind, e.open.meta.label = n.label, e.open.meta.value = n.value, bu(t).references.push(Object.assign({ label: n.label, tokens: e }, r));
}
const ZA = /^(.+?)<([^<>]+)>$/;
class Rve extends br {
  run(e) {
    const n = new this.state.Token("ref_open", "a", 1), r = new this.state.Token("text", "", 0), i = new this.state.Token("ref_close", "a", -1);
    return Ym(this.state, { open: n, content: r, close: i }, { kind: "eq", label: e.content }, {
      kind: Ql.equation,
      contentFromTarget: (s) => `(${s.number})`
    }), [n, r, i];
  }
}
class Zve extends br {
  run(e) {
    const n = ZA.exec(e.content), [, r, i] = n != null ? n : [], s = r == null ? void 0 : r.trim(), o = new this.state.Token("ref_open", "a", 1), l = new this.state.Token("text", "", 0), a = new this.state.Token("ref_close", "a", -1);
    return Ym(this.state, { open: o, content: l, close: a }, { kind: "numref", label: i || e.content, value: s }, {
      contentFromTarget: (c) => n ? s.replace(/%s/g, String(c.number)).replace(/\{number\}/g, String(c.number)) : c.title.trim()
    }), [o, l, a];
  }
}
class Ive extends br {
  run(e) {
    const n = ZA.exec(e.content), [, r, i] = n != null ? n : [], s = r == null ? void 0 : r.trim(), o = new this.state.Token("ref_open", "a", 1), l = new this.state.Token("text", "", 0), a = new this.state.Token("ref_close", "a", -1);
    return Ym(this.state, { open: o, content: l, close: a }, { kind: "ref", label: i || e.content, value: s }, {
      contentFromTarget: (c) => s || c.title
    }), [o, l, a];
  }
}
const Lve = {
  eq: Rve,
  ref: Ive,
  numref: Zve
}, Nve = Object.assign(Object.assign(Object.assign(Object.assign({}, Sve), Eve), Ave), Lve);
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function IA(t) {
  return typeof t > "u" || t === null;
}
function qve(t) {
  return typeof t == "object" && t !== null;
}
function Bve(t) {
  return Array.isArray(t) ? t : IA(t) ? [] : [t];
}
function Yve(t, e) {
  var n, r, i, s;
  if (e)
    for (s = Object.keys(e), n = 0, r = s.length; n < r; n += 1)
      i = s[n], t[i] = e[i];
  return t;
}
function jve(t, e) {
  var n = "", r;
  for (r = 0; r < e; r += 1)
    n += t;
  return n;
}
function Xve(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
var Wve = IA, zve = qve, Vve = Bve, Uve = jve, Fve = Xve, Gve = Yve, ze = {
  isNothing: Wve,
  isObject: zve,
  toArray: Vve,
  repeat: Uve,
  isNegativeZero: Fve,
  extend: Gve
};
function LA(t, e) {
  var n = "", r = t.reason || "(unknown reason)";
  return t.mark ? (t.mark.name && (n += 'in "' + t.mark.name + '" '), n += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (n += `

` + t.mark.snippet), r + " " + n) : r;
}
function El(t, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = LA(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
El.prototype = Object.create(Error.prototype);
El.prototype.constructor = El;
El.prototype.toString = function(e) {
  return this.name + ": " + LA(this, e);
};
var bt = El;
function Vf(t, e, n, r, i) {
  var s = "", o = "", l = Math.floor(i / 2) - 1;
  return r - e > l && (s = " ... ", e = r - l + s.length), n - r > l && (o = " ...", n = r + l - o.length), {
    str: s + t.slice(e, n).replace(/\t/g, "\u2192") + o,
    pos: r - e + s.length
  };
}
function Uf(t, e) {
  return ze.repeat(" ", e - t.length) + t;
}
function Hve(t, e) {
  if (e = Object.create(e || null), !t.buffer)
    return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, r = [0], i = [], s, o = -1; s = n.exec(t.buffer); )
    i.push(s.index), r.push(s.index + s[0].length), t.position <= s.index && o < 0 && (o = r.length - 2);
  o < 0 && (o = r.length - 1);
  var l = "", a, c, h = Math.min(t.line + e.linesAfter, i.length).toString().length, u = e.maxLength - (e.indent + h + 3);
  for (a = 1; a <= e.linesBefore && !(o - a < 0); a++)
    c = Vf(
      t.buffer,
      r[o - a],
      i[o - a],
      t.position - (r[o] - r[o - a]),
      u
    ), l = ze.repeat(" ", e.indent) + Uf((t.line - a + 1).toString(), h) + " | " + c.str + `
` + l;
  for (c = Vf(t.buffer, r[o], i[o], t.position, u), l += ze.repeat(" ", e.indent) + Uf((t.line + 1).toString(), h) + " | " + c.str + `
`, l += ze.repeat("-", e.indent + h + 3 + c.pos) + `^
`, a = 1; a <= e.linesAfter && !(o + a >= i.length); a++)
    c = Vf(
      t.buffer,
      r[o + a],
      i[o + a],
      t.position - (r[o] - r[o + a]),
      u
    ), l += ze.repeat(" ", e.indent) + Uf((t.line + a + 1).toString(), h) + " | " + c.str + `
`;
  return l.replace(/\n$/, "");
}
var Jve = Hve, Kve = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], eSe = [
  "scalar",
  "sequence",
  "mapping"
];
function tSe(t) {
  var e = {};
  return t !== null && Object.keys(t).forEach(function(n) {
    t[n].forEach(function(r) {
      e[String(r)] = n;
    });
  }), e;
}
function nSe(t, e) {
  if (e = e || {}, Object.keys(e).forEach(function(n) {
    if (Kve.indexOf(n) === -1)
      throw new bt('Unknown option "' + n + '" is met in definition of "' + t + '" YAML type.');
  }), this.options = e, this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(n) {
    return n;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || !1, this.styleAliases = tSe(e.styleAliases || null), eSe.indexOf(this.kind) === -1)
    throw new bt('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
var lt = nSe;
function ow(t, e) {
  var n = [];
  return t[e].forEach(function(r) {
    var i = n.length;
    n.forEach(function(s, o) {
      s.tag === r.tag && s.kind === r.kind && s.multi === r.multi && (i = o);
    }), n[i] = r;
  }), n;
}
function rSe() {
  var t = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, n;
  function r(i) {
    i.multi ? (t.multi[i.kind].push(i), t.multi.fallback.push(i)) : t[i.kind][i.tag] = t.fallback[i.tag] = i;
  }
  for (e = 0, n = arguments.length; e < n; e += 1)
    arguments[e].forEach(r);
  return t;
}
function zp(t) {
  return this.extend(t);
}
zp.prototype.extend = function(e) {
  var n = [], r = [];
  if (e instanceof lt)
    r.push(e);
  else if (Array.isArray(e))
    r = r.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (n = n.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit));
  else
    throw new bt("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(s) {
    if (!(s instanceof lt))
      throw new bt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new bt("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new bt("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), r.forEach(function(s) {
    if (!(s instanceof lt))
      throw new bt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(zp.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(r), i.compiledImplicit = ow(i, "implicit"), i.compiledExplicit = ow(i, "explicit"), i.compiledTypeMap = rSe(i.compiledImplicit, i.compiledExplicit), i;
};
var NA = zp, qA = new lt("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t) {
    return t !== null ? t : "";
  }
}), BA = new lt("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t) {
    return t !== null ? t : [];
  }
}), YA = new lt("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t) {
    return t !== null ? t : {};
  }
}), jA = new NA({
  explicit: [
    qA,
    BA,
    YA
  ]
});
function iSe(t) {
  if (t === null)
    return !0;
  var e = t.length;
  return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
}
function sSe() {
  return null;
}
function oSe(t) {
  return t === null;
}
var XA = new lt("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: iSe,
  construct: sSe,
  predicate: oSe,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function lSe(t) {
  if (t === null)
    return !1;
  var e = t.length;
  return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
}
function aSe(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
function cSe(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
var WA = new lt("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: lSe,
  construct: aSe,
  predicate: cSe,
  represent: {
    lowercase: function(t) {
      return t ? "true" : "false";
    },
    uppercase: function(t) {
      return t ? "TRUE" : "FALSE";
    },
    camelcase: function(t) {
      return t ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function hSe(t) {
  return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
}
function uSe(t) {
  return 48 <= t && t <= 55;
}
function fSe(t) {
  return 48 <= t && t <= 57;
}
function dSe(t) {
  if (t === null)
    return !1;
  var e = t.length, n = 0, r = !1, i;
  if (!e)
    return !1;
  if (i = t[n], (i === "-" || i === "+") && (i = t[++n]), i === "0") {
    if (n + 1 === e)
      return !0;
    if (i = t[++n], i === "b") {
      for (n++; n < e; n++)
        if (i = t[n], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "x") {
      for (n++; n < e; n++)
        if (i = t[n], i !== "_") {
          if (!hSe(t.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
    if (i === "o") {
      for (n++; n < e; n++)
        if (i = t[n], i !== "_") {
          if (!uSe(t.charCodeAt(n)))
            return !1;
          r = !0;
        }
      return r && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; n < e; n++)
    if (i = t[n], i !== "_") {
      if (!fSe(t.charCodeAt(n)))
        return !1;
      r = !0;
    }
  return !(!r || i === "_");
}
function pSe(t) {
  var e = t, n = 1, r;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), r = e[0], (r === "-" || r === "+") && (r === "-" && (n = -1), e = e.slice(1), r = e[0]), e === "0")
    return 0;
  if (r === "0") {
    if (e[1] === "b")
      return n * parseInt(e.slice(2), 2);
    if (e[1] === "x")
      return n * parseInt(e.slice(2), 16);
    if (e[1] === "o")
      return n * parseInt(e.slice(2), 8);
  }
  return n * parseInt(e, 10);
}
function gSe(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !ze.isNegativeZero(t);
}
var zA = new lt("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: dSe,
  construct: pSe,
  predicate: gSe,
  represent: {
    binary: function(t) {
      return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
    },
    octal: function(t) {
      return t >= 0 ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1);
    },
    decimal: function(t) {
      return t.toString(10);
    },
    hexadecimal: function(t) {
      return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), mSe = new RegExp(
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function OSe(t) {
  return !(t === null || !mSe.test(t) || t[t.length - 1] === "_");
}
function bSe(t) {
  var e, n;
  return e = t.replace(/_/g, "").toLowerCase(), n = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : n * parseFloat(e, 10);
}
var ySe = /^[-+]?[0-9]+e/;
function wSe(t, e) {
  var n;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (ze.isNegativeZero(t))
    return "-0.0";
  return n = t.toString(10), ySe.test(n) ? n.replace("e", ".e") : n;
}
function kSe(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || ze.isNegativeZero(t));
}
var VA = new lt("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: OSe,
  construct: bSe,
  predicate: kSe,
  represent: wSe,
  defaultStyle: "lowercase"
}), UA = jA.extend({
  implicit: [
    XA,
    WA,
    zA,
    VA
  ]
}), FA = UA, GA = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), HA = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function xSe(t) {
  return t === null ? !1 : GA.exec(t) !== null || HA.exec(t) !== null;
}
function vSe(t) {
  var e, n, r, i, s, o, l, a = 0, c = null, h, u, f;
  if (e = GA.exec(t), e === null && (e = HA.exec(t)), e === null)
    throw new Error("Date resolve error");
  if (n = +e[1], r = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(n, r, i));
  if (s = +e[4], o = +e[5], l = +e[6], e[7]) {
    for (a = e[7].slice(0, 3); a.length < 3; )
      a += "0";
    a = +a;
  }
  return e[9] && (h = +e[10], u = +(e[11] || 0), c = (h * 60 + u) * 6e4, e[9] === "-" && (c = -c)), f = new Date(Date.UTC(n, r, i, s, o, l, a)), c && f.setTime(f.getTime() - c), f;
}
function SSe(t) {
  return t.toISOString();
}
var JA = new lt("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: xSe,
  construct: vSe,
  instanceOf: Date,
  represent: SSe
});
function _Se(t) {
  return t === "<<" || t === null;
}
var KA = new lt("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: _Se
}), jm = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function CSe(t) {
  if (t === null)
    return !1;
  var e, n, r = 0, i = t.length, s = jm;
  for (n = 0; n < i; n++)
    if (e = s.indexOf(t.charAt(n)), !(e > 64)) {
      if (e < 0)
        return !1;
      r += 6;
    }
  return r % 8 === 0;
}
function ASe(t) {
  var e, n, r = t.replace(/[\r\n=]/g, ""), i = r.length, s = jm, o = 0, l = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (l.push(o >> 16 & 255), l.push(o >> 8 & 255), l.push(o & 255)), o = o << 6 | s.indexOf(r.charAt(e));
  return n = i % 4 * 6, n === 0 ? (l.push(o >> 16 & 255), l.push(o >> 8 & 255), l.push(o & 255)) : n === 18 ? (l.push(o >> 10 & 255), l.push(o >> 2 & 255)) : n === 12 && l.push(o >> 4 & 255), new Uint8Array(l);
}
function $Se(t) {
  var e = "", n = 0, r, i, s = t.length, o = jm;
  for (r = 0; r < s; r++)
    r % 3 === 0 && r && (e += o[n >> 18 & 63], e += o[n >> 12 & 63], e += o[n >> 6 & 63], e += o[n & 63]), n = (n << 8) + t[r];
  return i = s % 3, i === 0 ? (e += o[n >> 18 & 63], e += o[n >> 12 & 63], e += o[n >> 6 & 63], e += o[n & 63]) : i === 2 ? (e += o[n >> 10 & 63], e += o[n >> 4 & 63], e += o[n << 2 & 63], e += o[64]) : i === 1 && (e += o[n >> 2 & 63], e += o[n << 4 & 63], e += o[64], e += o[64]), e;
}
function PSe(t) {
  return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
var e$ = new lt("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: CSe,
  construct: ASe,
  predicate: PSe,
  represent: $Se
}), TSe = Object.prototype.hasOwnProperty, QSe = Object.prototype.toString;
function ESe(t) {
  if (t === null)
    return !0;
  var e = [], n, r, i, s, o, l = t;
  for (n = 0, r = l.length; n < r; n += 1) {
    if (i = l[n], o = !1, QSe.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if (TSe.call(i, s))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (e.indexOf(s) === -1)
      e.push(s);
    else
      return !1;
  }
  return !0;
}
function DSe(t) {
  return t !== null ? t : [];
}
var t$ = new lt("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: ESe,
  construct: DSe
}), MSe = Object.prototype.toString;
function RSe(t) {
  if (t === null)
    return !0;
  var e, n, r, i, s, o = t;
  for (s = new Array(o.length), e = 0, n = o.length; e < n; e += 1) {
    if (r = o[e], MSe.call(r) !== "[object Object]" || (i = Object.keys(r), i.length !== 1))
      return !1;
    s[e] = [i[0], r[i[0]]];
  }
  return !0;
}
function ZSe(t) {
  if (t === null)
    return [];
  var e, n, r, i, s, o = t;
  for (s = new Array(o.length), e = 0, n = o.length; e < n; e += 1)
    r = o[e], i = Object.keys(r), s[e] = [i[0], r[i[0]]];
  return s;
}
var n$ = new lt("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: RSe,
  construct: ZSe
}), ISe = Object.prototype.hasOwnProperty;
function LSe(t) {
  if (t === null)
    return !0;
  var e, n = t;
  for (e in n)
    if (ISe.call(n, e) && n[e] !== null)
      return !1;
  return !0;
}
function NSe(t) {
  return t !== null ? t : {};
}
var r$ = new lt("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: LSe,
  construct: NSe
}), Xm = FA.extend({
  implicit: [
    JA,
    KA
  ],
  explicit: [
    e$,
    t$,
    n$,
    r$
  ]
}), Vr = Object.prototype.hasOwnProperty, wh = 1, i$ = 2, s$ = 3, kh = 4, Ff = 1, qSe = 2, lw = 3, BSe = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, YSe = /[\x85\u2028\u2029]/, jSe = /[,\[\]\{\}]/, o$ = /^(?:!|!!|![a-z\-]+!)$/i, l$ = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function aw(t) {
  return Object.prototype.toString.call(t);
}
function jn(t) {
  return t === 10 || t === 13;
}
function ki(t) {
  return t === 9 || t === 32;
}
function Pt(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
function ns(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function XSe(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function WSe(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function zSe(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
function cw(t) {
  return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "\x85" : t === 95 ? "\xA0" : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
}
function VSe(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(
    (t - 65536 >> 10) + 55296,
    (t - 65536 & 1023) + 56320
  );
}
var a$ = new Array(256), c$ = new Array(256);
for (var Vi = 0; Vi < 256; Vi++)
  a$[Vi] = cw(Vi) ? 1 : 0, c$[Vi] = cw(Vi);
function USe(t, e) {
  this.input = t, this.filename = e.filename || null, this.schema = e.schema || Xm, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function h$(t, e) {
  var n = {
    name: t.filename,
    buffer: t.input.slice(0, -1),
    position: t.position,
    line: t.line,
    column: t.position - t.lineStart
  };
  return n.snippet = Jve(n), new bt(e, n);
}
function W(t, e) {
  throw h$(t, e);
}
function xh(t, e) {
  t.onWarning && t.onWarning.call(null, h$(t, e));
}
var hw = {
  YAML: function(e, n, r) {
    var i, s, o;
    e.version !== null && W(e, "duplication of %YAML directive"), r.length !== 1 && W(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(r[0]), i === null && W(e, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && W(e, "unacceptable YAML version of the document"), e.version = r[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && xh(e, "unsupported YAML version of the document");
  },
  TAG: function(e, n, r) {
    var i, s;
    r.length !== 2 && W(e, "TAG directive accepts exactly two arguments"), i = r[0], s = r[1], o$.test(i) || W(e, "ill-formed tag handle (first argument) of the TAG directive"), Vr.call(e.tagMap, i) && W(e, 'there is a previously declared suffix for "' + i + '" tag handle'), l$.test(s) || W(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      W(e, "tag prefix is malformed: " + s);
    }
    e.tagMap[i] = s;
  }
};
function Lr(t, e, n, r) {
  var i, s, o, l;
  if (e < n) {
    if (l = t.input.slice(e, n), r)
      for (i = 0, s = l.length; i < s; i += 1)
        o = l.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || W(t, "expected valid JSON character");
    else
      BSe.test(l) && W(t, "the stream contains non-printable characters");
    t.result += l;
  }
}
function uw(t, e, n, r) {
  var i, s, o, l;
  for (ze.isObject(n) || W(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, l = i.length; o < l; o += 1)
    s = i[o], Vr.call(e, s) || (e[s] = n[s], r[s] = !0);
}
function rs(t, e, n, r, i, s, o, l, a) {
  var c, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), c = 0, h = i.length; c < h; c += 1)
      Array.isArray(i[c]) && W(t, "nested arrays are not supported inside keys"), typeof i == "object" && aw(i[c]) === "[object Object]" && (i[c] = "[object Object]");
  if (typeof i == "object" && aw(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), r === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (c = 0, h = s.length; c < h; c += 1)
        uw(t, e, s[c], n);
    else
      uw(t, e, s, n);
  else
    !t.json && !Vr.call(n, i) && Vr.call(e, i) && (t.line = o || t.line, t.lineStart = l || t.lineStart, t.position = a || t.position, W(t, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : e[i] = s, delete n[i];
  return e;
}
function Wm(t) {
  var e;
  e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : W(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1;
}
function Ye(t, e, n) {
  for (var r = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; ki(i); )
      i === 9 && t.firstTabInLine === -1 && (t.firstTabInLine = t.position), i = t.input.charCodeAt(++t.position);
    if (e && i === 35)
      do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (jn(i))
      for (Wm(t), i = t.input.charCodeAt(t.position), r++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, i = t.input.charCodeAt(++t.position);
    else
      break;
  }
  return n !== -1 && r !== 0 && t.lineIndent < n && xh(t, "deficient indentation"), r;
}
function yu(t) {
  var e = t.position, n;
  return n = t.input.charCodeAt(e), !!((n === 45 || n === 46) && n === t.input.charCodeAt(e + 1) && n === t.input.charCodeAt(e + 2) && (e += 3, n = t.input.charCodeAt(e), n === 0 || Pt(n)));
}
function zm(t, e) {
  e === 1 ? t.result += " " : e > 1 && (t.result += ze.repeat(`
`, e - 1));
}
function FSe(t, e, n) {
  var r, i, s, o, l, a, c, h, u = t.kind, f = t.result, d;
  if (d = t.input.charCodeAt(t.position), Pt(d) || ns(d) || d === 35 || d === 38 || d === 42 || d === 33 || d === 124 || d === 62 || d === 39 || d === 34 || d === 37 || d === 64 || d === 96 || (d === 63 || d === 45) && (i = t.input.charCodeAt(t.position + 1), Pt(i) || n && ns(i)))
    return !1;
  for (t.kind = "scalar", t.result = "", s = o = t.position, l = !1; d !== 0; ) {
    if (d === 58) {
      if (i = t.input.charCodeAt(t.position + 1), Pt(i) || n && ns(i))
        break;
    } else if (d === 35) {
      if (r = t.input.charCodeAt(t.position - 1), Pt(r))
        break;
    } else {
      if (t.position === t.lineStart && yu(t) || n && ns(d))
        break;
      if (jn(d))
        if (a = t.line, c = t.lineStart, h = t.lineIndent, Ye(t, !1, -1), t.lineIndent >= e) {
          l = !0, d = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = o, t.line = a, t.lineStart = c, t.lineIndent = h;
          break;
        }
    }
    l && (Lr(t, s, o, !1), zm(t, t.line - a), s = o = t.position, l = !1), ki(d) || (o = t.position + 1), d = t.input.charCodeAt(++t.position);
  }
  return Lr(t, s, o, !1), t.result ? !0 : (t.kind = u, t.result = f, !1);
}
function GSe(t, e) {
  var n, r, i;
  if (n = t.input.charCodeAt(t.position), n !== 39)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = i = t.position; (n = t.input.charCodeAt(t.position)) !== 0; )
    if (n === 39)
      if (Lr(t, r, t.position, !0), n = t.input.charCodeAt(++t.position), n === 39)
        r = t.position, t.position++, i = t.position;
      else
        return !0;
    else
      jn(n) ? (Lr(t, r, i, !0), zm(t, Ye(t, !1, e)), r = i = t.position) : t.position === t.lineStart && yu(t) ? W(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
  W(t, "unexpected end of the stream within a single quoted scalar");
}
function HSe(t, e) {
  var n, r, i, s, o, l;
  if (l = t.input.charCodeAt(t.position), l !== 34)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = r = t.position; (l = t.input.charCodeAt(t.position)) !== 0; ) {
    if (l === 34)
      return Lr(t, n, t.position, !0), t.position++, !0;
    if (l === 92) {
      if (Lr(t, n, t.position, !0), l = t.input.charCodeAt(++t.position), jn(l))
        Ye(t, !1, e);
      else if (l < 256 && a$[l])
        t.result += c$[l], t.position++;
      else if ((o = WSe(l)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          l = t.input.charCodeAt(++t.position), (o = XSe(l)) >= 0 ? s = (s << 4) + o : W(t, "expected hexadecimal character");
        t.result += VSe(s), t.position++;
      } else
        W(t, "unknown escape sequence");
      n = r = t.position;
    } else
      jn(l) ? (Lr(t, n, r, !0), zm(t, Ye(t, !1, e)), n = r = t.position) : t.position === t.lineStart && yu(t) ? W(t, "unexpected end of the document within a double quoted scalar") : (t.position++, r = t.position);
  }
  W(t, "unexpected end of the stream within a double quoted scalar");
}
function JSe(t, e) {
  var n = !0, r, i, s, o = t.tag, l, a = t.anchor, c, h, u, f, d, p = /* @__PURE__ */ Object.create(null), g, m, O, b;
  if (b = t.input.charCodeAt(t.position), b === 91)
    h = 93, d = !1, l = [];
  else if (b === 123)
    h = 125, d = !0, l = {};
  else
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = l), b = t.input.charCodeAt(++t.position); b !== 0; ) {
    if (Ye(t, !0, e), b = t.input.charCodeAt(t.position), b === h)
      return t.position++, t.tag = o, t.anchor = a, t.kind = d ? "mapping" : "sequence", t.result = l, !0;
    n ? b === 44 && W(t, "expected the node content, but found ','") : W(t, "missed comma between flow collection entries"), m = g = O = null, u = f = !1, b === 63 && (c = t.input.charCodeAt(t.position + 1), Pt(c) && (u = f = !0, t.position++, Ye(t, !0, e))), r = t.line, i = t.lineStart, s = t.position, Bs(t, e, wh, !1, !0), m = t.tag, g = t.result, Ye(t, !0, e), b = t.input.charCodeAt(t.position), (f || t.line === r) && b === 58 && (u = !0, b = t.input.charCodeAt(++t.position), Ye(t, !0, e), Bs(t, e, wh, !1, !0), O = t.result), d ? rs(t, l, p, m, g, O, r, i, s) : u ? l.push(rs(t, null, p, m, g, O, r, i, s)) : l.push(g), Ye(t, !0, e), b = t.input.charCodeAt(t.position), b === 44 ? (n = !0, b = t.input.charCodeAt(++t.position)) : n = !1;
  }
  W(t, "unexpected end of the stream within a flow collection");
}
function KSe(t, e) {
  var n, r, i = Ff, s = !1, o = !1, l = e, a = 0, c = !1, h, u;
  if (u = t.input.charCodeAt(t.position), u === 124)
    r = !1;
  else if (u === 62)
    r = !0;
  else
    return !1;
  for (t.kind = "scalar", t.result = ""; u !== 0; )
    if (u = t.input.charCodeAt(++t.position), u === 43 || u === 45)
      Ff === i ? i = u === 43 ? lw : qSe : W(t, "repeat of a chomping mode identifier");
    else if ((h = zSe(u)) >= 0)
      h === 0 ? W(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? W(t, "repeat of an indentation width identifier") : (l = e + h - 1, o = !0);
    else
      break;
  if (ki(u)) {
    do
      u = t.input.charCodeAt(++t.position);
    while (ki(u));
    if (u === 35)
      do
        u = t.input.charCodeAt(++t.position);
      while (!jn(u) && u !== 0);
  }
  for (; u !== 0; ) {
    for (Wm(t), t.lineIndent = 0, u = t.input.charCodeAt(t.position); (!o || t.lineIndent < l) && u === 32; )
      t.lineIndent++, u = t.input.charCodeAt(++t.position);
    if (!o && t.lineIndent > l && (l = t.lineIndent), jn(u)) {
      a++;
      continue;
    }
    if (t.lineIndent < l) {
      i === lw ? t.result += ze.repeat(`
`, s ? 1 + a : a) : i === Ff && s && (t.result += `
`);
      break;
    }
    for (r ? ki(u) ? (c = !0, t.result += ze.repeat(`
`, s ? 1 + a : a)) : c ? (c = !1, t.result += ze.repeat(`
`, a + 1)) : a === 0 ? s && (t.result += " ") : t.result += ze.repeat(`
`, a) : t.result += ze.repeat(`
`, s ? 1 + a : a), s = !0, o = !0, a = 0, n = t.position; !jn(u) && u !== 0; )
      u = t.input.charCodeAt(++t.position);
    Lr(t, n, t.position, !1);
  }
  return !0;
}
function fw(t, e) {
  var n, r = t.tag, i = t.anchor, s = [], o, l = !1, a;
  if (t.firstTabInLine !== -1)
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = s), a = t.input.charCodeAt(t.position); a !== 0 && (t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, W(t, "tab characters must not be used in indentation")), !(a !== 45 || (o = t.input.charCodeAt(t.position + 1), !Pt(o)))); ) {
    if (l = !0, t.position++, Ye(t, !0, -1) && t.lineIndent <= e) {
      s.push(null), a = t.input.charCodeAt(t.position);
      continue;
    }
    if (n = t.line, Bs(t, e, s$, !1, !0), s.push(t.result), Ye(t, !0, -1), a = t.input.charCodeAt(t.position), (t.line === n || t.lineIndent > e) && a !== 0)
      W(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e)
      break;
  }
  return l ? (t.tag = r, t.anchor = i, t.kind = "sequence", t.result = s, !0) : !1;
}
function e_e(t, e, n) {
  var r, i, s, o, l, a, c = t.tag, h = t.anchor, u = {}, f = /* @__PURE__ */ Object.create(null), d = null, p = null, g = null, m = !1, O = !1, b;
  if (t.firstTabInLine !== -1)
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = u), b = t.input.charCodeAt(t.position); b !== 0; ) {
    if (!m && t.firstTabInLine !== -1 && (t.position = t.firstTabInLine, W(t, "tab characters must not be used in indentation")), r = t.input.charCodeAt(t.position + 1), s = t.line, (b === 63 || b === 58) && Pt(r))
      b === 63 ? (m && (rs(t, u, f, d, p, null, o, l, a), d = p = g = null), O = !0, m = !0, i = !0) : m ? (m = !1, i = !0) : W(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, b = r;
    else {
      if (o = t.line, l = t.lineStart, a = t.position, !Bs(t, n, i$, !1, !0))
        break;
      if (t.line === s) {
        for (b = t.input.charCodeAt(t.position); ki(b); )
          b = t.input.charCodeAt(++t.position);
        if (b === 58)
          b = t.input.charCodeAt(++t.position), Pt(b) || W(t, "a whitespace character is expected after the key-value separator within a block mapping"), m && (rs(t, u, f, d, p, null, o, l, a), d = p = g = null), O = !0, m = !1, i = !1, d = t.tag, p = t.result;
        else if (O)
          W(t, "can not read an implicit mapping pair; a colon is missed");
        else
          return t.tag = c, t.anchor = h, !0;
      } else if (O)
        W(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t.tag = c, t.anchor = h, !0;
    }
    if ((t.line === s || t.lineIndent > e) && (m && (o = t.line, l = t.lineStart, a = t.position), Bs(t, e, kh, !0, i) && (m ? p = t.result : g = t.result), m || (rs(t, u, f, d, p, g, o, l, a), d = p = g = null), Ye(t, !0, -1), b = t.input.charCodeAt(t.position)), (t.line === s || t.lineIndent > e) && b !== 0)
      W(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e)
      break;
  }
  return m && rs(t, u, f, d, p, null, o, l, a), O && (t.tag = c, t.anchor = h, t.kind = "mapping", t.result = u), O;
}
function t_e(t) {
  var e, n = !1, r = !1, i, s, o;
  if (o = t.input.charCodeAt(t.position), o !== 33)
    return !1;
  if (t.tag !== null && W(t, "duplication of a tag property"), o = t.input.charCodeAt(++t.position), o === 60 ? (n = !0, o = t.input.charCodeAt(++t.position)) : o === 33 ? (r = !0, i = "!!", o = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, n) {
    do
      o = t.input.charCodeAt(++t.position);
    while (o !== 0 && o !== 62);
    t.position < t.length ? (s = t.input.slice(e, t.position), o = t.input.charCodeAt(++t.position)) : W(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !Pt(o); )
      o === 33 && (r ? W(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), o$.test(i) || W(t, "named tag handle cannot contain such characters"), r = !0, e = t.position + 1)), o = t.input.charCodeAt(++t.position);
    s = t.input.slice(e, t.position), jSe.test(s) && W(t, "tag suffix cannot contain flow indicator characters");
  }
  s && !l$.test(s) && W(t, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    W(t, "tag name is malformed: " + s);
  }
  return n ? t.tag = s : Vr.call(t.tagMap, i) ? t.tag = t.tagMap[i] + s : i === "!" ? t.tag = "!" + s : i === "!!" ? t.tag = "tag:yaml.org,2002:" + s : W(t, 'undeclared tag handle "' + i + '"'), !0;
}
function n_e(t) {
  var e, n;
  if (n = t.input.charCodeAt(t.position), n !== 38)
    return !1;
  for (t.anchor !== null && W(t, "duplication of an anchor property"), n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !Pt(n) && !ns(n); )
    n = t.input.charCodeAt(++t.position);
  return t.position === e && W(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), !0;
}
function r_e(t) {
  var e, n, r;
  if (r = t.input.charCodeAt(t.position), r !== 42)
    return !1;
  for (r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !Pt(r) && !ns(r); )
    r = t.input.charCodeAt(++t.position);
  return t.position === e && W(t, "name of an alias node must contain at least one character"), n = t.input.slice(e, t.position), Vr.call(t.anchorMap, n) || W(t, 'unidentified alias "' + n + '"'), t.result = t.anchorMap[n], Ye(t, !0, -1), !0;
}
function Bs(t, e, n, r, i) {
  var s, o, l, a = 1, c = !1, h = !1, u, f, d, p, g, m;
  if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, s = o = l = kh === n || s$ === n, r && Ye(t, !0, -1) && (c = !0, t.lineIndent > e ? a = 1 : t.lineIndent === e ? a = 0 : t.lineIndent < e && (a = -1)), a === 1)
    for (; t_e(t) || n_e(t); )
      Ye(t, !0, -1) ? (c = !0, l = s, t.lineIndent > e ? a = 1 : t.lineIndent === e ? a = 0 : t.lineIndent < e && (a = -1)) : l = !1;
  if (l && (l = c || i), (a === 1 || kh === n) && (wh === n || i$ === n ? g = e : g = e + 1, m = t.position - t.lineStart, a === 1 ? l && (fw(t, m) || e_e(t, m, g)) || JSe(t, g) ? h = !0 : (o && KSe(t, g) || GSe(t, g) || HSe(t, g) ? h = !0 : r_e(t) ? (h = !0, (t.tag !== null || t.anchor !== null) && W(t, "alias node should not have any properties")) : FSe(t, g, wh === n) && (h = !0, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : a === 0 && (h = l && fw(t, m))), t.tag === null)
    t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
  else if (t.tag === "?") {
    for (t.result !== null && t.kind !== "scalar" && W(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), u = 0, f = t.implicitTypes.length; u < f; u += 1)
      if (p = t.implicitTypes[u], p.resolve(t.result)) {
        t.result = p.construct(t.result), t.tag = p.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
        break;
      }
  } else if (t.tag !== "!") {
    if (Vr.call(t.typeMap[t.kind || "fallback"], t.tag))
      p = t.typeMap[t.kind || "fallback"][t.tag];
    else
      for (p = null, d = t.typeMap.multi[t.kind || "fallback"], u = 0, f = d.length; u < f; u += 1)
        if (t.tag.slice(0, d[u].tag.length) === d[u].tag) {
          p = d[u];
          break;
        }
    p || W(t, "unknown tag !<" + t.tag + ">"), t.result !== null && p.kind !== t.kind && W(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + p.kind + '", not "' + t.kind + '"'), p.resolve(t.result, t.tag) ? (t.result = p.construct(t.result, t.tag), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : W(t, "cannot resolve a node with !<" + t.tag + "> explicit tag");
  }
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || h;
}
function i_e(t) {
  var e = t.position, n, r, i, s = !1, o;
  for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = /* @__PURE__ */ Object.create(null), t.anchorMap = /* @__PURE__ */ Object.create(null); (o = t.input.charCodeAt(t.position)) !== 0 && (Ye(t, !0, -1), o = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = t.input.charCodeAt(++t.position), n = t.position; o !== 0 && !Pt(o); )
      o = t.input.charCodeAt(++t.position);
    for (r = t.input.slice(n, t.position), i = [], r.length < 1 && W(t, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; ki(o); )
        o = t.input.charCodeAt(++t.position);
      if (o === 35) {
        do
          o = t.input.charCodeAt(++t.position);
        while (o !== 0 && !jn(o));
        break;
      }
      if (jn(o))
        break;
      for (n = t.position; o !== 0 && !Pt(o); )
        o = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(n, t.position));
    }
    o !== 0 && Wm(t), Vr.call(hw, r) ? hw[r](t, r, i) : xh(t, 'unknown document directive "' + r + '"');
  }
  if (Ye(t, !0, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, Ye(t, !0, -1)) : s && W(t, "directives end mark is expected"), Bs(t, t.lineIndent - 1, kh, !1, !0), Ye(t, !0, -1), t.checkLineBreaks && YSe.test(t.input.slice(e, t.position)) && xh(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && yu(t)) {
    t.input.charCodeAt(t.position) === 46 && (t.position += 3, Ye(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1)
    W(t, "end of the stream or a document separator is expected");
  else
    return;
}
function u$(t, e) {
  t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var n = new USe(t, e), r = t.indexOf("\0");
  for (r !== -1 && (n.position = r, W(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    i_e(n);
  return n.documents;
}
function s_e(t, e, n) {
  e !== null && typeof e == "object" && typeof n > "u" && (n = e, e = null);
  var r = u$(t, n);
  if (typeof e != "function")
    return r;
  for (var i = 0, s = r.length; i < s; i += 1)
    e(r[i]);
}
function o_e(t, e) {
  var n = u$(t, e);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new bt("expected a single document in the stream, but found more");
  }
}
var l_e = s_e, a_e = o_e, f$ = {
  loadAll: l_e,
  load: a_e
}, d$ = Object.prototype.toString, p$ = Object.prototype.hasOwnProperty, Vm = 65279, c_e = 9, Dl = 10, h_e = 13, u_e = 32, f_e = 33, d_e = 34, Vp = 35, p_e = 37, g_e = 38, m_e = 39, O_e = 42, g$ = 44, b_e = 45, vh = 58, y_e = 61, w_e = 62, k_e = 63, x_e = 64, m$ = 91, O$ = 93, v_e = 96, b$ = 123, S_e = 124, y$ = 125, mt = {};
mt[0] = "\\0";
mt[7] = "\\a";
mt[8] = "\\b";
mt[9] = "\\t";
mt[10] = "\\n";
mt[11] = "\\v";
mt[12] = "\\f";
mt[13] = "\\r";
mt[27] = "\\e";
mt[34] = '\\"';
mt[92] = "\\\\";
mt[133] = "\\N";
mt[160] = "\\_";
mt[8232] = "\\L";
mt[8233] = "\\P";
var __e = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], C_e = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function A_e(t, e) {
  var n, r, i, s, o, l, a;
  if (e === null)
    return {};
  for (n = {}, r = Object.keys(e), i = 0, s = r.length; i < s; i += 1)
    o = r[i], l = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), a = t.compiledTypeMap.fallback[o], a && p$.call(a.styleAliases, l) && (l = a.styleAliases[l]), n[o] = l;
  return n;
}
function $_e(t) {
  var e, n, r;
  if (e = t.toString(16).toUpperCase(), t <= 255)
    n = "x", r = 2;
  else if (t <= 65535)
    n = "u", r = 4;
  else if (t <= 4294967295)
    n = "U", r = 8;
  else
    throw new bt("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + ze.repeat("0", r - e.length) + e;
}
var P_e = 1, Ml = 2;
function T_e(t) {
  this.schema = t.schema || Xm, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = ze.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = A_e(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.quotingType = t.quotingType === '"' ? Ml : P_e, this.forceQuotes = t.forceQuotes || !1, this.replacer = typeof t.replacer == "function" ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function dw(t, e) {
  for (var n = ze.repeat(" ", e), r = 0, i = -1, s = "", o, l = t.length; r < l; )
    i = t.indexOf(`
`, r), i === -1 ? (o = t.slice(r), r = l) : (o = t.slice(r, i + 1), r = i + 1), o.length && o !== `
` && (s += n), s += o;
  return s;
}
function Up(t, e) {
  return `
` + ze.repeat(" ", t.indent * e);
}
function Q_e(t, e) {
  var n, r, i;
  for (n = 0, r = t.implicitTypes.length; n < r; n += 1)
    if (i = t.implicitTypes[n], i.resolve(e))
      return !0;
  return !1;
}
function Sh(t) {
  return t === u_e || t === c_e;
}
function Rl(t) {
  return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== Vm || 65536 <= t && t <= 1114111;
}
function pw(t) {
  return Rl(t) && t !== Vm && t !== h_e && t !== Dl;
}
function gw(t, e, n) {
  var r = pw(t), i = r && !Sh(t);
  return (n ? r : r && t !== g$ && t !== m$ && t !== O$ && t !== b$ && t !== y$) && t !== Vp && !(e === vh && !i) || pw(e) && !Sh(e) && t === Vp || e === vh && i;
}
function E_e(t) {
  return Rl(t) && t !== Vm && !Sh(t) && t !== b_e && t !== k_e && t !== vh && t !== g$ && t !== m$ && t !== O$ && t !== b$ && t !== y$ && t !== Vp && t !== g_e && t !== O_e && t !== f_e && t !== S_e && t !== y_e && t !== w_e && t !== m_e && t !== d_e && t !== p_e && t !== x_e && t !== v_e;
}
function D_e(t) {
  return !Sh(t) && t !== vh;
}
function Qo(t, e) {
  var n = t.charCodeAt(e), r;
  return n >= 55296 && n <= 56319 && e + 1 < t.length && (r = t.charCodeAt(e + 1), r >= 56320 && r <= 57343) ? (n - 55296) * 1024 + r - 56320 + 65536 : n;
}
function w$(t) {
  var e = /^\n* /;
  return e.test(t);
}
var k$ = 1, Fp = 2, x$ = 3, v$ = 4, Ji = 5;
function M_e(t, e, n, r, i, s, o, l) {
  var a, c = 0, h = null, u = !1, f = !1, d = r !== -1, p = -1, g = E_e(Qo(t, 0)) && D_e(Qo(t, t.length - 1));
  if (e || o)
    for (a = 0; a < t.length; c >= 65536 ? a += 2 : a++) {
      if (c = Qo(t, a), !Rl(c))
        return Ji;
      g = g && gw(c, h, l), h = c;
    }
  else {
    for (a = 0; a < t.length; c >= 65536 ? a += 2 : a++) {
      if (c = Qo(t, a), c === Dl)
        u = !0, d && (f = f || a - p - 1 > r && t[p + 1] !== " ", p = a);
      else if (!Rl(c))
        return Ji;
      g = g && gw(c, h, l), h = c;
    }
    f = f || d && a - p - 1 > r && t[p + 1] !== " ";
  }
  return !u && !f ? g && !o && !i(t) ? k$ : s === Ml ? Ji : Fp : n > 9 && w$(t) ? Ji : o ? s === Ml ? Ji : Fp : f ? v$ : x$;
}
function R_e(t, e, n, r, i) {
  t.dump = function() {
    if (e.length === 0)
      return t.quotingType === Ml ? '""' : "''";
    if (!t.noCompatMode && (__e.indexOf(e) !== -1 || C_e.test(e)))
      return t.quotingType === Ml ? '"' + e + '"' : "'" + e + "'";
    var s = t.indent * Math.max(1, n), o = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - s), l = r || t.flowLevel > -1 && n >= t.flowLevel;
    function a(c) {
      return Q_e(t, c);
    }
    switch (M_e(
      e,
      l,
      t.indent,
      o,
      a,
      t.quotingType,
      t.forceQuotes && !r,
      i
    )) {
      case k$:
        return e;
      case Fp:
        return "'" + e.replace(/'/g, "''") + "'";
      case x$:
        return "|" + mw(e, t.indent) + Ow(dw(e, s));
      case v$:
        return ">" + mw(e, t.indent) + Ow(dw(Z_e(e, o), s));
      case Ji:
        return '"' + I_e(e) + '"';
      default:
        throw new bt("impossible error: invalid scalar style");
    }
  }();
}
function mw(t, e) {
  var n = w$(t) ? String(e) : "", r = t[t.length - 1] === `
`, i = r && (t[t.length - 2] === `
` || t === `
`), s = i ? "+" : r ? "" : "-";
  return n + s + `
`;
}
function Ow(t) {
  return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
}
function Z_e(t, e) {
  for (var n = /(\n+)([^\n]*)/g, r = function() {
    var c = t.indexOf(`
`);
    return c = c !== -1 ? c : t.length, n.lastIndex = c, bw(t.slice(0, c), e);
  }(), i = t[0] === `
` || t[0] === " ", s, o; o = n.exec(t); ) {
    var l = o[1], a = o[2];
    s = a[0] === " ", r += l + (!i && !s && a !== "" ? `
` : "") + bw(a, e), i = s;
  }
  return r;
}
function bw(t, e) {
  if (t === "" || t[0] === " ")
    return t;
  for (var n = / [^ ]/g, r, i = 0, s, o = 0, l = 0, a = ""; r = n.exec(t); )
    l = r.index, l - i > e && (s = o > i ? o : l, a += `
` + t.slice(i, s), i = s + 1), o = l;
  return a += `
`, t.length - i > e && o > i ? a += t.slice(i, o) + `
` + t.slice(o + 1) : a += t.slice(i), a.slice(1);
}
function I_e(t) {
  for (var e = "", n = 0, r, i = 0; i < t.length; n >= 65536 ? i += 2 : i++)
    n = Qo(t, i), r = mt[n], !r && Rl(n) ? (e += t[i], n >= 65536 && (e += t[i + 1])) : e += r || $_e(n);
  return e;
}
function L_e(t, e, n) {
  var r = "", i = t.tag, s, o, l;
  for (s = 0, o = n.length; s < o; s += 1)
    l = n[s], t.replacer && (l = t.replacer.call(n, String(s), l)), (gr(t, e, l, !1, !1) || typeof l > "u" && gr(t, e, null, !1, !1)) && (r !== "" && (r += "," + (t.condenseFlow ? "" : " ")), r += t.dump);
  t.tag = i, t.dump = "[" + r + "]";
}
function yw(t, e, n, r) {
  var i = "", s = t.tag, o, l, a;
  for (o = 0, l = n.length; o < l; o += 1)
    a = n[o], t.replacer && (a = t.replacer.call(n, String(o), a)), (gr(t, e + 1, a, !0, !0, !1, !0) || typeof a > "u" && gr(t, e + 1, null, !0, !0, !1, !0)) && ((!r || i !== "") && (i += Up(t, e)), t.dump && Dl === t.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t.dump);
  t.tag = s, t.dump = i || "[]";
}
function N_e(t, e, n) {
  var r = "", i = t.tag, s = Object.keys(n), o, l, a, c, h;
  for (o = 0, l = s.length; o < l; o += 1)
    h = "", r !== "" && (h += ", "), t.condenseFlow && (h += '"'), a = s[o], c = n[a], t.replacer && (c = t.replacer.call(n, a, c)), gr(t, e, a, !1, !1) && (t.dump.length > 1024 && (h += "? "), h += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), gr(t, e, c, !1, !1) && (h += t.dump, r += h));
  t.tag = i, t.dump = "{" + r + "}";
}
function q_e(t, e, n, r) {
  var i = "", s = t.tag, o = Object.keys(n), l, a, c, h, u, f;
  if (t.sortKeys === !0)
    o.sort();
  else if (typeof t.sortKeys == "function")
    o.sort(t.sortKeys);
  else if (t.sortKeys)
    throw new bt("sortKeys must be a boolean or a function");
  for (l = 0, a = o.length; l < a; l += 1)
    f = "", (!r || i !== "") && (f += Up(t, e)), c = o[l], h = n[c], t.replacer && (h = t.replacer.call(n, c, h)), gr(t, e + 1, c, !0, !0, !0) && (u = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, u && (t.dump && Dl === t.dump.charCodeAt(0) ? f += "?" : f += "? "), f += t.dump, u && (f += Up(t, e)), gr(t, e + 1, h, !0, u) && (t.dump && Dl === t.dump.charCodeAt(0) ? f += ":" : f += ": ", f += t.dump, i += f));
  t.tag = s, t.dump = i || "{}";
}
function ww(t, e, n) {
  var r, i, s, o, l, a;
  for (i = n ? t.explicitTypes : t.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (l = i[s], (l.instanceOf || l.predicate) && (!l.instanceOf || typeof e == "object" && e instanceof l.instanceOf) && (!l.predicate || l.predicate(e))) {
      if (n ? l.multi && l.representName ? t.tag = l.representName(e) : t.tag = l.tag : t.tag = "?", l.represent) {
        if (a = t.styleMap[l.tag] || l.defaultStyle, d$.call(l.represent) === "[object Function]")
          r = l.represent(e, a);
        else if (p$.call(l.represent, a))
          r = l.represent[a](e, a);
        else
          throw new bt("!<" + l.tag + '> tag resolver accepts not "' + a + '" style');
        t.dump = r;
      }
      return !0;
    }
  return !1;
}
function gr(t, e, n, r, i, s, o) {
  t.tag = null, t.dump = n, ww(t, n, !1) || ww(t, n, !0);
  var l = d$.call(t.dump), a = r, c;
  r && (r = t.flowLevel < 0 || t.flowLevel > e);
  var h = l === "[object Object]" || l === "[object Array]", u, f;
  if (h && (u = t.duplicates.indexOf(n), f = u !== -1), (t.tag !== null && t.tag !== "?" || f || t.indent !== 2 && e > 0) && (i = !1), f && t.usedDuplicates[u])
    t.dump = "*ref_" + u;
  else {
    if (h && f && !t.usedDuplicates[u] && (t.usedDuplicates[u] = !0), l === "[object Object]")
      r && Object.keys(t.dump).length !== 0 ? (q_e(t, e, t.dump, i), f && (t.dump = "&ref_" + u + t.dump)) : (N_e(t, e, t.dump), f && (t.dump = "&ref_" + u + " " + t.dump));
    else if (l === "[object Array]")
      r && t.dump.length !== 0 ? (t.noArrayIndent && !o && e > 0 ? yw(t, e - 1, t.dump, i) : yw(t, e, t.dump, i), f && (t.dump = "&ref_" + u + t.dump)) : (L_e(t, e, t.dump), f && (t.dump = "&ref_" + u + " " + t.dump));
    else if (l === "[object String]")
      t.tag !== "?" && R_e(t, t.dump, e, s, a);
    else {
      if (l === "[object Undefined]")
        return !1;
      if (t.skipInvalid)
        return !1;
      throw new bt("unacceptable kind of an object to dump " + l);
    }
    t.tag !== null && t.tag !== "?" && (c = encodeURI(
      t.tag[0] === "!" ? t.tag.slice(1) : t.tag
    ).replace(/!/g, "%21"), t.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", t.dump = c + " " + t.dump);
  }
  return !0;
}
function B_e(t, e) {
  var n = [], r = [], i, s;
  for (Gp(t, n, r), i = 0, s = r.length; i < s; i += 1)
    e.duplicates.push(n[r[i]]);
  e.usedDuplicates = new Array(s);
}
function Gp(t, e, n) {
  var r, i, s;
  if (t !== null && typeof t == "object")
    if (i = e.indexOf(t), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (e.push(t), Array.isArray(t))
      for (i = 0, s = t.length; i < s; i += 1)
        Gp(t[i], e, n);
    else
      for (r = Object.keys(t), i = 0, s = r.length; i < s; i += 1)
        Gp(t[r[i]], e, n);
}
function Y_e(t, e) {
  e = e || {};
  var n = new T_e(e);
  n.noRefs || B_e(t, n);
  var r = t;
  return n.replacer && (r = n.replacer.call({ "": r }, "", r)), gr(n, 0, r, !0, !0) ? n.dump + `
` : "";
}
var j_e = Y_e, X_e = {
  dump: j_e
};
function Um(t, e) {
  return function() {
    throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
var W_e = lt, z_e = NA, V_e = jA, U_e = UA, F_e = FA, G_e = Xm, H_e = f$.load, J_e = f$.loadAll, K_e = X_e.dump, eCe = bt, tCe = {
  binary: e$,
  float: VA,
  map: YA,
  null: XA,
  pairs: n$,
  set: r$,
  timestamp: JA,
  bool: WA,
  int: zA,
  merge: KA,
  omap: t$,
  seq: BA,
  str: qA
}, nCe = Um("safeLoad", "load"), rCe = Um("safeLoadAll", "loadAll"), iCe = Um("safeDump", "dump"), sCe = {
  Type: W_e,
  Schema: z_e,
  FAILSAFE_SCHEMA: V_e,
  JSON_SCHEMA: U_e,
  CORE_SCHEMA: F_e,
  DEFAULT_SCHEMA: G_e,
  load: H_e,
  loadAll: J_e,
  dump: K_e,
  YAMLException: eCe,
  types: tCe,
  safeLoad: nCe,
  safeLoadAll: rCe,
  safeDump: iCe
};
function oCe(t, e, n, r, i, s = !0) {
  const o = [];
  for (const a of [...t.core.ruler.__rules__].reverse()) {
    if (a.name === e) {
      s || o.push(a.name);
      break;
    }
    a.name && o.push(a.name);
  }
  t.core.ruler.disable(o);
  let l = [];
  try {
    l = t.parse(n, r);
  } finally {
    t.core.ruler.enable(o);
  }
  for (const a of l)
    a.map = a.map !== null ? [a.map[0] + i, a.map[1] + i] : a.map;
  return l;
}
class Zi {
  constructor(e) {
    this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !1, this.option_spec = {}, this.rawOptions = !1, this.state = e;
  }
  run(e) {
    return [];
  }
  assert(e, n) {
    if (!e)
      throw new Error(n);
  }
  assert_has_content(e) {
    if (!e.body)
      throw new Error("Content block expected, but none found.");
  }
  createToken(e, n, r, i) {
    const s = new this.state.Token(e, n, r);
    return (i == null ? void 0 : i.content) !== void 0 && (s.content = i.content), (i == null ? void 0 : i.level) !== void 0 && (s.level = i.level), (i == null ? void 0 : i.map) !== void 0 && (s.map = i.map), (i == null ? void 0 : i.block) !== void 0 && (s.block = i.block), (i == null ? void 0 : i.info) !== void 0 && (s.info = i.info), (i == null ? void 0 : i.meta) !== void 0 && (s.meta = i.meta), (i == null ? void 0 : i.children) !== void 0 && (s.children = i.children), s;
  }
  nestedParse(e, n) {
    return oCe(this.state.md, "run_directives", e, this.state.env, n, !0);
  }
}
class Er extends Error {
  constructor() {
    super(...arguments), this.name = "DirectiveParsingError";
  }
}
function lCe(t, e) {
  const n = t.meta.arg || "", r = t.content;
  let i = r.trim() ? r.split(/\r?\n/) : [], s = 0, o = {};
  (Object.keys(e.option_spec || {}) || e.rawOptions) && ([i, o, s] = S$(i, e));
  let l = [];
  if (!e.required_arguments && !e.optional_arguments ? n && (s = 0, i = [n].concat(i)) : l = aCe(n, e), i.length && !i[0].trim() && (i.shift(), s++), i.length && !e.has_content)
    throw new Er("Has content but content not allowed");
  return {
    map: t.map ? t.map : [0, 0],
    args: l,
    options: o,
    body: i.join(`
`),
    bodyMap: t.map ? [
      i.length > 0 ? t.map[0] + s : t.map[1],
      i.length > 0 ? t.map[1] - 1 : t.map[1]
    ] : [0, 0]
  };
}
function S$(t, e) {
  let n = 1, r = {}, i = null;
  if (t.length && t[0].startsWith("---")) {
    n++;
    const s = [];
    i = [];
    let o = !1;
    for (const l of t.slice(1)) {
      if (l.startsWith("---")) {
        n++, o = !0;
        continue;
      }
      o ? s.push(l) : (n++, i.push(l));
    }
    t = s;
  } else if (t.length && t[0].startsWith(":")) {
    const s = [];
    i = [];
    let o = !1;
    for (const l of t) {
      if (!o && !l.startsWith(":")) {
        o = !0, s.push(l);
        continue;
      }
      o ? s.push(l) : (n++, i.push(l.slice(1)));
    }
    t = s;
  }
  if (i !== null)
    try {
      const s = sCe.load(i.join(`
`));
      if (s !== null && typeof s == "object")
        r = s;
      else
        throw new Er(`not dict: ${s}`);
    } catch (s) {
      throw new Er(`Invalid options YAML: ${s}`);
    }
  if (e.rawOptions)
    return [t, r, n];
  for (const [s, o] of Object.entries(r)) {
    const l = e.option_spec ? e.option_spec[s] : null;
    if (!l)
      throw new Er(`Unknown option: ${s}`);
    let a = o;
    (o === null || o === !1) && (a = "");
    try {
      a = l(`${a || ""}`);
    } catch (c) {
      throw new Er(`Invalid option value: (option: '${s}'; value: ${o})
${c}`);
    }
    r[s] = a;
  }
  return [t, r, n];
}
function aCe(t, e) {
  var n;
  let r = t.trim() ? (n = t.trim()) === null || n === void 0 ? void 0 : n.split(/\s+/) : [];
  const i = (e.required_arguments || 0) + (e.optional_arguments || 0);
  if (r.length < (e.required_arguments || 0))
    throw new Er(`${e.required_arguments} argument(s) required, ${r.length} supplied`);
  if (r.length > i)
    if (e.final_argument_whitespace) {
      const s = t.split(/\s+/);
      r = s.splice(0, i - 1), r.push(s.join(" "));
    } else
      throw new Er(`maximum ${i} argument(s) allowed, ${r.length} supplied`);
  return r;
}
function cCe(t, e) {
  var n;
  let r = e.directivesAfter || "block";
  (!((n = e.replaceFences) !== null && n !== void 0) || n) && (t.core.ruler.after(r, "fence_to_directive", hCe), r = "fence_to_directive"), t.core.ruler.after(r, "run_directives", uCe(e.directives || {})), t.renderer.rules.directive = (i, s) => {
    const o = i[s];
    return `<aside class="directive-unhandled">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.content}</pre></aside>
`;
  }, t.renderer.rules.directive_error = (i, s) => {
    const o = i[s];
    let l = "";
    return o.content && (l = `
---
${o.content}`), `<aside class="directive-error">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.meta.error_name}:
${o.meta.error_message}
${l}</pre></aside>
`;
  };
}
function hCe(t) {
  for (const e of t.tokens)
    if (e.type === "fence" || e.type === "colon_fence") {
      const n = e.info.match(/^\{([^\s}]+)\}\s*(.*)$/);
      n && (e.type = "directive", e.info = n[1], e.meta = { arg: n[2] });
    }
  return !0;
}
function uCe(t) {
  function e(n) {
    const r = [];
    for (const i of n.tokens)
      if (i.type === "directive" && i.info in t)
        try {
          const s = new t[i.info](n), o = lCe(i, s), [l, a] = S$(i.content.trim() ? i.content.split(/\r?\n/) : [], s), c = new n.Token("parsed_directive_open", "", 1);
          c.info = i.info, c.hidden = !0, c.content = l.join(`
`).trim(), c.meta = {
            arg: i.meta.arg,
            opts: a
          };
          const h = [c];
          h.push(...s.run(o));
          const u = new n.Token("parsed_directive_close", "", -1);
          u.hidden = !0, h.push(u), h[1].meta = Object.assign(Object.assign({ directive: !0 }, o.options), h[1].meta), r.push(...h);
        } catch (s) {
          const o = new n.Token("directive_error", "", 0);
          o.content = i.content, o.info = i.info, o.meta = i.meta, o.map = i.map, o.meta.error_message = s.message, o.meta.error_name = s.name, r.push(o);
        }
      else
        r.push(i);
    return n.tokens = r, !0;
  }
  return e;
}
function fCe(t) {
  return t.toLowerCase().split(/\s+/).join("-").replace(/[^a-z0-9]+/, "-").replace(/^[-0-9]+|-+$/, "");
}
class Di extends Error {
  constructor() {
    super(...arguments), this.name = "OptionSpecError";
  }
}
const Ur = (t) => t, Hp = (t) => {
  if (!t)
    throw new Di("Argument required but none supplied");
  return t;
}, Jp = (t) => {
  if (t.trim())
    throw new Di(`No argument is allowed: "${t}" supplied`);
  return null;
}, ro = (t) => `${t || ""}`.split(/\s+/).map((e) => fCe(e));
function _$(t) {
  if (!t)
    throw new Di("Value is not set");
  const e = Number.parseFloat(t);
  if (Number.isNaN(e) || !Number.isInteger(e))
    throw new Di(`Value "${t}" is not an integer`);
  return e;
}
function _h(t) {
  const e = _$(t);
  if (e < 0)
    throw new Di(`Value "${t}" must be positive or zero`);
  return e;
}
const C$ = (t) => t ? _h(t) : null, dCe = (t) => (t = `${t || ""}`.replace(/\s+%$/, ""), _h(t));
function A$(t, e) {
  const r = new RegExp(`^(?<number>[0-9.]+)\\s*(?<units>${e.join("|")})$`).exec(t);
  if (!r || !r.groups)
    throw new Di(`not a positive measure of one of the following units: ${e.join("|")}`);
  return r.groups.number + r.groups.units;
}
const $$ = ["em", "ex", "px", "in", "cm", "mm", "pt", "pc"], P$ = (t) => A$(t, [...$$, ""]), Fm = (t, e = "") => {
  try {
    return A$(t, [...$$, "%"]);
  } catch {
    return P$(t) + e;
  }
}, pCe = (t, e = "") => t.toLowerCase() === "image" ? "image" : Fm(t, e);
function Gm(t) {
  return (e) => {
    if (e = e.toLowerCase().trim(), t.includes(e))
      return e;
    throw new Di(`must be in: ${t.join("|")}`);
  };
}
const gCe = (t) => t;
class Sn extends Zi {
  constructor() {
    super(...arguments), this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      class: ro,
      name: Ur
    }, this.title = "", this.kind = "";
  }
  run(e) {
    var n;
    const r = [], i = this.createToken("admonition_open", "aside", 1, {
      map: e.map,
      block: !0,
      meta: { kind: this.kind }
    });
    ((n = e.options.class) === null || n === void 0 ? void 0 : n.length) >= 1 ? (i.attrSet("class", e.options.class.join(" ")), i.attrJoin("class", "admonition")) : i.attrSet("class", "admonition"), this.kind && i.attrJoin("class", this.kind), r.push(i);
    const s = this.createToken("admonition_title_open", "header", 1);
    s.attrSet("class", "admonition-title"), r.push(s);
    const o = e.args[0] || this.title;
    r.push(this.createToken("inline", "", 0, {
      map: [e.map[0], e.map[0]],
      content: o,
      children: []
    })), r.push(this.createToken("admonition_title_close", "header", -1, { block: !0 }));
    const l = this.nestedParse(e.body, e.bodyMap[0]);
    return r.push(...l), r.push(this.createToken("admonition_close", "aside", -1, { block: !0 })), r;
  }
}
class mCe extends Sn {
  constructor() {
    super(...arguments), this.required_arguments = 1;
  }
}
class OCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Attention", this.kind = "attention";
  }
}
class bCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Caution", this.kind = "caution";
  }
}
class yCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Danger", this.kind = "danger";
  }
}
class wCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Error", this.kind = "error";
  }
}
class kCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Important", this.kind = "important";
  }
}
class xCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Hint", this.kind = "hint";
  }
}
class vCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Note", this.kind = "note";
  }
}
class SCe extends Sn {
  constructor() {
    super(...arguments), this.title = "See Also", this.kind = "seealso";
  }
}
class _Ce extends Sn {
  constructor() {
    super(...arguments), this.title = "Tip", this.kind = "tip";
  }
}
class CCe extends Sn {
  constructor() {
    super(...arguments), this.title = "Warning", this.kind = "warning";
  }
}
const ACe = {
  admonition: mCe,
  attention: OCe,
  caution: bCe,
  danger: yCe,
  error: wCe,
  important: kCe,
  hint: xCe,
  note: vCe,
  seealso: SCe,
  tip: _Ce,
  warning: CCe
};
class $Ce extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      "number-lines": C$,
      force: Jp,
      name: Ur,
      class: ro
    };
  }
  run(e) {
    return this.assert_has_content(e), [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
class PCe extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      linenos: Jp,
      "lineno-start": _$,
      dedent: C$,
      "emphasize-lines": Hp,
      caption: Hp,
      force: Jp,
      name: Ur,
      class: ro
    };
  }
  run(e) {
    return this.assert_has_content(e), [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
class TCe extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.rawOptions = !0;
  }
  run(e) {
    return [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
const QCe = {
  code: $Ce,
  "code-block": PCe,
  "code-cell": TCe
}, T$ = {
  alt: Ur,
  height: P$,
  width: Fm,
  scale: dCe,
  target: Hp,
  class: ro,
  name: Ur
};
class Q$ extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 1, this.optional_arguments = 0, this.final_argument_whitespace = !0, this.option_spec = Object.assign(Object.assign({}, T$), { align: Gm(["left", "center", "right", "top", "middle", "bottom"]) });
  }
  create_image(e) {
    const n = gCe(e.args[0] || ""), r = this.createToken("image", "img", 0, { map: e.map, block: !0 });
    r.attrSet("src", n), r.attrSet("alt", e.options.alt || "");
    const i = [];
    return e.options.alt && this.state.md.inline.parse(e.options.alt, this.state.md, this.state.env, i), r.children = i, e.options.height && r.attrSet("height", e.options.height), e.options.width && r.attrSet("width", e.options.width), e.options.align && r.attrJoin("class", `align-${e.options.align}`), e.options.class && r.attrJoin("class", e.options.class.join(" ")), r;
  }
  run(e) {
    return [this.create_image(e)];
  }
}
class ECe extends Q$ {
  constructor() {
    super(...arguments), this.option_spec = Object.assign(Object.assign({}, T$), { align: Gm(["left", "center", "right"]), figwidth: pCe, figclass: ro }), this.has_content = !0;
  }
  run(e) {
    const n = this.createToken("figure_open", "figure", 1, {
      map: e.map,
      block: !0
    });
    e.options.figclass && n.attrJoin("class", e.options.figclass.join(" ")), e.options.align && n.attrJoin("class", `align-${e.options.align}`), e.options.figwidth && e.options.figwidth !== "image" && n.attrSet("width", e.options.figwidth);
    let r;
    e.options.name && (r = RA(
      this.state,
      n,
      Ql.figure,
      e.options.name,
      e.body.trim()
    ), n.attrJoin("class", "numbered"));
    const i = this.create_image(e);
    i.map = [e.map[0], e.map[0]];
    let s = [], o = [];
    if (e.body) {
      const [a, ...c] = e.body.split(`

`), h = c.join(`

`), u = e.bodyMap[0], f = this.createToken("figure_caption_open", "figcaption", 1, {
        block: !0
      });
      r && f.attrSet("number", `${r.number}`);
      const d = this.nestedParse(a, u), p = this.createToken("figure_caption_close", "figcaption", -1, {
        block: !0
      });
      if (s = [f, ...d, p], h) {
        const g = u + a.split(`
`).length + 1, m = this.createToken("figure_legend_open", "", 1, {
          block: !0
        }), O = this.nestedParse(h, g), b = this.createToken("figure_legend_close", "", -1, {
          block: !0
        });
        o = [m, ...O, b];
      }
    }
    const l = this.createToken("figure_close", "figure", -1, { block: !0 });
    return [n, i, ...s, ...o, l];
  }
}
const DCe = {
  image: Q$,
  figure: ECe
};
class Hm {
  constructor(e, n = !0) {
    if (this.children = [], this.children = [], n) {
      this._set_children_from_tokens(e);
      return;
    }
    if (e.length === 0)
      throw new Error("Tree creation: Can only create root from empty token sequence.");
    if (e.length === 1) {
      const r = e[0];
      if (r.nesting)
        throw new Error("Unequal nesting level at the start and end of token stream.");
      this.token = r, r.children !== null && r.children.length > 0 && this._set_children_from_tokens(r.children);
    } else
      this.nester_tokens = { opening: e[0], closing: e[e.length - 1] }, this._set_children_from_tokens(e.slice(1, -1));
  }
  _set_children_from_tokens(e) {
    const n = [...e].reverse();
    let r;
    for (; n.length > 0 && (r = n.pop(), !!r); ) {
      if (!r.nesting) {
        this._add_child([r]);
        continue;
      }
      if (r.nesting !== 1)
        throw new Error("Invalid token nesting");
      const i = [r];
      let s = 1;
      for (; n.length > 0 && s !== 0; )
        r = n.pop(), r && (i.push(r), s += r.nesting);
      if (s)
        throw new Error(`unclosed tokens starting: ${i[0]}`);
      this._add_child(i);
    }
  }
  _add_child(e) {
    const n = new Hm(e, !1);
    n.parent = this, this.children.push(n);
  }
  to_tokens() {
    function e(r, i) {
      if (r.type === "root")
        for (const s of r.children)
          e(s, i);
      else if (r.token)
        i.push(r.token);
      else {
        if (!r.nester_tokens)
          throw new Error("No nested token available");
        i.push(r.nester_tokens.opening);
        for (const s of r.children)
          e(s, i);
        i.push(r.nester_tokens.closing);
      }
    }
    const n = [];
    return e(this, n), n;
  }
  get is_root() {
    return !(this.token || this.nester_tokens);
  }
  get is_nested() {
    return !!this.nester_tokens;
  }
  get siblings() {
    return this.parent ? this.parent.children : [this];
  }
  *walk(e = !0) {
    e && (yield this);
    for (const n of this.children)
      yield* n.walk(!0);
  }
  get type() {
    var e, n, r;
    if (this.is_root)
      return "root";
    if (this.token)
      return this.token.type;
    if (!((e = this.nester_tokens) === null || e === void 0) && e.opening.type.endsWith("_open"))
      return (n = this.nester_tokens) === null || n === void 0 ? void 0 : n.opening.type.slice(0, -5);
    if (this.nester_tokens)
      return (r = this.nester_tokens) === null || r === void 0 ? void 0 : r.opening.type;
    throw new Error("no internal token");
  }
  attribute_token() {
    if (this.token)
      return this.token;
    if (this.nester_tokens)
      return this.nester_tokens.opening;
    throw new Error("Tree node does not have the accessed attribute");
  }
  get tag() {
    return this.attribute_token().tag;
  }
  get level() {
    return this.attribute_token().level;
  }
  get content() {
    return this.attribute_token().content;
  }
  get markup() {
    return this.attribute_token().markup;
  }
  get info() {
    return this.attribute_token().info;
  }
  get meta() {
    return this.attribute_token().meta;
  }
  get block() {
    return this.attribute_token().block;
  }
  get hidden() {
    return this.attribute_token().hidden;
  }
  get map() {
    return this.attribute_token().map;
  }
  get attrs() {
    return this.attribute_token().attrs;
  }
}
class MCe extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      "header-rows": _h,
      "stub-columns": _h,
      width: Fm,
      widths: Ur,
      class: ro,
      name: Ur,
      align: Gm(["left", "center", "right"])
    };
  }
  run(e) {
    this.assert_has_content(e);
    const n = e.options["header-rows"] || 0, r = this.nestedParse(e.body, e.bodyMap[0]);
    if (r.length < 2 || r[0].type !== "bullet_list_open" || r[r.length - 1].type !== "bullet_list_close")
      throw new Er("Content is not a single bullet list");
    const i = [], s = this.createToken("table_open", "table", 1, { map: e.bodyMap });
    e.options.align && s.attrJoin("class", `align-${e.options.align}`), e.options.class && s.attrJoin("class", e.options.class.join(" ")), i.push(s), e.args.length && e.args[0] && (i.push(this.createToken("table_caption_open", "caption", 1)), i.push(this.createToken("inline", "", 0, {
      map: [e.map[0], e.map[0]],
      content: e.args[0],
      children: []
    })), i.push(this.createToken("table_caption_close", "caption", -1)));
    let o = "th";
    n ? (i.push(this.createToken("thead_open", "thead", 1, { level: 1 })), o = "th") : (i.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td");
    let l, a = 0;
    for (const c of new Hm(r.slice(1, -1)).children) {
      a += 1, this.assert(c.type === "list_item", `list item ${a} not of type 'list_item': ${c.type}`), this.assert(c.children.length === 1 && c.children[0].type === "bullet_list", `list item ${a} content not a nested bullet list`);
      const h = c.children[0].children;
      l === void 0 ? l = h.length : this.assert(h.length === l, `list item ${a} does not contain the same number of columns as previous items`), n && a === n + 1 && (i.push(this.createToken("thead_close", "thead", -1, { level: 1 })), i.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td"), i.push(this.createToken("tr_open", "tr", 1, { map: c.map, level: 2 }));
      for (const u of h)
        i.push(this.createToken(`${o}_open`, o, 1, { map: u.map, level: 3 })), i.push(...u.to_tokens().slice(1, -1)), i.push(this.createToken(`${o}_close`, o, -1, { level: 3 }));
      i.push(this.createToken("tr_close", "tr", -1, { level: 2 }));
    }
    if (n && a < n)
      throw new Error(`Insufficient rows (${a}) for required header rows (${n})`);
    return o === "td" ? i.push(this.createToken("tbody_close", "tbody", -1, { level: 1 })) : i.push(this.createToken("thead_close", "thead", -1, { level: 1 })), i.push(this.createToken("table_close", "table", -1)), i;
  }
}
const RCe = {
  "list-table": MCe
};
class ZCe extends Zi {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      label: Ur
    };
  }
  run(e) {
    this.assert_has_content(e);
    const n = this.createToken("math_block", "div", 0, {
      content: e.body,
      map: e.bodyMap,
      block: !0
    });
    if (n.attrSet("class", "math block"), e.options.label) {
      n.attrSet("id", e.options.label);
      const r = RA(this.state, n, Ql.equation, e.options.label, "");
      n.attrSet("number", `${r.number}`), n.info = e.options.label, n.meta = { label: e.options.label, numbered: !0, number: r.number };
    }
    return [n];
  }
}
const ICe = {
  math: ZCe
}, LCe = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, ACe), DCe), QCe), RCe), ICe);
function NCe(t) {
  return (e) => {
    const n = bu(e);
    return n.references.forEach((r) => {
      const { label: i, tokens: s, contentFromTarget: o } = r, l = (c, h) => (s.open.attrJoin("class", "error"), s.open.tag = s.close.tag = "code", o && h ? s.content.content = o(h) : s.content.content = c, !0), a = n.targets[i];
      if (!a)
        return l(i, {
          kind: r.kind || "",
          label: i,
          title: i,
          number: `"${i}"`
        });
      if (r.kind && a.kind !== r.kind)
        return l(`Reference "${i}" does not match kind "${r.kind}"`);
      s.open.attrSet("href", `#${a.label}`), a.title && s.open.attrSet("title", a.title), o && (s.content.content = o(a).trim());
    }), !0;
  };
}
function qCe(t, e) {
  t.core.ruler.push("docutils_number", NCe());
}
const BCe = {
  parseRoles: !0,
  replaceFences: !0,
  rolesAfter: "inline",
  directivesAfter: "block",
  directives: LCe,
  roles: Nve
};
function YCe(t, e) {
  const n = Object.assign(Object.assign({}, BCe), e);
  t.use(MA, n), t.use(cCe, n), t.use(qCe, n);
}
const E$ = "myst-editor/", jCe = (t) => sessionStorage.getItem(E$ + t), kw = (t, e) => sessionStorage.setItem(E$ + t, e), D$ = () => {
  for (var t in sessionStorage)
    t.startsWith("myst-editor") && sessionStorage.removeItem(t);
};
function XCe(t) {
  return new Promise((e) => {
    const n = new MutationObserver(() => {
      const r = document.getElementById(t);
      r && (n.disconnect(), e(r));
    });
    document.querySelectorAll("#myst-css-namespace").forEach((r) => n.observe(r, {
      childList: !0,
      subtree: !0
    }));
  });
}
const WCe = (t, e) => {
  const n = document.getElementById(t);
  n && (n.outerHTML = e);
}, zCe = (t) => {
  const e = document.getElementById(t);
  e && (e.outerHTML = e.innerHTML);
}, VCe = (t, e) => {
  const n = "placeholder-" + Math.random().toString().slice(2);
  return e.then(XCe(n)).then((r) => {
    kw(t, r), WCe(n, r);
  }).catch((r) => {
    console.error(r), zCe(n), kw(t, t);
  }), `<span id="${n}">${t}</span>`;
}, M$ = ({
  transform: t,
  target: e
}) => ({
  target: e,
  transform: (n) => {
    const r = jCe(n);
    if (r)
      return r;
    let i = t(n);
    return typeof i.then == "function" ? VCe(n, i) : i;
  }
}), UCe = (t, {
  transform: e,
  target: n
}) => t.replaceAll(n, e), FCe = (t) => (e) => {
  const n = e.renderer.rules.text;
  e.renderer.rules.text = function(...r) {
    const i = n(...r);
    return t.map(M$).reduce(UCe, i);
  };
}, R$ = "custom_role", GCe = ({
  target: t,
  transform: e
}) => ({
  name: t,
  role: class extends br {
    run({
      content: r
    }) {
      const i = new this.state.Token(R$, "span", 1);
      return i.content = e(r), [i];
    }
  }
}), HCe = (t) => t.map(M$).map(GCe).reduce((e, {
  name: n,
  role: r
}) => (e[n] = r, e), {}), JCe = (t) => (e) => {
  const n = HCe(t);
  e.renderer.rules[R$] = (r, i) => r[i].content, e.use(MA, {
    roles: n
  });
};
/*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */
function Ar(t) {
  return Ar = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ar(t);
}
function Kp(t, e) {
  return Kp = Object.setPrototypeOf || function(r, i) {
    return r.__proto__ = i, r;
  }, Kp(t, e);
}
function KCe() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Sc(t, e, n) {
  return KCe() ? Sc = Reflect.construct : Sc = function(i, s, o) {
    var l = [null];
    l.push.apply(l, s);
    var a = Function.bind.apply(i, l), c = new a();
    return o && Kp(c, o.prototype), c;
  }, Sc.apply(null, arguments);
}
function ln(t) {
  return eAe(t) || tAe(t) || nAe(t) || rAe();
}
function eAe(t) {
  if (Array.isArray(t))
    return eg(t);
}
function tAe(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function nAe(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return eg(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set")
      return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return eg(t, e);
  }
}
function eg(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++)
    r[n] = t[n];
  return r;
}
function rAe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var iAe = Object.hasOwnProperty, xw = Object.setPrototypeOf, sAe = Object.isFrozen, oAe = Object.getPrototypeOf, lAe = Object.getOwnPropertyDescriptor, kt = Object.freeze, bn = Object.seal, aAe = Object.create, Z$ = typeof Reflect < "u" && Reflect, Ch = Z$.apply, tg = Z$.construct;
Ch || (Ch = function(e, n, r) {
  return e.apply(n, r);
});
kt || (kt = function(e) {
  return e;
});
bn || (bn = function(e) {
  return e;
});
tg || (tg = function(e, n) {
  return Sc(e, ln(n));
});
var cAe = en(Array.prototype.forEach), vw = en(Array.prototype.pop), yo = en(Array.prototype.push), _c = en(String.prototype.toLowerCase), Gf = en(String.prototype.toString), hAe = en(String.prototype.match), on = en(String.prototype.replace), uAe = en(String.prototype.indexOf), fAe = en(String.prototype.trim), Ot = en(RegExp.prototype.test), Hf = dAe(TypeError);
function en(t) {
  return function(e) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
      r[i - 1] = arguments[i];
    return Ch(t, e, r);
  };
}
function dAe(t) {
  return function() {
    for (var e = arguments.length, n = new Array(e), r = 0; r < e; r++)
      n[r] = arguments[r];
    return tg(t, n);
  };
}
function te(t, e, n) {
  var r;
  n = (r = n) !== null && r !== void 0 ? r : _c, xw && xw(t, null);
  for (var i = e.length; i--; ) {
    var s = e[i];
    if (typeof s == "string") {
      var o = n(s);
      o !== s && (sAe(e) || (e[i] = o), s = o);
    }
    t[s] = !0;
  }
  return t;
}
function ri(t) {
  var e = aAe(null), n;
  for (n in t)
    Ch(iAe, t, [n]) === !0 && (e[n] = t[n]);
  return e;
}
function Fa(t, e) {
  for (; t !== null; ) {
    var n = lAe(t, e);
    if (n) {
      if (n.get)
        return en(n.get);
      if (typeof n.value == "function")
        return en(n.value);
    }
    t = oAe(t);
  }
  function r(i) {
    return console.warn("fallback value for", i), null;
  }
  return r;
}
var Sw = kt(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Jf = kt(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Kf = kt(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), pAe = kt(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), ed = kt(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), gAe = kt(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), _w = kt(["#text"]), Cw = kt(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), td = kt(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Aw = kt(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ga = kt(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), mAe = bn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), OAe = bn(/<%[\w\W]*|[\w\W]*%>/gm), bAe = bn(/\${[\w\W]*}/gm), yAe = bn(/^data-[\-\w.\u00B7-\uFFFF]/), wAe = bn(/^aria-[\-\w]+$/), kAe = bn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), xAe = bn(/^(?:\w+script|data):/i), vAe = bn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), SAe = bn(/^html$/i), _Ae = function() {
  return typeof window > "u" ? null : window;
}, CAe = function(e, n) {
  if (Ar(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var r = null, i = "data-tt-policy-suffix";
  n.currentScript && n.currentScript.hasAttribute(i) && (r = n.currentScript.getAttribute(i));
  var s = "dompurify" + (r ? "#" + r : "");
  try {
    return e.createPolicy(s, {
      createHTML: function(l) {
        return l;
      },
      createScriptURL: function(l) {
        return l;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function I$() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _Ae(), e = function(_) {
    return I$(_);
  };
  if (e.version = "2.4.7", e.removed = [], !t || !t.document || t.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var n = t.document, r = t.document, i = t.DocumentFragment, s = t.HTMLTemplateElement, o = t.Node, l = t.Element, a = t.NodeFilter, c = t.NamedNodeMap, h = c === void 0 ? t.NamedNodeMap || t.MozNamedAttrMap : c, u = t.HTMLFormElement, f = t.DOMParser, d = t.trustedTypes, p = l.prototype, g = Fa(p, "cloneNode"), m = Fa(p, "nextSibling"), O = Fa(p, "childNodes"), b = Fa(p, "parentNode");
  if (typeof s == "function") {
    var y = r.createElement("template");
    y.content && y.content.ownerDocument && (r = y.content.ownerDocument);
  }
  var w = CAe(d, n), S = w ? w.createHTML("") : "", x = r, v = x.implementation, P = x.createNodeIterator, D = x.createDocumentFragment, Q = x.getElementsByTagName, R = n.importNode, N = {};
  try {
    N = ri(r).documentMode ? r.documentMode : {};
  } catch {
  }
  var F = {};
  e.isSupported = typeof b == "function" && v && v.createHTMLDocument !== void 0 && N !== 9;
  var A = mAe, z = OAe, V = bAe, ie = yAe, ae = wAe, Te = xAe, Oe = vAe, ge = kAe, se = null, xt = te({}, [].concat(ln(Sw), ln(Jf), ln(Kf), ln(ed), ln(_w))), fe = null, Qt = te({}, [].concat(ln(Cw), ln(td), ln(Aw), ln(Ga))), me = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Bt = null, rn = null, Ii = !0, yr = !0, sn = !1, Km = !0, Li = !1, Jr = !1, wu = !1, ku = !1, Ni = !1, ta = !1, na = !1, eO = !0, tO = !1, X$ = "user-content-", xu = !0, so = !1, qi = {}, Bi = null, nO = te({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), rO = null, iO = te({}, ["audio", "video", "img", "source", "image", "track"]), vu = null, sO = te({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ra = "http://www.w3.org/1998/Math/MathML", ia = "http://www.w3.org/2000/svg", Jn = "http://www.w3.org/1999/xhtml", Yi = Jn, Su = !1, _u = null, W$ = te({}, [ra, ia, Jn], Gf), Kr, z$ = ["application/xhtml+xml", "text/html"], V$ = "text/html", Fe, ji = null, U$ = r.createElement("form"), oO = function(_) {
    return _ instanceof RegExp || _ instanceof Function;
  }, Cu = function(_) {
    ji && ji === _ || ((!_ || Ar(_) !== "object") && (_ = {}), _ = ri(_), Kr = z$.indexOf(_.PARSER_MEDIA_TYPE) === -1 ? Kr = V$ : Kr = _.PARSER_MEDIA_TYPE, Fe = Kr === "application/xhtml+xml" ? Gf : _c, se = "ALLOWED_TAGS" in _ ? te({}, _.ALLOWED_TAGS, Fe) : xt, fe = "ALLOWED_ATTR" in _ ? te({}, _.ALLOWED_ATTR, Fe) : Qt, _u = "ALLOWED_NAMESPACES" in _ ? te({}, _.ALLOWED_NAMESPACES, Gf) : W$, vu = "ADD_URI_SAFE_ATTR" in _ ? te(
      ri(sO),
      _.ADD_URI_SAFE_ATTR,
      Fe
    ) : sO, rO = "ADD_DATA_URI_TAGS" in _ ? te(
      ri(iO),
      _.ADD_DATA_URI_TAGS,
      Fe
    ) : iO, Bi = "FORBID_CONTENTS" in _ ? te({}, _.FORBID_CONTENTS, Fe) : nO, Bt = "FORBID_TAGS" in _ ? te({}, _.FORBID_TAGS, Fe) : {}, rn = "FORBID_ATTR" in _ ? te({}, _.FORBID_ATTR, Fe) : {}, qi = "USE_PROFILES" in _ ? _.USE_PROFILES : !1, Ii = _.ALLOW_ARIA_ATTR !== !1, yr = _.ALLOW_DATA_ATTR !== !1, sn = _.ALLOW_UNKNOWN_PROTOCOLS || !1, Km = _.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Li = _.SAFE_FOR_TEMPLATES || !1, Jr = _.WHOLE_DOCUMENT || !1, Ni = _.RETURN_DOM || !1, ta = _.RETURN_DOM_FRAGMENT || !1, na = _.RETURN_TRUSTED_TYPE || !1, ku = _.FORCE_BODY || !1, eO = _.SANITIZE_DOM !== !1, tO = _.SANITIZE_NAMED_PROPS || !1, xu = _.KEEP_CONTENT !== !1, so = _.IN_PLACE || !1, ge = _.ALLOWED_URI_REGEXP || ge, Yi = _.NAMESPACE || Jn, me = _.CUSTOM_ELEMENT_HANDLING || {}, _.CUSTOM_ELEMENT_HANDLING && oO(_.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (me.tagNameCheck = _.CUSTOM_ELEMENT_HANDLING.tagNameCheck), _.CUSTOM_ELEMENT_HANDLING && oO(_.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (me.attributeNameCheck = _.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), _.CUSTOM_ELEMENT_HANDLING && typeof _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (me.allowCustomizedBuiltInElements = _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Li && (yr = !1), ta && (Ni = !0), qi && (se = te({}, ln(_w)), fe = [], qi.html === !0 && (te(se, Sw), te(fe, Cw)), qi.svg === !0 && (te(se, Jf), te(fe, td), te(fe, Ga)), qi.svgFilters === !0 && (te(se, Kf), te(fe, td), te(fe, Ga)), qi.mathMl === !0 && (te(se, ed), te(fe, Aw), te(fe, Ga))), _.ADD_TAGS && (se === xt && (se = ri(se)), te(se, _.ADD_TAGS, Fe)), _.ADD_ATTR && (fe === Qt && (fe = ri(fe)), te(fe, _.ADD_ATTR, Fe)), _.ADD_URI_SAFE_ATTR && te(vu, _.ADD_URI_SAFE_ATTR, Fe), _.FORBID_CONTENTS && (Bi === nO && (Bi = ri(Bi)), te(Bi, _.FORBID_CONTENTS, Fe)), xu && (se["#text"] = !0), Jr && te(se, ["html", "head", "body"]), se.table && (te(se, ["tbody"]), delete Bt.tbody), kt && kt(_), ji = _);
  }, lO = te({}, ["mi", "mo", "mn", "ms", "mtext"]), aO = te({}, ["foreignobject", "desc", "title", "annotation-xml"]), F$ = te({}, ["title", "style", "font", "a", "script"]), sa = te({}, Jf);
  te(sa, Kf), te(sa, pAe);
  var Au = te({}, ed);
  te(Au, gAe);
  var G$ = function(_) {
    var $ = b(_);
    (!$ || !$.tagName) && ($ = {
      namespaceURI: Yi,
      tagName: "template"
    });
    var Z = _c(_.tagName), ce = _c($.tagName);
    return _u[_.namespaceURI] ? _.namespaceURI === ia ? $.namespaceURI === Jn ? Z === "svg" : $.namespaceURI === ra ? Z === "svg" && (ce === "annotation-xml" || lO[ce]) : Boolean(sa[Z]) : _.namespaceURI === ra ? $.namespaceURI === Jn ? Z === "math" : $.namespaceURI === ia ? Z === "math" && aO[ce] : Boolean(Au[Z]) : _.namespaceURI === Jn ? $.namespaceURI === ia && !aO[ce] || $.namespaceURI === ra && !lO[ce] ? !1 : !Au[Z] && (F$[Z] || !sa[Z]) : !!(Kr === "application/xhtml+xml" && _u[_.namespaceURI]) : !1;
  }, Kn = function(_) {
    yo(e.removed, {
      element: _
    });
    try {
      _.parentNode.removeChild(_);
    } catch {
      try {
        _.outerHTML = S;
      } catch {
        _.remove();
      }
    }
  }, $u = function(_, $) {
    try {
      yo(e.removed, {
        attribute: $.getAttributeNode(_),
        from: $
      });
    } catch {
      yo(e.removed, {
        attribute: null,
        from: $
      });
    }
    if ($.removeAttribute(_), _ === "is" && !fe[_])
      if (Ni || ta)
        try {
          Kn($);
        } catch {
        }
      else
        try {
          $.setAttribute(_, "");
        } catch {
        }
  }, cO = function(_) {
    var $, Z;
    if (ku)
      _ = "<remove></remove>" + _;
    else {
      var ce = hAe(_, /^[\r\n\t ]+/);
      Z = ce && ce[0];
    }
    Kr === "application/xhtml+xml" && Yi === Jn && (_ = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + _ + "</body></html>");
    var vt = w ? w.createHTML(_) : _;
    if (Yi === Jn)
      try {
        $ = new f().parseFromString(vt, Kr);
      } catch {
      }
    if (!$ || !$.documentElement) {
      $ = v.createDocument(Yi, "template", null);
      try {
        $.documentElement.innerHTML = Su ? S : vt;
      } catch {
      }
    }
    var at = $.body || $.documentElement;
    return _ && Z && at.insertBefore(r.createTextNode(Z), at.childNodes[0] || null), Yi === Jn ? Q.call($, Jr ? "html" : "body")[0] : Jr ? $.documentElement : at;
  }, hO = function(_) {
    return P.call(
      _.ownerDocument || _,
      _,
      a.SHOW_ELEMENT | a.SHOW_COMMENT | a.SHOW_TEXT,
      null,
      !1
    );
  }, H$ = function(_) {
    return _ instanceof u && (typeof _.nodeName != "string" || typeof _.textContent != "string" || typeof _.removeChild != "function" || !(_.attributes instanceof h) || typeof _.removeAttribute != "function" || typeof _.setAttribute != "function" || typeof _.namespaceURI != "string" || typeof _.insertBefore != "function" || typeof _.hasChildNodes != "function");
  }, oo = function(_) {
    return Ar(o) === "object" ? _ instanceof o : _ && Ar(_) === "object" && typeof _.nodeType == "number" && typeof _.nodeName == "string";
  }, er = function(_, $, Z) {
    !F[_] || cAe(F[_], function(ce) {
      ce.call(e, $, Z, ji);
    });
  }, uO = function(_) {
    var $;
    if (er("beforeSanitizeElements", _, null), H$(_) || Ot(/[\u0080-\uFFFF]/, _.nodeName))
      return Kn(_), !0;
    var Z = Fe(_.nodeName);
    if (er("uponSanitizeElement", _, {
      tagName: Z,
      allowedTags: se
    }), _.hasChildNodes() && !oo(_.firstElementChild) && (!oo(_.content) || !oo(_.content.firstElementChild)) && Ot(/<[/\w]/g, _.innerHTML) && Ot(/<[/\w]/g, _.textContent) || Z === "select" && Ot(/<template/i, _.innerHTML))
      return Kn(_), !0;
    if (!se[Z] || Bt[Z]) {
      if (!Bt[Z] && dO(Z) && (me.tagNameCheck instanceof RegExp && Ot(me.tagNameCheck, Z) || me.tagNameCheck instanceof Function && me.tagNameCheck(Z)))
        return !1;
      if (xu && !Bi[Z]) {
        var ce = b(_) || _.parentNode, vt = O(_) || _.childNodes;
        if (vt && ce)
          for (var at = vt.length, tt = at - 1; tt >= 0; --tt)
            ce.insertBefore(g(vt[tt], !0), m(_));
      }
      return Kn(_), !0;
    }
    return _ instanceof l && !G$(_) || (Z === "noscript" || Z === "noembed" || Z === "noframes") && Ot(/<\/no(script|embed|frames)/i, _.innerHTML) ? (Kn(_), !0) : (Li && _.nodeType === 3 && ($ = _.textContent, $ = on($, A, " "), $ = on($, z, " "), $ = on($, V, " "), _.textContent !== $ && (yo(e.removed, {
      element: _.cloneNode()
    }), _.textContent = $)), er("afterSanitizeElements", _, null), !1);
  }, fO = function(_, $, Z) {
    if (eO && ($ === "id" || $ === "name") && (Z in r || Z in U$))
      return !1;
    if (!(yr && !rn[$] && Ot(ie, $))) {
      if (!(Ii && Ot(ae, $))) {
        if (!fe[$] || rn[$]) {
          if (!(dO(_) && (me.tagNameCheck instanceof RegExp && Ot(me.tagNameCheck, _) || me.tagNameCheck instanceof Function && me.tagNameCheck(_)) && (me.attributeNameCheck instanceof RegExp && Ot(me.attributeNameCheck, $) || me.attributeNameCheck instanceof Function && me.attributeNameCheck($)) || $ === "is" && me.allowCustomizedBuiltInElements && (me.tagNameCheck instanceof RegExp && Ot(me.tagNameCheck, Z) || me.tagNameCheck instanceof Function && me.tagNameCheck(Z))))
            return !1;
        } else if (!vu[$]) {
          if (!Ot(ge, on(Z, Oe, ""))) {
            if (!(($ === "src" || $ === "xlink:href" || $ === "href") && _ !== "script" && uAe(Z, "data:") === 0 && rO[_])) {
              if (!(sn && !Ot(Te, on(Z, Oe, "")))) {
                if (Z)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, dO = function(_) {
    return _.indexOf("-") > 0;
  }, pO = function(_) {
    var $, Z, ce, vt;
    er("beforeSanitizeAttributes", _, null);
    var at = _.attributes;
    if (!!at) {
      var tt = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: fe
      };
      for (vt = at.length; vt--; ) {
        $ = at[vt];
        var oa = $, Ge = oa.name, Pu = oa.namespaceURI;
        if (Z = Ge === "value" ? $.value : fAe($.value), ce = Fe(Ge), tt.attrName = ce, tt.attrValue = Z, tt.keepAttr = !0, tt.forceKeepAttr = void 0, er("uponSanitizeAttribute", _, tt), Z = tt.attrValue, !tt.forceKeepAttr && ($u(Ge, _), !!tt.keepAttr)) {
          if (!Km && Ot(/\/>/i, Z)) {
            $u(Ge, _);
            continue;
          }
          Li && (Z = on(Z, A, " "), Z = on(Z, z, " "), Z = on(Z, V, " "));
          var gO = Fe(_.nodeName);
          if (!!fO(gO, ce, Z)) {
            if (tO && (ce === "id" || ce === "name") && ($u(Ge, _), Z = X$ + Z), w && Ar(d) === "object" && typeof d.getAttributeType == "function" && !Pu)
              switch (d.getAttributeType(gO, ce)) {
                case "TrustedHTML": {
                  Z = w.createHTML(Z);
                  break;
                }
                case "TrustedScriptURL": {
                  Z = w.createScriptURL(Z);
                  break;
                }
              }
            try {
              Pu ? _.setAttributeNS(Pu, Ge, Z) : _.setAttribute(Ge, Z), vw(e.removed);
            } catch {
            }
          }
        }
      }
      er("afterSanitizeAttributes", _, null);
    }
  }, J$ = function X(_) {
    var $, Z = hO(_);
    for (er("beforeSanitizeShadowDOM", _, null); $ = Z.nextNode(); )
      er("uponSanitizeShadowNode", $, null), !uO($) && ($.content instanceof i && X($.content), pO($));
    er("afterSanitizeShadowDOM", _, null);
  };
  return e.sanitize = function(X) {
    var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $, Z, ce, vt, at;
    if (Su = !X, Su && (X = "<!-->"), typeof X != "string" && !oo(X))
      if (typeof X.toString == "function") {
        if (X = X.toString(), typeof X != "string")
          throw Hf("dirty is not a string, aborting");
      } else
        throw Hf("toString is not a function");
    if (!e.isSupported) {
      if (Ar(t.toStaticHTML) === "object" || typeof t.toStaticHTML == "function") {
        if (typeof X == "string")
          return t.toStaticHTML(X);
        if (oo(X))
          return t.toStaticHTML(X.outerHTML);
      }
      return X;
    }
    if (wu || Cu(_), e.removed = [], typeof X == "string" && (so = !1), so) {
      if (X.nodeName) {
        var tt = Fe(X.nodeName);
        if (!se[tt] || Bt[tt])
          throw Hf("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (X instanceof o)
      $ = cO("<!---->"), Z = $.ownerDocument.importNode(X, !0), Z.nodeType === 1 && Z.nodeName === "BODY" || Z.nodeName === "HTML" ? $ = Z : $.appendChild(Z);
    else {
      if (!Ni && !Li && !Jr && X.indexOf("<") === -1)
        return w && na ? w.createHTML(X) : X;
      if ($ = cO(X), !$)
        return Ni ? null : na ? S : "";
    }
    $ && ku && Kn($.firstChild);
    for (var oa = hO(so ? X : $); ce = oa.nextNode(); )
      ce.nodeType === 3 && ce === vt || uO(ce) || (ce.content instanceof i && J$(ce.content), pO(ce), vt = ce);
    if (vt = null, so)
      return X;
    if (Ni) {
      if (ta)
        for (at = D.call($.ownerDocument); $.firstChild; )
          at.appendChild($.firstChild);
      else
        at = $;
      return (fe.shadowroot || fe.shadowrootmod) && (at = R.call(n, at, !0)), at;
    }
    var Ge = Jr ? $.outerHTML : $.innerHTML;
    return Jr && se["!doctype"] && $.ownerDocument && $.ownerDocument.doctype && $.ownerDocument.doctype.name && Ot(SAe, $.ownerDocument.doctype.name) && (Ge = "<!DOCTYPE " + $.ownerDocument.doctype.name + `>
` + Ge), Li && (Ge = on(Ge, A, " "), Ge = on(Ge, z, " "), Ge = on(Ge, V, " ")), w && na ? w.createHTML(Ge) : Ge;
  }, e.setConfig = function(X) {
    Cu(X), wu = !0;
  }, e.clearConfig = function() {
    ji = null, wu = !1;
  }, e.isValidAttribute = function(X, _, $) {
    ji || Cu({});
    var Z = Fe(X), ce = Fe(_);
    return fO(Z, ce, $);
  }, e.addHook = function(X, _) {
    typeof _ == "function" && (F[X] = F[X] || [], yo(F[X], _));
  }, e.removeHook = function(X) {
    if (F[X])
      return vw(F[X]);
  }, e.removeHooks = function(X) {
    F[X] && (F[X] = []);
  }, e.removeAllHooks = function() {
    F = {};
  }, e;
}
var L$ = I$(), N$ = { exports: {} };
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
(function(t) {
  (function() {
    var e;
    function n(r, i) {
      var s = this instanceof n ? this : e;
      if (s.reset(i), typeof r == "string" && r.length > 0 && s.hash(r), s !== this)
        return s;
    }
    n.prototype.hash = function(r) {
      var i, s, o, l, a;
      switch (a = r.length, this.len += a, s = this.k1, o = 0, this.rem) {
        case 0:
          s ^= a > o ? r.charCodeAt(o++) & 65535 : 0;
        case 1:
          s ^= a > o ? (r.charCodeAt(o++) & 65535) << 8 : 0;
        case 2:
          s ^= a > o ? (r.charCodeAt(o++) & 65535) << 16 : 0;
        case 3:
          s ^= a > o ? (r.charCodeAt(o) & 255) << 24 : 0, s ^= a > o ? (r.charCodeAt(o++) & 65280) >> 8 : 0;
      }
      if (this.rem = a + this.rem & 3, a -= this.rem, a > 0) {
        for (i = this.h1; s = s * 11601 + (s & 65535) * 3432906752 & 4294967295, s = s << 15 | s >>> 17, s = s * 13715 + (s & 65535) * 461832192 & 4294967295, i ^= s, i = i << 13 | i >>> 19, i = i * 5 + 3864292196 & 4294967295, !(o >= a); )
          s = r.charCodeAt(o++) & 65535 ^ (r.charCodeAt(o++) & 65535) << 8 ^ (r.charCodeAt(o++) & 65535) << 16, l = r.charCodeAt(o++), s ^= (l & 255) << 24 ^ (l & 65280) >> 8;
        switch (s = 0, this.rem) {
          case 3:
            s ^= (r.charCodeAt(o + 2) & 65535) << 16;
          case 2:
            s ^= (r.charCodeAt(o + 1) & 65535) << 8;
          case 1:
            s ^= r.charCodeAt(o) & 65535;
        }
        this.h1 = i;
      }
      return this.k1 = s, this;
    }, n.prototype.result = function() {
      var r, i;
      return r = this.k1, i = this.h1, r > 0 && (r = r * 11601 + (r & 65535) * 3432906752 & 4294967295, r = r << 15 | r >>> 17, r = r * 13715 + (r & 65535) * 461832192 & 4294967295, i ^= r), i ^= this.len, i ^= i >>> 16, i = i * 51819 + (i & 65535) * 2246770688 & 4294967295, i ^= i >>> 13, i = i * 44597 + (i & 65535) * 3266445312 & 4294967295, i ^= i >>> 16, i >>> 0;
    }, n.prototype.reset = function(r) {
      return this.h1 = typeof r == "number" ? r : 0, this.rem = this.k1 = this.len = 0, this;
    }, e = new n(), t.exports = n;
  })();
})(N$);
const AAe = N$.exports, $Ae = (t, e) => ((t == null ? void 0 : t.match(e)) || []).length, PAe = (t) => () => {
  window.myst_editor || (window.myst_editor = {}), window.myst_editor.text = t;
}, TAe = (t) => {
  const e = (n) => {
    n.clipboardData.setData("text/html", t), n.clipboardData.setData("text/plain", t), n.preventDefault();
  };
  document.addEventListener("copy", e), document.execCommand("copy"), document.removeEventListener("copy", e);
}, QAe = ({
  initialText: t,
  transforms: e,
  customRoles: n,
  preview: r
}) => {
  const [i, s] = Ee(t), [o, l] = Ee(!1), [a, c] = Ee(!1), [h, u] = Ee({
    action: (m) => {
    }
  }), [f, d] = $h((m, {
    newMarkdown: O,
    force: b = !1
  }) => {
    let y = {};
    b || (y = m.reduce((S, {
      hash: x,
      html: v
    }) => (S[x] = v, S), {}));
    const w = g(O, y);
    return w.length !== m.length || b ? (r.current.innerHTML = w.map((S) => `<html-chunk id="html-chunk-${S.id}">` + S.html + "</html-chunk>").join(`
`), w) : (w.filter((S, x) => S.hash !== m[x].hash).forEach((S) => r.current.querySelector("html-chunk#html-chunk-" + S.id).innerHTML = S.html), w);
  }, []), p = Le(() => xve({
    breaks: !0,
    linkify: !0
  }).use(YCe).use(FCe(e)).use(JCe(n)), []), g = ig((m, O = {}) => m.split(/(?=\n#{1,3} )/g).reduce(
    (b, y) => {
      const w = b.length - 1, S = b[w];
      return $Ae(S, /\n```/g) % 2 != 0 ? b[w] = S + y : b.push(y), b;
    },
    []
  ).map((b, y) => {
    const w = new AAe(b, 42).result(), S = O[w] || L$.sanitize(p.render(b));
    return {
      md: b,
      hash: w,
      id: y,
      html: S
    };
  }), [p]);
  return Ke(() => o && d({
    newMarkdown: i
  }), [o]), Ke(PAe(i), [i]), Ke(() => {
    a && (h.action(i), c(!1));
  }, [a]), {
    set(m) {
      s(m), setTimeout(() => {
        try {
          d({
            newMarkdown: m
          });
        } catch (O) {
          console.warn(O), d({
            newMarkdown: m,
            force: !0
          });
        }
      });
    },
    get() {
      return i;
    },
    sync() {
      c(!0);
    },
    refresh() {
      d({
        newMarkdown: window.myst_editor.text,
        force: !0
      });
    },
    onSync(m) {
      u({
        action: m
      });
    },
    readyToRender() {
      l(!0);
    },
    copy() {
      TAe(g(window.myst_editor.text).map((m) => m.html).join(`
`));
    }
  };
}, io = H.button`
  &:focus {
    outline: 0 !important;
  }

  cursor: pointer;
  color: var(--icon-color);
  text-transform: uppercase;
  font-size: 12px;
  font-weight: bold;
  border: 1px solid var(--icon-border);
  background-color: var(--icon-bg);
  height: 40px;
  display: flex;
  justify-content: center;
  margin-top: 0px;
  align-items: center;
  padding: 0;
  transition: 0.4s ease;
  border-radius: var(--border-radius);

  &:not(:has(svg)) {
    padding: 0px 15px;
    margin: 5px;
  }
`, EAe = H.div`
  display: flex;
  justify-content: flex-end;
  align-items: center;
`, DAe = H(io)`
  color: ${(t) => t.active ? "white" : "var(--icon-color)"};
  background-color: ${(t) => t.active ? "var(--icon-main-active)" : "var(--navbar-bg)"};
  width: 40px;
  border: "1px solid var(--icon-border)";
  border-left: none;
  border-radius: 0;

  &:hover {
    background-color: var(--icon-main-selected);
  }

  &:first-child {
    border-left: 1px solid var(--icon-border) !important;
    border-radius: var(--border-radius) 0 0 var(--border-radius);
    margin-left: 10px;
  }

  &:last-child {
    border-radius: 0 var(--border-radius) var(--border-radius) 0;
  }
`, MAe = ({
  buttons: t,
  initialClickedId: e = 2
}) => {
  const [n, r] = Ee(e);
  return Ke(() => {
    t[e].action();
  }, [e]), j` <${EAe}>
    ${t.map((i, s) => j` <${DAe}
          className="icon radio-icon"
          type="button"
          key=${i.id}
          name=${i.id}
          onClick=${() => {
    r(s), i.action();
  }}
          title=${i.tooltip}
          active=${s === n}
        >
          ${typeof i.icon == "function" ? j`<${i.icon} />` : j`<img src=${i.icon} />`}
        <//>`)}
  <//>`;
}, Ha = 4, q$ = H.div`
  width: 200px;

  .avatar {
    border-radius: 50%;
    margin-top: 5px;
    float: right;
    border: 3px solid;
    height: 35px;
    width: 35px;
    margin: 5px 0px 5px -7px;
    transition: 0.5s;

    &:hover {
      margin: 5px 0px 5px 0px;
    }

    &.placeholder {
      margin-left: -7px;
      line-height: 30px;
      color: var(--icon-color);
      border-color: var(--icon-border);
      font-style: normal;
      font-size: small;
      font-weight: 700;
      text-align: center;
      background-color: var(--icon-bg);
    }
  }
`, B$ = ({
  login: t,
  color: e,
  avatarUrl: n
}) => j` <img src=${n} key=${t} title=${t} class="avatar" style="border-color: ${e}" />`, RAe = ({
  n: t,
  usernames: e
}) => j` <${q$} title=${e}>
    <span class="avatar placeholder">+${t}</span>
  <//>`, ZAe = ({
  users: t
}) => j` <${q$}>
    ${t.length > Ha ? j`<${RAe}
          n=${t.length - Ha}
          usernames=${t.filter((e, n) => n >= Ha).map((e) => e.login).join(", ")}
        />` : ""}
    ${t.filter((e, n) => n < Ha).map((e) => j`<${B$} ...${e} />`)}
  <//>`, IAe = H.section`
  z-index: 2;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  width: 450px;
  padding: 20px;
  right: 50%;
  transform: translate(50%, 0);
  top: 100%;
  position: absolute;
  background-color: var(--icon-bg);
  border: 1px solid var(--icon-border);
  border-radius: var(--border-radius);
`, LAe = H.h3`
  color: var(--gray-900);
`, NAe = H.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
`, $w = H(io)`
  padding: 0 10px;
  margin-top: 0px;

  &:hover {
    background-color: ${(t) => t.$negative ? "var(--red-500)" : "var(--icon-main-active)"} !important;
    border: 1px solid ${(t) => t.$negative ? "var(--red-500)" : "var(--icon-main-active)"} !important;
  }
`, qAe = ({
  changeDocumentTemplate: t,
  selectedTemplate: e,
  closeModal: n
}) => j`
    <${IAe}>
      <${LAe}>Are you sure you want to change the current template?<//>
      <${NAe}>
        <${$w} type="button" onClick=${() => t(e)}> Yes<//>
        <${$w} $negative type="button" onClick=${n}>x Cancel<//>
      <//>
    <//>
  `, BAe = H.div`
  position: absolute;
  ${(t) => t.$orientation == "left" && Mo`
      left: 0;
    `}
  transform: ${(t) => t.$orientation == "left" ? "translateX(-105%)" : "translate(-65%, 130%)"};
`, YAe = H.div`
  position: relative;
  background: var(--alert);
  color: var(--icon-color);
  text-align: left;
  padding: 10px 20px 10px 20px;
  border-radius: var(--border-radius);
  border: solid var(--alert);
  border-width: 1px 1px 1px 1px;
  max-height: 40px;
  top: calc(100% + 11px);
  ${(t) => t.$orientation == "bottom" && Mo`
      left: 50%;
    `}
  transform: ${(t) => t.$orientation == "left" ? "none" : "translateX(calc(50% - 14px))"};

  &::before {
    content: "";
    position: absolute;
    ${(t) => t.$orientation == "left" ? Mo`
            right: 0;
            top: 50%;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            border-left: 30px solid var(--alert);
          ` : Mo`
            left: 50%;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 30px solid var(--alert);
          `}
    transform: ${(t) => t.$orientation == "left" ? "translate(50%, -50%)" : "translate(-50%, -100%)"};
  }
`, Pw = ({
  tooltipOrientation: t,
  errorMessage: e
}) => j` <${BAe} $orientation=${t}>
    <${YAe} $orientation=${t}> ${e} <//>
  <//>`, jAe = H.div`
  display: none;
  margin-left: 5px;
  margin-right: 5px;
  text-transform: uppercase;
  white-space: nowrap;
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius);
  color: var(--icon-color);
  background-color: var(--icon-bg);
  width: 210%;
  z-index: 20;
`, nd = () => j`<svg width="20" height="22" viewBox="0 0 20 22" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M5 16L11 16" stroke="#332D37" stroke-width="1.75" />
    <path d="M1 21H10H19V12V6.5L13.5 1H1V6.5V12V21Z" stroke="#332D37" stroke-width="1.75" stroke-dasharray="6 3" />
    <path d="M5 12L15 12" stroke="#332D37" stroke-width="1.75" />
    <path d="M5 8L15 8" stroke="#332D37" stroke-width="1.75" />
  </svg> `, Tw = H(io)`
  width: 90%;
  color: var(--icon-color);
  border: 1px solid var(--icon-border);
  padding: 0 10px 0 10px;
  margin-top: 0px;
  text-wrap: wrap;
`, XAe = H.div`
  position: relative;
  &:hover {
    div {
      display: inline-flex;
      flex-direction: column;
    }
  }
`, WAe = H.div`
  display: flex;
  flex-direction: row-reverse;
  border: 1px solid var(--gray-900);
  width: inherit;
`, zAe = H.div`
  position: absolute;
  width: 100%;
  padding-top: 5px;
`, VAe = (t) => {
  const e = ["id", "templatetext"];
  for (const n in t) {
    for (let r of e)
      t[n][r] || (t[n].errorMessage = `Configuration of template ${n} is lacking '${r}'`);
    t[n].errorMessage && console.error(t[n].errorMessage);
  }
  return t;
}, UAe = ({
  text: t,
  templatelist: e
}) => {
  const [n, r] = Ee(""), [i, s] = Ee({}), [o, l] = Ee(null), [a, c] = Ee(!1), [h, u] = Ee(!1), [f, d] = Ee({
    error: null,
    message: null
  }), p = (y) => y.ok ? y : Promise.reject(`Invalid HTTP response: ${y.status}`), g = (y) => {
    r(i[y].templatetext), t.set(i[y].templatetext), t.sync(), c(!1);
  }, m = (y) => fetch(y).then(p).then((w) => w.json().catch((S) => {
    console.error(S), d({
      error: S,
      message: "Template configuration is not valid"
    });
  })).catch((w) => {
    console.warn(w), d({
      error: w,
      message: "Template configuration not found"
    });
  }), O = (y) => fetch(y).then(p).then((w) => w.text()).catch((w) => {
    throw console.error(w), new Error("Could not fetch the template");
  }), b = async (y) => {
    if (!y)
      return {};
    for (const w in y) {
      const S = y[w].templatetext;
      await O(S).then((x) => y[w].templatetext = x).catch((x) => {
        var v, P;
        return (P = (v = y[w]).errorMessage) != null ? P : v.errorMessage = x.message;
      });
    }
    return y;
  };
  return Ke(() => m(e).then(VAe).then(b).then(s), []), f.error ? j` <${Cc}
        type="button"
        template=${n}
        onMouseEnter=${() => u(!0)}
        onMouseLeave=${() => u(!1)}
      >
        <${nd} />
      <//>
      <${h && Pw} tooltipOrientation="bottom" errorMessage=${f.message} />` : Object.keys(i).length == 0 ? j` <${Cc}
      type="button"
      title="Templates"
      template=${n}
      onMouseEnter=${() => u(!0)}
      onMouseLeave=${() => u(!1)}
    >
      <${nd} />
    <//>` : j`
    ${a && j`<${qAe}
      selectedTemplate=${o}
      closeModal=${() => {
    c(!1), l(!1);
  }}
      changeDocumentTemplate=${g}
    />`}
    <${XAe}>
      <${Cc} className="icon" title="Templates" type="button"><${nd} /><//>
      <${zAe}>
        <${jAe}>
          ${Object.keys(i).map((y) => j`
              ${i[y].errorMessage ? j`
                    <${WAe}>
                      <${h === y && Pw} tooltipOrientation="left" errorMessage="${i[y].errorMessage}" />
                      <${Tw} type="button" onMouseEnter=${() => u(y)} onMouseLeave=${() => u(!1)}
                        >${i[y].id}
                      <//>
                    <//>
                  ` : j`
                    <${Tw}
                      type="button"
                      onClick=${() => {
    c(!0), l(y);
  }}
                      >${i[y].id}
                    <//>
                  `}
            `)}
        <//>
      <//>
    <//>
  `;
}, FAe = (t) => [...t.matchAll(/\[(.+)\]\(([^\s]+)\)/g)].reduce((e, n) => e.replace(n[0], `<a href="${n[2]}">${n[1]}</a>`), t), GAe = H.div`
  z-index: 10;
  position: sticky;
  top: 0;
  display: flex;
  width: 100%;
  height: 60px;
  background-color: var(--navbar-bg);

  svg > path {
    stroke: var(--icon-color);
    &.inner-copy {
      transition: 0.4s ease;
      fill: var(--icon-bg);
    }
  }

  button:not(:disabled):not(view-menu):not(.radio-icon):hover {
    background-color: var(--icon-selected);
    border: 1px solid var(--icon-selected);
    .inner-copy {
      fill: var(--icon-selected);
    }
  }

  @media print {
    & {
      display: none;
    }
  }
`, HAe = H.div`
  font-size: large;
  white-space: nowrap;
  margin-left: 10px;

  a {
    color: var(--blue-500);
  }
`, JAe = H.div`
  width: 100%;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin-left: 5px;
`, KAe = H(io)`
  padding: 0px 15px;
  margin: 5px;
  pointer-events: none;
  background-color: var(--alert);
  border: none;
  width: fit-content;
`, e$e = H.div`
  width: 100%;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-right: 15px;

  button[active] {
    pointer-events: none;
  }
`, Cc = H(io)`
  color: ${(t) => t.active ? "white" : "var(--icon-color)"};
  border: ${(t) => t.active ? "1px solid var(--icon-main-active)" : "1px solid var(--icon-border)"};
  background-color: ${(t) => t.active ? "var(--icon-main-active)" : "var(--icon-bg)"};
  margin: 5px;
  width: 40px;
`, t$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 22 22" fill="none">
    <path d="M20.35 1.78003L12.61 9.51003" stroke-width="1.75" />
    <path d="M14.88 1.08008H20.89V7.27008" stroke-width="1.75" />
    <path d="M1.42999 20.3601L9.16999 12.6301" stroke-width="1.75" />
    <path d="M6.90002 21.0601H0.890015V14.8701" stroke-width="1.75" />
  </svg>`, n$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="23" height="23" viewBox="0 0 23 23" fill="none">
    <path d="M21.75 1V7.66H14.9" stroke-width="1.75" />
    <path
      d="M21.65 12.5899C20.95 17.4199 16.78 21.1399 11.75 21.1399C6.23 21.1399 1.75 16.6599 1.75 11.1399C1.75 5.61989 6.23 1.13989 11.75 1.13989C16.24 1.13989 20.03 4.09989 21.3 8.16989"
      stroke-width="1.75"
    />
  </svg>`, r$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="26" height="18" viewBox="0 0 26 18" fill="none">
    <path
      d="M13.01 11.5902C14.5675 11.5902 15.83 10.3276 15.83 8.7702C15.83 7.21275 14.5675 5.9502 13.01 5.9502C11.4526 5.9502 10.1899 7.21275 10.1899 8.7702C10.1899 10.3276 11.4526 11.5902 13.01 11.5902Z"
      stroke-width="1.75"
    />
    <path
      d="M23.4301 9.80018C23.4301 9.80018 13.75 24.5402 2.58997 9.80018L1.98999 8.95018L2.59998 8.10018C2.59998 8.10018 12.2799 -6.63982 23.4399 8.10018L24.01 8.90018L23.4301 9.80018Z"
      stroke-width="1.75"
    />
  </svg>`, i$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="21" height="15" viewBox="0 0 21 15" fill="none">
    <path d="M15.31 2.8501L19.56 7.1001L15.19 11.4801" stroke-width="1.75" />
    <path d="M5.75 11.4801L1.5 7.2201L5.88 2.8501" stroke-width="1.75" />
    <path d="M12.35 0.340088L8.72 13.9901" stroke-width="1.75" />
  </svg>`, s$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="20" height="22" viewBox="0 0 20 22" fill="none">
    <path d="M13.99 1.04004H1.37V16.64H13.99V1.04004Z" stroke-width="1.75" />
    <path class="inner-copy" d="M18.63 5.51001H6.01001V21.11H18.63V5.51001Z" stroke-width="1.75" />
  </svg>`, o$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="23" height="18" viewBox="0 0 23 18" fill="none">
    <path d="M21.84 1.65015H1.83997V16.6701H21.84V1.65015Z" stroke-width="1.75" />
    <path d="M11.84 1.83008V16.6701" stroke-width="1.75" />
  </svg>`, l$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="24" height="16" viewBox="0 0 24 16" fill="none">
    <path d="M21.23 11.0801H10.29" stroke-width="1.75" />
    <path d="M17.86 6.71997L22.11 10.97L17.73 15.35" stroke-width="1.75" />
    <path d="M2.22998 5.09009H13.17" stroke-width="1.75" />
    <path d="M5.60999 9.44007L1.35999 5.19007L5.73999 0.820068" stroke-width="1.75" />
  </svg>`, a$e = () => j`<svg width="21" height="22" viewBox="0 0 21 22" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path stroke-width="0.2" d="M21 12.4286V11H16.7143V18.1429H18.1429V15.2857H20.2857V13.8571H18.1429V12.4286H21Z" fill="#332D37" />
    <path
      stroke-width="0.2"
      d="M13.1428 18.1429H10.2857V11H13.1428C14.3571 11 15.2857 11.9286 15.2857 13.1429V16C15.2857 17.2143 14.3571 18.1429 13.1428 18.1429ZM11.7143 16.7143H13.1428C13.5714 16.7143 13.8571 16.4286 13.8571 16V13.1429C13.8571 12.7143 13.5714 12.4286 13.1428 12.4286H11.7143V16.7143Z"
      fill="#332D37"
    />
    <path
      stroke-width="0.2"
      d="M7.42855 11H3.85712V18.1429H5.28569V16H7.42855C8.21426 16 8.85712 15.3571 8.85712 14.5714V12.4286C8.85712 11.6429 8.21426 11 7.42855 11ZM5.28569 14.5714V12.4286H7.42855V14.5714H5.28569Z"
      fill="#332D37"
    />
    <path d="M14 21H9.5H1V1H9M15 10V7.5M9 1H9.5L15 6.5V7.5M9 1V7.5H15" stroke="#332D37" stroke-width="1.75" />
  </svg> `, c$e = () => j` <svg xmlns="http://www.w3.org/2000/svg" width="26" height="17" viewBox="0.5 -1 17 17" fill="none">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M6.38496 5.09174C5.90507 5.09174 5.51465 5.48216 5.51465 5.96205C5.51465 6.18979 5.60412 6.41754 5.76679 6.58021C5.92947 6.74289 6.14908 6.83236 6.38496 6.83236C6.62084 6.83236 6.84045 6.74289 7.00313 6.58021C7.1658 6.41754 7.25527 6.19793 7.25527 5.96205C7.25527 5.48216 6.86485 5.09174 6.38496 5.09174Z"
      fill="#332D37"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M8.99629 5.09174C8.5164 5.09174 8.12598 5.48216 8.12598 5.96205C8.12598 6.18979 8.21545 6.41754 8.37812 6.58021C8.5408 6.74289 8.76041 6.83236 8.99629 6.83236C9.23217 6.83236 9.45178 6.74289 9.61445 6.58021C9.77713 6.41754 9.8666 6.19793 9.8666 5.96205C9.8666 5.48216 9.47618 5.09174 8.99629 5.09174Z"
      fill="#332D37"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M11.6066 5.09174C11.1267 5.09174 10.7363 5.48216 10.7363 5.96205C10.7363 6.18979 10.8258 6.41754 10.9885 6.58021C11.1511 6.74289 11.3708 6.83236 11.6066 6.83236C11.8425 6.83236 12.0621 6.74289 12.2248 6.58021C12.3875 6.41754 12.477 6.19793 12.477 5.96205C12.477 5.48216 12.0865 5.09174 11.6066 5.09174Z"
      fill="#332D37"
    />
    <path
      d="M17.1298 11.0375V0.862183H0.862305V10.8748L5.11626 10.9155L9.053 14.8522L12.884 11.0294L17.1298 11.0375Z"
      stroke="#332D37"
      stroke-width="1.5"
    />
  </svg>`, h$e = {
  fullscreen: t$e,
  "copy-html": s$e,
  refresh: n$e,
  "print-to-pdf": a$e
}, u$e = ({
  alert: t,
  users: e,
  text: n,
  setMode: r,
  templatelist: i,
  buttons: s,
  title: o,
  collaboration: l
}) => {
  const a = Le(() => L$.sanitize(FAe(o || ""), [])), c = [{
    id: "source",
    tooltip: "Source",
    action: () => r("Source"),
    icon: i$e
  }, {
    id: "preview",
    tooltip: "Preview",
    action: () => r("Preview"),
    icon: r$e
  }, {
    id: "both",
    tooltip: "Dual Pane",
    action: () => r("Both"),
    icon: o$e
  }, {
    id: "diff",
    tooltip: "Diff View",
    action: () => r("Diff"),
    icon: l$e
  }];
  l.resolvingCommentsEnabled && c.push({
    id: "resolved",
    tooltip: "Resolved Comments",
    action: () => r("Resolved"),
    icon: c$e
  });
  const h = Le(() => s.map((f) => ({
    ...f,
    icon: f.icon || h$e[f.id]
  })).filter((f) => f.icon), []), u = Le(() => s.filter((f) => f.text && f.id !== "template-manager"), []);
  return j` <${GAe}>
    <${JAe}>
      ${h.map((f) => j`
          <${Cc} className="icon" type="button" key=${f.id} title=${f.tooltip} name=${f.id} onClick=${f.action}>
            ${typeof f.icon == "function" ? j`<${f.icon} />` : j`<img src=${f.icon} />`}
          <//>
        `)}
      ${s.find((f) => f.id === "template-manager") && i && j`<${UAe} text=${n} templatelist=${i} />`}
      ${t && j`<${KAe}> ${t} <//>`}
      <${HAe} dangerouslySetInnerHTML=${{
    __html: a
  }} />
    <//>
    <${e$e}>
      <${ZAe} users=${e} />
      ${u.map((f) => j`<${io} type="button" onClick=${f.action}>${f.text}<//>`)}

      <${MAe} buttons=${c} initialClickedId=${2} />
    <//>
  <//>`;
};
GC.prototype.watchCollabolators = function(t) {
  this.awareness.on("change", ({
    added: e,
    removed: n
  }) => {
    if (e || n) {
      let r = Array.from(this.awareness.states).map(([i, {
        user: s
      }]) => ({
        login: s.name,
        color: s.color
      })).reduce((i, s) => (i[s.login] = s, i), {});
      t(Object.values(r));
    }
  });
};
function f$e(t) {
  if (!t.enabled)
    return {};
  const e = Le(() => new Js(), []), [n, r] = Ee(!1), [i, s] = Ee(!1), [o, l] = Ee(!1);
  Ke(() => {
    const u = console.error, f = (d) => d.includes("Caught error while handling a Yjs update");
    console.error = (...d) => {
      f(d[0]) && l("Collaboration error occured. Please check browser logs and restart the MyST Editor"), u(...d);
    };
  }, []);
  const a = Le(() => {
    var f;
    const u = new GC((f = t.wsUrl) != null ? f : "ws://localhost:4444", t.room, e, {
      connect: !0,
      params: {},
      WebSocketPolyfill: WebSocket,
      awareness: new zC(e),
      maxBackoffTime: 2500
    });
    return u.awareness.setLocalStateField("user", {
      name: t.username,
      color: t.color
    }), u.ws.onerror = () => l(!0), u.on("sync", r), u.on("status", ({
      status: d
    }) => s(d == "connected")), u;
  }, []), c = Le(() => e.getText("codemirror"), []), h = Le(() => new am(c, {
    trackedOrigins: /* @__PURE__ */ new Set([a.doc.clientID, null]),
    ignoreRemoteMapChanges: !0
  }), []);
  return Ke(() => !a.ws && l(!0), [i]), {
    provider: a,
    undoManager: h,
    ytext: c,
    ydoc: e,
    error: o,
    ready: n && i
  };
}
function d$e(t, e, n) {
  return !t || !e ? null : Le(() => new Xo(t, e, n), []);
}
const p$e = H.p`
  font-size: 16px;
  padding: 10px 6px;
  margin-bottom: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 95%;
  min-height: 22px;
  text-decoration: ${(t) => t.orphaned ? "line-through" : "none"};
  color: ${(t) => t.orphaned ? "var(--gray-700)" : "var(--gray-900)"};

  & > span {
    display: ${(t) => t.orphaned ? "none" : "block"};
  }
`, g$e = H.div`
  background-color: color-mix(in srgb, ${(t) => t.color}, white);
  border: 2px solid ${(t) => t.color};
  padding-top: 10px;
  margin-left: -1px;
  width: calc(100% - 2px);
`, m$e = H.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  line-height: 22px;
  padding: 0 6px;
`, O$e = H.h2`
  font-weight: bold;
  font-size: 12px;
  margin: 0;
`, b$e = H.p`
  font-size: 12px;
  font-weight: 400;
  line-height: 14px;
  margin: 0;
  margin-right: 25px;
`, y$e = H.p`
  margin: 0;
  margin-top: 3px;
  font-size: 16px;
  line-height: 22px;
  font-weight: 400;
`, Qw = H.div`
  display: flex;
  align-items: center;

  & .avatar {
    border-radius: 50%;
    border: 3px solid;
    height: 28px;
    width: 28px;
    position: absolute;
    transform: translateX(calc(-100% - 12px));
  }
`, w$e = H.span`
  display: block;
  background-color: color-mix(in srgb, ${(t) => t.color}, white);
  margin: 0;
  padding: 10px 6px;
  white-space: pre-wrap;
`, k$e = H.span`
  position: absolute;
  transform: translateX(calc(-100% - 24px));
  color: var(--gray-700);
`, x$e = H.span`
  margin-right: 6px;
  display: block;
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 10px 0;

  &:hover div {
    display: flex !important;
  }
`, v$e = H.div`
  align-items: center;
  position: absolute;
  background-color: var(--gray-200);
  transform: translate(calc(-100% + 22px), calc(100% - 10px));
  width: max-content;
  border: 1px solid var(--gray-600);
  display: none;

  & p {
    margin: 0;
    font-size: 12px;
    color: var(--red-500);
    font-weight: 700;
  }
`, Ew = H.button`
  background-color: transparent;
  border: none;
  display: flex;
  align-items: center;
  cursor: pointer;
  padding: 7px 18px;
  align-self: stretch;
  width: fit-content;

  &:hover {
    background-color: var(--gray-300);
  }

  &.myst-restore-btn {
    svg {
      padding-right: 10px;
    }

    p {
      color: var(--gray-900);
    }
  }
`, S$e = () => j`
  <svg width="20" height="5" viewBox="0 0 20 5" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M2.5 0C1.12149 0 0 1.12149 0 2.5C0 3.15421 0.257009 3.80841 0.724299 4.2757C1.19159 4.74299 1.82243 5 2.5 5C3.17757 5 3.80841 4.74299 4.2757 4.2757C4.74299 3.80841 5 3.17757 5 2.5C5 1.12149 3.8785 0 2.5 0Z"
      fill="#6C6C6C"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M10 0C8.6215 0 7.5 1.12149 7.5 2.5C7.5 3.15421 7.75701 3.80841 8.2243 4.2757C8.69159 4.74299 9.32243 5 10 5C10.6776 5 11.3084 4.74299 11.7757 4.2757C12.243 3.80841 12.5 3.17757 12.5 2.5C12.5 1.12149 11.3785 0 10 0Z"
      fill="#6C6C6C"
    />
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M17.5 0C16.1215 0 15 1.12149 15 2.5C15 3.15421 15.257 3.80841 15.7243 4.2757C16.1916 4.74299 16.8224 5 17.5 5C18.1776 5 18.8084 4.74299 19.2757 4.2757C19.743 3.80841 20 3.17757 20 2.5C20 1.12149 18.8785 0 17.5 0Z"
      fill="#6C6C6C"
    />
  </svg>
`, _$e = () => j`
  <svg width="25" height="26" viewBox="0 0 26 21" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M7.71387 6.14294V12.5715" stroke="#E7473C" stroke-width="1.75" />
    <path d="M10.2852 6.14288V12.5715" stroke="#E7473C" stroke-width="1.75" />
    <path d="M6.42871 1H11.5716" stroke="#E7473C" stroke-width="1.75" />
    <path d="M0 2.28564H18" stroke="#E7473C" stroke-width="1.75" />
    <path d="M1.92871 2.28564L3.85728 18.3571H14.143L16.0716 2.28564" stroke="#E7473C" stroke-width="1.75" />
  </svg>
`, C$e = () => j`
  <svg width="19" height="19" viewBox="0 0 19 19" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M1.00169 1V6.66103H6.82422" stroke="black" stroke-width="1.75" />
    <path
      d="M1.08493 10.8517C1.67993 14.9572 5.22444 18.1192 9.49996 18.1192C14.192 18.1192 18 14.3112 18 9.61918C18 4.92716 14.192 1.11914 9.49996 1.11914C5.68344 1.11914 2.46193 3.63515 1.38242 7.09467"
      stroke="black"
      stroke-width="1.75"
    />
  </svg>
`, A$e = new Intl.RelativeTimeFormat("en", {
  style: "long"
}), $$e = ({
  c: t,
  authors: e,
  ycomments: n,
  content: r
}) => {
  const [i, s] = Ee({
    amount: 0,
    unit: "second"
  }), o = hn(null), l = Le(() => {
    const h = r.split(`
`), u = [];
    for (let f = 0; f < h.length; f++)
      u.length == 0 || u[u.length - 1].author.name != e.get(f + 1).name ? u.push({
        text: h[f],
        author: e.get(f + 1)
      }) : u[u.length - 1].text += `
` + h[f];
    return u;
  }, [r]);
  function a() {
    const h = Math.floor((Date.now() - t.resolvedDate) / 1e3), u = Math.floor(h / 60), f = Math.floor(u / 60), d = Math.floor(f / 24), p = Math.floor(d / 30), g = Math.floor(p / 12);
    u >= 60 && clearInterval(o.current), h < 60 ? s({
      amount: h,
      unit: "second"
    }) : u < 60 ? s({
      amount: u,
      unit: "minute"
    }) : f < 24 ? s({
      amount: f,
      unit: "hour"
    }) : d < 30 ? s({
      amount: d,
      unit: "day"
    }) : p < 12 ? s({
      amount: p,
      unit: "month"
    }) : s({
      amount: g,
      unit: "year"
    });
  }
  Ke(() => (o.current = setInterval(a, 1e3), () => {
    clearInterval(o.current);
  }), []);
  const c = Le(() => t.orphaned ? "RESTORE ORPHANED" : t.occupied ? "RESTORE AND MERGE" : "RESTORE", [t]);
  return j`
    <div>
      <${p$e} orphaned=${t.orphaned}>
        <${k$e}>${t.lineNumber}<//>
        ${t.resolvedLine}
      <//>
      <${g$e} className="resolved-comment" color=${e.get(1).color}>
        <${m$e}>
          <${Qw}>
            <${B$} login=${e.get(1).name} color=${e.get(1).color} avatarUrl=${e.get(1).avatar} />
            <${O$e}>${e.get(1).name}<//>
          <//>
          <${Qw}>
            <${b$e}>Comment resolved by @${t.resolvedBy.name} ${A$e.format(-i.amount, i.unit)}<//>
            <${x$e}>
              <${S$e} />
              <${v$e}>
                <${Ew} className="myst-restore-btn" onClick=${() => n.restoreComment(t)}>
                  <${C$e} />
                  <p>${c}</p>
                <//>
                <${Ew} onClick=${() => n.resolver().delete(t.commentId)}>
                  <${_$e} />
                  <p>DELETE</p>
                <//>
              <//>
            <//>
          <//>
        <//>
        <${y$e}> ${l.map((h) => j` <${w$e} color=${h.author.color}>${h.text}<//> `)} <//>
      <//>
    </div>
  `;
}, P$e = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNSIgaGVpZ2h0PSIyMCIgdmlld0JveD0iMCAyIDIwIDEyIiBmaWxsPSJub25lIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjM4NDk2IDUuMDkxNzRDNS45MDUwNyA1LjA5MTc0IDUuNTE0NjUgNS40ODIxNiA1LjUxNDY1IDUuOTYyMDVDNS41MTQ2NSA2LjE4OTc5IDUuNjA0MTIgNi40MTc1NCA1Ljc2Njc5IDYuNTgwMjFDNS45Mjk0NyA2Ljc0Mjg5IDYuMTQ5MDggNi44MzIzNiA2LjM4NDk2IDYuODMyMzZDNi42MjA4NCA2LjgzMjM2IDYuODQwNDUgNi43NDI4OSA3LjAwMzEzIDYuNTgwMjFDNy4xNjU4IDYuNDE3NTQgNy4yNTUyNyA2LjE5NzkzIDcuMjU1MjcgNS45NjIwNUM3LjI1NTI3IDUuNDgyMTYgNi44NjQ4NSA1LjA5MTc0IDYuMzg0OTYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljk5NjI5IDUuMDkxNzRDOC41MTY0IDUuMDkxNzQgOC4xMjU5OCA1LjQ4MjE2IDguMTI1OTggNS45NjIwNUM4LjEyNTk4IDYuMTg5NzkgOC4yMTU0NSA2LjQxNzU0IDguMzc4MTIgNi41ODAyMUM4LjU0MDggNi43NDI4OSA4Ljc2MDQxIDYuODMyMzYgOC45OTYyOSA2LjgzMjM2QzkuMjMyMTcgNi44MzIzNiA5LjQ1MTc4IDYuNzQyODkgOS42MTQ0NSA2LjU4MDIxQzkuNzc3MTMgNi40MTc1NCA5Ljg2NjYgNi4xOTc5MyA5Ljg2NjYgNS45NjIwNUM5Ljg2NjYgNS40ODIxNiA5LjQ3NjE4IDUuMDkxNzQgOC45OTYyOSA1LjA5MTc0WiIgZmlsbD0iIzMzMkQzNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjYwNjYgNS4wOTE3NEMxMS4xMjY3IDUuMDkxNzQgMTAuNzM2MyA1LjQ4MjE2IDEwLjczNjMgNS45NjIwNUMxMC43MzYzIDYuMTg5NzkgMTAuODI1OCA2LjQxNzU0IDEwLjk4ODUgNi41ODAyMUMxMS4xNTExIDYuNzQyODkgMTEuMzcwOCA2LjgzMjM2IDExLjYwNjYgNi44MzIzNkMxMS44NDI1IDYuODMyMzYgMTIuMDYyMSA2Ljc0Mjg5IDEyLjIyNDggNi41ODAyMUMxMi4zODc1IDYuNDE3NTQgMTIuNDc3IDYuMTk3OTMgMTIuNDc3IDUuOTYyMDVDMTIuNDc3IDUuNDgyMTYgMTIuMDg2NSA1LjA5MTc0IDExLjYwNjYgNS4wOTE3NFoiIGZpbGw9IiMzMzJEMzciLz4KPHBhdGggZD0iTTE3LjEyOTggMTEuMDM3NVYwLjg2MjE4M0gwLjg2MjMwNVYxMC44NzQ4TDUuMTE2MjYgMTAuOTE1NUw5LjA1MyAxNC44NTIyTDEyLjg4NCAxMS4wMjk0TDE3LjEyOTggMTEuMDM3NVoiIHN0cm9rZT0iIzMzMkQzNyIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KPC9zdmc+", Y$ = H.div`
  background-color: white;
  padding: 20px 0;
  min-height: 150px;
  border: 1px solid var(--gray-400);
  border-left: 1px solid var(--gray-600);
  box-shadow: inset 0px 0px 4px var(--gray-600);
  border-radius: var(--border-radius);
  color: var(--gray-900);

  & h1 {
    font-size: 20px;
    padding-left: 100px;
    margin-bottom: 0;
  }
`, T$e = H.hr`
  border: none;
  height: 1px;
  background-color: var(--gray-600);
  margin-top: 20px;
  margin-bottom: 0;
`, Q$e = H.div`
  margin-left: 100px;
  border-left: 1px solid var(--gray-600);

  & ul,
  p {
    margin-top: 0;
  }
`, E$e = H.p`
  padding: 10px 6px;

  img {
    margin: 0 5px;
    transform: translateY(20%);
  }

  span {
    color: #e7473c;
    line-height: 25px;
    font-size: 10px;
    margin: 0 5px;
  }
`;
Y$.defaultProps = {
  className: "myst-resolved"
};
function rd(t, e) {
  return t.resolvedDate - e.resolvedDate;
}
const D$e = ({
  ycomments: t
}) => {
  let [e, n] = Ee(t.resolver().resolved().sort(rd)), r = Le(() => e.reduce((s, {
    commentId: o
  }) => (s[o] = t.getTextForComment(o).toString(), s), {}), [e]), i = Le(() => e.map((s) => t.lineAuthors(s.commentId)), [e]);
  return Ke(() => {
    n(t.resolver().resolved().sort(rd)), t.resolver().onUpdate((s) => n(s.sort(rd)));
  }, []), j` <${Y$}>
    <h1>Resolved comments</h1>
    <${T$e} />
    <${Q$e}>
      ${e.length === 0 ? j`<${E$e}
            >No resolved comments yet, to resolve a comment hover over it's icon <img src=${P$e} /> and click <span>RESOLVE</span><//
          >` : e.map((s, o) => j`<${$$e}
                key=${s.commentId}
                c=${s}
                authors=${i[o]}
                ycomments=${t}
                content=${r[s.commentId]}
              />`)}
    <//>
  <//>`;
};
var Mw;
(Mw = window.myst_editor) != null && Mw.isFresh || (D$(), window.myst_editor = {
  isFresh: !0
});
const M$e = H.div`
  display: flex;
  flex-flow: row wrap;
  width: 100%;
  ${(t) => t.fullscreen && "position: fixed; left: 0; top: 0; z-index: 10;"}
  ${(t) => {
  switch (t.mode) {
    case "Preview":
      return ".myst-main-editor { display: none } .myst-resolved { display: none }";
    case "Source":
      return ".myst-preview { display: none } .myst-resolved { display: none }";
    case "Diff":
      return ".myst-main-editor { display: none }; .myst-preview { display: none } .myst-resolved { display: none }";
    case "Both":
      return ".myst-resolved { display: none }";
    case "Resolved":
      return ".myst-preview { display: none };";
    default:
      return "";
  }
}}
`, j$ = H.div`
  padding: 20px;
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: minmax(50%, 1fr);
  grid-template-rows: max-content;
  box-sizing: border-box;
  width: 100%;
  position: relative;
  background-color: white;
  ${(t) => t.fullscreen && "box-sizing:border-box; height: calc(100vh - 60px); overflow-y: scroll;"}
`;
j$.defaultProps = {
  className: "myst-editor-wrapper"
};
const Dw = H.div`
  height: 40px;
  position: sticky;
  z-index: 10;
  width: 100%;
  top: 60px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: ${(t) => t.error ? "var(--red-500)" : "var(--blue-100)"};
  color: ${(t) => t.error ? "white" : "inherit"};
  font-weight: 600;
`, R$e = (t) => {
  const e = (n, r, i) => {
    n.type == "rule" && (n.props[0] = n.props[0].split(",").map((s) => `${t} ${s}`).join(","));
  };
  return Object.defineProperty(e, "name", {
    value: `scope-${t}`
  }), e;
}, Z$e = (t) => document.documentElement.style.overflow = t ? "hidden" : "visible", wo = {
  printToPdf: {
    id: "print-to-pdf",
    tooltip: "Print document as pdf",
    action: () => window.print()
  },
  templateManager: {
    id: "template-manager"
  },
  copyHtml: {
    id: "copy-html",
    tooltip: "Copy document as HTML"
  },
  fullscreen: {
    id: "fullscreen",
    tooltip: "Fullscreen"
  },
  refresh: {
    id: "refresh",
    tooltip: "Refresh issue links"
  }
}, I$e = [wo.fullscreen, wo.copyHtml, wo.refresh, wo.printToPdf, wo.templateManager], Y$e = ({
  name: t = "myst_editor_textarea",
  id: e = "myst_editor_textarea",
  title: n = null,
  initialMode: r = "Both",
  initialText: i = "",
  includeButtons: s = I$e,
  topbar: o = !0,
  templatelist: l,
  collaboration: a = {},
  spellcheckOpts: c = {
    dict: "en_US",
    dictionaryPath: "/dictionaries"
  },
  customRoles: h = [],
  transforms: u = [],
  getAvatar: f = (d) => `https://secure.gravatar.com/avatar/${d}?s=30&d=identicon`
}) => {
  const [d, p] = Ee(r), [g, m] = Ee(!1), O = hn(null), b = QAe({
    initialText: i,
    transforms: u,
    customRoles: h,
    preview: O
  }), [y, w] = Ee(null), [S, x] = $h((ie, ae) => ae.map((Te) => ({
    ...Te,
    avatarUrl: f(Te.login)
  })), []), {
    provider: v,
    undoManager: P,
    ytext: D,
    ydoc: Q,
    ready: R,
    error: N
  } = f$e(a), F = d$e(Q, v, f), A = (ie, ae) => {
    w(ie), setTimeout(() => w(null), ae * 1e3);
  }, z = {
    "copy-html": () => {
      b.copy(), A("copied!", 2);
    },
    fullscreen: () => m((ie) => !ie),
    refresh: () => {
      D$(), A("Rich links refreshed!", 1), b.refresh();
    }
  }, V = Le(() => s.map((ie) => ({
    ...ie,
    action: ie.action || z[ie.id]
  })), []);
  return Ke(() => Z$e(g), [g]), j` <div id="myst-css-namespace">
    <${HP} stylisPlugins=${[R$e("#myst-css-namespace")]}>
      <${M$e} mode=${d} fullscreen=${g}>
        ${o && j`<${u$e}
          ...${{
    alert: y,
    users: S,
    text: b,
    templatelist: l,
    buttons: V,
    collaboration: a,
    setMode: p,
    title: n
  }}
        />`}
        ${N && j`<${Dw} error> ${typeof N == "string" ? N : "No connection to the collaboration server"} <//>`}
        ${a.enabled && !R && !N && j`<${Dw}>Connecting to the collaboration server ...<//>`}
        <${j$} fullscreen=${g}>
          <${K4}
            ...${{
    mode: d,
    text: b,
    name: t,
    id: e,
    spellcheckOpts: c,
    highlights: u,
    collaboration: {
      opts: a,
      setUsers: x,
      provider: v,
      undoManager: P,
      ytext: D,
      ydoc: Q,
      ready: R,
      error: N,
      ycomments: F
    }
  }}
          />
          <${KC} ref=${O} />
          ${d === "Diff" && j`<${fA} oldText=${i} text=${b} />`}
          ${a.commentsEnabled && a.resolvingCommentsEnabled && !N && j`<${D$e} ycomments=${F} />`}
        <//>
      <//>
    <//>
  </div>`;
};
export {
  Y$e as default,
  I$e as defaultButtons,
  j as html,
  wo as predefinedButtons,
  Vo as render
};
