var Tt = function() {
  return Tt = Object.assign || function(e) {
    for (var t, i = 1, r = arguments.length; i < r; i++) {
      t = arguments[i];
      for (var s in t)
        Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, Tt.apply(this, arguments);
};
function As(n, e, t) {
  if (t || arguments.length === 2)
    for (var i = 0, r = e.length, s; i < r; i++)
      (s || !(i in e)) && (s || (s = Array.prototype.slice.call(e, 0, i)), s[i] = e[i]);
  return n.concat(s || Array.prototype.slice.call(e));
}
function h2(n) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var u2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, f2 = /* @__PURE__ */ h2(
  function(n) {
    return u2.test(n) || n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) < 91;
  }
), El, P, zw, or, zm, Uw, Pf, Ww, us = {}, jw = [], d2 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, mh = Array.isArray;
function ti(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function Gw(n) {
  var e = n.parentNode;
  e && e.removeChild(n);
}
function dn(n, e, t) {
  var i, r, s, o = {};
  for (s in e)
    s == "key" ? i = e[s] : s == "ref" ? r = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? El.call(arguments, 2) : t), typeof n == "function" && n.defaultProps != null)
    for (s in n.defaultProps)
      o[s] === void 0 && (o[s] = n.defaultProps[s]);
  return Ro(n, o, i, r, null);
}
function Ro(n, e, t, i, r) {
  var s = { type: n, props: e, key: t, ref: i, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: r == null ? ++zw : r };
  return r == null && P.vnode != null && P.vnode(s), s;
}
function p2() {
  return { current: null };
}
function oi(n) {
  return n.children;
}
function Fn(n, e) {
  this.props = n, this.context = e;
}
function Wo(n, e) {
  if (e == null)
    return n.__ ? Wo(n.__, n.__.__k.indexOf(n) + 1) : null;
  for (var t; e < n.__k.length; e++)
    if ((t = n.__k[e]) != null && t.__e != null)
      return t.__e;
  return typeof n.type == "function" ? Wo(n) : null;
}
function Kw(n) {
  var e, t;
  if ((n = n.__) != null && n.__c != null) {
    for (n.__e = n.__c.base = null, e = 0; e < n.__k.length; e++)
      if ((t = n.__k[e]) != null && t.__e != null) {
        n.__e = n.__c.base = t.__e;
        break;
      }
    return Kw(n);
  }
}
function Ff(n) {
  (!n.__d && (n.__d = !0) && or.push(n) && !mc.__r++ || zm !== P.debounceRendering) && ((zm = P.debounceRendering) || Uw)(mc);
}
function mc() {
  var n, e, t, i, r, s, o, l, a;
  for (or.sort(Pf); n = or.shift(); )
    n.__d && (e = or.length, i = void 0, r = void 0, s = void 0, l = (o = (t = n).__v).__e, (a = t.__P) && (i = [], r = [], (s = ti({}, o)).__v = o.__v + 1, qp(a, o, s, t.__n, a.ownerSVGElement !== void 0, o.__h != null ? [l] : null, i, l == null ? Wo(o) : l, o.__h, r), Xw(i, o, r), o.__e != l && Kw(o)), or.length > e && or.sort(Pf));
  mc.__r = 0;
}
function Yw(n, e, t, i, r, s, o, l, a, c, h) {
  var u, f, d, p, g, m, b, y, k, w = 0, x = i && i.__k || jw, v = x.length, C = v, B = e.length;
  for (t.__k = [], u = 0; u < B; u++)
    (p = t.__k[u] = (p = e[u]) == null || typeof p == "boolean" || typeof p == "function" ? null : typeof p == "string" || typeof p == "number" || typeof p == "bigint" ? Ro(null, p, null, null, p) : mh(p) ? Ro(oi, { children: p }, null, null, null) : p.__b > 0 ? Ro(p.type, p.props, p.key, p.ref ? p.ref : null, p.__v) : p) != null ? (p.__ = t, p.__b = t.__b + 1, (y = g2(p, x, b = u + w, C)) === -1 ? d = us : (d = x[y] || us, x[y] = void 0, C--), qp(n, p, d, r, s, o, l, a, c, h), g = p.__e, (f = p.ref) && d.ref != f && (d.ref && Vp(d.ref, null, p), h.push(f, p.__c || g, p)), g != null && (m == null && (m = g), (k = d === us || d.__v === null) ? y == -1 && w-- : y !== b && (y === b + 1 ? w++ : y > b ? C > B - b ? w += y - b : w-- : w = y < b && y == b - 1 ? y - b : 0), b = u + w, typeof p.type != "function" || y === b && d.__k !== p.__k ? typeof p.type == "function" || y === b && !k ? p.__d !== void 0 ? (a = p.__d, p.__d = void 0) : a = g.nextSibling : a = Zw(n, g, a) : a = Jw(p, a, n), typeof t.type == "function" && (t.__d = a))) : (d = x[u]) && d.key == null && d.__e && (d.__e == a && (a = Wo(d)), $f(d, d, !1), x[u] = null);
  for (t.__e = m, u = v; u--; )
    x[u] != null && (typeof t.type == "function" && x[u].__e != null && x[u].__e == t.__d && (t.__d = x[u].__e.nextSibling), $f(x[u], x[u]));
}
function Jw(n, e, t) {
  for (var i, r = n.__k, s = 0; r && s < r.length; s++)
    (i = r[s]) && (i.__ = n, e = typeof i.type == "function" ? Jw(i, e, t) : Zw(t, i.__e, e));
  return e;
}
function ii(n, e) {
  return e = e || [], n == null || typeof n == "boolean" || (mh(n) ? n.some(function(t) {
    ii(t, e);
  }) : e.push(n)), e;
}
function Zw(n, e, t) {
  return t == null || t.parentNode !== n ? n.insertBefore(e, null) : e == t && e.parentNode != null || n.insertBefore(e, t), e.nextSibling;
}
function g2(n, e, t, i) {
  var r = n.key, s = n.type, o = t - 1, l = t + 1, a = e[t];
  if (a === null || a && r == a.key && s === a.type)
    return t;
  if (i > (a != null ? 1 : 0))
    for (; o >= 0 || l < e.length; ) {
      if (o >= 0) {
        if ((a = e[o]) && r == a.key && s === a.type)
          return o;
        o--;
      }
      if (l < e.length) {
        if ((a = e[l]) && r == a.key && s === a.type)
          return l;
        l++;
      }
    }
  return -1;
}
function m2(n, e, t, i, r) {
  var s;
  for (s in t)
    s === "children" || s === "key" || s in e || bc(n, s, null, t[s], i);
  for (s in e)
    r && typeof e[s] != "function" || s === "children" || s === "key" || s === "value" || s === "checked" || t[s] === e[s] || bc(n, s, e[s], t[s], i);
}
function Um(n, e, t) {
  e[0] === "-" ? n.setProperty(e, t == null ? "" : t) : n[e] = t == null ? "" : typeof t != "number" || d2.test(e) ? t : t + "px";
}
function bc(n, e, t, i, r) {
  var s;
  e:
    if (e === "style")
      if (typeof t == "string")
        n.style.cssText = t;
      else {
        if (typeof i == "string" && (n.style.cssText = i = ""), i)
          for (e in i)
            t && e in t || Um(n.style, e, "");
        if (t)
          for (e in t)
            i && t[e] === i[e] || Um(n.style, e, t[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      s = e !== (e = e.replace(/(PointerCapture)$|Capture$/, "$1")), e = e.toLowerCase() in n ? e.toLowerCase().slice(2) : e.slice(2), n.l || (n.l = {}), n.l[e + s] = t, t ? i || n.addEventListener(e, s ? jm : Wm, s) : n.removeEventListener(e, s ? jm : Wm, s);
    else if (e !== "dangerouslySetInnerHTML") {
      if (r)
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e !== "width" && e !== "height" && e !== "href" && e !== "list" && e !== "form" && e !== "tabIndex" && e !== "download" && e !== "rowSpan" && e !== "colSpan" && e in n)
        try {
          n[e] = t == null ? "" : t;
          break e;
        } catch {
        }
      typeof t == "function" || (t == null || t === !1 && e[4] !== "-" ? n.removeAttribute(e) : n.setAttribute(e, t));
    }
}
function Wm(n) {
  return this.l[n.type + !1](P.event ? P.event(n) : n);
}
function jm(n) {
  return this.l[n.type + !0](P.event ? P.event(n) : n);
}
function qp(n, e, t, i, r, s, o, l, a, c) {
  var h, u, f, d, p, g, m, b, y, k, w, x, v, C, B, R = e.type;
  if (e.constructor !== void 0)
    return null;
  t.__h != null && (a = t.__h, l = e.__e = t.__e, e.__h = null, s = [l]), (h = P.__b) && h(e);
  e:
    if (typeof R == "function")
      try {
        if (b = e.props, y = (h = R.contextType) && i[h.__c], k = h ? y ? y.props.value : h.__ : i, t.__c ? m = (u = e.__c = t.__c).__ = u.__E : ("prototype" in R && R.prototype.render ? e.__c = u = new R(b, k) : (e.__c = u = new Fn(b, k), u.constructor = R, u.render = y2), y && y.sub(u), u.props = b, u.state || (u.state = {}), u.context = k, u.__n = i, f = u.__d = !0, u.__h = [], u._sb = []), u.__s == null && (u.__s = u.state), R.getDerivedStateFromProps != null && (u.__s == u.state && (u.__s = ti({}, u.__s)), ti(u.__s, R.getDerivedStateFromProps(b, u.__s))), d = u.props, p = u.state, u.__v = e, f)
          R.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), u.componentDidMount != null && u.__h.push(u.componentDidMount);
        else {
          if (R.getDerivedStateFromProps == null && b !== d && u.componentWillReceiveProps != null && u.componentWillReceiveProps(b, k), !u.__e && (u.shouldComponentUpdate != null && u.shouldComponentUpdate(b, u.__s, k) === !1 || e.__v === t.__v)) {
            for (e.__v !== t.__v && (u.props = b, u.state = u.__s, u.__d = !1), e.__e = t.__e, e.__k = t.__k, e.__k.forEach(function(T) {
              T && (T.__ = e);
            }), w = 0; w < u._sb.length; w++)
              u.__h.push(u._sb[w]);
            u._sb = [], u.__h.length && o.push(u);
            break e;
          }
          u.componentWillUpdate != null && u.componentWillUpdate(b, u.__s, k), u.componentDidUpdate != null && u.__h.push(function() {
            u.componentDidUpdate(d, p, g);
          });
        }
        if (u.context = k, u.props = b, u.__P = n, u.__e = !1, x = P.__r, v = 0, "prototype" in R && R.prototype.render) {
          for (u.state = u.__s, u.__d = !1, x && x(e), h = u.render(u.props, u.state, u.context), C = 0; C < u._sb.length; C++)
            u.__h.push(u._sb[C]);
          u._sb = [];
        } else
          do
            u.__d = !1, x && x(e), h = u.render(u.props, u.state, u.context), u.state = u.__s;
          while (u.__d && ++v < 25);
        u.state = u.__s, u.getChildContext != null && (i = ti(ti({}, i), u.getChildContext())), f || u.getSnapshotBeforeUpdate == null || (g = u.getSnapshotBeforeUpdate(d, p)), Yw(n, mh(B = h != null && h.type === oi && h.key == null ? h.props.children : h) ? B : [B], e, t, i, r, s, o, l, a, c), u.base = e.__e, e.__h = null, u.__h.length && o.push(u), m && (u.__E = u.__ = null);
      } catch (T) {
        e.__v = null, (a || s != null) && (e.__e = l, e.__h = !!a, s[s.indexOf(l)] = null), P.__e(T, e, t);
      }
    else
      s == null && e.__v === t.__v ? (e.__k = t.__k, e.__e = t.__e) : e.__e = b2(t.__e, e, t, i, r, s, o, a, c);
  (h = P.diffed) && h(e);
}
function Xw(n, e, t) {
  for (var i = 0; i < t.length; i++)
    Vp(t[i], t[++i], t[++i]);
  P.__c && P.__c(e, n), n.some(function(r) {
    try {
      n = r.__h, r.__h = [], n.some(function(s) {
        s.call(r);
      });
    } catch (s) {
      P.__e(s, r.__v);
    }
  });
}
function b2(n, e, t, i, r, s, o, l, a) {
  var c, h, u, f = t.props, d = e.props, p = e.type, g = 0;
  if (p === "svg" && (r = !0), s != null) {
    for (; g < s.length; g++)
      if ((c = s[g]) && "setAttribute" in c == !!p && (p ? c.localName === p : c.nodeType === 3)) {
        n = c, s[g] = null;
        break;
      }
  }
  if (n == null) {
    if (p === null)
      return document.createTextNode(d);
    n = r ? document.createElementNS("http://www.w3.org/2000/svg", p) : document.createElement(p, d.is && d), s = null, l = !1;
  }
  if (p === null)
    f === d || l && n.data === d || (n.data = d);
  else {
    if (s = s && El.call(n.childNodes), h = (f = t.props || us).dangerouslySetInnerHTML, u = d.dangerouslySetInnerHTML, !l) {
      if (s != null)
        for (f = {}, g = 0; g < n.attributes.length; g++)
          f[n.attributes[g].name] = n.attributes[g].value;
      (u || h) && (u && (h && u.__html == h.__html || u.__html === n.innerHTML) || (n.innerHTML = u && u.__html || ""));
    }
    if (m2(n, d, f, r, l), u)
      e.__k = [];
    else if (Yw(n, mh(g = e.props.children) ? g : [g], e, t, i, r && p !== "foreignObject", s, o, s ? s[0] : t.__k && Wo(t, 0), l, a), s != null)
      for (g = s.length; g--; )
        s[g] != null && Gw(s[g]);
    l || ("value" in d && (g = d.value) !== void 0 && (g !== n.value || p === "progress" && !g || p === "option" && g !== f.value) && bc(n, "value", g, f.value, !1), "checked" in d && (g = d.checked) !== void 0 && g !== n.checked && bc(n, "checked", g, f.checked, !1));
  }
  return n;
}
function Vp(n, e, t) {
  try {
    typeof n == "function" ? n(e) : n.current = e;
  } catch (i) {
    P.__e(i, t);
  }
}
function $f(n, e, t) {
  var i, r;
  if (P.unmount && P.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || Vp(i, null, e)), (i = n.__c) != null) {
    if (i.componentWillUnmount)
      try {
        i.componentWillUnmount();
      } catch (s) {
        P.__e(s, e);
      }
    i.base = i.__P = null, n.__c = void 0;
  }
  if (i = n.__k)
    for (r = 0; r < i.length; r++)
      i[r] && $f(i[r], e, t || typeof n.type != "function");
  t || n.__e == null || Gw(n.__e), n.__ = n.__e = n.__d = void 0;
}
function y2(n, e, t) {
  return this.constructor(n, t);
}
function jo(n, e, t) {
  var i, r, s, o;
  P.__ && P.__(n, e), r = (i = typeof t == "function") ? null : t && t.__k || e.__k, s = [], o = [], qp(e, n = (!i && t || e).__k = dn(oi, null, [n]), r || us, us, e.ownerSVGElement !== void 0, !i && t ? [t] : r ? null : e.firstChild ? El.call(e.childNodes) : null, s, !i && t ? t : r ? r.__e : e.firstChild, i, o), Xw(s, n, o);
}
function Qw(n, e) {
  jo(n, e, Qw);
}
function w2(n, e, t) {
  var i, r, s, o, l = ti({}, n.props);
  for (s in n.type && n.type.defaultProps && (o = n.type.defaultProps), e)
    s == "key" ? i = e[s] : s == "ref" ? r = e[s] : l[s] = e[s] === void 0 && o !== void 0 ? o[s] : e[s];
  return arguments.length > 2 && (l.children = arguments.length > 3 ? El.call(arguments, 2) : t), Ro(n.type, l, i || n.key, r || n.ref, null);
}
function v2(n, e) {
  var t = { __c: e = "__cC" + Ww++, __: n, Consumer: function(i, r) {
    return i.children(r);
  }, Provider: function(i) {
    var r, s;
    return this.getChildContext || (r = [], (s = {})[e] = this, this.getChildContext = function() {
      return s;
    }, this.shouldComponentUpdate = function(o) {
      this.props.value !== o.value && r.some(function(l) {
        l.__e = !0, Ff(l);
      });
    }, this.sub = function(o) {
      r.push(o);
      var l = o.componentWillUnmount;
      o.componentWillUnmount = function() {
        r.splice(r.indexOf(o), 1), l && l.call(o);
      };
    }), i.children;
  } };
  return t.Provider.__ = t.Consumer.contextType = t;
}
El = jw.slice, P = { __e: function(n, e, t, i) {
  for (var r, s, o; e = e.__; )
    if ((r = e.__c) && !r.__)
      try {
        if ((s = r.constructor) && s.getDerivedStateFromError != null && (r.setState(s.getDerivedStateFromError(n)), o = r.__d), r.componentDidCatch != null && (r.componentDidCatch(n, i || {}), o = r.__d), o)
          return r.__E = r;
      } catch (l) {
        n = l;
      }
  throw n;
} }, zw = 0, Fn.prototype.setState = function(n, e) {
  var t;
  t = this.__s != null && this.__s !== this.state ? this.__s : this.__s = ti({}, this.state), typeof n == "function" && (n = n(ti({}, t), this.props)), n && ti(t, n), n != null && this.__v && (e && this._sb.push(e), Ff(this));
}, Fn.prototype.forceUpdate = function(n) {
  this.__v && (this.__e = !0, n && this.__h.push(n), Ff(this));
}, Fn.prototype.render = oi, or = [], Uw = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, Pf = function(n, e) {
  return n.__v.__b - e.__v.__b;
}, mc.__r = 0, Ww = 0;
var Hi, _e, bu, Gm, Ds = 0, ev = [], za = [], Km = P.__b, Ym = P.__r, Jm = P.diffed, Zm = P.__c, Xm = P.unmount;
function Ks(n, e) {
  P.__h && P.__h(_e, n, Ds || e), Ds = 0;
  var t = _e.__H || (_e.__H = { __: [], __h: [] });
  return n >= t.__.length && t.__.push({ __V: za }), t.__[n];
}
function ht(n) {
  return Ds = 1, tv(iv, n);
}
function tv(n, e, t) {
  var i = Ks(Hi++, 2);
  if (i.t = n, !i.__c && (i.__ = [t ? t(e) : iv(void 0, e), function(l) {
    var a = i.__N ? i.__N[0] : i.__[0], c = i.t(a, l);
    a !== c && (i.__N = [c, i.__[1]], i.__c.setState({}));
  }], i.__c = _e, !_e.u)) {
    var r = function(l, a, c) {
      if (!i.__c.__H)
        return !0;
      var h = i.__c.__H.__.filter(function(f) {
        return f.__c;
      });
      if (h.every(function(f) {
        return !f.__N;
      }))
        return !s || s.call(this, l, a, c);
      var u = !1;
      return h.forEach(function(f) {
        if (f.__N) {
          var d = f.__[0];
          f.__ = f.__N, f.__N = void 0, d !== f.__[0] && (u = !0);
        }
      }), !(!u && i.__c.props === l) && (!s || s.call(this, l, a, c));
    };
    _e.u = !0;
    var s = _e.shouldComponentUpdate, o = _e.componentWillUpdate;
    _e.componentWillUpdate = function(l, a, c) {
      if (this.__e) {
        var h = s;
        s = void 0, r(l, a, c), s = h;
      }
      o && o.call(this, l, a, c);
    }, _e.shouldComponentUpdate = r;
  }
  return i.__N || i.__;
}
function Cr(n, e) {
  var t = Ks(Hi++, 3);
  !P.__s && zp(t.__H, e) && (t.__ = n, t.i = e, _e.__H.__h.push(t));
}
function bh(n, e) {
  var t = Ks(Hi++, 4);
  !P.__s && zp(t.__H, e) && (t.__ = n, t.i = e, _e.__h.push(t));
}
function fs(n) {
  return Ds = 5, ni(function() {
    return { current: n };
  }, []);
}
function x2(n, e, t) {
  Ds = 6, bh(function() {
    return typeof n == "function" ? (n(e()), function() {
      return n(null);
    }) : n ? (n.current = e(), function() {
      return n.current = null;
    }) : void 0;
  }, t == null ? t : t.concat(n));
}
function ni(n, e) {
  var t = Ks(Hi++, 7);
  return zp(t.__H, e) ? (t.__V = n(), t.i = e, t.__h = n, t.__V) : t.__;
}
function k2(n, e) {
  return Ds = 8, ni(function() {
    return n;
  }, e);
}
function nv(n) {
  var e = _e.context[n.__c], t = Ks(Hi++, 9);
  return t.c = n, e ? (t.__ == null && (t.__ = !0, e.sub(_e)), e.props.value) : n.__;
}
function Hf(n, e) {
  P.useDebugValue && P.useDebugValue(e ? e(n) : n);
}
function _2() {
  var n = Ks(Hi++, 11);
  if (!n.__) {
    for (var e = _e.__v; e !== null && !e.__m && e.__ !== null; )
      e = e.__;
    var t = e.__m || (e.__m = [0, 0]);
    n.__ = "P" + t[0] + "-" + t[1]++;
  }
  return n.__;
}
function S2() {
  for (var n; n = ev.shift(); )
    if (n.__P && n.__H)
      try {
        n.__H.__h.forEach(Ua), n.__H.__h.forEach(qf), n.__H.__h = [];
      } catch (e) {
        n.__H.__h = [], P.__e(e, n.__v);
      }
}
P.__b = function(n) {
  _e = null, Km && Km(n);
}, P.__r = function(n) {
  Ym && Ym(n), Hi = 0;
  var e = (_e = n.__c).__H;
  e && (bu === _e ? (e.__h = [], _e.__h = [], e.__.forEach(function(t) {
    t.__N && (t.__ = t.__N), t.__V = za, t.__N = t.i = void 0;
  })) : (e.__h.forEach(Ua), e.__h.forEach(qf), e.__h = [], Hi = 0)), bu = _e;
}, P.diffed = function(n) {
  Jm && Jm(n);
  var e = n.__c;
  e && e.__H && (e.__H.__h.length && (ev.push(e) !== 1 && Gm === P.requestAnimationFrame || ((Gm = P.requestAnimationFrame) || C2)(S2)), e.__H.__.forEach(function(t) {
    t.i && (t.__H = t.i), t.__V !== za && (t.__ = t.__V), t.i = void 0, t.__V = za;
  })), bu = _e = null;
}, P.__c = function(n, e) {
  e.some(function(t) {
    try {
      t.__h.forEach(Ua), t.__h = t.__h.filter(function(i) {
        return !i.__ || qf(i);
      });
    } catch (i) {
      e.some(function(r) {
        r.__h && (r.__h = []);
      }), e = [], P.__e(i, t.__v);
    }
  }), Zm && Zm(n, e);
}, P.unmount = function(n) {
  Xm && Xm(n);
  var e, t = n.__c;
  t && t.__H && (t.__H.__.forEach(function(i) {
    try {
      Ua(i);
    } catch (r) {
      e = r;
    }
  }), t.__H = void 0, e && P.__e(e, t.__v));
};
var Qm = typeof requestAnimationFrame == "function";
function C2(n) {
  var e, t = function() {
    clearTimeout(i), Qm && cancelAnimationFrame(e), setTimeout(n);
  }, i = setTimeout(t, 100);
  Qm && (e = requestAnimationFrame(t));
}
function Ua(n) {
  var e = _e, t = n.__c;
  typeof t == "function" && (n.__c = void 0, t()), _e = e;
}
function qf(n) {
  var e = _e;
  n.__c = n.__(), _e = e;
}
function zp(n, e) {
  return !n || n.length !== e.length || e.some(function(t, i) {
    return t !== n[i];
  });
}
function iv(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function rv(n, e) {
  for (var t in e)
    n[t] = e[t];
  return n;
}
function Vf(n, e) {
  for (var t in n)
    if (t !== "__source" && !(t in e))
      return !0;
  for (var i in e)
    if (i !== "__source" && n[i] !== e[i])
      return !0;
  return !1;
}
function yu(n, e) {
  return n === e && (n !== 0 || 1 / n == 1 / e) || n != n && e != e;
}
function zf(n) {
  this.props = n;
}
function A2(n, e) {
  function t(r) {
    var s = this.props.ref, o = s == r.ref;
    return !o && s && (s.call ? s(null) : s.current = null), e ? !e(this.props, r) || !o : Vf(this.props, r);
  }
  function i(r) {
    return this.shouldComponentUpdate = t, dn(n, r);
  }
  return i.displayName = "Memo(" + (n.displayName || n.name) + ")", i.prototype.isReactComponent = !0, i.__f = !0, i;
}
(zf.prototype = new Fn()).isPureReactComponent = !0, zf.prototype.shouldComponentUpdate = function(n, e) {
  return Vf(this.props, n) || Vf(this.state, e);
};
var e0 = P.__b;
P.__b = function(n) {
  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), e0 && e0(n);
};
var D2 = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function E2(n) {
  function e(t) {
    var i = rv({}, t);
    return delete i.ref, n(i, t.ref || null);
  }
  return e.$$typeof = D2, e.render = e, e.prototype.isReactComponent = e.__f = !0, e.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", e;
}
var t0 = function(n, e) {
  return n == null ? null : ii(ii(n).map(e));
}, T2 = { map: t0, forEach: t0, count: function(n) {
  return n ? ii(n).length : 0;
}, only: function(n) {
  var e = ii(n);
  if (e.length !== 1)
    throw "Children.only";
  return e[0];
}, toArray: ii }, M2 = P.__e;
P.__e = function(n, e, t, i) {
  if (n.then) {
    for (var r, s = e; s = s.__; )
      if ((r = s.__c) && r.__c)
        return e.__e == null && (e.__e = t.__e, e.__k = t.__k), r.__c(n, e);
  }
  M2(n, e, t, i);
};
var n0 = P.unmount;
function sv(n, e, t) {
  return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function(i) {
    typeof i.__c == "function" && i.__c();
  }), n.__c.__H = null), (n = rv({}, n)).__c != null && (n.__c.__P === t && (n.__c.__P = e), n.__c = null), n.__k = n.__k && n.__k.map(function(i) {
    return sv(i, e, t);
  })), n;
}
function ov(n, e, t) {
  return n && (n.__v = null, n.__k = n.__k && n.__k.map(function(i) {
    return ov(i, e, t);
  }), n.__c && n.__c.__P === e && (n.__e && t.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = t)), n;
}
function Wa() {
  this.__u = 0, this.t = null, this.__b = null;
}
function lv(n) {
  var e = n.__.__c;
  return e && e.__a && e.__a(n);
}
function O2(n) {
  var e, t, i;
  function r(s) {
    if (e || (e = n()).then(function(o) {
      t = o.default || o;
    }, function(o) {
      i = o;
    }), i)
      throw i;
    if (!t)
      throw e;
    return dn(t, s);
  }
  return r.displayName = "Lazy", r.__f = !0, r;
}
function wo() {
  this.u = null, this.o = null;
}
P.unmount = function(n) {
  var e = n.__c;
  e && e.__R && e.__R(), e && n.__h === !0 && (n.type = null), n0 && n0(n);
}, (Wa.prototype = new Fn()).__c = function(n, e) {
  var t = e.__c, i = this;
  i.t == null && (i.t = []), i.t.push(t);
  var r = lv(i.__v), s = !1, o = function() {
    s || (s = !0, t.__R = null, r ? r(l) : l());
  };
  t.__R = o;
  var l = function() {
    if (!--i.__u) {
      if (i.state.__a) {
        var c = i.state.__a;
        i.__v.__k[0] = ov(c, c.__c.__P, c.__c.__O);
      }
      var h;
      for (i.setState({ __a: i.__b = null }); h = i.t.pop(); )
        h.forceUpdate();
    }
  }, a = e.__h === !0;
  i.__u++ || a || i.setState({ __a: i.__b = i.__v.__k[0] }), n.then(o, o);
}, Wa.prototype.componentWillUnmount = function() {
  this.t = [];
}, Wa.prototype.render = function(n, e) {
  if (this.__b) {
    if (this.__v.__k) {
      var t = document.createElement("div"), i = this.__v.__k[0].__c;
      this.__v.__k[0] = sv(this.__b, t, i.__O = i.__P);
    }
    this.__b = null;
  }
  var r = e.__a && dn(oi, null, n.fallback);
  return r && (r.__h = null), [dn(oi, null, e.__a ? null : n.children), r];
};
var i0 = function(n, e, t) {
  if (++t[1] === t[0] && n.o.delete(e), n.props.revealOrder && (n.props.revealOrder[0] !== "t" || !n.o.size))
    for (t = n.u; t; ) {
      for (; t.length > 3; )
        t.pop()();
      if (t[1] < t[0])
        break;
      n.u = t = t[2];
    }
};
function L2(n) {
  return this.getChildContext = function() {
    return n.context;
  }, n.children;
}
function R2(n) {
  var e = this, t = n.i;
  e.componentWillUnmount = function() {
    jo(null, e.l), e.l = null, e.i = null;
  }, e.i && e.i !== t && e.componentWillUnmount(), e.l || (e.i = t, e.l = { nodeType: 1, parentNode: t, childNodes: [], appendChild: function(i) {
    this.childNodes.push(i), e.i.appendChild(i);
  }, insertBefore: function(i, r) {
    this.childNodes.push(i), e.i.appendChild(i);
  }, removeChild: function(i) {
    this.childNodes.splice(this.childNodes.indexOf(i) >>> 1, 1), e.i.removeChild(i);
  } }), jo(dn(L2, { context: e.context }, n.__v), e.l);
}
function I2(n, e) {
  var t = dn(R2, { __v: n, i: e });
  return t.containerInfo = e, t;
}
(wo.prototype = new Fn()).__a = function(n) {
  var e = this, t = lv(e.__v), i = e.o.get(n);
  return i[0]++, function(r) {
    var s = function() {
      e.props.revealOrder ? (i.push(r), i0(e, n, i)) : r();
    };
    t ? t(s) : s();
  };
}, wo.prototype.render = function(n) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var e = ii(n.children);
  n.revealOrder && n.revealOrder[0] === "b" && e.reverse();
  for (var t = e.length; t--; )
    this.o.set(e[t], this.u = [1, 0, this.u]);
  return n.children;
}, wo.prototype.componentDidUpdate = wo.prototype.componentDidMount = function() {
  var n = this;
  this.o.forEach(function(e, t) {
    i0(n, t, e);
  });
};
var av = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, N2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, P2 = /[A-Z0-9]/g, F2 = typeof document < "u", $2 = function(n) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(n);
};
function H2(n, e, t) {
  return e.__k == null && (e.textContent = ""), jo(n, e), typeof t == "function" && t(), n ? n.__c : null;
}
function q2(n, e, t) {
  return Qw(n, e), typeof t == "function" && t(), n ? n.__c : null;
}
Fn.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(n) {
  Object.defineProperty(Fn.prototype, n, { configurable: !0, get: function() {
    return this["UNSAFE_" + n];
  }, set: function(e) {
    Object.defineProperty(this, n, { configurable: !0, writable: !0, value: e });
  } });
});
var r0 = P.event;
function V2() {
}
function z2() {
  return this.cancelBubble;
}
function U2() {
  return this.defaultPrevented;
}
P.event = function(n) {
  return r0 && (n = r0(n)), n.persist = V2, n.isPropagationStopped = z2, n.isDefaultPrevented = U2, n.nativeEvent = n;
};
var Up, W2 = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, s0 = P.vnode;
P.vnode = function(n) {
  typeof n.type == "string" && function(e) {
    var t = e.props, i = e.type, r = {};
    for (var s in t) {
      var o = t[s];
      if (!(s === "value" && "defaultValue" in t && o == null || F2 && s === "children" && i === "noscript" || s === "class" || s === "className")) {
        var l = s.toLowerCase();
        s === "defaultValue" && "value" in t && t.value == null ? s = "value" : s === "download" && o === !0 ? o = "" : l === "ondoubleclick" ? s = "ondblclick" : l !== "onchange" || i !== "input" && i !== "textarea" || $2(t.type) ? l === "onfocus" ? s = "onfocusin" : l === "onblur" ? s = "onfocusout" : N2.test(s) ? s = l : i.indexOf("-") === -1 && B2.test(s) ? s = s.replace(P2, "-$&").toLowerCase() : o === null && (o = void 0) : l = s = "oninput", l === "oninput" && r[s = l] && (s = "oninputCapture"), r[s] = o;
      }
    }
    i == "select" && r.multiple && Array.isArray(r.value) && (r.value = ii(t.children).forEach(function(a) {
      a.props.selected = r.value.indexOf(a.props.value) != -1;
    })), i == "select" && r.defaultValue != null && (r.value = ii(t.children).forEach(function(a) {
      a.props.selected = r.multiple ? r.defaultValue.indexOf(a.props.value) != -1 : r.defaultValue == a.props.value;
    })), t.class && !t.className ? (r.class = t.class, Object.defineProperty(r, "className", W2)) : (t.className && !t.class || t.class && t.className) && (r.class = r.className = t.className), e.props = r;
  }(n), n.$$typeof = av, s0 && s0(n);
};
var o0 = P.__r;
P.__r = function(n) {
  o0 && o0(n), Up = n.__c;
};
var l0 = P.diffed;
P.diffed = function(n) {
  l0 && l0(n);
  var e = n.props, t = n.__e;
  t != null && n.type === "textarea" && "value" in e && e.value !== t.value && (t.value = e.value == null ? "" : e.value), Up = null;
};
var j2 = { ReactCurrentDispatcher: { current: { readContext: function(n) {
  return Up.__n[n.__c].props.value;
} } } };
function G2(n) {
  return dn.bind(null, n);
}
function yh(n) {
  return !!n && n.$$typeof === av;
}
function K2(n) {
  return yh(n) && n.type === oi;
}
function Y2(n) {
  return yh(n) ? w2.apply(null, arguments) : n;
}
function J2(n) {
  return !!n.__k && (jo(null, n), !0);
}
function Z2(n) {
  return n && (n.base || n.nodeType === 1 && n) || null;
}
var X2 = function(n, e) {
  return n(e);
}, Q2 = function(n, e) {
  return n(e);
}, eD = oi;
function cv(n) {
  n();
}
function tD(n) {
  return n;
}
function nD() {
  return [!1, cv];
}
var iD = bh, rD = yh;
function sD(n, e) {
  var t = e(), i = ht({ h: { __: t, v: e } }), r = i[0].h, s = i[1];
  return bh(function() {
    r.__ = t, r.v = e, yu(r.__, e()) || s({ h: r });
  }, [n, t, e]), Cr(function() {
    return yu(r.__, r.v()) || s({ h: r }), n(function() {
      yu(r.__, r.v()) || s({ h: r });
    });
  }, [n]), t;
}
var Ar = { useState: ht, useId: _2, useReducer: tv, useEffect: Cr, useLayoutEffect: bh, useInsertionEffect: iD, useTransition: nD, useDeferredValue: tD, useSyncExternalStore: sD, startTransition: cv, useRef: fs, useImperativeHandle: x2, useMemo: ni, useCallback: k2, useContext: nv, useDebugValue: Hf, version: "17.0.2", Children: T2, render: H2, hydrate: q2, unmountComponentAtNode: J2, createPortal: I2, createElement: dn, createContext: v2, createFactory: G2, cloneElement: Y2, createRef: p2, Fragment: oi, isValidElement: yh, isElement: rD, isFragment: K2, findDOMNode: Z2, Component: Fn, PureComponent: zf, memo: A2, forwardRef: E2, flushSync: Q2, unstable_batchedUpdates: X2, StrictMode: eD, Suspense: Wa, SuspenseList: wo, lazy: O2, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: j2 };
function oD(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function lD(n) {
  var e = n.default;
  if (typeof e == "function") {
    var t = function() {
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
var aD = function(e, t, i, r) {
  var s = i ? i.call(r, e, t) : void 0;
  if (s !== void 0)
    return !!s;
  if (e === t)
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  var o = Object.keys(e), l = Object.keys(t);
  if (o.length !== l.length)
    return !1;
  for (var a = Object.prototype.hasOwnProperty.bind(t), c = 0; c < o.length; c++) {
    var h = o[c];
    if (!a(h))
      return !1;
    var u = e[h], f = t[h];
    if (s = i ? i.call(r, u, f, h) : void 0, s === !1 || s === void 0 && u !== f)
      return !1;
  }
  return !0;
}, ve = "-ms-", Io = "-moz-", oe = "-webkit-", hv = "comm", wh = "rule", Wp = "decl", cD = "@import", uv = "@keyframes", hD = "@layer", uD = Math.abs, jp = String.fromCharCode, Uf = Object.assign;
function fD(n, e) {
  return Ze(n, 0) ^ 45 ? (((e << 2 ^ Ze(n, 0)) << 2 ^ Ze(n, 1)) << 2 ^ Ze(n, 2)) << 2 ^ Ze(n, 3) : 0;
}
function fv(n) {
  return n.trim();
}
function ei(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function Q(n, e, t) {
  return n.replace(e, t);
}
function ja(n, e) {
  return n.indexOf(e);
}
function Ze(n, e) {
  return n.charCodeAt(e) | 0;
}
function Es(n, e, t) {
  return n.slice(e, t);
}
function Dn(n) {
  return n.length;
}
function dv(n) {
  return n.length;
}
function vo(n, e) {
  return e.push(n), n;
}
function dD(n, e) {
  return n.map(e).join("");
}
function a0(n, e) {
  return n.filter(function(t) {
    return !ei(t, e);
  });
}
var vh = 1, Ts = 1, pv = 0, Zt = 0, $e = 0, Ys = "";
function xh(n, e, t, i, r, s, o, l) {
  return { value: n, root: e, parent: t, type: i, props: r, children: s, line: vh, column: Ts, length: o, return: "", siblings: l };
}
function xi(n, e) {
  return Uf(xh("", null, null, "", null, null, 0, n.siblings), n, { length: -n.length }, e);
}
function Jr(n) {
  for (; n.root; )
    n = xi(n.root, { children: [n] });
  vo(n, n.siblings);
}
function pD() {
  return $e;
}
function gD() {
  return $e = Zt > 0 ? Ze(Ys, --Zt) : 0, Ts--, $e === 10 && (Ts = 1, vh--), $e;
}
function hn() {
  return $e = Zt < pv ? Ze(Ys, Zt++) : 0, Ts++, $e === 10 && (Ts = 1, vh++), $e;
}
function mr() {
  return Ze(Ys, Zt);
}
function Ga() {
  return Zt;
}
function kh(n, e) {
  return Es(Ys, n, e);
}
function Wf(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function mD(n) {
  return vh = Ts = 1, pv = Dn(Ys = n), Zt = 0, [];
}
function bD(n) {
  return Ys = "", n;
}
function wu(n) {
  return fv(kh(Zt - 1, jf(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function yD(n) {
  for (; ($e = mr()) && $e < 33; )
    hn();
  return Wf(n) > 2 || Wf($e) > 3 ? "" : " ";
}
function wD(n, e) {
  for (; --e && hn() && !($e < 48 || $e > 102 || $e > 57 && $e < 65 || $e > 70 && $e < 97); )
    ;
  return kh(n, Ga() + (e < 6 && mr() == 32 && hn() == 32));
}
function jf(n) {
  for (; hn(); )
    switch ($e) {
      case n:
        return Zt;
      case 34:
      case 39:
        n !== 34 && n !== 39 && jf($e);
        break;
      case 40:
        n === 41 && jf(n);
        break;
      case 92:
        hn();
        break;
    }
  return Zt;
}
function vD(n, e) {
  for (; hn() && n + $e !== 47 + 10; )
    if (n + $e === 42 + 42 && mr() === 47)
      break;
  return "/*" + kh(e, Zt - 1) + "*" + jp(n === 47 ? n : hn());
}
function xD(n) {
  for (; !Wf(mr()); )
    hn();
  return kh(n, Zt);
}
function kD(n) {
  return bD(Ka("", null, null, null, [""], n = mD(n), 0, [0], n));
}
function Ka(n, e, t, i, r, s, o, l, a) {
  for (var c = 0, h = 0, u = o, f = 0, d = 0, p = 0, g = 1, m = 1, b = 1, y = 0, k = "", w = r, x = s, v = i, C = k; m; )
    switch (p = y, y = hn()) {
      case 40:
        if (p != 108 && Ze(C, u - 1) == 58) {
          ja(C += Q(wu(y), "&", "&\f"), "&\f") != -1 && (b = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        C += wu(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        C += yD(p);
        break;
      case 92:
        C += wD(Ga() - 1, 7);
        continue;
      case 47:
        switch (mr()) {
          case 42:
          case 47:
            vo(_D(vD(hn(), Ga()), e, t, a), a);
            break;
          default:
            C += "/";
        }
        break;
      case 123 * g:
        l[c++] = Dn(C) * b;
      case 125 * g:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            m = 0;
          case 59 + h:
            b == -1 && (C = Q(C, /\f/g, "")), d > 0 && Dn(C) - u && vo(d > 32 ? h0(C + ";", i, t, u - 1, a) : h0(Q(C, " ", "") + ";", i, t, u - 2, a), a);
            break;
          case 59:
            C += ";";
          default:
            if (vo(v = c0(C, e, t, c, h, r, l, k, w = [], x = [], u, s), s), y === 123)
              if (h === 0)
                Ka(C, e, v, v, w, s, u, l, x);
              else
                switch (f === 99 && Ze(C, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Ka(n, v, v, i && vo(c0(n, v, v, 0, 0, r, l, k, r, w = [], u, x), x), r, x, u, l, i ? w : x);
                    break;
                  default:
                    Ka(C, v, v, v, [""], x, 0, l, x);
                }
        }
        c = h = d = 0, g = b = 1, k = C = "", u = o;
        break;
      case 58:
        u = 1 + Dn(C), d = p;
      default:
        if (g < 1) {
          if (y == 123)
            --g;
          else if (y == 125 && g++ == 0 && gD() == 125)
            continue;
        }
        switch (C += jp(y), y * g) {
          case 38:
            b = h > 0 ? 1 : (C += "\f", -1);
            break;
          case 44:
            l[c++] = (Dn(C) - 1) * b, b = 1;
            break;
          case 64:
            mr() === 45 && (C += wu(hn())), f = mr(), h = u = Dn(k = C += xD(Ga())), y++;
            break;
          case 45:
            p === 45 && Dn(C) == 2 && (g = 0);
        }
    }
  return s;
}
function c0(n, e, t, i, r, s, o, l, a, c, h, u) {
  for (var f = r - 1, d = r === 0 ? s : [""], p = dv(d), g = 0, m = 0, b = 0; g < i; ++g)
    for (var y = 0, k = Es(n, f + 1, f = uD(m = o[g])), w = n; y < p; ++y)
      (w = fv(m > 0 ? d[y] + " " + k : Q(k, /&\f/g, d[y]))) && (a[b++] = w);
  return xh(n, e, t, r === 0 ? wh : l, a, c, h, u);
}
function _D(n, e, t, i) {
  return xh(n, e, t, hv, jp(pD()), Es(n, 2, -2), 0, i);
}
function h0(n, e, t, i, r) {
  return xh(n, e, t, Wp, Es(n, 0, i), Es(n, i + 1, -1), i, r);
}
function gv(n, e, t) {
  switch (fD(n, e)) {
    case 5103:
      return oe + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return oe + n + n;
    case 4789:
      return Io + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return oe + n + Io + n + ve + n + n;
    case 5936:
      switch (Ze(n, e + 11)) {
        case 114:
          return oe + n + ve + Q(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return oe + n + ve + Q(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return oe + n + ve + Q(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
    case 6828:
    case 4268:
    case 2903:
      return oe + n + ve + n + n;
    case 6165:
      return oe + n + ve + "flex-" + n + n;
    case 5187:
      return oe + n + Q(n, /(\w+).+(:[^]+)/, oe + "box-$1$2" + ve + "flex-$1$2") + n;
    case 5443:
      return oe + n + ve + "flex-item-" + Q(n, /flex-|-self/g, "") + (ei(n, /flex-|baseline/) ? "" : ve + "grid-row-" + Q(n, /flex-|-self/g, "")) + n;
    case 4675:
      return oe + n + ve + "flex-line-pack" + Q(n, /align-content|flex-|-self/g, "") + n;
    case 5548:
      return oe + n + ve + Q(n, "shrink", "negative") + n;
    case 5292:
      return oe + n + ve + Q(n, "basis", "preferred-size") + n;
    case 6060:
      return oe + "box-" + Q(n, "-grow", "") + oe + n + ve + Q(n, "grow", "positive") + n;
    case 4554:
      return oe + Q(n, /([^-])(transform)/g, "$1" + oe + "$2") + n;
    case 6187:
      return Q(Q(Q(n, /(zoom-|grab)/, oe + "$1"), /(image-set)/, oe + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return Q(n, /(image-set\([^]*)/, oe + "$1$`$1");
    case 4968:
      return Q(Q(n, /(.+:)(flex-)?(.*)/, oe + "box-pack:$3" + ve + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + oe + n + n;
    case 4200:
      if (!ei(n, /flex-|baseline/))
        return ve + "grid-column-align" + Es(n, e) + n;
      break;
    case 2592:
    case 3360:
      return ve + Q(n, "template-", "") + n;
    case 4384:
    case 3616:
      return t && t.some(function(i, r) {
        return e = r, ei(i.props, /grid-\w+-end/);
      }) ? ~ja(n + (t = t[e].value), "span") ? n : ve + Q(n, "-start", "") + n + ve + "grid-row-span:" + (~ja(t, "span") ? ei(t, /\d+/) : +ei(t, /\d+/) - +ei(n, /\d+/)) + ";" : ve + Q(n, "-start", "") + n;
    case 4896:
    case 4128:
      return t && t.some(function(i) {
        return ei(i.props, /grid-\w+-start/);
      }) ? n : ve + Q(Q(n, "-end", "-span"), "span ", "") + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Q(n, /(.+)-inline(.+)/, oe + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Dn(n) - 1 - e > 6)
        switch (Ze(n, e + 1)) {
          case 109:
            if (Ze(n, e + 4) !== 45)
              break;
          case 102:
            return Q(n, /(.+:)(.+)-([^]+)/, "$1" + oe + "$2-$3$1" + Io + (Ze(n, e + 3) == 108 ? "$3" : "$2-$3")) + n;
          case 115:
            return ~ja(n, "stretch") ? gv(Q(n, "stretch", "fill-available"), e, t) + n : n;
        }
      break;
    case 5152:
    case 5920:
      return Q(n, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(i, r, s, o, l, a, c) {
        return ve + r + ":" + s + c + (o ? ve + r + "-span:" + (l ? a : +a - +s) + c : "") + n;
      });
    case 4949:
      if (Ze(n, e + 6) === 121)
        return Q(n, ":", ":" + oe) + n;
      break;
    case 6444:
      switch (Ze(n, Ze(n, 14) === 45 ? 18 : 11)) {
        case 120:
          return Q(n, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + oe + (Ze(n, 14) === 45 ? "inline-" : "") + "box$3$1" + oe + "$2$3$1" + ve + "$2box$3") + n;
        case 100:
          return Q(n, ":", ":" + ve) + n;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return Q(n, "scroll-", "scroll-snap-") + n;
  }
  return n;
}
function yc(n, e) {
  for (var t = "", i = 0; i < n.length; i++)
    t += e(n[i], i, n, e) || "";
  return t;
}
function SD(n, e, t, i) {
  switch (n.type) {
    case hD:
      if (n.children.length)
        break;
    case cD:
    case Wp:
      return n.return = n.return || n.value;
    case hv:
      return "";
    case uv:
      return n.return = n.value + "{" + yc(n.children, i) + "}";
    case wh:
      if (!Dn(n.value = n.props.join(",")))
        return "";
  }
  return Dn(t = yc(n.children, i)) ? n.return = n.value + "{" + t + "}" : "";
}
function CD(n) {
  var e = dv(n);
  return function(t, i, r, s) {
    for (var o = "", l = 0; l < e; l++)
      o += n[l](t, i, r, s) || "";
    return o;
  };
}
function AD(n) {
  return function(e) {
    e.root || (e = e.return) && n(e);
  };
}
function DD(n, e, t, i) {
  if (n.length > -1 && !n.return)
    switch (n.type) {
      case Wp:
        n.return = gv(n.value, n.length, t);
        return;
      case uv:
        return yc([xi(n, { value: Q(n.value, "@", "@" + oe) })], i);
      case wh:
        if (n.length)
          return dD(t = n.props, function(r) {
            switch (ei(r, i = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                Jr(xi(n, { props: [Q(r, /:(read-\w+)/, ":" + Io + "$1")] })), Jr(xi(n, { props: [r] })), Uf(n, { props: a0(t, i) });
                break;
              case "::placeholder":
                Jr(xi(n, { props: [Q(r, /:(plac\w+)/, ":" + oe + "input-$1")] })), Jr(xi(n, { props: [Q(r, /:(plac\w+)/, ":" + Io + "$1")] })), Jr(xi(n, { props: [Q(r, /:(plac\w+)/, ve + "input-$1")] })), Jr(xi(n, { props: [r] })), Uf(n, { props: a0(t, i) });
                break;
            }
            return "";
          });
    }
}
var ED = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Dr = typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", Gp = typeof window < "u" && "HTMLElement" in window, TD = Boolean(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" ? {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY : {}.NODE_ENV !== "production"), u0 = /invalid hook call/i, Zl = /* @__PURE__ */ new Set(), MD = function(n, e) {
  if ({}.NODE_ENV !== "production") {
    var t = e ? ' with the id of "'.concat(e, '"') : "", i = "The component ".concat(n).concat(t, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, r = console.error;
    try {
      var s = !0;
      console.error = function(o) {
        for (var l = [], a = 1; a < arguments.length; a++)
          l[a - 1] = arguments[a];
        u0.test(o) ? (s = !1, Zl.delete(i)) : r.apply(void 0, As([o], l, !1));
      }, fs(), s && !Zl.has(i) && (console.warn(i), Zl.add(i));
    } catch (o) {
      u0.test(o.message) && Zl.delete(i);
    } finally {
      console.error = r;
    }
  }
}, _h = Object.freeze([]), Ms = Object.freeze({});
function OD(n, e, t) {
  return t === void 0 && (t = Ms), n.theme !== t.theme && n.theme || e || t.theme;
}
var Gf = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), LD = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, RD = /(^-|-$)/g;
function f0(n) {
  return n.replace(LD, "-").replace(RD, "");
}
var ID = /(a)(d)/gi, d0 = function(n) {
  return String.fromCharCode(n + (n > 25 ? 39 : 97));
};
function Kf(n) {
  var e, t = "";
  for (e = Math.abs(n); e > 52; e = e / 52 | 0)
    t = d0(e % 52) + t;
  return (d0(e % 52) + t).replace(ID, "$1-$2");
}
var vu, lr = function(n, e) {
  for (var t = e.length; t; )
    n = 33 * n ^ e.charCodeAt(--t);
  return n;
}, mv = function(n) {
  return lr(5381, n);
};
function BD(n) {
  return Kf(mv(n) >>> 0);
}
function bv(n) {
  return {}.NODE_ENV !== "production" && typeof n == "string" && n || n.displayName || n.name || "Component";
}
function xu(n) {
  return typeof n == "string" && ({}.NODE_ENV === "production" || n.charAt(0) === n.charAt(0).toLowerCase());
}
var yv = typeof Symbol == "function" && Symbol.for, wv = yv ? Symbol.for("react.memo") : 60115, ND = yv ? Symbol.for("react.forward_ref") : 60112, PD = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, FD = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, vv = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, $D = ((vu = {})[ND] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, vu[wv] = vv, vu);
function p0(n) {
  return ("type" in (e = n) && e.type.$$typeof) === wv ? vv : "$$typeof" in n ? $D[n.$$typeof] : PD;
  var e;
}
var HD = Object.defineProperty, qD = Object.getOwnPropertyNames, g0 = Object.getOwnPropertySymbols, VD = Object.getOwnPropertyDescriptor, zD = Object.getPrototypeOf, m0 = Object.prototype;
function xv(n, e, t) {
  if (typeof e != "string") {
    if (m0) {
      var i = zD(e);
      i && i !== m0 && xv(n, i, t);
    }
    var r = qD(e);
    g0 && (r = r.concat(g0(e)));
    for (var s = p0(n), o = p0(e), l = 0; l < r.length; ++l) {
      var a = r[l];
      if (!(a in FD || t && t[a] || o && a in o || s && a in s)) {
        var c = VD(e, a);
        try {
          HD(n, a, c);
        } catch {
        }
      }
    }
  }
  return n;
}
function Os(n) {
  return typeof n == "function";
}
function Kp(n) {
  return typeof n == "object" && "styledComponentId" in n;
}
function hr(n, e) {
  return n && e ? "".concat(n, " ").concat(e) : n || e || "";
}
function b0(n, e) {
  if (n.length === 0)
    return "";
  for (var t = n[0], i = 1; i < n.length; i++)
    t += e ? e + n[i] : n[i];
  return t;
}
function Ls(n) {
  return n !== null && typeof n == "object" && n.constructor.name === Object.name && !("props" in n && n.$$typeof);
}
function Yf(n, e, t) {
  if (t === void 0 && (t = !1), !t && !Ls(n) && !Array.isArray(n))
    return e;
  if (Array.isArray(e))
    for (var i = 0; i < e.length; i++)
      n[i] = Yf(n[i], e[i]);
  else if (Ls(e))
    for (var i in e)
      n[i] = Yf(n[i], e[i]);
  return n;
}
function Yp(n, e) {
  Object.defineProperty(n, "toString", { value: e });
}
var UD = {}.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function WD() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n[e] = arguments[e];
  for (var t = n[0], i = [], r = 1, s = n.length; r < s; r += 1)
    i.push(n[r]);
  return i.forEach(function(o) {
    t = t.replace(/%[a-z]/, o);
  }), t;
}
function Js(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return {}.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(n, " for more information.").concat(e.length > 0 ? " Args: ".concat(e.join(", ")) : "")) : new Error(WD.apply(void 0, As([UD[n]], e, !1)).trim());
}
var jD = function() {
  function n(e) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e;
  }
  return n.prototype.indexOfGroup = function(e) {
    for (var t = 0, i = 0; i < e; i++)
      t += this.groupSizes[i];
    return t;
  }, n.prototype.insertRules = function(e, t) {
    if (e >= this.groupSizes.length) {
      for (var i = this.groupSizes, r = i.length, s = r; e >= s; )
        if ((s <<= 1) < 0)
          throw Js(16, "".concat(e));
      this.groupSizes = new Uint32Array(s), this.groupSizes.set(i), this.length = s;
      for (var o = r; o < s; o++)
        this.groupSizes[o] = 0;
    }
    for (var l = this.indexOfGroup(e + 1), a = (o = 0, t.length); o < a; o++)
      this.tag.insertRule(l, t[o]) && (this.groupSizes[e]++, l++);
  }, n.prototype.clearGroup = function(e) {
    if (e < this.length) {
      var t = this.groupSizes[e], i = this.indexOfGroup(e), r = i + t;
      this.groupSizes[e] = 0;
      for (var s = i; s < r; s++)
        this.tag.deleteRule(i);
    }
  }, n.prototype.getGroup = function(e) {
    var t = "";
    if (e >= this.length || this.groupSizes[e] === 0)
      return t;
    for (var i = this.groupSizes[e], r = this.indexOfGroup(e), s = r + i, o = r; o < s; o++)
      t += "".concat(this.tag.getRule(o)).concat(`/*!sc*/
`);
    return t;
  }, n;
}(), Ya = /* @__PURE__ */ new Map(), wc = /* @__PURE__ */ new Map(), ku = 1, Xl = function(n) {
  if (Ya.has(n))
    return Ya.get(n);
  for (; wc.has(ku); )
    ku++;
  var e = ku++;
  if ({}.NODE_ENV !== "production" && ((0 | e) < 0 || e > 1073741824))
    throw Js(16, "".concat(e));
  return Ya.set(n, e), wc.set(e, n), e;
}, GD = function(n, e) {
  Ya.set(n, e), wc.set(e, n);
}, KD = "style[".concat(Dr, "][").concat("data-styled-version", '="').concat("6.0.7", '"]'), YD = new RegExp("^".concat(Dr, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), JD = function(n, e, t) {
  for (var i, r = t.split(","), s = 0, o = r.length; s < o; s++)
    (i = r[s]) && n.registerName(e, i);
}, ZD = function(n, e) {
  for (var t, i = ((t = e.textContent) !== null && t !== void 0 ? t : "").split(`/*!sc*/
`), r = [], s = 0, o = i.length; s < o; s++) {
    var l = i[s].trim();
    if (l) {
      var a = l.match(YD);
      if (a) {
        var c = 0 | parseInt(a[1], 10), h = a[2];
        c !== 0 && (GD(h, c), JD(n, h, a[3]), n.getTag().insertRules(c, r)), r.length = 0;
      } else
        r.push(l);
    }
  }
};
function XD() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var kv = function(n) {
  var e = document.head, t = n || e, i = document.createElement("style"), r = function(l) {
    var a = Array.from(l.querySelectorAll("style[".concat(Dr, "]")));
    return a[a.length - 1];
  }(t), s = r !== void 0 ? r.nextSibling : null;
  i.setAttribute(Dr, "active"), i.setAttribute("data-styled-version", "6.0.7");
  var o = XD();
  return o && i.setAttribute("nonce", o), t.insertBefore(i, s), i;
}, QD = function() {
  function n(e) {
    this.element = kv(e), this.element.appendChild(document.createTextNode("")), this.sheet = function(t) {
      if (t.sheet)
        return t.sheet;
      for (var i = document.styleSheets, r = 0, s = i.length; r < s; r++) {
        var o = i[r];
        if (o.ownerNode === t)
          return o;
      }
      throw Js(17);
    }(this.element), this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    try {
      return this.sheet.insertRule(t, e), this.length++, !0;
    } catch {
      return !1;
    }
  }, n.prototype.deleteRule = function(e) {
    this.sheet.deleteRule(e), this.length--;
  }, n.prototype.getRule = function(e) {
    var t = this.sheet.cssRules[e];
    return t && t.cssText ? t.cssText : "";
  }, n;
}(), eE = function() {
  function n(e) {
    this.element = kv(e), this.nodes = this.element.childNodes, this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    if (e <= this.length && e >= 0) {
      var i = document.createTextNode(t);
      return this.element.insertBefore(i, this.nodes[e] || null), this.length++, !0;
    }
    return !1;
  }, n.prototype.deleteRule = function(e) {
    this.element.removeChild(this.nodes[e]), this.length--;
  }, n.prototype.getRule = function(e) {
    return e < this.length ? this.nodes[e].textContent : "";
  }, n;
}(), tE = function() {
  function n(e) {
    this.rules = [], this.length = 0;
  }
  return n.prototype.insertRule = function(e, t) {
    return e <= this.length && (this.rules.splice(e, 0, t), this.length++, !0);
  }, n.prototype.deleteRule = function(e) {
    this.rules.splice(e, 1), this.length--;
  }, n.prototype.getRule = function(e) {
    return e < this.length ? this.rules[e] : "";
  }, n;
}(), y0 = Gp, nE = { isServer: !Gp, useCSSOMInjection: !TD }, _v = function() {
  function n(e, t, i) {
    e === void 0 && (e = Ms), t === void 0 && (t = {});
    var r = this;
    this.options = Tt(Tt({}, nE), e), this.gs = t, this.names = new Map(i), this.server = !!e.isServer, !this.server && Gp && y0 && (y0 = !1, function(s) {
      for (var o = document.querySelectorAll(KD), l = 0, a = o.length; l < a; l++) {
        var c = o[l];
        c && c.getAttribute(Dr) !== "active" && (ZD(s, c), c.parentNode && c.parentNode.removeChild(c));
      }
    }(this)), Yp(this, function() {
      return function(s) {
        for (var o = s.getTag(), l = o.length, a = "", c = function(u) {
          var f = function(b) {
            return wc.get(b);
          }(u);
          if (f === void 0)
            return "continue";
          var d = s.names.get(f), p = o.getGroup(u);
          if (d === void 0 || p.length === 0)
            return "continue";
          var g = "".concat(Dr, ".g").concat(u, '[id="').concat(f, '"]'), m = "";
          d !== void 0 && d.forEach(function(b) {
            b.length > 0 && (m += "".concat(b, ","));
          }), a += "".concat(p).concat(g, '{content:"').concat(m, '"}').concat(`/*!sc*/
`);
        }, h = 0; h < l; h++)
          c(h);
        return a;
      }(r);
    });
  }
  return n.registerId = function(e) {
    return Xl(e);
  }, n.prototype.reconstructWithOptions = function(e, t) {
    return t === void 0 && (t = !0), new n(Tt(Tt({}, this.options), e), this.gs, t && this.names || void 0);
  }, n.prototype.allocateGSInstance = function(e) {
    return this.gs[e] = (this.gs[e] || 0) + 1;
  }, n.prototype.getTag = function() {
    return this.tag || (this.tag = (e = function(t) {
      var i = t.useCSSOMInjection, r = t.target;
      return t.isServer ? new tE(r) : i ? new QD(r) : new eE(r);
    }(this.options), new jD(e)));
    var e;
  }, n.prototype.hasNameForId = function(e, t) {
    return this.names.has(e) && this.names.get(e).has(t);
  }, n.prototype.registerName = function(e, t) {
    if (Xl(e), this.names.has(e))
      this.names.get(e).add(t);
    else {
      var i = /* @__PURE__ */ new Set();
      i.add(t), this.names.set(e, i);
    }
  }, n.prototype.insertRules = function(e, t, i) {
    this.registerName(e, t), this.getTag().insertRules(Xl(e), i);
  }, n.prototype.clearNames = function(e) {
    this.names.has(e) && this.names.get(e).clear();
  }, n.prototype.clearRules = function(e) {
    this.getTag().clearGroup(Xl(e)), this.clearNames(e);
  }, n.prototype.clearTag = function() {
    this.tag = void 0;
  }, n;
}(), iE = /&/g, rE = /^\s*\/\/.*$/gm;
function Sv(n, e) {
  return n.map(function(t) {
    return t.type === "rule" && (t.value = "".concat(e, " ").concat(t.value), t.value = t.value.replaceAll(",", ",".concat(e, " ")), t.props = t.props.map(function(i) {
      return "".concat(e, " ").concat(i);
    })), Array.isArray(t.children) && t.type !== "@keyframes" && (t.children = Sv(t.children, e)), t;
  });
}
function Cv(n) {
  var e, t, i, r = n === void 0 ? Ms : n, s = r.options, o = s === void 0 ? Ms : s, l = r.plugins, a = l === void 0 ? _h : l, c = function(f, d, p) {
    return p === t || p.startsWith(t) && p.endsWith(t) && p.replaceAll(t, "").length > 0 ? ".".concat(e) : f;
  }, h = a.slice();
  h.push(function(f) {
    f.type === wh && f.value.includes("&") && (f.props[0] = f.props[0].replace(iE, t).replace(i, c));
  }), o.prefix && h.push(DD), h.push(SD);
  var u = function(f, d, p, g) {
    d === void 0 && (d = ""), p === void 0 && (p = ""), g === void 0 && (g = "&"), e = g, t = d, i = new RegExp("\\".concat(t, "\\b"), "g");
    var m = f.replace(rE, ""), b = kD(p || d ? "".concat(p, " ").concat(d, " { ").concat(m, " }") : m);
    o.namespace && (b = Sv(b, o.namespace));
    var y = [];
    return yc(b, CD(h.concat(AD(function(k) {
      return y.push(k);
    })))), y;
  };
  return u.hash = a.length ? a.reduce(function(f, d) {
    return d.name || Js(15), lr(f, d.name);
  }, 5381).toString() : "", u;
}
var sE = new _v(), Jf = Cv(), Jp = Ar.createContext({ shouldForwardProp: void 0, styleSheet: sE, stylis: Jf });
Jp.Consumer;
var oE = Ar.createContext(void 0);
function Zf() {
  return nv(Jp);
}
function lE(n) {
  var e = ht(n.stylisPlugins), t = e[0], i = e[1], r = Zf().styleSheet, s = ni(function() {
    var l = r;
    return n.sheet ? l = n.sheet : n.target && (l = l.reconstructWithOptions({ target: n.target }, !1)), n.disableCSSOMInjection && (l = l.reconstructWithOptions({ useCSSOMInjection: !1 })), l;
  }, [n.disableCSSOMInjection, n.sheet, n.target, r]), o = ni(function() {
    return Cv({ options: { namespace: n.namespace, prefix: n.enableVendorPrefixes }, plugins: t });
  }, [n.enableVendorPrefixes, n.namespace, t]);
  return Cr(function() {
    aD(t, n.stylisPlugins) || i(n.stylisPlugins);
  }, [n.stylisPlugins]), Ar.createElement(Jp.Provider, { value: { shouldForwardProp: n.shouldForwardProp, styleSheet: s, stylis: o } }, Ar.createElement(oE.Provider, { value: o }, n.children));
}
var w0 = function() {
  function n(e, t) {
    var i = this;
    this.inject = function(r, s) {
      s === void 0 && (s = Jf);
      var o = i.name + s.hash;
      r.hasNameForId(i.id, o) || r.insertRules(i.id, o, s(i.rules, o, "@keyframes"));
    }, this.name = e, this.id = "sc-keyframes-".concat(e), this.rules = t, Yp(this, function() {
      throw Js(12, String(i.name));
    });
  }
  return n.prototype.getName = function(e) {
    return e === void 0 && (e = Jf), this.name + e.hash;
  }, n;
}(), aE = function(n) {
  return n >= "A" && n <= "Z";
};
function v0(n) {
  for (var e = "", t = 0; t < n.length; t++) {
    var i = n[t];
    if (t === 1 && i === "-" && n[0] === "-")
      return n;
    aE(i) ? e += "-" + i.toLowerCase() : e += i;
  }
  return e.startsWith("ms-") ? "-" + e : e;
}
var Av = function(n) {
  return n == null || n === !1 || n === "";
}, Dv = function(n) {
  var e, t, i = [];
  for (var r in n) {
    var s = n[r];
    n.hasOwnProperty(r) && !Av(s) && (Array.isArray(s) && s.isCss || Os(s) ? i.push("".concat(v0(r), ":"), s, ";") : Ls(s) ? i.push.apply(i, As(As(["".concat(r, " {")], Dv(s), !1), ["}"], !1)) : i.push("".concat(v0(r), ": ").concat((e = r, (t = s) == null || typeof t == "boolean" || t === "" ? "" : typeof t != "number" || t === 0 || e in ED || e.startsWith("--") ? String(t).trim() : "".concat(t, "px")), ";")));
  }
  return i;
};
function br(n, e, t, i) {
  if (Av(n))
    return [];
  if (Kp(n))
    return [".".concat(n.styledComponentId)];
  if (Os(n)) {
    if (!Os(s = n) || s.prototype && s.prototype.isReactComponent || !e)
      return [n];
    var r = n(e);
    return {}.NODE_ENV === "production" || typeof r != "object" || Array.isArray(r) || r instanceof w0 || Ls(r) || r === null || console.error("".concat(bv(n), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), br(r, e, t, i);
  }
  var s;
  return n instanceof w0 ? t ? (n.inject(t, i), [n.getName(i)]) : [n] : Ls(n) ? Dv(n) : Array.isArray(n) ? Array.prototype.concat.apply(_h, n.map(function(o) {
    return br(o, e, t, i);
  })) : [n.toString()];
}
function cE(n) {
  for (var e = 0; e < n.length; e += 1) {
    var t = n[e];
    if (Os(t) && !Kp(t))
      return !1;
  }
  return !0;
}
var hE = mv("6.0.7"), uE = function() {
  function n(e, t, i) {
    this.rules = e, this.staticRulesId = "", this.isStatic = {}.NODE_ENV === "production" && (i === void 0 || i.isStatic) && cE(e), this.componentId = t, this.baseHash = lr(hE, t), this.baseStyle = i, _v.registerId(t);
  }
  return n.prototype.generateAndInjectStyles = function(e, t, i) {
    var r = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e, t, i) : "";
    if (this.isStatic && !i.hash)
      if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId))
        r = hr(r, this.staticRulesId);
      else {
        var s = b0(br(this.rules, e, t, i)), o = Kf(lr(this.baseHash, s) >>> 0);
        if (!t.hasNameForId(this.componentId, o)) {
          var l = i(s, ".".concat(o), void 0, this.componentId);
          t.insertRules(this.componentId, o, l);
        }
        r = hr(r, o), this.staticRulesId = o;
      }
    else {
      for (var a = lr(this.baseHash, i.hash), c = "", h = 0; h < this.rules.length; h++) {
        var u = this.rules[h];
        if (typeof u == "string")
          c += u, {}.NODE_ENV !== "production" && (a = lr(a, u));
        else if (u) {
          var f = b0(br(u, e, t, i));
          a = lr(a, f), c += f;
        }
      }
      if (c) {
        var d = Kf(a >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, i(c, ".".concat(d), void 0, this.componentId)), r = hr(r, d);
      }
    }
    return r;
  }, n;
}(), Ev = Ar.createContext(void 0);
Ev.Consumer;
var _u = {}, x0 = /* @__PURE__ */ new Set();
function fE(n, e, t) {
  var i = Kp(n), r = n, s = !xu(n), o = e.attrs, l = o === void 0 ? _h : o, a = e.componentId, c = a === void 0 ? function(w, x) {
    var v = typeof w != "string" ? "sc" : f0(w);
    _u[v] = (_u[v] || 0) + 1;
    var C = "".concat(v, "-").concat(BD("6.0.7" + v + _u[v]));
    return x ? "".concat(x, "-").concat(C) : C;
  }(e.displayName, e.parentComponentId) : a, h = e.displayName, u = h === void 0 ? function(w) {
    return xu(w) ? "styled.".concat(w) : "Styled(".concat(bv(w), ")");
  }(n) : h, f = e.displayName && e.componentId ? "".concat(f0(e.displayName), "-").concat(e.componentId) : e.componentId || c, d = i && r.attrs ? r.attrs.concat(l).filter(Boolean) : l, p = e.shouldForwardProp;
  if (i && r.shouldForwardProp) {
    var g = r.shouldForwardProp;
    if (e.shouldForwardProp) {
      var m = e.shouldForwardProp;
      p = function(w, x) {
        return g(w, x) && m(w, x);
      };
    } else
      p = g;
  }
  var b = new uE(t, f, i ? r.componentStyle : void 0);
  function y(w, x) {
    return function(v, C, B) {
      var R = v.attrs, T = v.componentStyle, z = v.defaultProps, se = v.foldedComponentIds, ee = v.styledComponentId, A = v.target, j = Ar.useContext(Ev), q = Zf(), we = v.shouldForwardProp || q.shouldForwardProp;
      ({}).NODE_ENV !== "production" && Hf(ee);
      var ce = function(ge, wi, me) {
        for (var zt, on = Tt(Tt({}, wi), { className: void 0, theme: me }), zr = 0; zr < ge.length; zr += 1) {
          var vi = Os(zt = ge[zr]) ? zt(on) : zt;
          for (var ln in vi)
            on[ln] = ln === "className" ? hr(on[ln], vi[ln]) : ln === "style" ? Tt(Tt({}, on[ln]), vi[ln]) : vi[ln];
        }
        return wi.className && (on.className = hr(on.className, wi.className)), on;
      }(R, C, OD(C, j, z) || Ms), le = ce.as || A, he = {};
      for (var De in ce)
        ce[De] === void 0 || De[0] === "$" || De === "as" || De === "theme" || (De === "forwardedAs" ? he.as = ce.forwardedAs : we && !we(De, le) || (he[De] = ce[De], we || {}.NODE_ENV !== "development" || f2(De) || x0.has(De) || !Gf.has(le) || (x0.add(De), console.warn('styled-components: it looks like an unknown prop "'.concat(De, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var ae = function(ge, wi) {
        var me = Zf(), zt = ge.generateAndInjectStyles(wi, me.styleSheet, me.stylis);
        return {}.NODE_ENV !== "production" && Hf(zt), zt;
      }(T, ce);
      ({}).NODE_ENV !== "production" && v.warnTooManyClasses && v.warnTooManyClasses(ae);
      var sn = hr(se, ee);
      return ae && (sn += " " + ae), ce.className && (sn += " " + ce.className), he[xu(le) && !Gf.has(le) ? "class" : "className"] = sn, he.ref = B, dn(le, he);
    }(k, w, x);
  }
  ({}).NODE_ENV !== "production" && (y.displayName = u);
  var k = Ar.forwardRef(y);
  return k.attrs = d, k.componentStyle = b, k.shouldForwardProp = p, {}.NODE_ENV !== "production" && (k.displayName = u), k.foldedComponentIds = i ? hr(r.foldedComponentIds, r.styledComponentId) : "", k.styledComponentId = f, k.target = i ? r.target : n, Object.defineProperty(k, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(w) {
    this._foldedDefaultProps = i ? function(x) {
      for (var v = [], C = 1; C < arguments.length; C++)
        v[C - 1] = arguments[C];
      for (var B = 0, R = v; B < R.length; B++)
        Yf(x, R[B], !0);
      return x;
    }({}, r.defaultProps, w) : w;
  } }), {}.NODE_ENV !== "production" && (MD(u, f), k.warnTooManyClasses = function(w, x) {
    var v = {}, C = !1;
    return function(B) {
      if (!C && (v[B] = !0, Object.keys(v).length >= 200)) {
        var R = x ? ' with the id of "'.concat(x, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(w).concat(R, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), C = !0, v = {};
      }
    };
  }(u, f)), Yp(k, function() {
    return ".".concat(k.styledComponentId);
  }), s && xv(k, n, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), k;
}
function k0(n, e) {
  for (var t = [n[0]], i = 0, r = e.length; i < r; i += 1)
    t.push(e[i], n[i + 1]);
  return t;
}
var _0 = function(n) {
  return Object.assign(n, { isCss: !0 });
};
function ds(n) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  if (Os(n) || Ls(n)) {
    var i = n;
    return _0(br(k0(_h, As([i], e, !0))));
  }
  var r = n;
  return e.length === 0 && r.length === 1 && typeof r[0] == "string" ? br(r) : _0(br(k0(r, e)));
}
function Xf(n, e, t) {
  if (t === void 0 && (t = Ms), !e)
    throw Js(1, e);
  var i = function(r) {
    for (var s = [], o = 1; o < arguments.length; o++)
      s[o - 1] = arguments[o];
    return n(e, t, ds.apply(void 0, As([r], s, !1)));
  };
  return i.attrs = function(r) {
    return Xf(n, e, Tt(Tt({}, t), { attrs: Array.prototype.concat(t.attrs, r).filter(Boolean) }));
  }, i.withConfig = function(r) {
    return Xf(n, e, Tt(Tt({}, t), r));
  }, i;
}
var Tv = function(n) {
  return Xf(fE, n);
}, Ae = Tv;
Gf.forEach(function(n) {
  Ae[n] = Tv(n);
});
({}).NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var Ql = "__sc-".concat(Dr, "__");
({}).NODE_ENV !== "production" && {}.NODE_ENV !== "test" && typeof window < "u" && (window[Ql] || (window[Ql] = 0), window[Ql] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[Ql] += 1);
var Mv = function(n, e, t, i) {
  var r;
  e[0] = 0;
  for (var s = 1; s < e.length; s++) {
    var o = e[s++], l = e[s] ? (e[0] |= o ? 1 : 2, t[e[s++]]) : e[++s];
    o === 3 ? i[0] = l : o === 4 ? i[1] = Object.assign(i[1] || {}, l) : o === 5 ? (i[1] = i[1] || {})[e[++s]] = l : o === 6 ? i[1][e[++s]] += l + "" : o ? (r = n.apply(l, Mv(n, l, t, ["", null])), i.push(r), l[0] ? e[0] |= 2 : (e[s - 2] = 0, e[s] = r)) : i.push(l);
  }
  return i;
}, S0 = /* @__PURE__ */ new Map();
function dE(n) {
  var e = S0.get(this);
  return e || (e = /* @__PURE__ */ new Map(), S0.set(this, e)), (e = Mv(this, e.get(n) || (e.set(n, e = function(t) {
    for (var i, r, s = 1, o = "", l = "", a = [0], c = function(f) {
      s === 1 && (f || (o = o.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? a.push(0, f, o) : s === 3 && (f || o) ? (a.push(3, f, o), s = 2) : s === 2 && o === "..." && f ? a.push(4, f, 0) : s === 2 && o && !f ? a.push(5, 0, !0, o) : s >= 5 && ((o || !f && s === 5) && (a.push(s, 0, o, r), s = 6), f && (a.push(s, f, 0, r), s = 6)), o = "";
    }, h = 0; h < t.length; h++) {
      h && (s === 1 && c(), c(h));
      for (var u = 0; u < t[h].length; u++)
        i = t[h][u], s === 1 ? i === "<" ? (c(), a = [a], s = 3) : o += i : s === 4 ? o === "--" && i === ">" ? (s = 1, o = "") : o = i + o[0] : l ? i === l ? l = "" : o += i : i === '"' || i === "'" ? l = i : i === ">" ? (c(), s = 1) : s && (i === "=" ? (s = 5, r = o, o = "") : i === "/" && (s < 5 || t[h][u + 1] === ">") ? (c(), s === 3 && (a = a[0]), s = a, (a = a[0]).push(2, 0, s), s = 0) : i === " " || i === "	" || i === `
` || i === "\r" ? (c(), s = 2) : o += i), s === 3 && o === "!--" && (s = 4, a = a[0]);
    }
    return c(), a;
  }(n)), e), arguments, [])).length > 1 ? e : e[0];
}
var yt = dE.bind(dn);
class Zi {
  constructor(e) {
    this.state = e;
  }
  run(e) {
    return [];
  }
}
class pE extends Zi {
  run(e) {
    const t = new this.state.Token("code_inline", "code", 0);
    return t.content = e.content, [t];
  }
}
const gE = {
  raw: pE
}, Qf = "math_inline";
class mE extends Zi {
  run(e) {
    const t = new this.state.Token(Qf, "span", 0);
    return t.attrSet("class", "math inline"), t.markup = "$", t.content = e.content, [t];
  }
}
function bE(n, e) {
  var t;
  !(!((t = e == null ? void 0 : e.roles) === null || t === void 0) && t.math) || n.renderer.rules[Qf] || (n.renderer.rules[Qf] = (i, r) => {
    var s, o, l;
    const a = (l = (o = (s = e == null ? void 0 : e.opts) === null || s === void 0 ? void 0 : s.math) === null || o === void 0 ? void 0 : o.renderer) !== null && l !== void 0 ? l : (f) => n.utils.escapeHtml(f), c = i[r], h = c.content.trim(), u = a(h, { displayMode: !1 });
    return `<span class="${c.attrGet("class")}">${u}</span>`;
  });
}
const yE = {
  math: mE
};
function wE(n, e) {
  e.parseRoles && n.inline.ruler.before("backticks", "parse_roles", vE), n.core.ruler.after(e.rolesAfter || "inline", "run_roles", kE(e.roles || {})), n.renderer.rules.role = (t, i) => {
    const r = t[i];
    return `<span class="role-unhandled"><mark>${r.meta.name}</mark><code>${r.content}</code></span>`;
  }, bE(n, e);
}
function vE(n, e) {
  if (n.src.charCodeAt(n.pos - 1) === 92)
    return !1;
  const t = xE.exec(n.src.slice(n.pos));
  if (t == null)
    return !1;
  const [i, r, , s] = t;
  if (n.pos += i.length, !e) {
    const o = n.push("role", "", 0);
    o.meta = { name: r }, o.content = s;
  }
  return !0;
}
let ed;
try {
  ed = new RegExp("^\\{([a-zA-Z_\\-+:]{1,36})\\}(`+)(?!`)(.+?)(?<!`)\\2(?!`)");
} catch {
  ed = /^\{([a-zA-Z_\-+:]{1,36})\}(`+)(?!`)(.+?)\2(?!`)/;
}
const xE = ed;
function kE(n) {
  function e(t) {
    var i;
    for (const r of t.tokens)
      if (r.type === "inline" && r.children) {
        const s = [];
        for (const o of r.children)
          if (o.type === "role" && ((i = o.meta) === null || i === void 0 ? void 0 : i.name) in n)
            try {
              const l = new n[o.meta.name](t), a = new t.Token("parsed_role_open", "", 1);
              a.content = o.content, a.hidden = !0, a.meta = { name: o.meta.name }, a.block = !1;
              const c = [a];
              c.push(...l.run({
                parentMap: r.map,
                content: o.content
              }));
              const h = new t.Token("parsed_role_close", "", -1);
              h.block = !1, h.hidden = !0, c.push(h), s.push(...c);
            } catch (l) {
              const a = new t.Token("role_error", "", 0);
              a.content = o.content, a.info = o.info, a.meta = o.meta, a.map = o.map, a.meta.error_message = l.message, a.meta.error_name = l.name, s.push(a);
            }
          else
            s.push(o);
        r.children = s;
      }
    return !0;
  }
  return e;
}
class C0 extends Zi {
  run(e) {
    const t = new this.state.Token("sub_open", "sub", 1);
    t.markup = "~";
    const i = new this.state.Token("text", "", 0);
    i.content = e.content;
    const r = new this.state.Token("sub_close", "sub", -1);
    return r.markup = "~", [t, i, r];
  }
}
class A0 extends Zi {
  run(e) {
    const t = new this.state.Token("sup_open", "sup", 1);
    t.markup = "~";
    const i = new this.state.Token("text", "", 0);
    i.content = e.content;
    const r = new this.state.Token("sup_close", "sup", -1);
    return r.markup = "~", [t, i, r];
  }
}
const _E = /^(.+?)\(([^()]+)\)$/;
class D0 extends Zi {
  run(e) {
    var t, i, r, s;
    const o = _E.exec(e.content), l = (i = (t = o == null ? void 0 : o[1]) === null || t === void 0 ? void 0 : t.trim()) !== null && i !== void 0 ? i : e.content.trim(), a = (s = (r = o == null ? void 0 : o[2]) === null || r === void 0 ? void 0 : r.trim()) !== null && s !== void 0 ? s : null, c = new this.state.Token("abbr_open", "abbr", 1);
    a && c.attrSet("title", a);
    const h = new this.state.Token("text", "", 0);
    h.content = l;
    const u = new this.state.Token("abbr_close", "abbr", -1);
    return [c, h, u];
  }
}
const SE = {
  subscript: C0,
  sub: C0,
  superscript: A0,
  sup: A0,
  abbreviation: D0,
  abbr: D0
};
var Go;
(function(n) {
  n.equation = "eq", n.figure = "fig", n.table = "table", n.code = "code", n.section = "sec";
})(Go || (Go = {}));
function Sh(n) {
  var e, t;
  const i = (t = (e = n.env) === null || e === void 0 ? void 0 : e.docutils) !== null && t !== void 0 ? t : {};
  return i.targets || (i.targets = {}), i.references || (i.references = []), i.numbering || (i.numbering = {}), n.env.docutils || (n.env.docutils = i), i;
}
function CE(n) {
  var e, t;
  const i = (t = (e = n.meta) === null || e === void 0 ? void 0 : e.docutils) !== null && t !== void 0 ? t : {};
  return n.meta || (n.meta = {}), n.meta.docutils || (n.meta.docutils = i), i;
}
function AE(n, e) {
  const t = Sh(n);
  return t.numbering[e] == null ? t.numbering[e] = 1 : t.numbering[e] += 1, t.numbering[e];
}
function Ov(n, e, t, i, r, s = !1) {
  const o = Sh(n), l = AE(n, t), a = {
    label: i,
    kind: t,
    number: l,
    title: r
  };
  if (!s) {
    const c = CE(e);
    c.target = a, e.attrSet("id", i), o.targets[i] = a;
  }
  return a;
}
function Zp(n, e, t, i) {
  var r;
  e.open.meta = (r = e.open.meta) !== null && r !== void 0 ? r : {}, e.open.meta.kind = t.kind, e.open.meta.label = t.label, e.open.meta.value = t.value, Sh(n).references.push(Object.assign({ label: t.label, tokens: e }, i));
}
const Lv = /^(.+?)<([^<>]+)>$/;
class DE extends Zi {
  run(e) {
    const t = new this.state.Token("ref_open", "a", 1), i = new this.state.Token("text", "", 0), r = new this.state.Token("ref_close", "a", -1);
    return Zp(this.state, { open: t, content: i, close: r }, { kind: "eq", label: e.content }, {
      kind: Go.equation,
      contentFromTarget: (s) => `(${s.number})`
    }), [t, i, r];
  }
}
class EE extends Zi {
  run(e) {
    const t = Lv.exec(e.content), [, i, r] = t != null ? t : [], s = i == null ? void 0 : i.trim(), o = new this.state.Token("ref_open", "a", 1), l = new this.state.Token("text", "", 0), a = new this.state.Token("ref_close", "a", -1);
    return Zp(this.state, { open: o, content: l, close: a }, { kind: "numref", label: r || e.content, value: s }, {
      contentFromTarget: (c) => t ? s.replace(/%s/g, String(c.number)).replace(/\{number\}/g, String(c.number)) : c.title.trim()
    }), [o, l, a];
  }
}
class TE extends Zi {
  run(e) {
    const t = Lv.exec(e.content), [, i, r] = t != null ? t : [], s = i == null ? void 0 : i.trim(), o = new this.state.Token("ref_open", "a", 1), l = new this.state.Token("text", "", 0), a = new this.state.Token("ref_close", "a", -1);
    return Zp(this.state, { open: o, content: l, close: a }, { kind: "ref", label: r || e.content, value: s }, {
      contentFromTarget: (c) => s || c.title
    }), [o, l, a];
  }
}
const ME = {
  eq: DE,
  ref: TE,
  numref: EE
}, OE = Object.assign(Object.assign(Object.assign(Object.assign({}, gE), SE), yE), ME);
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
function Rv(n) {
  return typeof n > "u" || n === null;
}
function LE(n) {
  return typeof n == "object" && n !== null;
}
function RE(n) {
  return Array.isArray(n) ? n : Rv(n) ? [] : [n];
}
function IE(n, e) {
  var t, i, r, s;
  if (e)
    for (s = Object.keys(e), t = 0, i = s.length; t < i; t += 1)
      r = s[t], n[r] = e[r];
  return n;
}
function BE(n, e) {
  var t = "", i;
  for (i = 0; i < e; i += 1)
    t += n;
  return t;
}
function NE(n) {
  return n === 0 && Number.NEGATIVE_INFINITY === 1 / n;
}
var PE = Rv, FE = LE, $E = RE, HE = BE, qE = NE, VE = IE, je = {
  isNothing: PE,
  isObject: FE,
  toArray: $E,
  repeat: HE,
  isNegativeZero: qE,
  extend: VE
};
function Iv(n, e) {
  var t = "", i = n.reason || "(unknown reason)";
  return n.mark ? (n.mark.name && (t += 'in "' + n.mark.name + '" '), t += "(" + (n.mark.line + 1) + ":" + (n.mark.column + 1) + ")", !e && n.mark.snippet && (t += `

` + n.mark.snippet), i + " " + t) : i;
}
function Ko(n, e) {
  Error.call(this), this.name = "YAMLException", this.reason = n, this.mark = e, this.message = Iv(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
Ko.prototype = Object.create(Error.prototype);
Ko.prototype.constructor = Ko;
Ko.prototype.toString = function(e) {
  return this.name + ": " + Iv(this, e);
};
var vt = Ko;
function Su(n, e, t, i, r) {
  var s = "", o = "", l = Math.floor(r / 2) - 1;
  return i - e > l && (s = " ... ", e = i - l + s.length), t - i > l && (o = " ...", t = i + l - o.length), {
    str: s + n.slice(e, t).replace(/\t/g, "\u2192") + o,
    pos: i - e + s.length
  };
}
function Cu(n, e) {
  return je.repeat(" ", e - n.length) + n;
}
function zE(n, e) {
  if (e = Object.create(e || null), !n.buffer)
    return null;
  e.maxLength || (e.maxLength = 79), typeof e.indent != "number" && (e.indent = 1), typeof e.linesBefore != "number" && (e.linesBefore = 3), typeof e.linesAfter != "number" && (e.linesAfter = 2);
  for (var t = /\r?\n|\r|\0/g, i = [0], r = [], s, o = -1; s = t.exec(n.buffer); )
    r.push(s.index), i.push(s.index + s[0].length), n.position <= s.index && o < 0 && (o = i.length - 2);
  o < 0 && (o = i.length - 1);
  var l = "", a, c, h = Math.min(n.line + e.linesAfter, r.length).toString().length, u = e.maxLength - (e.indent + h + 3);
  for (a = 1; a <= e.linesBefore && !(o - a < 0); a++)
    c = Su(
      n.buffer,
      i[o - a],
      r[o - a],
      n.position - (i[o] - i[o - a]),
      u
    ), l = je.repeat(" ", e.indent) + Cu((n.line - a + 1).toString(), h) + " | " + c.str + `
` + l;
  for (c = Su(n.buffer, i[o], r[o], n.position, u), l += je.repeat(" ", e.indent) + Cu((n.line + 1).toString(), h) + " | " + c.str + `
`, l += je.repeat("-", e.indent + h + 3 + c.pos) + `^
`, a = 1; a <= e.linesAfter && !(o + a >= r.length); a++)
    c = Su(
      n.buffer,
      i[o + a],
      r[o + a],
      n.position - (i[o] - i[o + a]),
      u
    ), l += je.repeat(" ", e.indent) + Cu((n.line + a + 1).toString(), h) + " | " + c.str + `
`;
  return l.replace(/\n$/, "");
}
var UE = zE, WE = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], jE = [
  "scalar",
  "sequence",
  "mapping"
];
function GE(n) {
  var e = {};
  return n !== null && Object.keys(n).forEach(function(t) {
    n[t].forEach(function(i) {
      e[String(i)] = t;
    });
  }), e;
}
function KE(n, e) {
  if (e = e || {}, Object.keys(e).forEach(function(t) {
    if (WE.indexOf(t) === -1)
      throw new vt('Unknown option "' + t + '" is met in definition of "' + n + '" YAML type.');
  }), this.options = e, this.tag = n, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(t) {
    return t;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.representName = e.representName || null, this.defaultStyle = e.defaultStyle || null, this.multi = e.multi || !1, this.styleAliases = GE(e.styleAliases || null), jE.indexOf(this.kind) === -1)
    throw new vt('Unknown kind "' + this.kind + '" is specified for "' + n + '" YAML type.');
}
var rt = KE;
function E0(n, e) {
  var t = [];
  return n[e].forEach(function(i) {
    var r = t.length;
    t.forEach(function(s, o) {
      s.tag === i.tag && s.kind === i.kind && s.multi === i.multi && (r = o);
    }), t[r] = i;
  }), t;
}
function YE() {
  var n = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, e, t;
  function i(r) {
    r.multi ? (n.multi[r.kind].push(r), n.multi.fallback.push(r)) : n[r.kind][r.tag] = n.fallback[r.tag] = r;
  }
  for (e = 0, t = arguments.length; e < t; e += 1)
    arguments[e].forEach(i);
  return n;
}
function td(n) {
  return this.extend(n);
}
td.prototype.extend = function(e) {
  var t = [], i = [];
  if (e instanceof rt)
    i.push(e);
  else if (Array.isArray(e))
    i = i.concat(e);
  else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
    e.implicit && (t = t.concat(e.implicit)), e.explicit && (i = i.concat(e.explicit));
  else
    throw new vt("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  t.forEach(function(s) {
    if (!(s instanceof rt))
      throw new vt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (s.loadKind && s.loadKind !== "scalar")
      throw new vt("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (s.multi)
      throw new vt("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), i.forEach(function(s) {
    if (!(s instanceof rt))
      throw new vt("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var r = Object.create(td.prototype);
  return r.implicit = (this.implicit || []).concat(t), r.explicit = (this.explicit || []).concat(i), r.compiledImplicit = E0(r, "implicit"), r.compiledExplicit = E0(r, "explicit"), r.compiledTypeMap = YE(r.compiledImplicit, r.compiledExplicit), r;
};
var Bv = td, Nv = new rt("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(n) {
    return n !== null ? n : "";
  }
}), Pv = new rt("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(n) {
    return n !== null ? n : [];
  }
}), Fv = new rt("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(n) {
    return n !== null ? n : {};
  }
}), $v = new Bv({
  explicit: [
    Nv,
    Pv,
    Fv
  ]
});
function JE(n) {
  if (n === null)
    return !0;
  var e = n.length;
  return e === 1 && n === "~" || e === 4 && (n === "null" || n === "Null" || n === "NULL");
}
function ZE() {
  return null;
}
function XE(n) {
  return n === null;
}
var Hv = new rt("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: JE,
  construct: ZE,
  predicate: XE,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function QE(n) {
  if (n === null)
    return !1;
  var e = n.length;
  return e === 4 && (n === "true" || n === "True" || n === "TRUE") || e === 5 && (n === "false" || n === "False" || n === "FALSE");
}
function eT(n) {
  return n === "true" || n === "True" || n === "TRUE";
}
function tT(n) {
  return Object.prototype.toString.call(n) === "[object Boolean]";
}
var qv = new rt("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: QE,
  construct: eT,
  predicate: tT,
  represent: {
    lowercase: function(n) {
      return n ? "true" : "false";
    },
    uppercase: function(n) {
      return n ? "TRUE" : "FALSE";
    },
    camelcase: function(n) {
      return n ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function nT(n) {
  return 48 <= n && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102;
}
function iT(n) {
  return 48 <= n && n <= 55;
}
function rT(n) {
  return 48 <= n && n <= 57;
}
function sT(n) {
  if (n === null)
    return !1;
  var e = n.length, t = 0, i = !1, r;
  if (!e)
    return !1;
  if (r = n[t], (r === "-" || r === "+") && (r = n[++t]), r === "0") {
    if (t + 1 === e)
      return !0;
    if (r = n[++t], r === "b") {
      for (t++; t < e; t++)
        if (r = n[t], r !== "_") {
          if (r !== "0" && r !== "1")
            return !1;
          i = !0;
        }
      return i && r !== "_";
    }
    if (r === "x") {
      for (t++; t < e; t++)
        if (r = n[t], r !== "_") {
          if (!nT(n.charCodeAt(t)))
            return !1;
          i = !0;
        }
      return i && r !== "_";
    }
    if (r === "o") {
      for (t++; t < e; t++)
        if (r = n[t], r !== "_") {
          if (!iT(n.charCodeAt(t)))
            return !1;
          i = !0;
        }
      return i && r !== "_";
    }
  }
  if (r === "_")
    return !1;
  for (; t < e; t++)
    if (r = n[t], r !== "_") {
      if (!rT(n.charCodeAt(t)))
        return !1;
      i = !0;
    }
  return !(!i || r === "_");
}
function oT(n) {
  var e = n, t = 1, i;
  if (e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), i = e[0], (i === "-" || i === "+") && (i === "-" && (t = -1), e = e.slice(1), i = e[0]), e === "0")
    return 0;
  if (i === "0") {
    if (e[1] === "b")
      return t * parseInt(e.slice(2), 2);
    if (e[1] === "x")
      return t * parseInt(e.slice(2), 16);
    if (e[1] === "o")
      return t * parseInt(e.slice(2), 8);
  }
  return t * parseInt(e, 10);
}
function lT(n) {
  return Object.prototype.toString.call(n) === "[object Number]" && n % 1 === 0 && !je.isNegativeZero(n);
}
var Vv = new rt("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: sT,
  construct: oT,
  predicate: lT,
  represent: {
    binary: function(n) {
      return n >= 0 ? "0b" + n.toString(2) : "-0b" + n.toString(2).slice(1);
    },
    octal: function(n) {
      return n >= 0 ? "0o" + n.toString(8) : "-0o" + n.toString(8).slice(1);
    },
    decimal: function(n) {
      return n.toString(10);
    },
    hexadecimal: function(n) {
      return n >= 0 ? "0x" + n.toString(16).toUpperCase() : "-0x" + n.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), aT = new RegExp(
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function cT(n) {
  return !(n === null || !aT.test(n) || n[n.length - 1] === "_");
}
function hT(n) {
  var e, t;
  return e = n.replace(/_/g, "").toLowerCase(), t = e[0] === "-" ? -1 : 1, "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? t === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : t * parseFloat(e, 10);
}
var uT = /^[-+]?[0-9]+e/;
function fT(n, e) {
  var t;
  if (isNaN(n))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === n)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === n)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (je.isNegativeZero(n))
    return "-0.0";
  return t = n.toString(10), uT.test(t) ? t.replace("e", ".e") : t;
}
function dT(n) {
  return Object.prototype.toString.call(n) === "[object Number]" && (n % 1 !== 0 || je.isNegativeZero(n));
}
var zv = new rt("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: cT,
  construct: hT,
  predicate: dT,
  represent: fT,
  defaultStyle: "lowercase"
}), Uv = $v.extend({
  implicit: [
    Hv,
    qv,
    Vv,
    zv
  ]
}), Wv = Uv, jv = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Gv = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function pT(n) {
  return n === null ? !1 : jv.exec(n) !== null || Gv.exec(n) !== null;
}
function gT(n) {
  var e, t, i, r, s, o, l, a = 0, c = null, h, u, f;
  if (e = jv.exec(n), e === null && (e = Gv.exec(n)), e === null)
    throw new Error("Date resolve error");
  if (t = +e[1], i = +e[2] - 1, r = +e[3], !e[4])
    return new Date(Date.UTC(t, i, r));
  if (s = +e[4], o = +e[5], l = +e[6], e[7]) {
    for (a = e[7].slice(0, 3); a.length < 3; )
      a += "0";
    a = +a;
  }
  return e[9] && (h = +e[10], u = +(e[11] || 0), c = (h * 60 + u) * 6e4, e[9] === "-" && (c = -c)), f = new Date(Date.UTC(t, i, r, s, o, l, a)), c && f.setTime(f.getTime() - c), f;
}
function mT(n) {
  return n.toISOString();
}
var Kv = new rt("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: pT,
  construct: gT,
  instanceOf: Date,
  represent: mT
});
function bT(n) {
  return n === "<<" || n === null;
}
var Yv = new rt("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: bT
}), Xp = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function yT(n) {
  if (n === null)
    return !1;
  var e, t, i = 0, r = n.length, s = Xp;
  for (t = 0; t < r; t++)
    if (e = s.indexOf(n.charAt(t)), !(e > 64)) {
      if (e < 0)
        return !1;
      i += 6;
    }
  return i % 8 === 0;
}
function wT(n) {
  var e, t, i = n.replace(/[\r\n=]/g, ""), r = i.length, s = Xp, o = 0, l = [];
  for (e = 0; e < r; e++)
    e % 4 === 0 && e && (l.push(o >> 16 & 255), l.push(o >> 8 & 255), l.push(o & 255)), o = o << 6 | s.indexOf(i.charAt(e));
  return t = r % 4 * 6, t === 0 ? (l.push(o >> 16 & 255), l.push(o >> 8 & 255), l.push(o & 255)) : t === 18 ? (l.push(o >> 10 & 255), l.push(o >> 2 & 255)) : t === 12 && l.push(o >> 4 & 255), new Uint8Array(l);
}
function vT(n) {
  var e = "", t = 0, i, r, s = n.length, o = Xp;
  for (i = 0; i < s; i++)
    i % 3 === 0 && i && (e += o[t >> 18 & 63], e += o[t >> 12 & 63], e += o[t >> 6 & 63], e += o[t & 63]), t = (t << 8) + n[i];
  return r = s % 3, r === 0 ? (e += o[t >> 18 & 63], e += o[t >> 12 & 63], e += o[t >> 6 & 63], e += o[t & 63]) : r === 2 ? (e += o[t >> 10 & 63], e += o[t >> 4 & 63], e += o[t << 2 & 63], e += o[64]) : r === 1 && (e += o[t >> 2 & 63], e += o[t << 4 & 63], e += o[64], e += o[64]), e;
}
function xT(n) {
  return Object.prototype.toString.call(n) === "[object Uint8Array]";
}
var Jv = new rt("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: yT,
  construct: wT,
  predicate: xT,
  represent: vT
}), kT = Object.prototype.hasOwnProperty, _T = Object.prototype.toString;
function ST(n) {
  if (n === null)
    return !0;
  var e = [], t, i, r, s, o, l = n;
  for (t = 0, i = l.length; t < i; t += 1) {
    if (r = l[t], o = !1, _T.call(r) !== "[object Object]")
      return !1;
    for (s in r)
      if (kT.call(r, s))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (e.indexOf(s) === -1)
      e.push(s);
    else
      return !1;
  }
  return !0;
}
function CT(n) {
  return n !== null ? n : [];
}
var Zv = new rt("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: ST,
  construct: CT
}), AT = Object.prototype.toString;
function DT(n) {
  if (n === null)
    return !0;
  var e, t, i, r, s, o = n;
  for (s = new Array(o.length), e = 0, t = o.length; e < t; e += 1) {
    if (i = o[e], AT.call(i) !== "[object Object]" || (r = Object.keys(i), r.length !== 1))
      return !1;
    s[e] = [r[0], i[r[0]]];
  }
  return !0;
}
function ET(n) {
  if (n === null)
    return [];
  var e, t, i, r, s, o = n;
  for (s = new Array(o.length), e = 0, t = o.length; e < t; e += 1)
    i = o[e], r = Object.keys(i), s[e] = [r[0], i[r[0]]];
  return s;
}
var Xv = new rt("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: DT,
  construct: ET
}), TT = Object.prototype.hasOwnProperty;
function MT(n) {
  if (n === null)
    return !0;
  var e, t = n;
  for (e in t)
    if (TT.call(t, e) && t[e] !== null)
      return !1;
  return !0;
}
function OT(n) {
  return n !== null ? n : {};
}
var Qv = new rt("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: MT,
  construct: OT
}), Qp = Wv.extend({
  implicit: [
    Kv,
    Yv
  ],
  explicit: [
    Jv,
    Zv,
    Xv,
    Qv
  ]
}), qi = Object.prototype.hasOwnProperty, vc = 1, ex = 2, tx = 3, xc = 4, Au = 1, LT = 2, T0 = 3, RT = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, IT = /[\x85\u2028\u2029]/, BT = /[,\[\]\{\}]/, nx = /^(?:!|!!|![a-z\-]+!)$/i, ix = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function M0(n) {
  return Object.prototype.toString.call(n);
}
function $n(n) {
  return n === 10 || n === 13;
}
function yr(n) {
  return n === 9 || n === 32;
}
function Mt(n) {
  return n === 9 || n === 32 || n === 10 || n === 13;
}
function ss(n) {
  return n === 44 || n === 91 || n === 93 || n === 123 || n === 125;
}
function NT(n) {
  var e;
  return 48 <= n && n <= 57 ? n - 48 : (e = n | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function PT(n) {
  return n === 120 ? 2 : n === 117 ? 4 : n === 85 ? 8 : 0;
}
function FT(n) {
  return 48 <= n && n <= 57 ? n - 48 : -1;
}
function O0(n) {
  return n === 48 ? "\0" : n === 97 ? "\x07" : n === 98 ? "\b" : n === 116 || n === 9 ? "	" : n === 110 ? `
` : n === 118 ? "\v" : n === 102 ? "\f" : n === 114 ? "\r" : n === 101 ? "\x1B" : n === 32 ? " " : n === 34 ? '"' : n === 47 ? "/" : n === 92 ? "\\" : n === 78 ? "\x85" : n === 95 ? "\xA0" : n === 76 ? "\u2028" : n === 80 ? "\u2029" : "";
}
function $T(n) {
  return n <= 65535 ? String.fromCharCode(n) : String.fromCharCode(
    (n - 65536 >> 10) + 55296,
    (n - 65536 & 1023) + 56320
  );
}
var rx = new Array(256), sx = new Array(256);
for (var Zr = 0; Zr < 256; Zr++)
  rx[Zr] = O0(Zr) ? 1 : 0, sx[Zr] = O0(Zr);
function HT(n, e) {
  this.input = n, this.filename = e.filename || null, this.schema = e.schema || Qp, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = n.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function ox(n, e) {
  var t = {
    name: n.filename,
    buffer: n.input.slice(0, -1),
    position: n.position,
    line: n.line,
    column: n.position - n.lineStart
  };
  return t.snippet = UE(t), new vt(e, t);
}
function $(n, e) {
  throw ox(n, e);
}
function kc(n, e) {
  n.onWarning && n.onWarning.call(null, ox(n, e));
}
var L0 = {
  YAML: function(e, t, i) {
    var r, s, o;
    e.version !== null && $(e, "duplication of %YAML directive"), i.length !== 1 && $(e, "YAML directive accepts exactly one argument"), r = /^([0-9]+)\.([0-9]+)$/.exec(i[0]), r === null && $(e, "ill-formed argument of the YAML directive"), s = parseInt(r[1], 10), o = parseInt(r[2], 10), s !== 1 && $(e, "unacceptable YAML version of the document"), e.version = i[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && kc(e, "unsupported YAML version of the document");
  },
  TAG: function(e, t, i) {
    var r, s;
    i.length !== 2 && $(e, "TAG directive accepts exactly two arguments"), r = i[0], s = i[1], nx.test(r) || $(e, "ill-formed tag handle (first argument) of the TAG directive"), qi.call(e.tagMap, r) && $(e, 'there is a previously declared suffix for "' + r + '" tag handle'), ix.test(s) || $(e, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      s = decodeURIComponent(s);
    } catch {
      $(e, "tag prefix is malformed: " + s);
    }
    e.tagMap[r] = s;
  }
};
function Bi(n, e, t, i) {
  var r, s, o, l;
  if (e < t) {
    if (l = n.input.slice(e, t), i)
      for (r = 0, s = l.length; r < s; r += 1)
        o = l.charCodeAt(r), o === 9 || 32 <= o && o <= 1114111 || $(n, "expected valid JSON character");
    else
      RT.test(l) && $(n, "the stream contains non-printable characters");
    n.result += l;
  }
}
function R0(n, e, t, i) {
  var r, s, o, l;
  for (je.isObject(t) || $(n, "cannot merge mappings; the provided source object is unacceptable"), r = Object.keys(t), o = 0, l = r.length; o < l; o += 1)
    s = r[o], qi.call(e, s) || (e[s] = t[s], i[s] = !0);
}
function os(n, e, t, i, r, s, o, l, a) {
  var c, h;
  if (Array.isArray(r))
    for (r = Array.prototype.slice.call(r), c = 0, h = r.length; c < h; c += 1)
      Array.isArray(r[c]) && $(n, "nested arrays are not supported inside keys"), typeof r == "object" && M0(r[c]) === "[object Object]" && (r[c] = "[object Object]");
  if (typeof r == "object" && M0(r) === "[object Object]" && (r = "[object Object]"), r = String(r), e === null && (e = {}), i === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (c = 0, h = s.length; c < h; c += 1)
        R0(n, e, s[c], t);
    else
      R0(n, e, s, t);
  else
    !n.json && !qi.call(t, r) && qi.call(e, r) && (n.line = o || n.line, n.lineStart = l || n.lineStart, n.position = a || n.position, $(n, "duplicated mapping key")), r === "__proto__" ? Object.defineProperty(e, r, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: s
    }) : e[r] = s, delete t[r];
  return e;
}
function eg(n) {
  var e;
  e = n.input.charCodeAt(n.position), e === 10 ? n.position++ : e === 13 ? (n.position++, n.input.charCodeAt(n.position) === 10 && n.position++) : $(n, "a line break is expected"), n.line += 1, n.lineStart = n.position, n.firstTabInLine = -1;
}
function He(n, e, t) {
  for (var i = 0, r = n.input.charCodeAt(n.position); r !== 0; ) {
    for (; yr(r); )
      r === 9 && n.firstTabInLine === -1 && (n.firstTabInLine = n.position), r = n.input.charCodeAt(++n.position);
    if (e && r === 35)
      do
        r = n.input.charCodeAt(++n.position);
      while (r !== 10 && r !== 13 && r !== 0);
    if ($n(r))
      for (eg(n), r = n.input.charCodeAt(n.position), i++, n.lineIndent = 0; r === 32; )
        n.lineIndent++, r = n.input.charCodeAt(++n.position);
    else
      break;
  }
  return t !== -1 && i !== 0 && n.lineIndent < t && kc(n, "deficient indentation"), i;
}
function Ch(n) {
  var e = n.position, t;
  return t = n.input.charCodeAt(e), !!((t === 45 || t === 46) && t === n.input.charCodeAt(e + 1) && t === n.input.charCodeAt(e + 2) && (e += 3, t = n.input.charCodeAt(e), t === 0 || Mt(t)));
}
function tg(n, e) {
  e === 1 ? n.result += " " : e > 1 && (n.result += je.repeat(`
`, e - 1));
}
function qT(n, e, t) {
  var i, r, s, o, l, a, c, h, u = n.kind, f = n.result, d;
  if (d = n.input.charCodeAt(n.position), Mt(d) || ss(d) || d === 35 || d === 38 || d === 42 || d === 33 || d === 124 || d === 62 || d === 39 || d === 34 || d === 37 || d === 64 || d === 96 || (d === 63 || d === 45) && (r = n.input.charCodeAt(n.position + 1), Mt(r) || t && ss(r)))
    return !1;
  for (n.kind = "scalar", n.result = "", s = o = n.position, l = !1; d !== 0; ) {
    if (d === 58) {
      if (r = n.input.charCodeAt(n.position + 1), Mt(r) || t && ss(r))
        break;
    } else if (d === 35) {
      if (i = n.input.charCodeAt(n.position - 1), Mt(i))
        break;
    } else {
      if (n.position === n.lineStart && Ch(n) || t && ss(d))
        break;
      if ($n(d))
        if (a = n.line, c = n.lineStart, h = n.lineIndent, He(n, !1, -1), n.lineIndent >= e) {
          l = !0, d = n.input.charCodeAt(n.position);
          continue;
        } else {
          n.position = o, n.line = a, n.lineStart = c, n.lineIndent = h;
          break;
        }
    }
    l && (Bi(n, s, o, !1), tg(n, n.line - a), s = o = n.position, l = !1), yr(d) || (o = n.position + 1), d = n.input.charCodeAt(++n.position);
  }
  return Bi(n, s, o, !1), n.result ? !0 : (n.kind = u, n.result = f, !1);
}
function VT(n, e) {
  var t, i, r;
  if (t = n.input.charCodeAt(n.position), t !== 39)
    return !1;
  for (n.kind = "scalar", n.result = "", n.position++, i = r = n.position; (t = n.input.charCodeAt(n.position)) !== 0; )
    if (t === 39)
      if (Bi(n, i, n.position, !0), t = n.input.charCodeAt(++n.position), t === 39)
        i = n.position, n.position++, r = n.position;
      else
        return !0;
    else
      $n(t) ? (Bi(n, i, r, !0), tg(n, He(n, !1, e)), i = r = n.position) : n.position === n.lineStart && Ch(n) ? $(n, "unexpected end of the document within a single quoted scalar") : (n.position++, r = n.position);
  $(n, "unexpected end of the stream within a single quoted scalar");
}
function zT(n, e) {
  var t, i, r, s, o, l;
  if (l = n.input.charCodeAt(n.position), l !== 34)
    return !1;
  for (n.kind = "scalar", n.result = "", n.position++, t = i = n.position; (l = n.input.charCodeAt(n.position)) !== 0; ) {
    if (l === 34)
      return Bi(n, t, n.position, !0), n.position++, !0;
    if (l === 92) {
      if (Bi(n, t, n.position, !0), l = n.input.charCodeAt(++n.position), $n(l))
        He(n, !1, e);
      else if (l < 256 && rx[l])
        n.result += sx[l], n.position++;
      else if ((o = PT(l)) > 0) {
        for (r = o, s = 0; r > 0; r--)
          l = n.input.charCodeAt(++n.position), (o = NT(l)) >= 0 ? s = (s << 4) + o : $(n, "expected hexadecimal character");
        n.result += $T(s), n.position++;
      } else
        $(n, "unknown escape sequence");
      t = i = n.position;
    } else
      $n(l) ? (Bi(n, t, i, !0), tg(n, He(n, !1, e)), t = i = n.position) : n.position === n.lineStart && Ch(n) ? $(n, "unexpected end of the document within a double quoted scalar") : (n.position++, i = n.position);
  }
  $(n, "unexpected end of the stream within a double quoted scalar");
}
function UT(n, e) {
  var t = !0, i, r, s, o = n.tag, l, a = n.anchor, c, h, u, f, d, p = /* @__PURE__ */ Object.create(null), g, m, b, y;
  if (y = n.input.charCodeAt(n.position), y === 91)
    h = 93, d = !1, l = [];
  else if (y === 123)
    h = 125, d = !0, l = {};
  else
    return !1;
  for (n.anchor !== null && (n.anchorMap[n.anchor] = l), y = n.input.charCodeAt(++n.position); y !== 0; ) {
    if (He(n, !0, e), y = n.input.charCodeAt(n.position), y === h)
      return n.position++, n.tag = o, n.anchor = a, n.kind = d ? "mapping" : "sequence", n.result = l, !0;
    t ? y === 44 && $(n, "expected the node content, but found ','") : $(n, "missed comma between flow collection entries"), m = g = b = null, u = f = !1, y === 63 && (c = n.input.charCodeAt(n.position + 1), Mt(c) && (u = f = !0, n.position++, He(n, !0, e))), i = n.line, r = n.lineStart, s = n.position, Rs(n, e, vc, !1, !0), m = n.tag, g = n.result, He(n, !0, e), y = n.input.charCodeAt(n.position), (f || n.line === i) && y === 58 && (u = !0, y = n.input.charCodeAt(++n.position), He(n, !0, e), Rs(n, e, vc, !1, !0), b = n.result), d ? os(n, l, p, m, g, b, i, r, s) : u ? l.push(os(n, null, p, m, g, b, i, r, s)) : l.push(g), He(n, !0, e), y = n.input.charCodeAt(n.position), y === 44 ? (t = !0, y = n.input.charCodeAt(++n.position)) : t = !1;
  }
  $(n, "unexpected end of the stream within a flow collection");
}
function WT(n, e) {
  var t, i, r = Au, s = !1, o = !1, l = e, a = 0, c = !1, h, u;
  if (u = n.input.charCodeAt(n.position), u === 124)
    i = !1;
  else if (u === 62)
    i = !0;
  else
    return !1;
  for (n.kind = "scalar", n.result = ""; u !== 0; )
    if (u = n.input.charCodeAt(++n.position), u === 43 || u === 45)
      Au === r ? r = u === 43 ? T0 : LT : $(n, "repeat of a chomping mode identifier");
    else if ((h = FT(u)) >= 0)
      h === 0 ? $(n, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? $(n, "repeat of an indentation width identifier") : (l = e + h - 1, o = !0);
    else
      break;
  if (yr(u)) {
    do
      u = n.input.charCodeAt(++n.position);
    while (yr(u));
    if (u === 35)
      do
        u = n.input.charCodeAt(++n.position);
      while (!$n(u) && u !== 0);
  }
  for (; u !== 0; ) {
    for (eg(n), n.lineIndent = 0, u = n.input.charCodeAt(n.position); (!o || n.lineIndent < l) && u === 32; )
      n.lineIndent++, u = n.input.charCodeAt(++n.position);
    if (!o && n.lineIndent > l && (l = n.lineIndent), $n(u)) {
      a++;
      continue;
    }
    if (n.lineIndent < l) {
      r === T0 ? n.result += je.repeat(`
`, s ? 1 + a : a) : r === Au && s && (n.result += `
`);
      break;
    }
    for (i ? yr(u) ? (c = !0, n.result += je.repeat(`
`, s ? 1 + a : a)) : c ? (c = !1, n.result += je.repeat(`
`, a + 1)) : a === 0 ? s && (n.result += " ") : n.result += je.repeat(`
`, a) : n.result += je.repeat(`
`, s ? 1 + a : a), s = !0, o = !0, a = 0, t = n.position; !$n(u) && u !== 0; )
      u = n.input.charCodeAt(++n.position);
    Bi(n, t, n.position, !1);
  }
  return !0;
}
function I0(n, e) {
  var t, i = n.tag, r = n.anchor, s = [], o, l = !1, a;
  if (n.firstTabInLine !== -1)
    return !1;
  for (n.anchor !== null && (n.anchorMap[n.anchor] = s), a = n.input.charCodeAt(n.position); a !== 0 && (n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, $(n, "tab characters must not be used in indentation")), !(a !== 45 || (o = n.input.charCodeAt(n.position + 1), !Mt(o)))); ) {
    if (l = !0, n.position++, He(n, !0, -1) && n.lineIndent <= e) {
      s.push(null), a = n.input.charCodeAt(n.position);
      continue;
    }
    if (t = n.line, Rs(n, e, tx, !1, !0), s.push(n.result), He(n, !0, -1), a = n.input.charCodeAt(n.position), (n.line === t || n.lineIndent > e) && a !== 0)
      $(n, "bad indentation of a sequence entry");
    else if (n.lineIndent < e)
      break;
  }
  return l ? (n.tag = i, n.anchor = r, n.kind = "sequence", n.result = s, !0) : !1;
}
function jT(n, e, t) {
  var i, r, s, o, l, a, c = n.tag, h = n.anchor, u = {}, f = /* @__PURE__ */ Object.create(null), d = null, p = null, g = null, m = !1, b = !1, y;
  if (n.firstTabInLine !== -1)
    return !1;
  for (n.anchor !== null && (n.anchorMap[n.anchor] = u), y = n.input.charCodeAt(n.position); y !== 0; ) {
    if (!m && n.firstTabInLine !== -1 && (n.position = n.firstTabInLine, $(n, "tab characters must not be used in indentation")), i = n.input.charCodeAt(n.position + 1), s = n.line, (y === 63 || y === 58) && Mt(i))
      y === 63 ? (m && (os(n, u, f, d, p, null, o, l, a), d = p = g = null), b = !0, m = !0, r = !0) : m ? (m = !1, r = !0) : $(n, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), n.position += 1, y = i;
    else {
      if (o = n.line, l = n.lineStart, a = n.position, !Rs(n, t, ex, !1, !0))
        break;
      if (n.line === s) {
        for (y = n.input.charCodeAt(n.position); yr(y); )
          y = n.input.charCodeAt(++n.position);
        if (y === 58)
          y = n.input.charCodeAt(++n.position), Mt(y) || $(n, "a whitespace character is expected after the key-value separator within a block mapping"), m && (os(n, u, f, d, p, null, o, l, a), d = p = g = null), b = !0, m = !1, r = !1, d = n.tag, p = n.result;
        else if (b)
          $(n, "can not read an implicit mapping pair; a colon is missed");
        else
          return n.tag = c, n.anchor = h, !0;
      } else if (b)
        $(n, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return n.tag = c, n.anchor = h, !0;
    }
    if ((n.line === s || n.lineIndent > e) && (m && (o = n.line, l = n.lineStart, a = n.position), Rs(n, e, xc, !0, r) && (m ? p = n.result : g = n.result), m || (os(n, u, f, d, p, g, o, l, a), d = p = g = null), He(n, !0, -1), y = n.input.charCodeAt(n.position)), (n.line === s || n.lineIndent > e) && y !== 0)
      $(n, "bad indentation of a mapping entry");
    else if (n.lineIndent < e)
      break;
  }
  return m && os(n, u, f, d, p, null, o, l, a), b && (n.tag = c, n.anchor = h, n.kind = "mapping", n.result = u), b;
}
function GT(n) {
  var e, t = !1, i = !1, r, s, o;
  if (o = n.input.charCodeAt(n.position), o !== 33)
    return !1;
  if (n.tag !== null && $(n, "duplication of a tag property"), o = n.input.charCodeAt(++n.position), o === 60 ? (t = !0, o = n.input.charCodeAt(++n.position)) : o === 33 ? (i = !0, r = "!!", o = n.input.charCodeAt(++n.position)) : r = "!", e = n.position, t) {
    do
      o = n.input.charCodeAt(++n.position);
    while (o !== 0 && o !== 62);
    n.position < n.length ? (s = n.input.slice(e, n.position), o = n.input.charCodeAt(++n.position)) : $(n, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !Mt(o); )
      o === 33 && (i ? $(n, "tag suffix cannot contain exclamation marks") : (r = n.input.slice(e - 1, n.position + 1), nx.test(r) || $(n, "named tag handle cannot contain such characters"), i = !0, e = n.position + 1)), o = n.input.charCodeAt(++n.position);
    s = n.input.slice(e, n.position), BT.test(s) && $(n, "tag suffix cannot contain flow indicator characters");
  }
  s && !ix.test(s) && $(n, "tag name cannot contain such characters: " + s);
  try {
    s = decodeURIComponent(s);
  } catch {
    $(n, "tag name is malformed: " + s);
  }
  return t ? n.tag = s : qi.call(n.tagMap, r) ? n.tag = n.tagMap[r] + s : r === "!" ? n.tag = "!" + s : r === "!!" ? n.tag = "tag:yaml.org,2002:" + s : $(n, 'undeclared tag handle "' + r + '"'), !0;
}
function KT(n) {
  var e, t;
  if (t = n.input.charCodeAt(n.position), t !== 38)
    return !1;
  for (n.anchor !== null && $(n, "duplication of an anchor property"), t = n.input.charCodeAt(++n.position), e = n.position; t !== 0 && !Mt(t) && !ss(t); )
    t = n.input.charCodeAt(++n.position);
  return n.position === e && $(n, "name of an anchor node must contain at least one character"), n.anchor = n.input.slice(e, n.position), !0;
}
function YT(n) {
  var e, t, i;
  if (i = n.input.charCodeAt(n.position), i !== 42)
    return !1;
  for (i = n.input.charCodeAt(++n.position), e = n.position; i !== 0 && !Mt(i) && !ss(i); )
    i = n.input.charCodeAt(++n.position);
  return n.position === e && $(n, "name of an alias node must contain at least one character"), t = n.input.slice(e, n.position), qi.call(n.anchorMap, t) || $(n, 'unidentified alias "' + t + '"'), n.result = n.anchorMap[t], He(n, !0, -1), !0;
}
function Rs(n, e, t, i, r) {
  var s, o, l, a = 1, c = !1, h = !1, u, f, d, p, g, m;
  if (n.listener !== null && n.listener("open", n), n.tag = null, n.anchor = null, n.kind = null, n.result = null, s = o = l = xc === t || tx === t, i && He(n, !0, -1) && (c = !0, n.lineIndent > e ? a = 1 : n.lineIndent === e ? a = 0 : n.lineIndent < e && (a = -1)), a === 1)
    for (; GT(n) || KT(n); )
      He(n, !0, -1) ? (c = !0, l = s, n.lineIndent > e ? a = 1 : n.lineIndent === e ? a = 0 : n.lineIndent < e && (a = -1)) : l = !1;
  if (l && (l = c || r), (a === 1 || xc === t) && (vc === t || ex === t ? g = e : g = e + 1, m = n.position - n.lineStart, a === 1 ? l && (I0(n, m) || jT(n, m, g)) || UT(n, g) ? h = !0 : (o && WT(n, g) || VT(n, g) || zT(n, g) ? h = !0 : YT(n) ? (h = !0, (n.tag !== null || n.anchor !== null) && $(n, "alias node should not have any properties")) : qT(n, g, vc === t) && (h = !0, n.tag === null && (n.tag = "?")), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : a === 0 && (h = l && I0(n, m))), n.tag === null)
    n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
  else if (n.tag === "?") {
    for (n.result !== null && n.kind !== "scalar" && $(n, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + n.kind + '"'), u = 0, f = n.implicitTypes.length; u < f; u += 1)
      if (p = n.implicitTypes[u], p.resolve(n.result)) {
        n.result = p.construct(n.result), n.tag = p.tag, n.anchor !== null && (n.anchorMap[n.anchor] = n.result);
        break;
      }
  } else if (n.tag !== "!") {
    if (qi.call(n.typeMap[n.kind || "fallback"], n.tag))
      p = n.typeMap[n.kind || "fallback"][n.tag];
    else
      for (p = null, d = n.typeMap.multi[n.kind || "fallback"], u = 0, f = d.length; u < f; u += 1)
        if (n.tag.slice(0, d[u].tag.length) === d[u].tag) {
          p = d[u];
          break;
        }
    p || $(n, "unknown tag !<" + n.tag + ">"), n.result !== null && p.kind !== n.kind && $(n, "unacceptable node kind for !<" + n.tag + '> tag; it should be "' + p.kind + '", not "' + n.kind + '"'), p.resolve(n.result, n.tag) ? (n.result = p.construct(n.result, n.tag), n.anchor !== null && (n.anchorMap[n.anchor] = n.result)) : $(n, "cannot resolve a node with !<" + n.tag + "> explicit tag");
  }
  return n.listener !== null && n.listener("close", n), n.tag !== null || n.anchor !== null || h;
}
function JT(n) {
  var e = n.position, t, i, r, s = !1, o;
  for (n.version = null, n.checkLineBreaks = n.legacy, n.tagMap = /* @__PURE__ */ Object.create(null), n.anchorMap = /* @__PURE__ */ Object.create(null); (o = n.input.charCodeAt(n.position)) !== 0 && (He(n, !0, -1), o = n.input.charCodeAt(n.position), !(n.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = n.input.charCodeAt(++n.position), t = n.position; o !== 0 && !Mt(o); )
      o = n.input.charCodeAt(++n.position);
    for (i = n.input.slice(t, n.position), r = [], i.length < 1 && $(n, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; yr(o); )
        o = n.input.charCodeAt(++n.position);
      if (o === 35) {
        do
          o = n.input.charCodeAt(++n.position);
        while (o !== 0 && !$n(o));
        break;
      }
      if ($n(o))
        break;
      for (t = n.position; o !== 0 && !Mt(o); )
        o = n.input.charCodeAt(++n.position);
      r.push(n.input.slice(t, n.position));
    }
    o !== 0 && eg(n), qi.call(L0, i) ? L0[i](n, i, r) : kc(n, 'unknown document directive "' + i + '"');
  }
  if (He(n, !0, -1), n.lineIndent === 0 && n.input.charCodeAt(n.position) === 45 && n.input.charCodeAt(n.position + 1) === 45 && n.input.charCodeAt(n.position + 2) === 45 ? (n.position += 3, He(n, !0, -1)) : s && $(n, "directives end mark is expected"), Rs(n, n.lineIndent - 1, xc, !1, !0), He(n, !0, -1), n.checkLineBreaks && IT.test(n.input.slice(e, n.position)) && kc(n, "non-ASCII line breaks are interpreted as content"), n.documents.push(n.result), n.position === n.lineStart && Ch(n)) {
    n.input.charCodeAt(n.position) === 46 && (n.position += 3, He(n, !0, -1));
    return;
  }
  if (n.position < n.length - 1)
    $(n, "end of the stream or a document separator is expected");
  else
    return;
}
function lx(n, e) {
  n = String(n), e = e || {}, n.length !== 0 && (n.charCodeAt(n.length - 1) !== 10 && n.charCodeAt(n.length - 1) !== 13 && (n += `
`), n.charCodeAt(0) === 65279 && (n = n.slice(1)));
  var t = new HT(n, e), i = n.indexOf("\0");
  for (i !== -1 && (t.position = i, $(t, "null byte is not allowed in input")), t.input += "\0"; t.input.charCodeAt(t.position) === 32; )
    t.lineIndent += 1, t.position += 1;
  for (; t.position < t.length - 1; )
    JT(t);
  return t.documents;
}
function ZT(n, e, t) {
  e !== null && typeof e == "object" && typeof t > "u" && (t = e, e = null);
  var i = lx(n, t);
  if (typeof e != "function")
    return i;
  for (var r = 0, s = i.length; r < s; r += 1)
    e(i[r]);
}
function XT(n, e) {
  var t = lx(n, e);
  if (t.length !== 0) {
    if (t.length === 1)
      return t[0];
    throw new vt("expected a single document in the stream, but found more");
  }
}
var QT = ZT, eM = XT, ax = {
  loadAll: QT,
  load: eM
}, cx = Object.prototype.toString, hx = Object.prototype.hasOwnProperty, ng = 65279, tM = 9, Yo = 10, nM = 13, iM = 32, rM = 33, sM = 34, nd = 35, oM = 37, lM = 38, aM = 39, cM = 42, ux = 44, hM = 45, _c = 58, uM = 61, fM = 62, dM = 63, pM = 64, fx = 91, dx = 93, gM = 96, px = 123, mM = 124, gx = 125, gt = {};
gt[0] = "\\0";
gt[7] = "\\a";
gt[8] = "\\b";
gt[9] = "\\t";
gt[10] = "\\n";
gt[11] = "\\v";
gt[12] = "\\f";
gt[13] = "\\r";
gt[27] = "\\e";
gt[34] = '\\"';
gt[92] = "\\\\";
gt[133] = "\\N";
gt[160] = "\\_";
gt[8232] = "\\L";
gt[8233] = "\\P";
var bM = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], yM = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function wM(n, e) {
  var t, i, r, s, o, l, a;
  if (e === null)
    return {};
  for (t = {}, i = Object.keys(e), r = 0, s = i.length; r < s; r += 1)
    o = i[r], l = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), a = n.compiledTypeMap.fallback[o], a && hx.call(a.styleAliases, l) && (l = a.styleAliases[l]), t[o] = l;
  return t;
}
function vM(n) {
  var e, t, i;
  if (e = n.toString(16).toUpperCase(), n <= 255)
    t = "x", i = 2;
  else if (n <= 65535)
    t = "u", i = 4;
  else if (n <= 4294967295)
    t = "U", i = 8;
  else
    throw new vt("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + t + je.repeat("0", i - e.length) + e;
}
var xM = 1, Jo = 2;
function kM(n) {
  this.schema = n.schema || Qp, this.indent = Math.max(1, n.indent || 2), this.noArrayIndent = n.noArrayIndent || !1, this.skipInvalid = n.skipInvalid || !1, this.flowLevel = je.isNothing(n.flowLevel) ? -1 : n.flowLevel, this.styleMap = wM(this.schema, n.styles || null), this.sortKeys = n.sortKeys || !1, this.lineWidth = n.lineWidth || 80, this.noRefs = n.noRefs || !1, this.noCompatMode = n.noCompatMode || !1, this.condenseFlow = n.condenseFlow || !1, this.quotingType = n.quotingType === '"' ? Jo : xM, this.forceQuotes = n.forceQuotes || !1, this.replacer = typeof n.replacer == "function" ? n.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function B0(n, e) {
  for (var t = je.repeat(" ", e), i = 0, r = -1, s = "", o, l = n.length; i < l; )
    r = n.indexOf(`
`, i), r === -1 ? (o = n.slice(i), i = l) : (o = n.slice(i, r + 1), i = r + 1), o.length && o !== `
` && (s += t), s += o;
  return s;
}
function id(n, e) {
  return `
` + je.repeat(" ", n.indent * e);
}
function _M(n, e) {
  var t, i, r;
  for (t = 0, i = n.implicitTypes.length; t < i; t += 1)
    if (r = n.implicitTypes[t], r.resolve(e))
      return !0;
  return !1;
}
function Sc(n) {
  return n === iM || n === tM;
}
function Zo(n) {
  return 32 <= n && n <= 126 || 161 <= n && n <= 55295 && n !== 8232 && n !== 8233 || 57344 <= n && n <= 65533 && n !== ng || 65536 <= n && n <= 1114111;
}
function N0(n) {
  return Zo(n) && n !== ng && n !== nM && n !== Yo;
}
function P0(n, e, t) {
  var i = N0(n), r = i && !Sc(n);
  return (t ? i : i && n !== ux && n !== fx && n !== dx && n !== px && n !== gx) && n !== nd && !(e === _c && !r) || N0(e) && !Sc(e) && n === nd || e === _c && r;
}
function SM(n) {
  return Zo(n) && n !== ng && !Sc(n) && n !== hM && n !== dM && n !== _c && n !== ux && n !== fx && n !== dx && n !== px && n !== gx && n !== nd && n !== lM && n !== cM && n !== rM && n !== mM && n !== uM && n !== fM && n !== aM && n !== sM && n !== oM && n !== pM && n !== gM;
}
function CM(n) {
  return !Sc(n) && n !== _c;
}
function xo(n, e) {
  var t = n.charCodeAt(e), i;
  return t >= 55296 && t <= 56319 && e + 1 < n.length && (i = n.charCodeAt(e + 1), i >= 56320 && i <= 57343) ? (t - 55296) * 1024 + i - 56320 + 65536 : t;
}
function mx(n) {
  var e = /^\n* /;
  return e.test(n);
}
var bx = 1, rd = 2, yx = 3, wx = 4, ts = 5;
function AM(n, e, t, i, r, s, o, l) {
  var a, c = 0, h = null, u = !1, f = !1, d = i !== -1, p = -1, g = SM(xo(n, 0)) && CM(xo(n, n.length - 1));
  if (e || o)
    for (a = 0; a < n.length; c >= 65536 ? a += 2 : a++) {
      if (c = xo(n, a), !Zo(c))
        return ts;
      g = g && P0(c, h, l), h = c;
    }
  else {
    for (a = 0; a < n.length; c >= 65536 ? a += 2 : a++) {
      if (c = xo(n, a), c === Yo)
        u = !0, d && (f = f || a - p - 1 > i && n[p + 1] !== " ", p = a);
      else if (!Zo(c))
        return ts;
      g = g && P0(c, h, l), h = c;
    }
    f = f || d && a - p - 1 > i && n[p + 1] !== " ";
  }
  return !u && !f ? g && !o && !r(n) ? bx : s === Jo ? ts : rd : t > 9 && mx(n) ? ts : o ? s === Jo ? ts : rd : f ? wx : yx;
}
function DM(n, e, t, i, r) {
  n.dump = function() {
    if (e.length === 0)
      return n.quotingType === Jo ? '""' : "''";
    if (!n.noCompatMode && (bM.indexOf(e) !== -1 || yM.test(e)))
      return n.quotingType === Jo ? '"' + e + '"' : "'" + e + "'";
    var s = n.indent * Math.max(1, t), o = n.lineWidth === -1 ? -1 : Math.max(Math.min(n.lineWidth, 40), n.lineWidth - s), l = i || n.flowLevel > -1 && t >= n.flowLevel;
    function a(c) {
      return _M(n, c);
    }
    switch (AM(
      e,
      l,
      n.indent,
      o,
      a,
      n.quotingType,
      n.forceQuotes && !i,
      r
    )) {
      case bx:
        return e;
      case rd:
        return "'" + e.replace(/'/g, "''") + "'";
      case yx:
        return "|" + F0(e, n.indent) + $0(B0(e, s));
      case wx:
        return ">" + F0(e, n.indent) + $0(B0(EM(e, o), s));
      case ts:
        return '"' + TM(e) + '"';
      default:
        throw new vt("impossible error: invalid scalar style");
    }
  }();
}
function F0(n, e) {
  var t = mx(n) ? String(e) : "", i = n[n.length - 1] === `
`, r = i && (n[n.length - 2] === `
` || n === `
`), s = r ? "+" : i ? "" : "-";
  return t + s + `
`;
}
function $0(n) {
  return n[n.length - 1] === `
` ? n.slice(0, -1) : n;
}
function EM(n, e) {
  for (var t = /(\n+)([^\n]*)/g, i = function() {
    var c = n.indexOf(`
`);
    return c = c !== -1 ? c : n.length, t.lastIndex = c, H0(n.slice(0, c), e);
  }(), r = n[0] === `
` || n[0] === " ", s, o; o = t.exec(n); ) {
    var l = o[1], a = o[2];
    s = a[0] === " ", i += l + (!r && !s && a !== "" ? `
` : "") + H0(a, e), r = s;
  }
  return i;
}
function H0(n, e) {
  if (n === "" || n[0] === " ")
    return n;
  for (var t = / [^ ]/g, i, r = 0, s, o = 0, l = 0, a = ""; i = t.exec(n); )
    l = i.index, l - r > e && (s = o > r ? o : l, a += `
` + n.slice(r, s), r = s + 1), o = l;
  return a += `
`, n.length - r > e && o > r ? a += n.slice(r, o) + `
` + n.slice(o + 1) : a += n.slice(r), a.slice(1);
}
function TM(n) {
  for (var e = "", t = 0, i, r = 0; r < n.length; t >= 65536 ? r += 2 : r++)
    t = xo(n, r), i = gt[t], !i && Zo(t) ? (e += n[r], t >= 65536 && (e += n[r + 1])) : e += i || vM(t);
  return e;
}
function MM(n, e, t) {
  var i = "", r = n.tag, s, o, l;
  for (s = 0, o = t.length; s < o; s += 1)
    l = t[s], n.replacer && (l = n.replacer.call(t, String(s), l)), (li(n, e, l, !1, !1) || typeof l > "u" && li(n, e, null, !1, !1)) && (i !== "" && (i += "," + (n.condenseFlow ? "" : " ")), i += n.dump);
  n.tag = r, n.dump = "[" + i + "]";
}
function q0(n, e, t, i) {
  var r = "", s = n.tag, o, l, a;
  for (o = 0, l = t.length; o < l; o += 1)
    a = t[o], n.replacer && (a = n.replacer.call(t, String(o), a)), (li(n, e + 1, a, !0, !0, !1, !0) || typeof a > "u" && li(n, e + 1, null, !0, !0, !1, !0)) && ((!i || r !== "") && (r += id(n, e)), n.dump && Yo === n.dump.charCodeAt(0) ? r += "-" : r += "- ", r += n.dump);
  n.tag = s, n.dump = r || "[]";
}
function OM(n, e, t) {
  var i = "", r = n.tag, s = Object.keys(t), o, l, a, c, h;
  for (o = 0, l = s.length; o < l; o += 1)
    h = "", i !== "" && (h += ", "), n.condenseFlow && (h += '"'), a = s[o], c = t[a], n.replacer && (c = n.replacer.call(t, a, c)), li(n, e, a, !1, !1) && (n.dump.length > 1024 && (h += "? "), h += n.dump + (n.condenseFlow ? '"' : "") + ":" + (n.condenseFlow ? "" : " "), li(n, e, c, !1, !1) && (h += n.dump, i += h));
  n.tag = r, n.dump = "{" + i + "}";
}
function LM(n, e, t, i) {
  var r = "", s = n.tag, o = Object.keys(t), l, a, c, h, u, f;
  if (n.sortKeys === !0)
    o.sort();
  else if (typeof n.sortKeys == "function")
    o.sort(n.sortKeys);
  else if (n.sortKeys)
    throw new vt("sortKeys must be a boolean or a function");
  for (l = 0, a = o.length; l < a; l += 1)
    f = "", (!i || r !== "") && (f += id(n, e)), c = o[l], h = t[c], n.replacer && (h = n.replacer.call(t, c, h)), li(n, e + 1, c, !0, !0, !0) && (u = n.tag !== null && n.tag !== "?" || n.dump && n.dump.length > 1024, u && (n.dump && Yo === n.dump.charCodeAt(0) ? f += "?" : f += "? "), f += n.dump, u && (f += id(n, e)), li(n, e + 1, h, !0, u) && (n.dump && Yo === n.dump.charCodeAt(0) ? f += ":" : f += ": ", f += n.dump, r += f));
  n.tag = s, n.dump = r || "{}";
}
function V0(n, e, t) {
  var i, r, s, o, l, a;
  for (r = t ? n.explicitTypes : n.implicitTypes, s = 0, o = r.length; s < o; s += 1)
    if (l = r[s], (l.instanceOf || l.predicate) && (!l.instanceOf || typeof e == "object" && e instanceof l.instanceOf) && (!l.predicate || l.predicate(e))) {
      if (t ? l.multi && l.representName ? n.tag = l.representName(e) : n.tag = l.tag : n.tag = "?", l.represent) {
        if (a = n.styleMap[l.tag] || l.defaultStyle, cx.call(l.represent) === "[object Function]")
          i = l.represent(e, a);
        else if (hx.call(l.represent, a))
          i = l.represent[a](e, a);
        else
          throw new vt("!<" + l.tag + '> tag resolver accepts not "' + a + '" style');
        n.dump = i;
      }
      return !0;
    }
  return !1;
}
function li(n, e, t, i, r, s, o) {
  n.tag = null, n.dump = t, V0(n, t, !1) || V0(n, t, !0);
  var l = cx.call(n.dump), a = i, c;
  i && (i = n.flowLevel < 0 || n.flowLevel > e);
  var h = l === "[object Object]" || l === "[object Array]", u, f;
  if (h && (u = n.duplicates.indexOf(t), f = u !== -1), (n.tag !== null && n.tag !== "?" || f || n.indent !== 2 && e > 0) && (r = !1), f && n.usedDuplicates[u])
    n.dump = "*ref_" + u;
  else {
    if (h && f && !n.usedDuplicates[u] && (n.usedDuplicates[u] = !0), l === "[object Object]")
      i && Object.keys(n.dump).length !== 0 ? (LM(n, e, n.dump, r), f && (n.dump = "&ref_" + u + n.dump)) : (OM(n, e, n.dump), f && (n.dump = "&ref_" + u + " " + n.dump));
    else if (l === "[object Array]")
      i && n.dump.length !== 0 ? (n.noArrayIndent && !o && e > 0 ? q0(n, e - 1, n.dump, r) : q0(n, e, n.dump, r), f && (n.dump = "&ref_" + u + n.dump)) : (MM(n, e, n.dump), f && (n.dump = "&ref_" + u + " " + n.dump));
    else if (l === "[object String]")
      n.tag !== "?" && DM(n, n.dump, e, s, a);
    else {
      if (l === "[object Undefined]")
        return !1;
      if (n.skipInvalid)
        return !1;
      throw new vt("unacceptable kind of an object to dump " + l);
    }
    n.tag !== null && n.tag !== "?" && (c = encodeURI(
      n.tag[0] === "!" ? n.tag.slice(1) : n.tag
    ).replace(/!/g, "%21"), n.tag[0] === "!" ? c = "!" + c : c.slice(0, 18) === "tag:yaml.org,2002:" ? c = "!!" + c.slice(18) : c = "!<" + c + ">", n.dump = c + " " + n.dump);
  }
  return !0;
}
function RM(n, e) {
  var t = [], i = [], r, s;
  for (sd(n, t, i), r = 0, s = i.length; r < s; r += 1)
    e.duplicates.push(t[i[r]]);
  e.usedDuplicates = new Array(s);
}
function sd(n, e, t) {
  var i, r, s;
  if (n !== null && typeof n == "object")
    if (r = e.indexOf(n), r !== -1)
      t.indexOf(r) === -1 && t.push(r);
    else if (e.push(n), Array.isArray(n))
      for (r = 0, s = n.length; r < s; r += 1)
        sd(n[r], e, t);
    else
      for (i = Object.keys(n), r = 0, s = i.length; r < s; r += 1)
        sd(n[i[r]], e, t);
}
function IM(n, e) {
  e = e || {};
  var t = new kM(e);
  t.noRefs || RM(n, t);
  var i = n;
  return t.replacer && (i = t.replacer.call({ "": i }, "", i)), li(t, 0, i, !0, !0) ? t.dump + `
` : "";
}
var BM = IM, NM = {
  dump: BM
};
function ig(n, e) {
  return function() {
    throw new Error("Function yaml." + n + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.");
  };
}
var PM = rt, FM = Bv, $M = $v, HM = Uv, qM = Wv, VM = Qp, zM = ax.load, UM = ax.loadAll, WM = NM.dump, jM = vt, GM = {
  binary: Jv,
  float: zv,
  map: Fv,
  null: Hv,
  pairs: Xv,
  set: Qv,
  timestamp: Kv,
  bool: qv,
  int: Vv,
  merge: Yv,
  omap: Zv,
  seq: Pv,
  str: Nv
}, KM = ig("safeLoad", "load"), YM = ig("safeLoadAll", "loadAll"), JM = ig("safeDump", "dump"), ZM = {
  Type: PM,
  Schema: FM,
  FAILSAFE_SCHEMA: $M,
  JSON_SCHEMA: HM,
  CORE_SCHEMA: qM,
  DEFAULT_SCHEMA: VM,
  load: zM,
  loadAll: UM,
  dump: WM,
  YAMLException: jM,
  types: GM,
  safeLoad: KM,
  safeLoadAll: YM,
  safeDump: JM
};
function XM(n, e, t, i, r, s = !0) {
  const o = [];
  for (const a of [...n.core.ruler.__rules__].reverse()) {
    if (a.name === e) {
      s || o.push(a.name);
      break;
    }
    a.name && o.push(a.name);
  }
  n.core.ruler.disable(o);
  let l = [];
  try {
    l = n.parse(t, i);
  } finally {
    n.core.ruler.enable(o);
  }
  for (const a of l)
    a.map = a.map !== null ? [a.map[0] + r, a.map[1] + r] : a.map;
  return l;
}
class Hr {
  constructor(e) {
    this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !1, this.option_spec = {}, this.rawOptions = !1, this.state = e;
  }
  run(e) {
    return [];
  }
  assert(e, t) {
    if (!e)
      throw new Error(t);
  }
  assert_has_content(e) {
    if (!e.body)
      throw new Error("Content block expected, but none found.");
  }
  createToken(e, t, i, r) {
    const s = new this.state.Token(e, t, i);
    return (r == null ? void 0 : r.content) !== void 0 && (s.content = r.content), (r == null ? void 0 : r.level) !== void 0 && (s.level = r.level), (r == null ? void 0 : r.map) !== void 0 && (s.map = r.map), (r == null ? void 0 : r.block) !== void 0 && (s.block = r.block), (r == null ? void 0 : r.info) !== void 0 && (s.info = r.info), (r == null ? void 0 : r.meta) !== void 0 && (s.meta = r.meta), (r == null ? void 0 : r.children) !== void 0 && (s.children = r.children), s;
  }
  nestedParse(e, t) {
    return XM(this.state.md, "run_directives", e, this.state.env, t, !0);
  }
}
class Ei extends Error {
  constructor() {
    super(...arguments), this.name = "DirectiveParsingError";
  }
}
function QM(n, e) {
  const t = n.meta.arg || "", i = n.content;
  let r = i.trim() ? i.split(/\r?\n/) : [], s = 0, o = {};
  (Object.keys(e.option_spec || {}) || e.rawOptions) && ([r, o, s] = vx(r, e));
  let l = [];
  if (!e.required_arguments && !e.optional_arguments ? t && (s = 0, r = [t].concat(r)) : l = eO(t, e), r.length && !r[0].trim() && (r.shift(), s++), r.length && !e.has_content)
    throw new Ei("Has content but content not allowed");
  return {
    map: n.map ? n.map : [0, 0],
    args: l,
    options: o,
    body: r.join(`
`),
    bodyMap: n.map ? [
      r.length > 0 ? n.map[0] + s : n.map[1],
      r.length > 0 ? n.map[1] - 1 : n.map[1]
    ] : [0, 0]
  };
}
function vx(n, e) {
  let t = 1, i = {}, r = null;
  if (n.length && n[0].startsWith("---")) {
    t++;
    const s = [];
    r = [];
    let o = !1;
    for (const l of n.slice(1)) {
      if (l.startsWith("---")) {
        t++, o = !0;
        continue;
      }
      o ? s.push(l) : (t++, r.push(l));
    }
    n = s;
  } else if (n.length && n[0].startsWith(":")) {
    const s = [];
    r = [];
    let o = !1;
    for (const l of n) {
      if (!o && !l.startsWith(":")) {
        o = !0, s.push(l);
        continue;
      }
      o ? s.push(l) : (t++, r.push(l.slice(1)));
    }
    n = s;
  }
  if (r !== null)
    try {
      const s = ZM.load(r.join(`
`));
      if (s !== null && typeof s == "object")
        i = s;
      else
        throw new Ei(`not dict: ${s}`);
    } catch (s) {
      throw new Ei(`Invalid options YAML: ${s}`);
    }
  if (e.rawOptions)
    return [n, i, t];
  for (const [s, o] of Object.entries(i)) {
    const l = e.option_spec ? e.option_spec[s] : null;
    if (!l)
      throw new Ei(`Unknown option: ${s}`);
    let a = o;
    (o === null || o === !1) && (a = "");
    try {
      a = l(`${a || ""}`);
    } catch (c) {
      throw new Ei(`Invalid option value: (option: '${s}'; value: ${o})
${c}`);
    }
    i[s] = a;
  }
  return [n, i, t];
}
function eO(n, e) {
  var t;
  let i = n.trim() ? (t = n.trim()) === null || t === void 0 ? void 0 : t.split(/\s+/) : [];
  const r = (e.required_arguments || 0) + (e.optional_arguments || 0);
  if (i.length < (e.required_arguments || 0))
    throw new Ei(`${e.required_arguments} argument(s) required, ${i.length} supplied`);
  if (i.length > r)
    if (e.final_argument_whitespace) {
      const s = n.split(/\s+/);
      i = s.splice(0, r - 1), i.push(s.join(" "));
    } else
      throw new Ei(`maximum ${r} argument(s) allowed, ${i.length} supplied`);
  return i;
}
function tO(n, e) {
  var t;
  let i = e.directivesAfter || "block";
  (!((t = e.replaceFences) !== null && t !== void 0) || t) && (n.core.ruler.after(i, "fence_to_directive", nO), i = "fence_to_directive"), n.core.ruler.after(i, "run_directives", iO(e.directives || {})), n.renderer.rules.directive = (r, s) => {
    const o = r[s];
    return `<aside class="directive-unhandled">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.content}</pre></aside>
`;
  }, n.renderer.rules.directive_error = (r, s) => {
    const o = r[s];
    let l = "";
    return o.content && (l = `
---
${o.content}`), `<aside class="directive-error">
<header><mark>${o.info}</mark><code> ${o.meta.arg}</code></header>
<pre>${o.meta.error_name}:
${o.meta.error_message}
${l}</pre></aside>
`;
  };
}
function nO(n) {
  for (const e of n.tokens)
    if (e.type === "fence" || e.type === "colon_fence") {
      const t = e.info.match(/^\{([^\s}]+)\}\s*(.*)$/);
      t && (e.type = "directive", e.info = t[1], e.meta = { arg: t[2] });
    }
  return !0;
}
function iO(n) {
  function e(t) {
    const i = [];
    for (const r of t.tokens)
      if (r.type === "directive" && r.info in n)
        try {
          const s = new n[r.info](t), o = QM(r, s), [l, a] = vx(r.content.trim() ? r.content.split(/\r?\n/) : [], s), c = new t.Token("parsed_directive_open", "", 1);
          c.info = r.info, c.hidden = !0, c.content = l.join(`
`).trim(), c.meta = {
            arg: r.meta.arg,
            opts: a
          };
          const h = [c];
          h.push(...s.run(o));
          const u = new t.Token("parsed_directive_close", "", -1);
          u.hidden = !0, h.push(u), h[1].meta = Object.assign(Object.assign({ directive: !0 }, o.options), h[1].meta), i.push(...h);
        } catch (s) {
          const o = new t.Token("directive_error", "", 0);
          o.content = r.content, o.info = r.info, o.meta = r.meta, o.map = r.map, o.meta.error_message = s.message, o.meta.error_name = s.name, i.push(o);
        }
      else
        i.push(r);
    return t.tokens = i, !0;
  }
  return e;
}
function rO(n) {
  return n.toLowerCase().split(/\s+/).join("-").replace(/[^a-z0-9]+/, "-").replace(/^[-0-9]+|-+$/, "");
}
class Er extends Error {
  constructor() {
    super(...arguments), this.name = "OptionSpecError";
  }
}
const Vi = (n) => n, od = (n) => {
  if (!n)
    throw new Er("Argument required but none supplied");
  return n;
}, ld = (n) => {
  if (n.trim())
    throw new Er(`No argument is allowed: "${n}" supplied`);
  return null;
}, Zs = (n) => `${n || ""}`.split(/\s+/).map((e) => rO(e));
function xx(n) {
  if (!n)
    throw new Er("Value is not set");
  const e = Number.parseFloat(n);
  if (Number.isNaN(e) || !Number.isInteger(e))
    throw new Er(`Value "${n}" is not an integer`);
  return e;
}
function Cc(n) {
  const e = xx(n);
  if (e < 0)
    throw new Er(`Value "${n}" must be positive or zero`);
  return e;
}
const kx = (n) => n ? Cc(n) : null, sO = (n) => (n = `${n || ""}`.replace(/\s+%$/, ""), Cc(n));
function _x(n, e) {
  const i = new RegExp(`^(?<number>[0-9.]+)\\s*(?<units>${e.join("|")})$`).exec(n);
  if (!i || !i.groups)
    throw new Er(`not a positive measure of one of the following units: ${e.join("|")}`);
  return i.groups.number + i.groups.units;
}
const Sx = ["em", "ex", "px", "in", "cm", "mm", "pt", "pc"], Cx = (n) => _x(n, [...Sx, ""]), rg = (n, e = "") => {
  try {
    return _x(n, [...Sx, "%"]);
  } catch {
    return Cx(n) + e;
  }
}, oO = (n, e = "") => n.toLowerCase() === "image" ? "image" : rg(n, e);
function sg(n) {
  return (e) => {
    if (e = e.toLowerCase().trim(), n.includes(e))
      return e;
    throw new Er(`must be in: ${n.join("|")}`);
  };
}
const lO = (n) => n;
class yn extends Hr {
  constructor() {
    super(...arguments), this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      class: Zs,
      name: Vi
    }, this.title = "", this.kind = "";
  }
  run(e) {
    var t;
    const i = [], r = this.createToken("admonition_open", "aside", 1, {
      map: e.map,
      block: !0,
      meta: { kind: this.kind }
    });
    ((t = e.options.class) === null || t === void 0 ? void 0 : t.length) >= 1 ? (r.attrSet("class", e.options.class.join(" ")), r.attrJoin("class", "admonition")) : r.attrSet("class", "admonition"), this.kind && r.attrJoin("class", this.kind), i.push(r);
    const s = this.createToken("admonition_title_open", "header", 1);
    s.attrSet("class", "admonition-title"), i.push(s);
    const o = e.args[0] || this.title;
    i.push(this.createToken("inline", "", 0, {
      map: [e.map[0], e.map[0]],
      content: o,
      children: []
    })), i.push(this.createToken("admonition_title_close", "header", -1, { block: !0 }));
    const l = this.nestedParse(e.body, e.bodyMap[0]);
    return i.push(...l), i.push(this.createToken("admonition_close", "aside", -1, { block: !0 })), i;
  }
}
class aO extends yn {
  constructor() {
    super(...arguments), this.required_arguments = 1;
  }
}
class cO extends yn {
  constructor() {
    super(...arguments), this.title = "Attention", this.kind = "attention";
  }
}
class hO extends yn {
  constructor() {
    super(...arguments), this.title = "Caution", this.kind = "caution";
  }
}
class uO extends yn {
  constructor() {
    super(...arguments), this.title = "Danger", this.kind = "danger";
  }
}
class fO extends yn {
  constructor() {
    super(...arguments), this.title = "Error", this.kind = "error";
  }
}
class dO extends yn {
  constructor() {
    super(...arguments), this.title = "Important", this.kind = "important";
  }
}
class pO extends yn {
  constructor() {
    super(...arguments), this.title = "Hint", this.kind = "hint";
  }
}
class gO extends yn {
  constructor() {
    super(...arguments), this.title = "Note", this.kind = "note";
  }
}
class mO extends yn {
  constructor() {
    super(...arguments), this.title = "See Also", this.kind = "seealso";
  }
}
class bO extends yn {
  constructor() {
    super(...arguments), this.title = "Tip", this.kind = "tip";
  }
}
class yO extends yn {
  constructor() {
    super(...arguments), this.title = "Warning", this.kind = "warning";
  }
}
const wO = {
  admonition: aO,
  attention: cO,
  caution: hO,
  danger: uO,
  error: fO,
  important: dO,
  hint: pO,
  note: gO,
  seealso: mO,
  tip: bO,
  warning: yO
};
class vO extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      "number-lines": kx,
      force: ld,
      name: Vi,
      class: Zs
    };
  }
  run(e) {
    return this.assert_has_content(e), [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
class xO extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      linenos: ld,
      "lineno-start": xx,
      dedent: kx,
      "emphasize-lines": od,
      caption: od,
      force: ld,
      name: Vi,
      class: Zs
    };
  }
  run(e) {
    return this.assert_has_content(e), [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
class kO extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !1, this.has_content = !0, this.rawOptions = !0;
  }
  run(e) {
    return [this.createToken("fence", "code", 0, {
      info: e.args ? e.args[0] : "",
      content: e.body,
      map: e.bodyMap
    })];
  }
}
const _O = {
  code: vO,
  "code-block": xO,
  "code-cell": kO
}, Ax = {
  alt: Vi,
  height: Cx,
  width: rg,
  scale: sO,
  target: od,
  class: Zs,
  name: Vi
};
class Dx extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 1, this.optional_arguments = 0, this.final_argument_whitespace = !0, this.option_spec = Object.assign(Object.assign({}, Ax), { align: sg(["left", "center", "right", "top", "middle", "bottom"]) });
  }
  create_image(e) {
    const t = lO(e.args[0] || ""), i = this.createToken("image", "img", 0, { map: e.map, block: !0 });
    i.attrSet("src", t), i.attrSet("alt", e.options.alt || "");
    const r = [];
    return e.options.alt && this.state.md.inline.parse(e.options.alt, this.state.md, this.state.env, r), i.children = r, e.options.height && i.attrSet("height", e.options.height), e.options.width && i.attrSet("width", e.options.width), e.options.align && i.attrJoin("class", `align-${e.options.align}`), e.options.class && i.attrJoin("class", e.options.class.join(" ")), i;
  }
  run(e) {
    return [this.create_image(e)];
  }
}
class SO extends Dx {
  constructor() {
    super(...arguments), this.option_spec = Object.assign(Object.assign({}, Ax), { align: sg(["left", "center", "right"]), figwidth: oO, figclass: Zs }), this.has_content = !0;
  }
  run(e) {
    const t = this.createToken("figure_open", "figure", 1, {
      map: e.map,
      block: !0
    });
    e.options.figclass && t.attrJoin("class", e.options.figclass.join(" ")), e.options.align && t.attrJoin("class", `align-${e.options.align}`), e.options.figwidth && e.options.figwidth !== "image" && t.attrSet("width", e.options.figwidth);
    let i;
    e.options.name && (i = Ov(
      this.state,
      t,
      Go.figure,
      e.options.name,
      e.body.trim()
    ), t.attrJoin("class", "numbered"));
    const r = this.create_image(e);
    r.map = [e.map[0], e.map[0]];
    let s = [], o = [];
    if (e.body) {
      const [a, ...c] = e.body.split(`

`), h = c.join(`

`), u = e.bodyMap[0], f = this.createToken("figure_caption_open", "figcaption", 1, {
        block: !0
      });
      i && f.attrSet("number", `${i.number}`);
      const d = this.nestedParse(a, u), p = this.createToken("figure_caption_close", "figcaption", -1, {
        block: !0
      });
      if (s = [f, ...d, p], h) {
        const g = u + a.split(`
`).length + 1, m = this.createToken("figure_legend_open", "", 1, {
          block: !0
        }), b = this.nestedParse(h, g), y = this.createToken("figure_legend_close", "", -1, {
          block: !0
        });
        o = [m, ...b, y];
      }
    }
    const l = this.createToken("figure_close", "figure", -1, { block: !0 });
    return [t, r, ...s, ...o, l];
  }
}
const CO = {
  image: Dx,
  figure: SO
};
class og {
  constructor(e, t = !0) {
    if (this.children = [], this.children = [], t) {
      this._set_children_from_tokens(e);
      return;
    }
    if (e.length === 0)
      throw new Error("Tree creation: Can only create root from empty token sequence.");
    if (e.length === 1) {
      const i = e[0];
      if (i.nesting)
        throw new Error("Unequal nesting level at the start and end of token stream.");
      this.token = i, i.children !== null && i.children.length > 0 && this._set_children_from_tokens(i.children);
    } else
      this.nester_tokens = { opening: e[0], closing: e[e.length - 1] }, this._set_children_from_tokens(e.slice(1, -1));
  }
  _set_children_from_tokens(e) {
    const t = [...e].reverse();
    let i;
    for (; t.length > 0 && (i = t.pop(), !!i); ) {
      if (!i.nesting) {
        this._add_child([i]);
        continue;
      }
      if (i.nesting !== 1)
        throw new Error("Invalid token nesting");
      const r = [i];
      let s = 1;
      for (; t.length > 0 && s !== 0; )
        i = t.pop(), i && (r.push(i), s += i.nesting);
      if (s)
        throw new Error(`unclosed tokens starting: ${r[0]}`);
      this._add_child(r);
    }
  }
  _add_child(e) {
    const t = new og(e, !1);
    t.parent = this, this.children.push(t);
  }
  to_tokens() {
    function e(i, r) {
      if (i.type === "root")
        for (const s of i.children)
          e(s, r);
      else if (i.token)
        r.push(i.token);
      else {
        if (!i.nester_tokens)
          throw new Error("No nested token available");
        r.push(i.nester_tokens.opening);
        for (const s of i.children)
          e(s, r);
        r.push(i.nester_tokens.closing);
      }
    }
    const t = [];
    return e(this, t), t;
  }
  get is_root() {
    return !(this.token || this.nester_tokens);
  }
  get is_nested() {
    return !!this.nester_tokens;
  }
  get siblings() {
    return this.parent ? this.parent.children : [this];
  }
  *walk(e = !0) {
    e && (yield this);
    for (const t of this.children)
      yield* t.walk(!0);
  }
  get type() {
    var e, t, i;
    if (this.is_root)
      return "root";
    if (this.token)
      return this.token.type;
    if (!((e = this.nester_tokens) === null || e === void 0) && e.opening.type.endsWith("_open"))
      return (t = this.nester_tokens) === null || t === void 0 ? void 0 : t.opening.type.slice(0, -5);
    if (this.nester_tokens)
      return (i = this.nester_tokens) === null || i === void 0 ? void 0 : i.opening.type;
    throw new Error("no internal token");
  }
  attribute_token() {
    if (this.token)
      return this.token;
    if (this.nester_tokens)
      return this.nester_tokens.opening;
    throw new Error("Tree node does not have the accessed attribute");
  }
  get tag() {
    return this.attribute_token().tag;
  }
  get level() {
    return this.attribute_token().level;
  }
  get content() {
    return this.attribute_token().content;
  }
  get markup() {
    return this.attribute_token().markup;
  }
  get info() {
    return this.attribute_token().info;
  }
  get meta() {
    return this.attribute_token().meta;
  }
  get block() {
    return this.attribute_token().block;
  }
  get hidden() {
    return this.attribute_token().hidden;
  }
  get map() {
    return this.attribute_token().map;
  }
  get attrs() {
    return this.attribute_token().attrs;
  }
}
class AO extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 1, this.final_argument_whitespace = !0, this.has_content = !0, this.option_spec = {
      "header-rows": Cc,
      "stub-columns": Cc,
      width: rg,
      widths: Vi,
      class: Zs,
      name: Vi,
      align: sg(["left", "center", "right"])
    };
  }
  run(e) {
    this.assert_has_content(e);
    const t = e.options["header-rows"] || 0, i = this.nestedParse(e.body, e.bodyMap[0]);
    if (i.length < 2 || i[0].type !== "bullet_list_open" || i[i.length - 1].type !== "bullet_list_close")
      throw new Ei("Content is not a single bullet list");
    const r = [], s = this.createToken("table_open", "table", 1, { map: e.bodyMap });
    e.options.align && s.attrJoin("class", `align-${e.options.align}`), e.options.class && s.attrJoin("class", e.options.class.join(" ")), r.push(s), e.args.length && e.args[0] && (r.push(this.createToken("table_caption_open", "caption", 1)), r.push(this.createToken("inline", "", 0, {
      map: [e.map[0], e.map[0]],
      content: e.args[0],
      children: []
    })), r.push(this.createToken("table_caption_close", "caption", -1)));
    let o = "th";
    t ? (r.push(this.createToken("thead_open", "thead", 1, { level: 1 })), o = "th") : (r.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td");
    let l, a = 0;
    for (const c of new og(i.slice(1, -1)).children) {
      a += 1, this.assert(c.type === "list_item", `list item ${a} not of type 'list_item': ${c.type}`), this.assert(c.children.length === 1 && c.children[0].type === "bullet_list", `list item ${a} content not a nested bullet list`);
      const h = c.children[0].children;
      l === void 0 ? l = h.length : this.assert(h.length === l, `list item ${a} does not contain the same number of columns as previous items`), t && a === t + 1 && (r.push(this.createToken("thead_close", "thead", -1, { level: 1 })), r.push(this.createToken("tbody_open", "tbody", 1, { level: 1 })), o = "td"), r.push(this.createToken("tr_open", "tr", 1, { map: c.map, level: 2 }));
      for (const u of h)
        r.push(this.createToken(`${o}_open`, o, 1, { map: u.map, level: 3 })), r.push(...u.to_tokens().slice(1, -1)), r.push(this.createToken(`${o}_close`, o, -1, { level: 3 }));
      r.push(this.createToken("tr_close", "tr", -1, { level: 2 }));
    }
    if (t && a < t)
      throw new Error(`Insufficient rows (${a}) for required header rows (${t})`);
    return o === "td" ? r.push(this.createToken("tbody_close", "tbody", -1, { level: 1 })) : r.push(this.createToken("thead_close", "thead", -1, { level: 1 })), r.push(this.createToken("table_close", "table", -1)), r;
  }
}
const DO = {
  "list-table": AO
};
class EO extends Hr {
  constructor() {
    super(...arguments), this.required_arguments = 0, this.optional_arguments = 0, this.final_argument_whitespace = !1, this.has_content = !0, this.option_spec = {
      label: Vi
    };
  }
  run(e) {
    this.assert_has_content(e);
    const t = this.createToken("math_block", "div", 0, {
      content: e.body,
      map: e.bodyMap,
      block: !0
    });
    if (t.attrSet("class", "math block"), e.options.label) {
      t.attrSet("id", e.options.label);
      const i = Ov(this.state, t, Go.equation, e.options.label, "");
      t.attrSet("number", `${i.number}`), t.info = e.options.label, t.meta = { label: e.options.label, numbered: !0, number: i.number };
    }
    return [t];
  }
}
const TO = {
  math: EO
}, MO = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, wO), CO), _O), DO), TO);
function OO(n) {
  return (e) => {
    const t = Sh(e);
    return t.references.forEach((i) => {
      const { label: r, tokens: s, contentFromTarget: o } = i, l = (c, h) => (s.open.attrJoin("class", "error"), s.open.tag = s.close.tag = "code", o && h ? s.content.content = o(h) : s.content.content = c, !0), a = t.targets[r];
      if (!a)
        return l(r, {
          kind: i.kind || "",
          label: r,
          title: r,
          number: `"${r}"`
        });
      if (i.kind && a.kind !== i.kind)
        return l(`Reference "${r}" does not match kind "${i.kind}"`);
      s.open.attrSet("href", `#${a.label}`), a.title && s.open.attrSet("title", a.title), o && (s.content.content = o(a).trim());
    }), !0;
  };
}
function LO(n, e) {
  n.core.ruler.push("docutils_number", OO());
}
const RO = {
  parseRoles: !0,
  replaceFences: !0,
  rolesAfter: "inline",
  directivesAfter: "block",
  directives: MO,
  roles: OE
};
function IO(n, e) {
  const t = Object.assign(Object.assign({}, RO), e);
  n.use(wE, t), n.use(tO, t), n.use(LO, t);
}
/*! @license DOMPurify 2.4.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.7/LICENSE */
function Ci(n) {
  return Ci = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ci(n);
}
function ad(n, e) {
  return ad = Object.setPrototypeOf || function(i, r) {
    return i.__proto__ = r, i;
  }, ad(n, e);
}
function BO() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Ja(n, e, t) {
  return BO() ? Ja = Reflect.construct : Ja = function(r, s, o) {
    var l = [null];
    l.push.apply(l, s);
    var a = Function.bind.apply(r, l), c = new a();
    return o && ad(c, o.prototype), c;
  }, Ja.apply(null, arguments);
}
function cn(n) {
  return NO(n) || PO(n) || FO(n) || $O();
}
function NO(n) {
  if (Array.isArray(n))
    return cd(n);
}
function PO(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function FO(n, e) {
  if (!!n) {
    if (typeof n == "string")
      return cd(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return cd(n, e);
  }
}
function cd(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++)
    i[t] = n[t];
  return i;
}
function $O() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var HO = Object.hasOwnProperty, z0 = Object.setPrototypeOf, qO = Object.isFrozen, VO = Object.getPrototypeOf, zO = Object.getOwnPropertyDescriptor, St = Object.freeze, pn = Object.seal, UO = Object.create, Ex = typeof Reflect < "u" && Reflect, Ac = Ex.apply, hd = Ex.construct;
Ac || (Ac = function(e, t, i) {
  return e.apply(t, i);
});
St || (St = function(e) {
  return e;
});
pn || (pn = function(e) {
  return e;
});
hd || (hd = function(e, t) {
  return Ja(e, cn(t));
});
var WO = Xt(Array.prototype.forEach), U0 = Xt(Array.prototype.pop), uo = Xt(Array.prototype.push), Za = Xt(String.prototype.toLowerCase), Du = Xt(String.prototype.toString), jO = Xt(String.prototype.match), an = Xt(String.prototype.replace), GO = Xt(String.prototype.indexOf), KO = Xt(String.prototype.trim), bt = Xt(RegExp.prototype.test), Eu = YO(TypeError);
function Xt(n) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      i[r - 1] = arguments[r];
    return Ac(n, e, i);
  };
}
function YO(n) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return hd(n, t);
  };
}
function X(n, e, t) {
  var i;
  t = (i = t) !== null && i !== void 0 ? i : Za, z0 && z0(n, null);
  for (var r = e.length; r--; ) {
    var s = e[r];
    if (typeof s == "string") {
      var o = t(s);
      o !== s && (qO(e) || (e[r] = o), s = o);
    }
    n[s] = !0;
  }
  return n;
}
function ir(n) {
  var e = UO(null), t;
  for (t in n)
    Ac(HO, n, [t]) === !0 && (e[t] = n[t]);
  return e;
}
function ea(n, e) {
  for (; n !== null; ) {
    var t = zO(n, e);
    if (t) {
      if (t.get)
        return Xt(t.get);
      if (typeof t.value == "function")
        return Xt(t.value);
    }
    n = VO(n);
  }
  function i(r) {
    return console.warn("fallback value for", r), null;
  }
  return i;
}
var W0 = St(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Tu = St(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), Mu = St(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), JO = St(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Ou = St(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), ZO = St(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), j0 = St(["#text"]), G0 = St(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), Lu = St(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), K0 = St(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), ta = St(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), XO = pn(/\{\{[\w\W]*|[\w\W]*\}\}/gm), QO = pn(/<%[\w\W]*|[\w\W]*%>/gm), eL = pn(/\${[\w\W]*}/gm), tL = pn(/^data-[\-\w.\u00B7-\uFFFF]/), nL = pn(/^aria-[\-\w]+$/), iL = pn(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
), rL = pn(/^(?:\w+script|data):/i), sL = pn(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
), oL = pn(/^html$/i), lL = function() {
  return typeof window > "u" ? null : window;
}, aL = function(e, t) {
  if (Ci(e) !== "object" || typeof e.createPolicy != "function")
    return null;
  var i = null, r = "data-tt-policy-suffix";
  t.currentScript && t.currentScript.hasAttribute(r) && (i = t.currentScript.getAttribute(r));
  var s = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(s, {
      createHTML: function(l) {
        return l;
      },
      createScriptURL: function(l) {
        return l;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + s + " could not be created."), null;
  }
};
function Tx() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : lL(), e = function(_) {
    return Tx(_);
  };
  if (e.version = "2.4.7", e.removed = [], !n || !n.document || n.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var t = n.document, i = n.document, r = n.DocumentFragment, s = n.HTMLTemplateElement, o = n.Node, l = n.Element, a = n.NodeFilter, c = n.NamedNodeMap, h = c === void 0 ? n.NamedNodeMap || n.MozNamedAttrMap : c, u = n.HTMLFormElement, f = n.DOMParser, d = n.trustedTypes, p = l.prototype, g = ea(p, "cloneNode"), m = ea(p, "nextSibling"), b = ea(p, "childNodes"), y = ea(p, "parentNode");
  if (typeof s == "function") {
    var k = i.createElement("template");
    k.content && k.content.ownerDocument && (i = k.content.ownerDocument);
  }
  var w = aL(d, t), x = w ? w.createHTML("") : "", v = i, C = v.implementation, B = v.createNodeIterator, R = v.createDocumentFragment, T = v.getElementsByTagName, z = t.importNode, se = {};
  try {
    se = ir(i).documentMode ? i.documentMode : {};
  } catch {
  }
  var ee = {};
  e.isSupported = typeof y == "function" && C && C.createHTMLDocument !== void 0 && se !== 9;
  var A = XO, j = QO, q = eL, we = tL, ce = nL, le = rL, he = sL, De = iL, ae = null, sn = X({}, [].concat(cn(W0), cn(Tu), cn(Mu), cn(Ou), cn(j0))), ge = null, wi = X({}, [].concat(cn(G0), cn(Lu), cn(K0), cn(ta))), me = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), zt = null, on = null, zr = !0, vi = !0, ln = !1, Am = !0, Ur = !1, tr = !1, lu = !1, au = !1, Wr = !1, Wl = !1, jl = !1, Dm = !0, Em = !1, t2 = "user-content-", cu = !0, co = !1, jr = {}, Gr = null, Tm = X({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Mm = null, Om = X({}, ["audio", "video", "img", "source", "image", "track"]), hu = null, Lm = X({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Gl = "http://www.w3.org/1998/Math/MathML", Kl = "http://www.w3.org/2000/svg", Zn = "http://www.w3.org/1999/xhtml", Kr = Zn, uu = !1, fu = null, n2 = X({}, [Gl, Kl, Zn], Du), nr, i2 = ["application/xhtml+xml", "text/html"], r2 = "text/html", Ke, Yr = null, s2 = i.createElement("form"), Rm = function(_) {
    return _ instanceof RegExp || _ instanceof Function;
  }, du = function(_) {
    Yr && Yr === _ || ((!_ || Ci(_) !== "object") && (_ = {}), _ = ir(_), nr = i2.indexOf(_.PARSER_MEDIA_TYPE) === -1 ? nr = r2 : nr = _.PARSER_MEDIA_TYPE, Ke = nr === "application/xhtml+xml" ? Du : Za, ae = "ALLOWED_TAGS" in _ ? X({}, _.ALLOWED_TAGS, Ke) : sn, ge = "ALLOWED_ATTR" in _ ? X({}, _.ALLOWED_ATTR, Ke) : wi, fu = "ALLOWED_NAMESPACES" in _ ? X({}, _.ALLOWED_NAMESPACES, Du) : n2, hu = "ADD_URI_SAFE_ATTR" in _ ? X(
      ir(Lm),
      _.ADD_URI_SAFE_ATTR,
      Ke
    ) : Lm, Mm = "ADD_DATA_URI_TAGS" in _ ? X(
      ir(Om),
      _.ADD_DATA_URI_TAGS,
      Ke
    ) : Om, Gr = "FORBID_CONTENTS" in _ ? X({}, _.FORBID_CONTENTS, Ke) : Tm, zt = "FORBID_TAGS" in _ ? X({}, _.FORBID_TAGS, Ke) : {}, on = "FORBID_ATTR" in _ ? X({}, _.FORBID_ATTR, Ke) : {}, jr = "USE_PROFILES" in _ ? _.USE_PROFILES : !1, zr = _.ALLOW_ARIA_ATTR !== !1, vi = _.ALLOW_DATA_ATTR !== !1, ln = _.ALLOW_UNKNOWN_PROTOCOLS || !1, Am = _.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Ur = _.SAFE_FOR_TEMPLATES || !1, tr = _.WHOLE_DOCUMENT || !1, Wr = _.RETURN_DOM || !1, Wl = _.RETURN_DOM_FRAGMENT || !1, jl = _.RETURN_TRUSTED_TYPE || !1, au = _.FORCE_BODY || !1, Dm = _.SANITIZE_DOM !== !1, Em = _.SANITIZE_NAMED_PROPS || !1, cu = _.KEEP_CONTENT !== !1, co = _.IN_PLACE || !1, De = _.ALLOWED_URI_REGEXP || De, Kr = _.NAMESPACE || Zn, me = _.CUSTOM_ELEMENT_HANDLING || {}, _.CUSTOM_ELEMENT_HANDLING && Rm(_.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (me.tagNameCheck = _.CUSTOM_ELEMENT_HANDLING.tagNameCheck), _.CUSTOM_ELEMENT_HANDLING && Rm(_.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (me.attributeNameCheck = _.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), _.CUSTOM_ELEMENT_HANDLING && typeof _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (me.allowCustomizedBuiltInElements = _.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Ur && (vi = !1), Wl && (Wr = !0), jr && (ae = X({}, cn(j0)), ge = [], jr.html === !0 && (X(ae, W0), X(ge, G0)), jr.svg === !0 && (X(ae, Tu), X(ge, Lu), X(ge, ta)), jr.svgFilters === !0 && (X(ae, Mu), X(ge, Lu), X(ge, ta)), jr.mathMl === !0 && (X(ae, Ou), X(ge, K0), X(ge, ta))), _.ADD_TAGS && (ae === sn && (ae = ir(ae)), X(ae, _.ADD_TAGS, Ke)), _.ADD_ATTR && (ge === wi && (ge = ir(ge)), X(ge, _.ADD_ATTR, Ke)), _.ADD_URI_SAFE_ATTR && X(hu, _.ADD_URI_SAFE_ATTR, Ke), _.FORBID_CONTENTS && (Gr === Tm && (Gr = ir(Gr)), X(Gr, _.FORBID_CONTENTS, Ke)), cu && (ae["#text"] = !0), tr && X(ae, ["html", "head", "body"]), ae.table && (X(ae, ["tbody"]), delete zt.tbody), St && St(_), Yr = _);
  }, Im = X({}, ["mi", "mo", "mn", "ms", "mtext"]), Bm = X({}, ["foreignobject", "desc", "title", "annotation-xml"]), o2 = X({}, ["title", "style", "font", "a", "script"]), Yl = X({}, Tu);
  X(Yl, Mu), X(Yl, JO);
  var pu = X({}, Ou);
  X(pu, ZO);
  var l2 = function(_) {
    var D = y(_);
    (!D || !D.tagName) && (D = {
      namespaceURI: Kr,
      tagName: "template"
    });
    var O = Za(_.tagName), ie = Za(D.tagName);
    return fu[_.namespaceURI] ? _.namespaceURI === Kl ? D.namespaceURI === Zn ? O === "svg" : D.namespaceURI === Gl ? O === "svg" && (ie === "annotation-xml" || Im[ie]) : Boolean(Yl[O]) : _.namespaceURI === Gl ? D.namespaceURI === Zn ? O === "math" : D.namespaceURI === Kl ? O === "math" && Bm[ie] : Boolean(pu[O]) : _.namespaceURI === Zn ? D.namespaceURI === Kl && !Bm[ie] || D.namespaceURI === Gl && !Im[ie] ? !1 : !pu[O] && (o2[O] || !Yl[O]) : !!(nr === "application/xhtml+xml" && fu[_.namespaceURI]) : !1;
  }, Xn = function(_) {
    uo(e.removed, {
      element: _
    });
    try {
      _.parentNode.removeChild(_);
    } catch {
      try {
        _.outerHTML = x;
      } catch {
        _.remove();
      }
    }
  }, gu = function(_, D) {
    try {
      uo(e.removed, {
        attribute: D.getAttributeNode(_),
        from: D
      });
    } catch {
      uo(e.removed, {
        attribute: null,
        from: D
      });
    }
    if (D.removeAttribute(_), _ === "is" && !ge[_])
      if (Wr || Wl)
        try {
          Xn(D);
        } catch {
        }
      else
        try {
          D.setAttribute(_, "");
        } catch {
        }
  }, Nm = function(_) {
    var D, O;
    if (au)
      _ = "<remove></remove>" + _;
    else {
      var ie = jO(_, /^[\r\n\t ]+/);
      O = ie && ie[0];
    }
    nr === "application/xhtml+xml" && Kr === Zn && (_ = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + _ + "</body></html>");
    var At = w ? w.createHTML(_) : _;
    if (Kr === Zn)
      try {
        D = new f().parseFromString(At, nr);
      } catch {
      }
    if (!D || !D.documentElement) {
      D = C.createDocument(Kr, "template", null);
      try {
        D.documentElement.innerHTML = uu ? x : At;
      } catch {
      }
    }
    var ot = D.body || D.documentElement;
    return _ && O && ot.insertBefore(i.createTextNode(O), ot.childNodes[0] || null), Kr === Zn ? T.call(D, tr ? "html" : "body")[0] : tr ? D.documentElement : ot;
  }, Pm = function(_) {
    return B.call(
      _.ownerDocument || _,
      _,
      a.SHOW_ELEMENT | a.SHOW_COMMENT | a.SHOW_TEXT,
      null,
      !1
    );
  }, a2 = function(_) {
    return _ instanceof u && (typeof _.nodeName != "string" || typeof _.textContent != "string" || typeof _.removeChild != "function" || !(_.attributes instanceof h) || typeof _.removeAttribute != "function" || typeof _.setAttribute != "function" || typeof _.namespaceURI != "string" || typeof _.insertBefore != "function" || typeof _.hasChildNodes != "function");
  }, ho = function(_) {
    return Ci(o) === "object" ? _ instanceof o : _ && Ci(_) === "object" && typeof _.nodeType == "number" && typeof _.nodeName == "string";
  }, Qn = function(_, D, O) {
    !ee[_] || WO(ee[_], function(ie) {
      ie.call(e, D, O, Yr);
    });
  }, Fm = function(_) {
    var D;
    if (Qn("beforeSanitizeElements", _, null), a2(_) || bt(/[\u0080-\uFFFF]/, _.nodeName))
      return Xn(_), !0;
    var O = Ke(_.nodeName);
    if (Qn("uponSanitizeElement", _, {
      tagName: O,
      allowedTags: ae
    }), _.hasChildNodes() && !ho(_.firstElementChild) && (!ho(_.content) || !ho(_.content.firstElementChild)) && bt(/<[/\w]/g, _.innerHTML) && bt(/<[/\w]/g, _.textContent) || O === "select" && bt(/<template/i, _.innerHTML))
      return Xn(_), !0;
    if (!ae[O] || zt[O]) {
      if (!zt[O] && Hm(O) && (me.tagNameCheck instanceof RegExp && bt(me.tagNameCheck, O) || me.tagNameCheck instanceof Function && me.tagNameCheck(O)))
        return !1;
      if (cu && !Gr[O]) {
        var ie = y(_) || _.parentNode, At = b(_) || _.childNodes;
        if (At && ie)
          for (var ot = At.length, Xe = ot - 1; Xe >= 0; --Xe)
            ie.insertBefore(g(At[Xe], !0), m(_));
      }
      return Xn(_), !0;
    }
    return _ instanceof l && !l2(_) || (O === "noscript" || O === "noembed" || O === "noframes") && bt(/<\/no(script|embed|frames)/i, _.innerHTML) ? (Xn(_), !0) : (Ur && _.nodeType === 3 && (D = _.textContent, D = an(D, A, " "), D = an(D, j, " "), D = an(D, q, " "), _.textContent !== D && (uo(e.removed, {
      element: _.cloneNode()
    }), _.textContent = D)), Qn("afterSanitizeElements", _, null), !1);
  }, $m = function(_, D, O) {
    if (Dm && (D === "id" || D === "name") && (O in i || O in s2))
      return !1;
    if (!(vi && !on[D] && bt(we, D))) {
      if (!(zr && bt(ce, D))) {
        if (!ge[D] || on[D]) {
          if (!(Hm(_) && (me.tagNameCheck instanceof RegExp && bt(me.tagNameCheck, _) || me.tagNameCheck instanceof Function && me.tagNameCheck(_)) && (me.attributeNameCheck instanceof RegExp && bt(me.attributeNameCheck, D) || me.attributeNameCheck instanceof Function && me.attributeNameCheck(D)) || D === "is" && me.allowCustomizedBuiltInElements && (me.tagNameCheck instanceof RegExp && bt(me.tagNameCheck, O) || me.tagNameCheck instanceof Function && me.tagNameCheck(O))))
            return !1;
        } else if (!hu[D]) {
          if (!bt(De, an(O, he, ""))) {
            if (!((D === "src" || D === "xlink:href" || D === "href") && _ !== "script" && GO(O, "data:") === 0 && Mm[_])) {
              if (!(ln && !bt(le, an(O, he, "")))) {
                if (O)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, Hm = function(_) {
    return _.indexOf("-") > 0;
  }, qm = function(_) {
    var D, O, ie, At;
    Qn("beforeSanitizeAttributes", _, null);
    var ot = _.attributes;
    if (!!ot) {
      var Xe = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: ge
      };
      for (At = ot.length; At--; ) {
        D = ot[At];
        var Jl = D, Ye = Jl.name, mu = Jl.namespaceURI;
        if (O = Ye === "value" ? D.value : KO(D.value), ie = Ke(Ye), Xe.attrName = ie, Xe.attrValue = O, Xe.keepAttr = !0, Xe.forceKeepAttr = void 0, Qn("uponSanitizeAttribute", _, Xe), O = Xe.attrValue, !Xe.forceKeepAttr && (gu(Ye, _), !!Xe.keepAttr)) {
          if (!Am && bt(/\/>/i, O)) {
            gu(Ye, _);
            continue;
          }
          Ur && (O = an(O, A, " "), O = an(O, j, " "), O = an(O, q, " "));
          var Vm = Ke(_.nodeName);
          if (!!$m(Vm, ie, O)) {
            if (Em && (ie === "id" || ie === "name") && (gu(Ye, _), O = t2 + O), w && Ci(d) === "object" && typeof d.getAttributeType == "function" && !mu)
              switch (d.getAttributeType(Vm, ie)) {
                case "TrustedHTML": {
                  O = w.createHTML(O);
                  break;
                }
                case "TrustedScriptURL": {
                  O = w.createScriptURL(O);
                  break;
                }
              }
            try {
              mu ? _.setAttributeNS(mu, Ye, O) : _.setAttribute(Ye, O), U0(e.removed);
            } catch {
            }
          }
        }
      }
      Qn("afterSanitizeAttributes", _, null);
    }
  }, c2 = function F(_) {
    var D, O = Pm(_);
    for (Qn("beforeSanitizeShadowDOM", _, null); D = O.nextNode(); )
      Qn("uponSanitizeShadowNode", D, null), !Fm(D) && (D.content instanceof r && F(D.content), qm(D));
    Qn("afterSanitizeShadowDOM", _, null);
  };
  return e.sanitize = function(F) {
    var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, D, O, ie, At, ot;
    if (uu = !F, uu && (F = "<!-->"), typeof F != "string" && !ho(F))
      if (typeof F.toString == "function") {
        if (F = F.toString(), typeof F != "string")
          throw Eu("dirty is not a string, aborting");
      } else
        throw Eu("toString is not a function");
    if (!e.isSupported) {
      if (Ci(n.toStaticHTML) === "object" || typeof n.toStaticHTML == "function") {
        if (typeof F == "string")
          return n.toStaticHTML(F);
        if (ho(F))
          return n.toStaticHTML(F.outerHTML);
      }
      return F;
    }
    if (lu || du(_), e.removed = [], typeof F == "string" && (co = !1), co) {
      if (F.nodeName) {
        var Xe = Ke(F.nodeName);
        if (!ae[Xe] || zt[Xe])
          throw Eu("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (F instanceof o)
      D = Nm("<!---->"), O = D.ownerDocument.importNode(F, !0), O.nodeType === 1 && O.nodeName === "BODY" || O.nodeName === "HTML" ? D = O : D.appendChild(O);
    else {
      if (!Wr && !Ur && !tr && F.indexOf("<") === -1)
        return w && jl ? w.createHTML(F) : F;
      if (D = Nm(F), !D)
        return Wr ? null : jl ? x : "";
    }
    D && au && Xn(D.firstChild);
    for (var Jl = Pm(co ? F : D); ie = Jl.nextNode(); )
      ie.nodeType === 3 && ie === At || Fm(ie) || (ie.content instanceof r && c2(ie.content), qm(ie), At = ie);
    if (At = null, co)
      return F;
    if (Wr) {
      if (Wl)
        for (ot = R.call(D.ownerDocument); D.firstChild; )
          ot.appendChild(D.firstChild);
      else
        ot = D;
      return (ge.shadowroot || ge.shadowrootmod) && (ot = z.call(t, ot, !0)), ot;
    }
    var Ye = tr ? D.outerHTML : D.innerHTML;
    return tr && ae["!doctype"] && D.ownerDocument && D.ownerDocument.doctype && D.ownerDocument.doctype.name && bt(oL, D.ownerDocument.doctype.name) && (Ye = "<!DOCTYPE " + D.ownerDocument.doctype.name + `>
` + Ye), Ur && (Ye = an(Ye, A, " "), Ye = an(Ye, j, " "), Ye = an(Ye, q, " ")), w && jl ? w.createHTML(Ye) : Ye;
  }, e.setConfig = function(F) {
    du(F), lu = !0;
  }, e.clearConfig = function() {
    Yr = null, lu = !1;
  }, e.isValidAttribute = function(F, _, D) {
    Yr || du({});
    var O = Ke(F), ie = Ke(_);
    return $m(O, ie, D);
  }, e.addHook = function(F, _) {
    typeof _ == "function" && (ee[F] = ee[F] || [], uo(ee[F], _));
  }, e.removeHook = function(F) {
    if (ee[F])
      return U0(ee[F]);
  }, e.removeHooks = function(F) {
    ee[F] && (ee[F] = []);
  }, e.removeAllHooks = function() {
    ee = {};
  }, e;
}
var cL = Tx(), Mx = { exports: {} }, re = {}, lg = { exports: {} };
const hL = "\xC1", uL = "\xE1", fL = "\u0102", dL = "\u0103", pL = "\u223E", gL = "\u223F", mL = "\u223E\u0333", bL = "\xC2", yL = "\xE2", wL = "\xB4", vL = "\u0410", xL = "\u0430", kL = "\xC6", _L = "\xE6", SL = "\u2061", CL = "\u{1D504}", AL = "\u{1D51E}", DL = "\xC0", EL = "\xE0", TL = "\u2135", ML = "\u2135", OL = "\u0391", LL = "\u03B1", RL = "\u0100", IL = "\u0101", BL = "\u2A3F", NL = "&", PL = "&", FL = "\u2A55", $L = "\u2A53", HL = "\u2227", qL = "\u2A5C", VL = "\u2A58", zL = "\u2A5A", UL = "\u2220", WL = "\u29A4", jL = "\u2220", GL = "\u29A8", KL = "\u29A9", YL = "\u29AA", JL = "\u29AB", ZL = "\u29AC", XL = "\u29AD", QL = "\u29AE", eR = "\u29AF", tR = "\u2221", nR = "\u221F", iR = "\u22BE", rR = "\u299D", sR = "\u2222", oR = "\xC5", lR = "\u237C", aR = "\u0104", cR = "\u0105", hR = "\u{1D538}", uR = "\u{1D552}", fR = "\u2A6F", dR = "\u2248", pR = "\u2A70", gR = "\u224A", mR = "\u224B", bR = "'", yR = "\u2061", wR = "\u2248", vR = "\u224A", xR = "\xC5", kR = "\xE5", _R = "\u{1D49C}", SR = "\u{1D4B6}", CR = "\u2254", AR = "*", DR = "\u2248", ER = "\u224D", TR = "\xC3", MR = "\xE3", OR = "\xC4", LR = "\xE4", RR = "\u2233", IR = "\u2A11", BR = "\u224C", NR = "\u03F6", PR = "\u2035", FR = "\u223D", $R = "\u22CD", HR = "\u2216", qR = "\u2AE7", VR = "\u22BD", zR = "\u2305", UR = "\u2306", WR = "\u2305", jR = "\u23B5", GR = "\u23B6", KR = "\u224C", YR = "\u0411", JR = "\u0431", ZR = "\u201E", XR = "\u2235", QR = "\u2235", e3 = "\u2235", t3 = "\u29B0", n3 = "\u03F6", i3 = "\u212C", r3 = "\u212C", s3 = "\u0392", o3 = "\u03B2", l3 = "\u2136", a3 = "\u226C", c3 = "\u{1D505}", h3 = "\u{1D51F}", u3 = "\u22C2", f3 = "\u25EF", d3 = "\u22C3", p3 = "\u2A00", g3 = "\u2A01", m3 = "\u2A02", b3 = "\u2A06", y3 = "\u2605", w3 = "\u25BD", v3 = "\u25B3", x3 = "\u2A04", k3 = "\u22C1", _3 = "\u22C0", S3 = "\u290D", C3 = "\u29EB", A3 = "\u25AA", D3 = "\u25B4", E3 = "\u25BE", T3 = "\u25C2", M3 = "\u25B8", O3 = "\u2423", L3 = "\u2592", R3 = "\u2591", I3 = "\u2593", B3 = "\u2588", N3 = "=\u20E5", P3 = "\u2261\u20E5", F3 = "\u2AED", $3 = "\u2310", H3 = "\u{1D539}", q3 = "\u{1D553}", V3 = "\u22A5", z3 = "\u22A5", U3 = "\u22C8", W3 = "\u29C9", j3 = "\u2510", G3 = "\u2555", K3 = "\u2556", Y3 = "\u2557", J3 = "\u250C", Z3 = "\u2552", X3 = "\u2553", Q3 = "\u2554", eI = "\u2500", tI = "\u2550", nI = "\u252C", iI = "\u2564", rI = "\u2565", sI = "\u2566", oI = "\u2534", lI = "\u2567", aI = "\u2568", cI = "\u2569", hI = "\u229F", uI = "\u229E", fI = "\u22A0", dI = "\u2518", pI = "\u255B", gI = "\u255C", mI = "\u255D", bI = "\u2514", yI = "\u2558", wI = "\u2559", vI = "\u255A", xI = "\u2502", kI = "\u2551", _I = "\u253C", SI = "\u256A", CI = "\u256B", AI = "\u256C", DI = "\u2524", EI = "\u2561", TI = "\u2562", MI = "\u2563", OI = "\u251C", LI = "\u255E", RI = "\u255F", II = "\u2560", BI = "\u2035", NI = "\u02D8", PI = "\u02D8", FI = "\xA6", $I = "\u{1D4B7}", HI = "\u212C", qI = "\u204F", VI = "\u223D", zI = "\u22CD", UI = "\u29C5", WI = "\\", jI = "\u27C8", GI = "\u2022", KI = "\u2022", YI = "\u224E", JI = "\u2AAE", ZI = "\u224F", XI = "\u224E", QI = "\u224F", eB = "\u0106", tB = "\u0107", nB = "\u2A44", iB = "\u2A49", rB = "\u2A4B", sB = "\u2229", oB = "\u22D2", lB = "\u2A47", aB = "\u2A40", cB = "\u2145", hB = "\u2229\uFE00", uB = "\u2041", fB = "\u02C7", dB = "\u212D", pB = "\u2A4D", gB = "\u010C", mB = "\u010D", bB = "\xC7", yB = "\xE7", wB = "\u0108", vB = "\u0109", xB = "\u2230", kB = "\u2A4C", _B = "\u2A50", SB = "\u010A", CB = "\u010B", AB = "\xB8", DB = "\xB8", EB = "\u29B2", TB = "\xA2", MB = "\xB7", OB = "\xB7", LB = "\u{1D520}", RB = "\u212D", IB = "\u0427", BB = "\u0447", NB = "\u2713", PB = "\u2713", FB = "\u03A7", $B = "\u03C7", HB = "\u02C6", qB = "\u2257", VB = "\u21BA", zB = "\u21BB", UB = "\u229B", WB = "\u229A", jB = "\u229D", GB = "\u2299", KB = "\xAE", YB = "\u24C8", JB = "\u2296", ZB = "\u2295", XB = "\u2297", QB = "\u25CB", eN = "\u29C3", tN = "\u2257", nN = "\u2A10", iN = "\u2AEF", rN = "\u29C2", sN = "\u2232", oN = "\u201D", lN = "\u2019", aN = "\u2663", cN = "\u2663", hN = ":", uN = "\u2237", fN = "\u2A74", dN = "\u2254", pN = "\u2254", gN = ",", mN = "@", bN = "\u2201", yN = "\u2218", wN = "\u2201", vN = "\u2102", xN = "\u2245", kN = "\u2A6D", _N = "\u2261", SN = "\u222E", CN = "\u222F", AN = "\u222E", DN = "\u{1D554}", EN = "\u2102", TN = "\u2210", MN = "\u2210", ON = "\xA9", LN = "\xA9", RN = "\u2117", IN = "\u2233", BN = "\u21B5", NN = "\u2717", PN = "\u2A2F", FN = "\u{1D49E}", $N = "\u{1D4B8}", HN = "\u2ACF", qN = "\u2AD1", VN = "\u2AD0", zN = "\u2AD2", UN = "\u22EF", WN = "\u2938", jN = "\u2935", GN = "\u22DE", KN = "\u22DF", YN = "\u21B6", JN = "\u293D", ZN = "\u2A48", XN = "\u2A46", QN = "\u224D", eP = "\u222A", tP = "\u22D3", nP = "\u2A4A", iP = "\u228D", rP = "\u2A45", sP = "\u222A\uFE00", oP = "\u21B7", lP = "\u293C", aP = "\u22DE", cP = "\u22DF", hP = "\u22CE", uP = "\u22CF", fP = "\xA4", dP = "\u21B6", pP = "\u21B7", gP = "\u22CE", mP = "\u22CF", bP = "\u2232", yP = "\u2231", wP = "\u232D", vP = "\u2020", xP = "\u2021", kP = "\u2138", _P = "\u2193", SP = "\u21A1", CP = "\u21D3", AP = "\u2010", DP = "\u2AE4", EP = "\u22A3", TP = "\u290F", MP = "\u02DD", OP = "\u010E", LP = "\u010F", RP = "\u0414", IP = "\u0434", BP = "\u2021", NP = "\u21CA", PP = "\u2145", FP = "\u2146", $P = "\u2911", HP = "\u2A77", qP = "\xB0", VP = "\u2207", zP = "\u0394", UP = "\u03B4", WP = "\u29B1", jP = "\u297F", GP = "\u{1D507}", KP = "\u{1D521}", YP = "\u2965", JP = "\u21C3", ZP = "\u21C2", XP = "\xB4", QP = "\u02D9", eF = "\u02DD", tF = "`", nF = "\u02DC", iF = "\u22C4", rF = "\u22C4", sF = "\u22C4", oF = "\u2666", lF = "\u2666", aF = "\xA8", cF = "\u2146", hF = "\u03DD", uF = "\u22F2", fF = "\xF7", dF = "\xF7", pF = "\u22C7", gF = "\u22C7", mF = "\u0402", bF = "\u0452", yF = "\u231E", wF = "\u230D", vF = "$", xF = "\u{1D53B}", kF = "\u{1D555}", _F = "\xA8", SF = "\u02D9", CF = "\u20DC", AF = "\u2250", DF = "\u2251", EF = "\u2250", TF = "\u2238", MF = "\u2214", OF = "\u22A1", LF = "\u2306", RF = "\u222F", IF = "\xA8", BF = "\u21D3", NF = "\u21D0", PF = "\u21D4", FF = "\u2AE4", $F = "\u27F8", HF = "\u27FA", qF = "\u27F9", VF = "\u21D2", zF = "\u22A8", UF = "\u21D1", WF = "\u21D5", jF = "\u2225", GF = "\u2913", KF = "\u2193", YF = "\u2193", JF = "\u21D3", ZF = "\u21F5", XF = "\u0311", QF = "\u21CA", e4 = "\u21C3", t4 = "\u21C2", n4 = "\u2950", i4 = "\u295E", r4 = "\u2956", s4 = "\u21BD", o4 = "\u295F", l4 = "\u2957", a4 = "\u21C1", c4 = "\u21A7", h4 = "\u22A4", u4 = "\u2910", f4 = "\u231F", d4 = "\u230C", p4 = "\u{1D49F}", g4 = "\u{1D4B9}", m4 = "\u0405", b4 = "\u0455", y4 = "\u29F6", w4 = "\u0110", v4 = "\u0111", x4 = "\u22F1", k4 = "\u25BF", _4 = "\u25BE", S4 = "\u21F5", C4 = "\u296F", A4 = "\u29A6", D4 = "\u040F", E4 = "\u045F", T4 = "\u27FF", M4 = "\xC9", O4 = "\xE9", L4 = "\u2A6E", R4 = "\u011A", I4 = "\u011B", B4 = "\xCA", N4 = "\xEA", P4 = "\u2256", F4 = "\u2255", $4 = "\u042D", H4 = "\u044D", q4 = "\u2A77", V4 = "\u0116", z4 = "\u0117", U4 = "\u2251", W4 = "\u2147", j4 = "\u2252", G4 = "\u{1D508}", K4 = "\u{1D522}", Y4 = "\u2A9A", J4 = "\xC8", Z4 = "\xE8", X4 = "\u2A96", Q4 = "\u2A98", e5 = "\u2A99", t5 = "\u2208", n5 = "\u23E7", i5 = "\u2113", r5 = "\u2A95", s5 = "\u2A97", o5 = "\u0112", l5 = "\u0113", a5 = "\u2205", c5 = "\u2205", h5 = "\u25FB", u5 = "\u2205", f5 = "\u25AB", d5 = "\u2004", p5 = "\u2005", g5 = "\u2003", m5 = "\u014A", b5 = "\u014B", y5 = "\u2002", w5 = "\u0118", v5 = "\u0119", x5 = "\u{1D53C}", k5 = "\u{1D556}", _5 = "\u22D5", S5 = "\u29E3", C5 = "\u2A71", A5 = "\u03B5", D5 = "\u0395", E5 = "\u03B5", T5 = "\u03F5", M5 = "\u2256", O5 = "\u2255", L5 = "\u2242", R5 = "\u2A96", I5 = "\u2A95", B5 = "\u2A75", N5 = "=", P5 = "\u2242", F5 = "\u225F", $5 = "\u21CC", H5 = "\u2261", q5 = "\u2A78", V5 = "\u29E5", z5 = "\u2971", U5 = "\u2253", W5 = "\u212F", j5 = "\u2130", G5 = "\u2250", K5 = "\u2A73", Y5 = "\u2242", J5 = "\u0397", Z5 = "\u03B7", X5 = "\xD0", Q5 = "\xF0", e8 = "\xCB", t8 = "\xEB", n8 = "\u20AC", i8 = "!", r8 = "\u2203", s8 = "\u2203", o8 = "\u2130", l8 = "\u2147", a8 = "\u2147", c8 = "\u2252", h8 = "\u0424", u8 = "\u0444", f8 = "\u2640", d8 = "\uFB03", p8 = "\uFB00", g8 = "\uFB04", m8 = "\u{1D509}", b8 = "\u{1D523}", y8 = "\uFB01", w8 = "\u25FC", v8 = "\u25AA", x8 = "fj", k8 = "\u266D", _8 = "\uFB02", S8 = "\u25B1", C8 = "\u0192", A8 = "\u{1D53D}", D8 = "\u{1D557}", E8 = "\u2200", T8 = "\u2200", M8 = "\u22D4", O8 = "\u2AD9", L8 = "\u2131", R8 = "\u2A0D", I8 = "\xBD", B8 = "\u2153", N8 = "\xBC", P8 = "\u2155", F8 = "\u2159", $8 = "\u215B", H8 = "\u2154", q8 = "\u2156", V8 = "\xBE", z8 = "\u2157", U8 = "\u215C", W8 = "\u2158", j8 = "\u215A", G8 = "\u215D", K8 = "\u215E", Y8 = "\u2044", J8 = "\u2322", Z8 = "\u{1D4BB}", X8 = "\u2131", Q8 = "\u01F5", e$ = "\u0393", t$ = "\u03B3", n$ = "\u03DC", i$ = "\u03DD", r$ = "\u2A86", s$ = "\u011E", o$ = "\u011F", l$ = "\u0122", a$ = "\u011C", c$ = "\u011D", h$ = "\u0413", u$ = "\u0433", f$ = "\u0120", d$ = "\u0121", p$ = "\u2265", g$ = "\u2267", m$ = "\u2A8C", b$ = "\u22DB", y$ = "\u2265", w$ = "\u2267", v$ = "\u2A7E", x$ = "\u2AA9", k$ = "\u2A7E", _$ = "\u2A80", S$ = "\u2A82", C$ = "\u2A84", A$ = "\u22DB\uFE00", D$ = "\u2A94", E$ = "\u{1D50A}", T$ = "\u{1D524}", M$ = "\u226B", O$ = "\u22D9", L$ = "\u22D9", R$ = "\u2137", I$ = "\u0403", B$ = "\u0453", N$ = "\u2AA5", P$ = "\u2277", F$ = "\u2A92", $$ = "\u2AA4", H$ = "\u2A8A", q$ = "\u2A8A", V$ = "\u2A88", z$ = "\u2269", U$ = "\u2A88", W$ = "\u2269", j$ = "\u22E7", G$ = "\u{1D53E}", K$ = "\u{1D558}", Y$ = "`", J$ = "\u2265", Z$ = "\u22DB", X$ = "\u2267", Q$ = "\u2AA2", e6 = "\u2277", t6 = "\u2A7E", n6 = "\u2273", i6 = "\u{1D4A2}", r6 = "\u210A", s6 = "\u2273", o6 = "\u2A8E", l6 = "\u2A90", a6 = "\u2AA7", c6 = "\u2A7A", h6 = ">", u6 = ">", f6 = "\u226B", d6 = "\u22D7", p6 = "\u2995", g6 = "\u2A7C", m6 = "\u2A86", b6 = "\u2978", y6 = "\u22D7", w6 = "\u22DB", v6 = "\u2A8C", x6 = "\u2277", k6 = "\u2273", _6 = "\u2269\uFE00", S6 = "\u2269\uFE00", C6 = "\u02C7", A6 = "\u200A", D6 = "\xBD", E6 = "\u210B", T6 = "\u042A", M6 = "\u044A", O6 = "\u2948", L6 = "\u2194", R6 = "\u21D4", I6 = "\u21AD", B6 = "^", N6 = "\u210F", P6 = "\u0124", F6 = "\u0125", $6 = "\u2665", H6 = "\u2665", q6 = "\u2026", V6 = "\u22B9", z6 = "\u{1D525}", U6 = "\u210C", W6 = "\u210B", j6 = "\u2925", G6 = "\u2926", K6 = "\u21FF", Y6 = "\u223B", J6 = "\u21A9", Z6 = "\u21AA", X6 = "\u{1D559}", Q6 = "\u210D", eH = "\u2015", tH = "\u2500", nH = "\u{1D4BD}", iH = "\u210B", rH = "\u210F", sH = "\u0126", oH = "\u0127", lH = "\u224E", aH = "\u224F", cH = "\u2043", hH = "\u2010", uH = "\xCD", fH = "\xED", dH = "\u2063", pH = "\xCE", gH = "\xEE", mH = "\u0418", bH = "\u0438", yH = "\u0130", wH = "\u0415", vH = "\u0435", xH = "\xA1", kH = "\u21D4", _H = "\u{1D526}", SH = "\u2111", CH = "\xCC", AH = "\xEC", DH = "\u2148", EH = "\u2A0C", TH = "\u222D", MH = "\u29DC", OH = "\u2129", LH = "\u0132", RH = "\u0133", IH = "\u012A", BH = "\u012B", NH = "\u2111", PH = "\u2148", FH = "\u2110", $H = "\u2111", HH = "\u0131", qH = "\u2111", VH = "\u22B7", zH = "\u01B5", UH = "\u21D2", WH = "\u2105", jH = "\u221E", GH = "\u29DD", KH = "\u0131", YH = "\u22BA", JH = "\u222B", ZH = "\u222C", XH = "\u2124", QH = "\u222B", eq = "\u22BA", tq = "\u22C2", nq = "\u2A17", iq = "\u2A3C", rq = "\u2063", sq = "\u2062", oq = "\u0401", lq = "\u0451", aq = "\u012E", cq = "\u012F", hq = "\u{1D540}", uq = "\u{1D55A}", fq = "\u0399", dq = "\u03B9", pq = "\u2A3C", gq = "\xBF", mq = "\u{1D4BE}", bq = "\u2110", yq = "\u2208", wq = "\u22F5", vq = "\u22F9", xq = "\u22F4", kq = "\u22F3", _q = "\u2208", Sq = "\u2062", Cq = "\u0128", Aq = "\u0129", Dq = "\u0406", Eq = "\u0456", Tq = "\xCF", Mq = "\xEF", Oq = "\u0134", Lq = "\u0135", Rq = "\u0419", Iq = "\u0439", Bq = "\u{1D50D}", Nq = "\u{1D527}", Pq = "\u0237", Fq = "\u{1D541}", $q = "\u{1D55B}", Hq = "\u{1D4A5}", qq = "\u{1D4BF}", Vq = "\u0408", zq = "\u0458", Uq = "\u0404", Wq = "\u0454", jq = "\u039A", Gq = "\u03BA", Kq = "\u03F0", Yq = "\u0136", Jq = "\u0137", Zq = "\u041A", Xq = "\u043A", Qq = "\u{1D50E}", e9 = "\u{1D528}", t9 = "\u0138", n9 = "\u0425", i9 = "\u0445", r9 = "\u040C", s9 = "\u045C", o9 = "\u{1D542}", l9 = "\u{1D55C}", a9 = "\u{1D4A6}", c9 = "\u{1D4C0}", h9 = "\u21DA", u9 = "\u0139", f9 = "\u013A", d9 = "\u29B4", p9 = "\u2112", g9 = "\u039B", m9 = "\u03BB", b9 = "\u27E8", y9 = "\u27EA", w9 = "\u2991", v9 = "\u27E8", x9 = "\u2A85", k9 = "\u2112", _9 = "\xAB", S9 = "\u21E4", C9 = "\u291F", A9 = "\u2190", D9 = "\u219E", E9 = "\u21D0", T9 = "\u291D", M9 = "\u21A9", O9 = "\u21AB", L9 = "\u2939", R9 = "\u2973", I9 = "\u21A2", B9 = "\u2919", N9 = "\u291B", P9 = "\u2AAB", F9 = "\u2AAD", $9 = "\u2AAD\uFE00", H9 = "\u290C", q9 = "\u290E", V9 = "\u2772", z9 = "{", U9 = "[", W9 = "\u298B", j9 = "\u298F", G9 = "\u298D", K9 = "\u013D", Y9 = "\u013E", J9 = "\u013B", Z9 = "\u013C", X9 = "\u2308", Q9 = "{", eV = "\u041B", tV = "\u043B", nV = "\u2936", iV = "\u201C", rV = "\u201E", sV = "\u2967", oV = "\u294B", lV = "\u21B2", aV = "\u2264", cV = "\u2266", hV = "\u27E8", uV = "\u21E4", fV = "\u2190", dV = "\u2190", pV = "\u21D0", gV = "\u21C6", mV = "\u21A2", bV = "\u2308", yV = "\u27E6", wV = "\u2961", vV = "\u2959", xV = "\u21C3", kV = "\u230A", _V = "\u21BD", SV = "\u21BC", CV = "\u21C7", AV = "\u2194", DV = "\u2194", EV = "\u21D4", TV = "\u21C6", MV = "\u21CB", OV = "\u21AD", LV = "\u294E", RV = "\u21A4", IV = "\u22A3", BV = "\u295A", NV = "\u22CB", PV = "\u29CF", FV = "\u22B2", $V = "\u22B4", HV = "\u2951", qV = "\u2960", VV = "\u2958", zV = "\u21BF", UV = "\u2952", WV = "\u21BC", jV = "\u2A8B", GV = "\u22DA", KV = "\u2264", YV = "\u2266", JV = "\u2A7D", ZV = "\u2AA8", XV = "\u2A7D", QV = "\u2A7F", ez = "\u2A81", tz = "\u2A83", nz = "\u22DA\uFE00", iz = "\u2A93", rz = "\u2A85", sz = "\u22D6", oz = "\u22DA", lz = "\u2A8B", az = "\u22DA", cz = "\u2266", hz = "\u2276", uz = "\u2276", fz = "\u2AA1", dz = "\u2272", pz = "\u2A7D", gz = "\u2272", mz = "\u297C", bz = "\u230A", yz = "\u{1D50F}", wz = "\u{1D529}", vz = "\u2276", xz = "\u2A91", kz = "\u2962", _z = "\u21BD", Sz = "\u21BC", Cz = "\u296A", Az = "\u2584", Dz = "\u0409", Ez = "\u0459", Tz = "\u21C7", Mz = "\u226A", Oz = "\u22D8", Lz = "\u231E", Rz = "\u21DA", Iz = "\u296B", Bz = "\u25FA", Nz = "\u013F", Pz = "\u0140", Fz = "\u23B0", $z = "\u23B0", Hz = "\u2A89", qz = "\u2A89", Vz = "\u2A87", zz = "\u2268", Uz = "\u2A87", Wz = "\u2268", jz = "\u22E6", Gz = "\u27EC", Kz = "\u21FD", Yz = "\u27E6", Jz = "\u27F5", Zz = "\u27F5", Xz = "\u27F8", Qz = "\u27F7", e7 = "\u27F7", t7 = "\u27FA", n7 = "\u27FC", i7 = "\u27F6", r7 = "\u27F6", s7 = "\u27F9", o7 = "\u21AB", l7 = "\u21AC", a7 = "\u2985", c7 = "\u{1D543}", h7 = "\u{1D55D}", u7 = "\u2A2D", f7 = "\u2A34", d7 = "\u2217", p7 = "_", g7 = "\u2199", m7 = "\u2198", b7 = "\u25CA", y7 = "\u25CA", w7 = "\u29EB", v7 = "(", x7 = "\u2993", k7 = "\u21C6", _7 = "\u231F", S7 = "\u21CB", C7 = "\u296D", A7 = "\u200E", D7 = "\u22BF", E7 = "\u2039", T7 = "\u{1D4C1}", M7 = "\u2112", O7 = "\u21B0", L7 = "\u21B0", R7 = "\u2272", I7 = "\u2A8D", B7 = "\u2A8F", N7 = "[", P7 = "\u2018", F7 = "\u201A", $7 = "\u0141", H7 = "\u0142", q7 = "\u2AA6", V7 = "\u2A79", z7 = "<", U7 = "<", W7 = "\u226A", j7 = "\u22D6", G7 = "\u22CB", K7 = "\u22C9", Y7 = "\u2976", J7 = "\u2A7B", Z7 = "\u25C3", X7 = "\u22B4", Q7 = "\u25C2", eU = "\u2996", tU = "\u294A", nU = "\u2966", iU = "\u2268\uFE00", rU = "\u2268\uFE00", sU = "\xAF", oU = "\u2642", lU = "\u2720", aU = "\u2720", cU = "\u21A6", hU = "\u21A6", uU = "\u21A7", fU = "\u21A4", dU = "\u21A5", pU = "\u25AE", gU = "\u2A29", mU = "\u041C", bU = "\u043C", yU = "\u2014", wU = "\u223A", vU = "\u2221", xU = "\u205F", kU = "\u2133", _U = "\u{1D510}", SU = "\u{1D52A}", CU = "\u2127", AU = "\xB5", DU = "*", EU = "\u2AF0", TU = "\u2223", MU = "\xB7", OU = "\u229F", LU = "\u2212", RU = "\u2238", IU = "\u2A2A", BU = "\u2213", NU = "\u2ADB", PU = "\u2026", FU = "\u2213", $U = "\u22A7", HU = "\u{1D544}", qU = "\u{1D55E}", VU = "\u2213", zU = "\u{1D4C2}", UU = "\u2133", WU = "\u223E", jU = "\u039C", GU = "\u03BC", KU = "\u22B8", YU = "\u22B8", JU = "\u2207", ZU = "\u0143", XU = "\u0144", QU = "\u2220\u20D2", eW = "\u2249", tW = "\u2A70\u0338", nW = "\u224B\u0338", iW = "\u0149", rW = "\u2249", sW = "\u266E", oW = "\u2115", lW = "\u266E", aW = "\xA0", cW = "\u224E\u0338", hW = "\u224F\u0338", uW = "\u2A43", fW = "\u0147", dW = "\u0148", pW = "\u0145", gW = "\u0146", mW = "\u2247", bW = "\u2A6D\u0338", yW = "\u2A42", wW = "\u041D", vW = "\u043D", xW = "\u2013", kW = "\u2924", _W = "\u2197", SW = "\u21D7", CW = "\u2197", AW = "\u2260", DW = "\u2250\u0338", EW = "\u200B", TW = "\u200B", MW = "\u200B", OW = "\u200B", LW = "\u2262", RW = "\u2928", IW = "\u2242\u0338", BW = "\u226B", NW = "\u226A", PW = `
`, FW = "\u2204", $W = "\u2204", HW = "\u{1D511}", qW = "\u{1D52B}", VW = "\u2267\u0338", zW = "\u2271", UW = "\u2271", WW = "\u2267\u0338", jW = "\u2A7E\u0338", GW = "\u2A7E\u0338", KW = "\u22D9\u0338", YW = "\u2275", JW = "\u226B\u20D2", ZW = "\u226F", XW = "\u226F", QW = "\u226B\u0338", ej = "\u21AE", tj = "\u21CE", nj = "\u2AF2", ij = "\u220B", rj = "\u22FC", sj = "\u22FA", oj = "\u220B", lj = "\u040A", aj = "\u045A", cj = "\u219A", hj = "\u21CD", uj = "\u2025", fj = "\u2266\u0338", dj = "\u2270", pj = "\u219A", gj = "\u21CD", mj = "\u21AE", bj = "\u21CE", yj = "\u2270", wj = "\u2266\u0338", vj = "\u2A7D\u0338", xj = "\u2A7D\u0338", kj = "\u226E", _j = "\u22D8\u0338", Sj = "\u2274", Cj = "\u226A\u20D2", Aj = "\u226E", Dj = "\u22EA", Ej = "\u22EC", Tj = "\u226A\u0338", Mj = "\u2224", Oj = "\u2060", Lj = "\xA0", Rj = "\u{1D55F}", Ij = "\u2115", Bj = "\u2AEC", Nj = "\xAC", Pj = "\u2262", Fj = "\u226D", $j = "\u2226", Hj = "\u2209", qj = "\u2260", Vj = "\u2242\u0338", zj = "\u2204", Uj = "\u226F", Wj = "\u2271", jj = "\u2267\u0338", Gj = "\u226B\u0338", Kj = "\u2279", Yj = "\u2A7E\u0338", Jj = "\u2275", Zj = "\u224E\u0338", Xj = "\u224F\u0338", Qj = "\u2209", eG = "\u22F5\u0338", tG = "\u22F9\u0338", nG = "\u2209", iG = "\u22F7", rG = "\u22F6", sG = "\u29CF\u0338", oG = "\u22EA", lG = "\u22EC", aG = "\u226E", cG = "\u2270", hG = "\u2278", uG = "\u226A\u0338", fG = "\u2A7D\u0338", dG = "\u2274", pG = "\u2AA2\u0338", gG = "\u2AA1\u0338", mG = "\u220C", bG = "\u220C", yG = "\u22FE", wG = "\u22FD", vG = "\u2280", xG = "\u2AAF\u0338", kG = "\u22E0", _G = "\u220C", SG = "\u29D0\u0338", CG = "\u22EB", AG = "\u22ED", DG = "\u228F\u0338", EG = "\u22E2", TG = "\u2290\u0338", MG = "\u22E3", OG = "\u2282\u20D2", LG = "\u2288", RG = "\u2281", IG = "\u2AB0\u0338", BG = "\u22E1", NG = "\u227F\u0338", PG = "\u2283\u20D2", FG = "\u2289", $G = "\u2241", HG = "\u2244", qG = "\u2247", VG = "\u2249", zG = "\u2224", UG = "\u2226", WG = "\u2226", jG = "\u2AFD\u20E5", GG = "\u2202\u0338", KG = "\u2A14", YG = "\u2280", JG = "\u22E0", ZG = "\u2280", XG = "\u2AAF\u0338", QG = "\u2AAF\u0338", eK = "\u2933\u0338", tK = "\u219B", nK = "\u21CF", iK = "\u219D\u0338", rK = "\u219B", sK = "\u21CF", oK = "\u22EB", lK = "\u22ED", aK = "\u2281", cK = "\u22E1", hK = "\u2AB0\u0338", uK = "\u{1D4A9}", fK = "\u{1D4C3}", dK = "\u2224", pK = "\u2226", gK = "\u2241", mK = "\u2244", bK = "\u2244", yK = "\u2224", wK = "\u2226", vK = "\u22E2", xK = "\u22E3", kK = "\u2284", _K = "\u2AC5\u0338", SK = "\u2288", CK = "\u2282\u20D2", AK = "\u2288", DK = "\u2AC5\u0338", EK = "\u2281", TK = "\u2AB0\u0338", MK = "\u2285", OK = "\u2AC6\u0338", LK = "\u2289", RK = "\u2283\u20D2", IK = "\u2289", BK = "\u2AC6\u0338", NK = "\u2279", PK = "\xD1", FK = "\xF1", $K = "\u2278", HK = "\u22EA", qK = "\u22EC", VK = "\u22EB", zK = "\u22ED", UK = "\u039D", WK = "\u03BD", jK = "#", GK = "\u2116", KK = "\u2007", YK = "\u224D\u20D2", JK = "\u22AC", ZK = "\u22AD", XK = "\u22AE", QK = "\u22AF", eY = "\u2265\u20D2", tY = ">\u20D2", nY = "\u2904", iY = "\u29DE", rY = "\u2902", sY = "\u2264\u20D2", oY = "<\u20D2", lY = "\u22B4\u20D2", aY = "\u2903", cY = "\u22B5\u20D2", hY = "\u223C\u20D2", uY = "\u2923", fY = "\u2196", dY = "\u21D6", pY = "\u2196", gY = "\u2927", mY = "\xD3", bY = "\xF3", yY = "\u229B", wY = "\xD4", vY = "\xF4", xY = "\u229A", kY = "\u041E", _Y = "\u043E", SY = "\u229D", CY = "\u0150", AY = "\u0151", DY = "\u2A38", EY = "\u2299", TY = "\u29BC", MY = "\u0152", OY = "\u0153", LY = "\u29BF", RY = "\u{1D512}", IY = "\u{1D52C}", BY = "\u02DB", NY = "\xD2", PY = "\xF2", FY = "\u29C1", $Y = "\u29B5", HY = "\u03A9", qY = "\u222E", VY = "\u21BA", zY = "\u29BE", UY = "\u29BB", WY = "\u203E", jY = "\u29C0", GY = "\u014C", KY = "\u014D", YY = "\u03A9", JY = "\u03C9", ZY = "\u039F", XY = "\u03BF", QY = "\u29B6", eJ = "\u2296", tJ = "\u{1D546}", nJ = "\u{1D560}", iJ = "\u29B7", rJ = "\u201C", sJ = "\u2018", oJ = "\u29B9", lJ = "\u2295", aJ = "\u21BB", cJ = "\u2A54", hJ = "\u2228", uJ = "\u2A5D", fJ = "\u2134", dJ = "\u2134", pJ = "\xAA", gJ = "\xBA", mJ = "\u22B6", bJ = "\u2A56", yJ = "\u2A57", wJ = "\u2A5B", vJ = "\u24C8", xJ = "\u{1D4AA}", kJ = "\u2134", _J = "\xD8", SJ = "\xF8", CJ = "\u2298", AJ = "\xD5", DJ = "\xF5", EJ = "\u2A36", TJ = "\u2A37", MJ = "\u2297", OJ = "\xD6", LJ = "\xF6", RJ = "\u233D", IJ = "\u203E", BJ = "\u23DE", NJ = "\u23B4", PJ = "\u23DC", FJ = "\xB6", $J = "\u2225", HJ = "\u2225", qJ = "\u2AF3", VJ = "\u2AFD", zJ = "\u2202", UJ = "\u2202", WJ = "\u041F", jJ = "\u043F", GJ = "%", KJ = ".", YJ = "\u2030", JJ = "\u22A5", ZJ = "\u2031", XJ = "\u{1D513}", QJ = "\u{1D52D}", eZ = "\u03A6", tZ = "\u03C6", nZ = "\u03D5", iZ = "\u2133", rZ = "\u260E", sZ = "\u03A0", oZ = "\u03C0", lZ = "\u22D4", aZ = "\u03D6", cZ = "\u210F", hZ = "\u210E", uZ = "\u210F", fZ = "\u2A23", dZ = "\u229E", pZ = "\u2A22", gZ = "+", mZ = "\u2214", bZ = "\u2A25", yZ = "\u2A72", wZ = "\xB1", vZ = "\xB1", xZ = "\u2A26", kZ = "\u2A27", _Z = "\xB1", SZ = "\u210C", CZ = "\u2A15", AZ = "\u{1D561}", DZ = "\u2119", EZ = "\xA3", TZ = "\u2AB7", MZ = "\u2ABB", OZ = "\u227A", LZ = "\u227C", RZ = "\u2AB7", IZ = "\u227A", BZ = "\u227C", NZ = "\u227A", PZ = "\u2AAF", FZ = "\u227C", $Z = "\u227E", HZ = "\u2AAF", qZ = "\u2AB9", VZ = "\u2AB5", zZ = "\u22E8", UZ = "\u2AAF", WZ = "\u2AB3", jZ = "\u227E", GZ = "\u2032", KZ = "\u2033", YZ = "\u2119", JZ = "\u2AB9", ZZ = "\u2AB5", XZ = "\u22E8", QZ = "\u220F", eX = "\u220F", tX = "\u232E", nX = "\u2312", iX = "\u2313", rX = "\u221D", sX = "\u221D", oX = "\u2237", lX = "\u221D", aX = "\u227E", cX = "\u22B0", hX = "\u{1D4AB}", uX = "\u{1D4C5}", fX = "\u03A8", dX = "\u03C8", pX = "\u2008", gX = "\u{1D514}", mX = "\u{1D52E}", bX = "\u2A0C", yX = "\u{1D562}", wX = "\u211A", vX = "\u2057", xX = "\u{1D4AC}", kX = "\u{1D4C6}", _X = "\u210D", SX = "\u2A16", CX = "?", AX = "\u225F", DX = '"', EX = '"', TX = "\u21DB", MX = "\u223D\u0331", OX = "\u0154", LX = "\u0155", RX = "\u221A", IX = "\u29B3", BX = "\u27E9", NX = "\u27EB", PX = "\u2992", FX = "\u29A5", $X = "\u27E9", HX = "\xBB", qX = "\u2975", VX = "\u21E5", zX = "\u2920", UX = "\u2933", WX = "\u2192", jX = "\u21A0", GX = "\u21D2", KX = "\u291E", YX = "\u21AA", JX = "\u21AC", ZX = "\u2945", XX = "\u2974", QX = "\u2916", eQ = "\u21A3", tQ = "\u219D", nQ = "\u291A", iQ = "\u291C", rQ = "\u2236", sQ = "\u211A", oQ = "\u290D", lQ = "\u290F", aQ = "\u2910", cQ = "\u2773", hQ = "}", uQ = "]", fQ = "\u298C", dQ = "\u298E", pQ = "\u2990", gQ = "\u0158", mQ = "\u0159", bQ = "\u0156", yQ = "\u0157", wQ = "\u2309", vQ = "}", xQ = "\u0420", kQ = "\u0440", _Q = "\u2937", SQ = "\u2969", CQ = "\u201D", AQ = "\u201D", DQ = "\u21B3", EQ = "\u211C", TQ = "\u211B", MQ = "\u211C", OQ = "\u211D", LQ = "\u211C", RQ = "\u25AD", IQ = "\xAE", BQ = "\xAE", NQ = "\u220B", PQ = "\u21CB", FQ = "\u296F", $Q = "\u297D", HQ = "\u230B", qQ = "\u{1D52F}", VQ = "\u211C", zQ = "\u2964", UQ = "\u21C1", WQ = "\u21C0", jQ = "\u296C", GQ = "\u03A1", KQ = "\u03C1", YQ = "\u03F1", JQ = "\u27E9", ZQ = "\u21E5", XQ = "\u2192", QQ = "\u2192", eee = "\u21D2", tee = "\u21C4", nee = "\u21A3", iee = "\u2309", ree = "\u27E7", see = "\u295D", oee = "\u2955", lee = "\u21C2", aee = "\u230B", cee = "\u21C1", hee = "\u21C0", uee = "\u21C4", fee = "\u21CC", dee = "\u21C9", pee = "\u219D", gee = "\u21A6", mee = "\u22A2", bee = "\u295B", yee = "\u22CC", wee = "\u29D0", vee = "\u22B3", xee = "\u22B5", kee = "\u294F", _ee = "\u295C", See = "\u2954", Cee = "\u21BE", Aee = "\u2953", Dee = "\u21C0", Eee = "\u02DA", Tee = "\u2253", Mee = "\u21C4", Oee = "\u21CC", Lee = "\u200F", Ree = "\u23B1", Iee = "\u23B1", Bee = "\u2AEE", Nee = "\u27ED", Pee = "\u21FE", Fee = "\u27E7", $ee = "\u2986", Hee = "\u{1D563}", qee = "\u211D", Vee = "\u2A2E", zee = "\u2A35", Uee = "\u2970", Wee = ")", jee = "\u2994", Gee = "\u2A12", Kee = "\u21C9", Yee = "\u21DB", Jee = "\u203A", Zee = "\u{1D4C7}", Xee = "\u211B", Qee = "\u21B1", ete = "\u21B1", tte = "]", nte = "\u2019", ite = "\u2019", rte = "\u22CC", ste = "\u22CA", ote = "\u25B9", lte = "\u22B5", ate = "\u25B8", cte = "\u29CE", hte = "\u29F4", ute = "\u2968", fte = "\u211E", dte = "\u015A", pte = "\u015B", gte = "\u201A", mte = "\u2AB8", bte = "\u0160", yte = "\u0161", wte = "\u2ABC", vte = "\u227B", xte = "\u227D", kte = "\u2AB0", _te = "\u2AB4", Ste = "\u015E", Cte = "\u015F", Ate = "\u015C", Dte = "\u015D", Ete = "\u2ABA", Tte = "\u2AB6", Mte = "\u22E9", Ote = "\u2A13", Lte = "\u227F", Rte = "\u0421", Ite = "\u0441", Bte = "\u22A1", Nte = "\u22C5", Pte = "\u2A66", Fte = "\u2925", $te = "\u2198", Hte = "\u21D8", qte = "\u2198", Vte = "\xA7", zte = ";", Ute = "\u2929", Wte = "\u2216", jte = "\u2216", Gte = "\u2736", Kte = "\u{1D516}", Yte = "\u{1D530}", Jte = "\u2322", Zte = "\u266F", Xte = "\u0429", Qte = "\u0449", ene = "\u0428", tne = "\u0448", nne = "\u2193", ine = "\u2190", rne = "\u2223", sne = "\u2225", one = "\u2192", lne = "\u2191", ane = "\xAD", cne = "\u03A3", hne = "\u03C3", une = "\u03C2", fne = "\u03C2", dne = "\u223C", pne = "\u2A6A", gne = "\u2243", mne = "\u2243", bne = "\u2A9E", yne = "\u2AA0", wne = "\u2A9D", vne = "\u2A9F", xne = "\u2246", kne = "\u2A24", _ne = "\u2972", Sne = "\u2190", Cne = "\u2218", Ane = "\u2216", Dne = "\u2A33", Ene = "\u29E4", Tne = "\u2223", Mne = "\u2323", One = "\u2AAA", Lne = "\u2AAC", Rne = "\u2AAC\uFE00", Ine = "\u042C", Bne = "\u044C", Nne = "\u233F", Pne = "\u29C4", Fne = "/", $ne = "\u{1D54A}", Hne = "\u{1D564}", qne = "\u2660", Vne = "\u2660", zne = "\u2225", Une = "\u2293", Wne = "\u2293\uFE00", jne = "\u2294", Gne = "\u2294\uFE00", Kne = "\u221A", Yne = "\u228F", Jne = "\u2291", Zne = "\u228F", Xne = "\u2291", Qne = "\u2290", eie = "\u2292", tie = "\u2290", nie = "\u2292", iie = "\u25A1", rie = "\u25A1", sie = "\u2293", oie = "\u228F", lie = "\u2291", aie = "\u2290", cie = "\u2292", hie = "\u2294", uie = "\u25AA", fie = "\u25A1", die = "\u25AA", pie = "\u2192", gie = "\u{1D4AE}", mie = "\u{1D4C8}", bie = "\u2216", yie = "\u2323", wie = "\u22C6", vie = "\u22C6", xie = "\u2606", kie = "\u2605", _ie = "\u03F5", Sie = "\u03D5", Cie = "\xAF", Aie = "\u2282", Die = "\u22D0", Eie = "\u2ABD", Tie = "\u2AC5", Mie = "\u2286", Oie = "\u2AC3", Lie = "\u2AC1", Rie = "\u2ACB", Iie = "\u228A", Bie = "\u2ABF", Nie = "\u2979", Pie = "\u2282", Fie = "\u22D0", $ie = "\u2286", Hie = "\u2AC5", qie = "\u2286", Vie = "\u228A", zie = "\u2ACB", Uie = "\u2AC7", Wie = "\u2AD5", jie = "\u2AD3", Gie = "\u2AB8", Kie = "\u227B", Yie = "\u227D", Jie = "\u227B", Zie = "\u2AB0", Xie = "\u227D", Qie = "\u227F", ere = "\u2AB0", tre = "\u2ABA", nre = "\u2AB6", ire = "\u22E9", rre = "\u227F", sre = "\u220B", ore = "\u2211", lre = "\u2211", are = "\u266A", cre = "\xB9", hre = "\xB2", ure = "\xB3", fre = "\u2283", dre = "\u22D1", pre = "\u2ABE", gre = "\u2AD8", mre = "\u2AC6", bre = "\u2287", yre = "\u2AC4", wre = "\u2283", vre = "\u2287", xre = "\u27C9", kre = "\u2AD7", _re = "\u297B", Sre = "\u2AC2", Cre = "\u2ACC", Are = "\u228B", Dre = "\u2AC0", Ere = "\u2283", Tre = "\u22D1", Mre = "\u2287", Ore = "\u2AC6", Lre = "\u228B", Rre = "\u2ACC", Ire = "\u2AC8", Bre = "\u2AD4", Nre = "\u2AD6", Pre = "\u2926", Fre = "\u2199", $re = "\u21D9", Hre = "\u2199", qre = "\u292A", Vre = "\xDF", zre = "	", Ure = "\u2316", Wre = "\u03A4", jre = "\u03C4", Gre = "\u23B4", Kre = "\u0164", Yre = "\u0165", Jre = "\u0162", Zre = "\u0163", Xre = "\u0422", Qre = "\u0442", ese = "\u20DB", tse = "\u2315", nse = "\u{1D517}", ise = "\u{1D531}", rse = "\u2234", sse = "\u2234", ose = "\u2234", lse = "\u0398", ase = "\u03B8", cse = "\u03D1", hse = "\u03D1", use = "\u2248", fse = "\u223C", dse = "\u205F\u200A", pse = "\u2009", gse = "\u2009", mse = "\u2248", bse = "\u223C", yse = "\xDE", wse = "\xFE", vse = "\u02DC", xse = "\u223C", kse = "\u2243", _se = "\u2245", Sse = "\u2248", Cse = "\u2A31", Ase = "\u22A0", Dse = "\xD7", Ese = "\u2A30", Tse = "\u222D", Mse = "\u2928", Ose = "\u2336", Lse = "\u2AF1", Rse = "\u22A4", Ise = "\u{1D54B}", Bse = "\u{1D565}", Nse = "\u2ADA", Pse = "\u2929", Fse = "\u2034", $se = "\u2122", Hse = "\u2122", qse = "\u25B5", Vse = "\u25BF", zse = "\u25C3", Use = "\u22B4", Wse = "\u225C", jse = "\u25B9", Gse = "\u22B5", Kse = "\u25EC", Yse = "\u225C", Jse = "\u2A3A", Zse = "\u20DB", Xse = "\u2A39", Qse = "\u29CD", eoe = "\u2A3B", toe = "\u23E2", noe = "\u{1D4AF}", ioe = "\u{1D4C9}", roe = "\u0426", soe = "\u0446", ooe = "\u040B", loe = "\u045B", aoe = "\u0166", coe = "\u0167", hoe = "\u226C", uoe = "\u219E", foe = "\u21A0", doe = "\xDA", poe = "\xFA", goe = "\u2191", moe = "\u219F", boe = "\u21D1", yoe = "\u2949", woe = "\u040E", voe = "\u045E", xoe = "\u016C", koe = "\u016D", _oe = "\xDB", Soe = "\xFB", Coe = "\u0423", Aoe = "\u0443", Doe = "\u21C5", Eoe = "\u0170", Toe = "\u0171", Moe = "\u296E", Ooe = "\u297E", Loe = "\u{1D518}", Roe = "\u{1D532}", Ioe = "\xD9", Boe = "\xF9", Noe = "\u2963", Poe = "\u21BF", Foe = "\u21BE", $oe = "\u2580", Hoe = "\u231C", qoe = "\u231C", Voe = "\u230F", zoe = "\u25F8", Uoe = "\u016A", Woe = "\u016B", joe = "\xA8", Goe = "_", Koe = "\u23DF", Yoe = "\u23B5", Joe = "\u23DD", Zoe = "\u22C3", Xoe = "\u228E", Qoe = "\u0172", ele = "\u0173", tle = "\u{1D54C}", nle = "\u{1D566}", ile = "\u2912", rle = "\u2191", sle = "\u2191", ole = "\u21D1", lle = "\u21C5", ale = "\u2195", cle = "\u2195", hle = "\u21D5", ule = "\u296E", fle = "\u21BF", dle = "\u21BE", ple = "\u228E", gle = "\u2196", mle = "\u2197", ble = "\u03C5", yle = "\u03D2", wle = "\u03D2", vle = "\u03A5", xle = "\u03C5", kle = "\u21A5", _le = "\u22A5", Sle = "\u21C8", Cle = "\u231D", Ale = "\u231D", Dle = "\u230E", Ele = "\u016E", Tle = "\u016F", Mle = "\u25F9", Ole = "\u{1D4B0}", Lle = "\u{1D4CA}", Rle = "\u22F0", Ile = "\u0168", Ble = "\u0169", Nle = "\u25B5", Ple = "\u25B4", Fle = "\u21C8", $le = "\xDC", Hle = "\xFC", qle = "\u29A7", Vle = "\u299C", zle = "\u03F5", Ule = "\u03F0", Wle = "\u2205", jle = "\u03D5", Gle = "\u03D6", Kle = "\u221D", Yle = "\u2195", Jle = "\u21D5", Zle = "\u03F1", Xle = "\u03C2", Qle = "\u228A\uFE00", eae = "\u2ACB\uFE00", tae = "\u228B\uFE00", nae = "\u2ACC\uFE00", iae = "\u03D1", rae = "\u22B2", sae = "\u22B3", oae = "\u2AE8", lae = "\u2AEB", aae = "\u2AE9", cae = "\u0412", hae = "\u0432", uae = "\u22A2", fae = "\u22A8", dae = "\u22A9", pae = "\u22AB", gae = "\u2AE6", mae = "\u22BB", bae = "\u2228", yae = "\u22C1", wae = "\u225A", vae = "\u22EE", xae = "|", kae = "\u2016", _ae = "|", Sae = "\u2016", Cae = "\u2223", Aae = "|", Dae = "\u2758", Eae = "\u2240", Tae = "\u200A", Mae = "\u{1D519}", Oae = "\u{1D533}", Lae = "\u22B2", Rae = "\u2282\u20D2", Iae = "\u2283\u20D2", Bae = "\u{1D54D}", Nae = "\u{1D567}", Pae = "\u221D", Fae = "\u22B3", $ae = "\u{1D4B1}", Hae = "\u{1D4CB}", qae = "\u2ACB\uFE00", Vae = "\u228A\uFE00", zae = "\u2ACC\uFE00", Uae = "\u228B\uFE00", Wae = "\u22AA", jae = "\u299A", Gae = "\u0174", Kae = "\u0175", Yae = "\u2A5F", Jae = "\u2227", Zae = "\u22C0", Xae = "\u2259", Qae = "\u2118", ece = "\u{1D51A}", tce = "\u{1D534}", nce = "\u{1D54E}", ice = "\u{1D568}", rce = "\u2118", sce = "\u2240", oce = "\u2240", lce = "\u{1D4B2}", ace = "\u{1D4CC}", cce = "\u22C2", hce = "\u25EF", uce = "\u22C3", fce = "\u25BD", dce = "\u{1D51B}", pce = "\u{1D535}", gce = "\u27F7", mce = "\u27FA", bce = "\u039E", yce = "\u03BE", wce = "\u27F5", vce = "\u27F8", xce = "\u27FC", kce = "\u22FB", _ce = "\u2A00", Sce = "\u{1D54F}", Cce = "\u{1D569}", Ace = "\u2A01", Dce = "\u2A02", Ece = "\u27F6", Tce = "\u27F9", Mce = "\u{1D4B3}", Oce = "\u{1D4CD}", Lce = "\u2A06", Rce = "\u2A04", Ice = "\u25B3", Bce = "\u22C1", Nce = "\u22C0", Pce = "\xDD", Fce = "\xFD", $ce = "\u042F", Hce = "\u044F", qce = "\u0176", Vce = "\u0177", zce = "\u042B", Uce = "\u044B", Wce = "\xA5", jce = "\u{1D51C}", Gce = "\u{1D536}", Kce = "\u0407", Yce = "\u0457", Jce = "\u{1D550}", Zce = "\u{1D56A}", Xce = "\u{1D4B4}", Qce = "\u{1D4CE}", ehe = "\u042E", the = "\u044E", nhe = "\xFF", ihe = "\u0178", rhe = "\u0179", she = "\u017A", ohe = "\u017D", lhe = "\u017E", ahe = "\u0417", che = "\u0437", hhe = "\u017B", uhe = "\u017C", fhe = "\u2128", dhe = "\u200B", phe = "\u0396", ghe = "\u03B6", mhe = "\u{1D537}", bhe = "\u2128", yhe = "\u0416", whe = "\u0436", vhe = "\u21DD", xhe = "\u{1D56B}", khe = "\u2124", _he = "\u{1D4B5}", She = "\u{1D4CF}", Che = "\u200D", Ahe = "\u200C", Dhe = {
  Aacute: hL,
  aacute: uL,
  Abreve: fL,
  abreve: dL,
  ac: pL,
  acd: gL,
  acE: mL,
  Acirc: bL,
  acirc: yL,
  acute: wL,
  Acy: vL,
  acy: xL,
  AElig: kL,
  aelig: _L,
  af: SL,
  Afr: CL,
  afr: AL,
  Agrave: DL,
  agrave: EL,
  alefsym: TL,
  aleph: ML,
  Alpha: OL,
  alpha: LL,
  Amacr: RL,
  amacr: IL,
  amalg: BL,
  amp: NL,
  AMP: PL,
  andand: FL,
  And: $L,
  and: HL,
  andd: qL,
  andslope: VL,
  andv: zL,
  ang: UL,
  ange: WL,
  angle: jL,
  angmsdaa: GL,
  angmsdab: KL,
  angmsdac: YL,
  angmsdad: JL,
  angmsdae: ZL,
  angmsdaf: XL,
  angmsdag: QL,
  angmsdah: eR,
  angmsd: tR,
  angrt: nR,
  angrtvb: iR,
  angrtvbd: rR,
  angsph: sR,
  angst: oR,
  angzarr: lR,
  Aogon: aR,
  aogon: cR,
  Aopf: hR,
  aopf: uR,
  apacir: fR,
  ap: dR,
  apE: pR,
  ape: gR,
  apid: mR,
  apos: bR,
  ApplyFunction: yR,
  approx: wR,
  approxeq: vR,
  Aring: xR,
  aring: kR,
  Ascr: _R,
  ascr: SR,
  Assign: CR,
  ast: AR,
  asymp: DR,
  asympeq: ER,
  Atilde: TR,
  atilde: MR,
  Auml: OR,
  auml: LR,
  awconint: RR,
  awint: IR,
  backcong: BR,
  backepsilon: NR,
  backprime: PR,
  backsim: FR,
  backsimeq: $R,
  Backslash: HR,
  Barv: qR,
  barvee: VR,
  barwed: zR,
  Barwed: UR,
  barwedge: WR,
  bbrk: jR,
  bbrktbrk: GR,
  bcong: KR,
  Bcy: YR,
  bcy: JR,
  bdquo: ZR,
  becaus: XR,
  because: QR,
  Because: e3,
  bemptyv: t3,
  bepsi: n3,
  bernou: i3,
  Bernoullis: r3,
  Beta: s3,
  beta: o3,
  beth: l3,
  between: a3,
  Bfr: c3,
  bfr: h3,
  bigcap: u3,
  bigcirc: f3,
  bigcup: d3,
  bigodot: p3,
  bigoplus: g3,
  bigotimes: m3,
  bigsqcup: b3,
  bigstar: y3,
  bigtriangledown: w3,
  bigtriangleup: v3,
  biguplus: x3,
  bigvee: k3,
  bigwedge: _3,
  bkarow: S3,
  blacklozenge: C3,
  blacksquare: A3,
  blacktriangle: D3,
  blacktriangledown: E3,
  blacktriangleleft: T3,
  blacktriangleright: M3,
  blank: O3,
  blk12: L3,
  blk14: R3,
  blk34: I3,
  block: B3,
  bne: N3,
  bnequiv: P3,
  bNot: F3,
  bnot: $3,
  Bopf: H3,
  bopf: q3,
  bot: V3,
  bottom: z3,
  bowtie: U3,
  boxbox: W3,
  boxdl: j3,
  boxdL: G3,
  boxDl: K3,
  boxDL: Y3,
  boxdr: J3,
  boxdR: Z3,
  boxDr: X3,
  boxDR: Q3,
  boxh: eI,
  boxH: tI,
  boxhd: nI,
  boxHd: iI,
  boxhD: rI,
  boxHD: sI,
  boxhu: oI,
  boxHu: lI,
  boxhU: aI,
  boxHU: cI,
  boxminus: hI,
  boxplus: uI,
  boxtimes: fI,
  boxul: dI,
  boxuL: pI,
  boxUl: gI,
  boxUL: mI,
  boxur: bI,
  boxuR: yI,
  boxUr: wI,
  boxUR: vI,
  boxv: xI,
  boxV: kI,
  boxvh: _I,
  boxvH: SI,
  boxVh: CI,
  boxVH: AI,
  boxvl: DI,
  boxvL: EI,
  boxVl: TI,
  boxVL: MI,
  boxvr: OI,
  boxvR: LI,
  boxVr: RI,
  boxVR: II,
  bprime: BI,
  breve: NI,
  Breve: PI,
  brvbar: FI,
  bscr: $I,
  Bscr: HI,
  bsemi: qI,
  bsim: VI,
  bsime: zI,
  bsolb: UI,
  bsol: WI,
  bsolhsub: jI,
  bull: GI,
  bullet: KI,
  bump: YI,
  bumpE: JI,
  bumpe: ZI,
  Bumpeq: XI,
  bumpeq: QI,
  Cacute: eB,
  cacute: tB,
  capand: nB,
  capbrcup: iB,
  capcap: rB,
  cap: sB,
  Cap: oB,
  capcup: lB,
  capdot: aB,
  CapitalDifferentialD: cB,
  caps: hB,
  caret: uB,
  caron: fB,
  Cayleys: dB,
  ccaps: pB,
  Ccaron: gB,
  ccaron: mB,
  Ccedil: bB,
  ccedil: yB,
  Ccirc: wB,
  ccirc: vB,
  Cconint: xB,
  ccups: kB,
  ccupssm: _B,
  Cdot: SB,
  cdot: CB,
  cedil: AB,
  Cedilla: DB,
  cemptyv: EB,
  cent: TB,
  centerdot: MB,
  CenterDot: OB,
  cfr: LB,
  Cfr: RB,
  CHcy: IB,
  chcy: BB,
  check: NB,
  checkmark: PB,
  Chi: FB,
  chi: $B,
  circ: HB,
  circeq: qB,
  circlearrowleft: VB,
  circlearrowright: zB,
  circledast: UB,
  circledcirc: WB,
  circleddash: jB,
  CircleDot: GB,
  circledR: KB,
  circledS: YB,
  CircleMinus: JB,
  CirclePlus: ZB,
  CircleTimes: XB,
  cir: QB,
  cirE: eN,
  cire: tN,
  cirfnint: nN,
  cirmid: iN,
  cirscir: rN,
  ClockwiseContourIntegral: sN,
  CloseCurlyDoubleQuote: oN,
  CloseCurlyQuote: lN,
  clubs: aN,
  clubsuit: cN,
  colon: hN,
  Colon: uN,
  Colone: fN,
  colone: dN,
  coloneq: pN,
  comma: gN,
  commat: mN,
  comp: bN,
  compfn: yN,
  complement: wN,
  complexes: vN,
  cong: xN,
  congdot: kN,
  Congruent: _N,
  conint: SN,
  Conint: CN,
  ContourIntegral: AN,
  copf: DN,
  Copf: EN,
  coprod: TN,
  Coproduct: MN,
  copy: ON,
  COPY: LN,
  copysr: RN,
  CounterClockwiseContourIntegral: IN,
  crarr: BN,
  cross: NN,
  Cross: PN,
  Cscr: FN,
  cscr: $N,
  csub: HN,
  csube: qN,
  csup: VN,
  csupe: zN,
  ctdot: UN,
  cudarrl: WN,
  cudarrr: jN,
  cuepr: GN,
  cuesc: KN,
  cularr: YN,
  cularrp: JN,
  cupbrcap: ZN,
  cupcap: XN,
  CupCap: QN,
  cup: eP,
  Cup: tP,
  cupcup: nP,
  cupdot: iP,
  cupor: rP,
  cups: sP,
  curarr: oP,
  curarrm: lP,
  curlyeqprec: aP,
  curlyeqsucc: cP,
  curlyvee: hP,
  curlywedge: uP,
  curren: fP,
  curvearrowleft: dP,
  curvearrowright: pP,
  cuvee: gP,
  cuwed: mP,
  cwconint: bP,
  cwint: yP,
  cylcty: wP,
  dagger: vP,
  Dagger: xP,
  daleth: kP,
  darr: _P,
  Darr: SP,
  dArr: CP,
  dash: AP,
  Dashv: DP,
  dashv: EP,
  dbkarow: TP,
  dblac: MP,
  Dcaron: OP,
  dcaron: LP,
  Dcy: RP,
  dcy: IP,
  ddagger: BP,
  ddarr: NP,
  DD: PP,
  dd: FP,
  DDotrahd: $P,
  ddotseq: HP,
  deg: qP,
  Del: VP,
  Delta: zP,
  delta: UP,
  demptyv: WP,
  dfisht: jP,
  Dfr: GP,
  dfr: KP,
  dHar: YP,
  dharl: JP,
  dharr: ZP,
  DiacriticalAcute: XP,
  DiacriticalDot: QP,
  DiacriticalDoubleAcute: eF,
  DiacriticalGrave: tF,
  DiacriticalTilde: nF,
  diam: iF,
  diamond: rF,
  Diamond: sF,
  diamondsuit: oF,
  diams: lF,
  die: aF,
  DifferentialD: cF,
  digamma: hF,
  disin: uF,
  div: fF,
  divide: dF,
  divideontimes: pF,
  divonx: gF,
  DJcy: mF,
  djcy: bF,
  dlcorn: yF,
  dlcrop: wF,
  dollar: vF,
  Dopf: xF,
  dopf: kF,
  Dot: _F,
  dot: SF,
  DotDot: CF,
  doteq: AF,
  doteqdot: DF,
  DotEqual: EF,
  dotminus: TF,
  dotplus: MF,
  dotsquare: OF,
  doublebarwedge: LF,
  DoubleContourIntegral: RF,
  DoubleDot: IF,
  DoubleDownArrow: BF,
  DoubleLeftArrow: NF,
  DoubleLeftRightArrow: PF,
  DoubleLeftTee: FF,
  DoubleLongLeftArrow: $F,
  DoubleLongLeftRightArrow: HF,
  DoubleLongRightArrow: qF,
  DoubleRightArrow: VF,
  DoubleRightTee: zF,
  DoubleUpArrow: UF,
  DoubleUpDownArrow: WF,
  DoubleVerticalBar: jF,
  DownArrowBar: GF,
  downarrow: KF,
  DownArrow: YF,
  Downarrow: JF,
  DownArrowUpArrow: ZF,
  DownBreve: XF,
  downdownarrows: QF,
  downharpoonleft: e4,
  downharpoonright: t4,
  DownLeftRightVector: n4,
  DownLeftTeeVector: i4,
  DownLeftVectorBar: r4,
  DownLeftVector: s4,
  DownRightTeeVector: o4,
  DownRightVectorBar: l4,
  DownRightVector: a4,
  DownTeeArrow: c4,
  DownTee: h4,
  drbkarow: u4,
  drcorn: f4,
  drcrop: d4,
  Dscr: p4,
  dscr: g4,
  DScy: m4,
  dscy: b4,
  dsol: y4,
  Dstrok: w4,
  dstrok: v4,
  dtdot: x4,
  dtri: k4,
  dtrif: _4,
  duarr: S4,
  duhar: C4,
  dwangle: A4,
  DZcy: D4,
  dzcy: E4,
  dzigrarr: T4,
  Eacute: M4,
  eacute: O4,
  easter: L4,
  Ecaron: R4,
  ecaron: I4,
  Ecirc: B4,
  ecirc: N4,
  ecir: P4,
  ecolon: F4,
  Ecy: $4,
  ecy: H4,
  eDDot: q4,
  Edot: V4,
  edot: z4,
  eDot: U4,
  ee: W4,
  efDot: j4,
  Efr: G4,
  efr: K4,
  eg: Y4,
  Egrave: J4,
  egrave: Z4,
  egs: X4,
  egsdot: Q4,
  el: e5,
  Element: t5,
  elinters: n5,
  ell: i5,
  els: r5,
  elsdot: s5,
  Emacr: o5,
  emacr: l5,
  empty: a5,
  emptyset: c5,
  EmptySmallSquare: h5,
  emptyv: u5,
  EmptyVerySmallSquare: f5,
  emsp13: d5,
  emsp14: p5,
  emsp: g5,
  ENG: m5,
  eng: b5,
  ensp: y5,
  Eogon: w5,
  eogon: v5,
  Eopf: x5,
  eopf: k5,
  epar: _5,
  eparsl: S5,
  eplus: C5,
  epsi: A5,
  Epsilon: D5,
  epsilon: E5,
  epsiv: T5,
  eqcirc: M5,
  eqcolon: O5,
  eqsim: L5,
  eqslantgtr: R5,
  eqslantless: I5,
  Equal: B5,
  equals: N5,
  EqualTilde: P5,
  equest: F5,
  Equilibrium: $5,
  equiv: H5,
  equivDD: q5,
  eqvparsl: V5,
  erarr: z5,
  erDot: U5,
  escr: W5,
  Escr: j5,
  esdot: G5,
  Esim: K5,
  esim: Y5,
  Eta: J5,
  eta: Z5,
  ETH: X5,
  eth: Q5,
  Euml: e8,
  euml: t8,
  euro: n8,
  excl: i8,
  exist: r8,
  Exists: s8,
  expectation: o8,
  exponentiale: l8,
  ExponentialE: a8,
  fallingdotseq: c8,
  Fcy: h8,
  fcy: u8,
  female: f8,
  ffilig: d8,
  fflig: p8,
  ffllig: g8,
  Ffr: m8,
  ffr: b8,
  filig: y8,
  FilledSmallSquare: w8,
  FilledVerySmallSquare: v8,
  fjlig: x8,
  flat: k8,
  fllig: _8,
  fltns: S8,
  fnof: C8,
  Fopf: A8,
  fopf: D8,
  forall: E8,
  ForAll: T8,
  fork: M8,
  forkv: O8,
  Fouriertrf: L8,
  fpartint: R8,
  frac12: I8,
  frac13: B8,
  frac14: N8,
  frac15: P8,
  frac16: F8,
  frac18: $8,
  frac23: H8,
  frac25: q8,
  frac34: V8,
  frac35: z8,
  frac38: U8,
  frac45: W8,
  frac56: j8,
  frac58: G8,
  frac78: K8,
  frasl: Y8,
  frown: J8,
  fscr: Z8,
  Fscr: X8,
  gacute: Q8,
  Gamma: e$,
  gamma: t$,
  Gammad: n$,
  gammad: i$,
  gap: r$,
  Gbreve: s$,
  gbreve: o$,
  Gcedil: l$,
  Gcirc: a$,
  gcirc: c$,
  Gcy: h$,
  gcy: u$,
  Gdot: f$,
  gdot: d$,
  ge: p$,
  gE: g$,
  gEl: m$,
  gel: b$,
  geq: y$,
  geqq: w$,
  geqslant: v$,
  gescc: x$,
  ges: k$,
  gesdot: _$,
  gesdoto: S$,
  gesdotol: C$,
  gesl: A$,
  gesles: D$,
  Gfr: E$,
  gfr: T$,
  gg: M$,
  Gg: O$,
  ggg: L$,
  gimel: R$,
  GJcy: I$,
  gjcy: B$,
  gla: N$,
  gl: P$,
  glE: F$,
  glj: $$,
  gnap: H$,
  gnapprox: q$,
  gne: V$,
  gnE: z$,
  gneq: U$,
  gneqq: W$,
  gnsim: j$,
  Gopf: G$,
  gopf: K$,
  grave: Y$,
  GreaterEqual: J$,
  GreaterEqualLess: Z$,
  GreaterFullEqual: X$,
  GreaterGreater: Q$,
  GreaterLess: e6,
  GreaterSlantEqual: t6,
  GreaterTilde: n6,
  Gscr: i6,
  gscr: r6,
  gsim: s6,
  gsime: o6,
  gsiml: l6,
  gtcc: a6,
  gtcir: c6,
  gt: h6,
  GT: u6,
  Gt: f6,
  gtdot: d6,
  gtlPar: p6,
  gtquest: g6,
  gtrapprox: m6,
  gtrarr: b6,
  gtrdot: y6,
  gtreqless: w6,
  gtreqqless: v6,
  gtrless: x6,
  gtrsim: k6,
  gvertneqq: _6,
  gvnE: S6,
  Hacek: C6,
  hairsp: A6,
  half: D6,
  hamilt: E6,
  HARDcy: T6,
  hardcy: M6,
  harrcir: O6,
  harr: L6,
  hArr: R6,
  harrw: I6,
  Hat: B6,
  hbar: N6,
  Hcirc: P6,
  hcirc: F6,
  hearts: $6,
  heartsuit: H6,
  hellip: q6,
  hercon: V6,
  hfr: z6,
  Hfr: U6,
  HilbertSpace: W6,
  hksearow: j6,
  hkswarow: G6,
  hoarr: K6,
  homtht: Y6,
  hookleftarrow: J6,
  hookrightarrow: Z6,
  hopf: X6,
  Hopf: Q6,
  horbar: eH,
  HorizontalLine: tH,
  hscr: nH,
  Hscr: iH,
  hslash: rH,
  Hstrok: sH,
  hstrok: oH,
  HumpDownHump: lH,
  HumpEqual: aH,
  hybull: cH,
  hyphen: hH,
  Iacute: uH,
  iacute: fH,
  ic: dH,
  Icirc: pH,
  icirc: gH,
  Icy: mH,
  icy: bH,
  Idot: yH,
  IEcy: wH,
  iecy: vH,
  iexcl: xH,
  iff: kH,
  ifr: _H,
  Ifr: SH,
  Igrave: CH,
  igrave: AH,
  ii: DH,
  iiiint: EH,
  iiint: TH,
  iinfin: MH,
  iiota: OH,
  IJlig: LH,
  ijlig: RH,
  Imacr: IH,
  imacr: BH,
  image: NH,
  ImaginaryI: PH,
  imagline: FH,
  imagpart: $H,
  imath: HH,
  Im: qH,
  imof: VH,
  imped: zH,
  Implies: UH,
  incare: WH,
  in: "\u2208",
  infin: jH,
  infintie: GH,
  inodot: KH,
  intcal: YH,
  int: JH,
  Int: ZH,
  integers: XH,
  Integral: QH,
  intercal: eq,
  Intersection: tq,
  intlarhk: nq,
  intprod: iq,
  InvisibleComma: rq,
  InvisibleTimes: sq,
  IOcy: oq,
  iocy: lq,
  Iogon: aq,
  iogon: cq,
  Iopf: hq,
  iopf: uq,
  Iota: fq,
  iota: dq,
  iprod: pq,
  iquest: gq,
  iscr: mq,
  Iscr: bq,
  isin: yq,
  isindot: wq,
  isinE: vq,
  isins: xq,
  isinsv: kq,
  isinv: _q,
  it: Sq,
  Itilde: Cq,
  itilde: Aq,
  Iukcy: Dq,
  iukcy: Eq,
  Iuml: Tq,
  iuml: Mq,
  Jcirc: Oq,
  jcirc: Lq,
  Jcy: Rq,
  jcy: Iq,
  Jfr: Bq,
  jfr: Nq,
  jmath: Pq,
  Jopf: Fq,
  jopf: $q,
  Jscr: Hq,
  jscr: qq,
  Jsercy: Vq,
  jsercy: zq,
  Jukcy: Uq,
  jukcy: Wq,
  Kappa: jq,
  kappa: Gq,
  kappav: Kq,
  Kcedil: Yq,
  kcedil: Jq,
  Kcy: Zq,
  kcy: Xq,
  Kfr: Qq,
  kfr: e9,
  kgreen: t9,
  KHcy: n9,
  khcy: i9,
  KJcy: r9,
  kjcy: s9,
  Kopf: o9,
  kopf: l9,
  Kscr: a9,
  kscr: c9,
  lAarr: h9,
  Lacute: u9,
  lacute: f9,
  laemptyv: d9,
  lagran: p9,
  Lambda: g9,
  lambda: m9,
  lang: b9,
  Lang: y9,
  langd: w9,
  langle: v9,
  lap: x9,
  Laplacetrf: k9,
  laquo: _9,
  larrb: S9,
  larrbfs: C9,
  larr: A9,
  Larr: D9,
  lArr: E9,
  larrfs: T9,
  larrhk: M9,
  larrlp: O9,
  larrpl: L9,
  larrsim: R9,
  larrtl: I9,
  latail: B9,
  lAtail: N9,
  lat: P9,
  late: F9,
  lates: $9,
  lbarr: H9,
  lBarr: q9,
  lbbrk: V9,
  lbrace: z9,
  lbrack: U9,
  lbrke: W9,
  lbrksld: j9,
  lbrkslu: G9,
  Lcaron: K9,
  lcaron: Y9,
  Lcedil: J9,
  lcedil: Z9,
  lceil: X9,
  lcub: Q9,
  Lcy: eV,
  lcy: tV,
  ldca: nV,
  ldquo: iV,
  ldquor: rV,
  ldrdhar: sV,
  ldrushar: oV,
  ldsh: lV,
  le: aV,
  lE: cV,
  LeftAngleBracket: hV,
  LeftArrowBar: uV,
  leftarrow: fV,
  LeftArrow: dV,
  Leftarrow: pV,
  LeftArrowRightArrow: gV,
  leftarrowtail: mV,
  LeftCeiling: bV,
  LeftDoubleBracket: yV,
  LeftDownTeeVector: wV,
  LeftDownVectorBar: vV,
  LeftDownVector: xV,
  LeftFloor: kV,
  leftharpoondown: _V,
  leftharpoonup: SV,
  leftleftarrows: CV,
  leftrightarrow: AV,
  LeftRightArrow: DV,
  Leftrightarrow: EV,
  leftrightarrows: TV,
  leftrightharpoons: MV,
  leftrightsquigarrow: OV,
  LeftRightVector: LV,
  LeftTeeArrow: RV,
  LeftTee: IV,
  LeftTeeVector: BV,
  leftthreetimes: NV,
  LeftTriangleBar: PV,
  LeftTriangle: FV,
  LeftTriangleEqual: $V,
  LeftUpDownVector: HV,
  LeftUpTeeVector: qV,
  LeftUpVectorBar: VV,
  LeftUpVector: zV,
  LeftVectorBar: UV,
  LeftVector: WV,
  lEg: jV,
  leg: GV,
  leq: KV,
  leqq: YV,
  leqslant: JV,
  lescc: ZV,
  les: XV,
  lesdot: QV,
  lesdoto: ez,
  lesdotor: tz,
  lesg: nz,
  lesges: iz,
  lessapprox: rz,
  lessdot: sz,
  lesseqgtr: oz,
  lesseqqgtr: lz,
  LessEqualGreater: az,
  LessFullEqual: cz,
  LessGreater: hz,
  lessgtr: uz,
  LessLess: fz,
  lesssim: dz,
  LessSlantEqual: pz,
  LessTilde: gz,
  lfisht: mz,
  lfloor: bz,
  Lfr: yz,
  lfr: wz,
  lg: vz,
  lgE: xz,
  lHar: kz,
  lhard: _z,
  lharu: Sz,
  lharul: Cz,
  lhblk: Az,
  LJcy: Dz,
  ljcy: Ez,
  llarr: Tz,
  ll: Mz,
  Ll: Oz,
  llcorner: Lz,
  Lleftarrow: Rz,
  llhard: Iz,
  lltri: Bz,
  Lmidot: Nz,
  lmidot: Pz,
  lmoustache: Fz,
  lmoust: $z,
  lnap: Hz,
  lnapprox: qz,
  lne: Vz,
  lnE: zz,
  lneq: Uz,
  lneqq: Wz,
  lnsim: jz,
  loang: Gz,
  loarr: Kz,
  lobrk: Yz,
  longleftarrow: Jz,
  LongLeftArrow: Zz,
  Longleftarrow: Xz,
  longleftrightarrow: Qz,
  LongLeftRightArrow: e7,
  Longleftrightarrow: t7,
  longmapsto: n7,
  longrightarrow: i7,
  LongRightArrow: r7,
  Longrightarrow: s7,
  looparrowleft: o7,
  looparrowright: l7,
  lopar: a7,
  Lopf: c7,
  lopf: h7,
  loplus: u7,
  lotimes: f7,
  lowast: d7,
  lowbar: p7,
  LowerLeftArrow: g7,
  LowerRightArrow: m7,
  loz: b7,
  lozenge: y7,
  lozf: w7,
  lpar: v7,
  lparlt: x7,
  lrarr: k7,
  lrcorner: _7,
  lrhar: S7,
  lrhard: C7,
  lrm: A7,
  lrtri: D7,
  lsaquo: E7,
  lscr: T7,
  Lscr: M7,
  lsh: O7,
  Lsh: L7,
  lsim: R7,
  lsime: I7,
  lsimg: B7,
  lsqb: N7,
  lsquo: P7,
  lsquor: F7,
  Lstrok: $7,
  lstrok: H7,
  ltcc: q7,
  ltcir: V7,
  lt: z7,
  LT: U7,
  Lt: W7,
  ltdot: j7,
  lthree: G7,
  ltimes: K7,
  ltlarr: Y7,
  ltquest: J7,
  ltri: Z7,
  ltrie: X7,
  ltrif: Q7,
  ltrPar: eU,
  lurdshar: tU,
  luruhar: nU,
  lvertneqq: iU,
  lvnE: rU,
  macr: sU,
  male: oU,
  malt: lU,
  maltese: aU,
  Map: "\u2905",
  map: cU,
  mapsto: hU,
  mapstodown: uU,
  mapstoleft: fU,
  mapstoup: dU,
  marker: pU,
  mcomma: gU,
  Mcy: mU,
  mcy: bU,
  mdash: yU,
  mDDot: wU,
  measuredangle: vU,
  MediumSpace: xU,
  Mellintrf: kU,
  Mfr: _U,
  mfr: SU,
  mho: CU,
  micro: AU,
  midast: DU,
  midcir: EU,
  mid: TU,
  middot: MU,
  minusb: OU,
  minus: LU,
  minusd: RU,
  minusdu: IU,
  MinusPlus: BU,
  mlcp: NU,
  mldr: PU,
  mnplus: FU,
  models: $U,
  Mopf: HU,
  mopf: qU,
  mp: VU,
  mscr: zU,
  Mscr: UU,
  mstpos: WU,
  Mu: jU,
  mu: GU,
  multimap: KU,
  mumap: YU,
  nabla: JU,
  Nacute: ZU,
  nacute: XU,
  nang: QU,
  nap: eW,
  napE: tW,
  napid: nW,
  napos: iW,
  napprox: rW,
  natural: sW,
  naturals: oW,
  natur: lW,
  nbsp: aW,
  nbump: cW,
  nbumpe: hW,
  ncap: uW,
  Ncaron: fW,
  ncaron: dW,
  Ncedil: pW,
  ncedil: gW,
  ncong: mW,
  ncongdot: bW,
  ncup: yW,
  Ncy: wW,
  ncy: vW,
  ndash: xW,
  nearhk: kW,
  nearr: _W,
  neArr: SW,
  nearrow: CW,
  ne: AW,
  nedot: DW,
  NegativeMediumSpace: EW,
  NegativeThickSpace: TW,
  NegativeThinSpace: MW,
  NegativeVeryThinSpace: OW,
  nequiv: LW,
  nesear: RW,
  nesim: IW,
  NestedGreaterGreater: BW,
  NestedLessLess: NW,
  NewLine: PW,
  nexist: FW,
  nexists: $W,
  Nfr: HW,
  nfr: qW,
  ngE: VW,
  nge: zW,
  ngeq: UW,
  ngeqq: WW,
  ngeqslant: jW,
  nges: GW,
  nGg: KW,
  ngsim: YW,
  nGt: JW,
  ngt: ZW,
  ngtr: XW,
  nGtv: QW,
  nharr: ej,
  nhArr: tj,
  nhpar: nj,
  ni: ij,
  nis: rj,
  nisd: sj,
  niv: oj,
  NJcy: lj,
  njcy: aj,
  nlarr: cj,
  nlArr: hj,
  nldr: uj,
  nlE: fj,
  nle: dj,
  nleftarrow: pj,
  nLeftarrow: gj,
  nleftrightarrow: mj,
  nLeftrightarrow: bj,
  nleq: yj,
  nleqq: wj,
  nleqslant: vj,
  nles: xj,
  nless: kj,
  nLl: _j,
  nlsim: Sj,
  nLt: Cj,
  nlt: Aj,
  nltri: Dj,
  nltrie: Ej,
  nLtv: Tj,
  nmid: Mj,
  NoBreak: Oj,
  NonBreakingSpace: Lj,
  nopf: Rj,
  Nopf: Ij,
  Not: Bj,
  not: Nj,
  NotCongruent: Pj,
  NotCupCap: Fj,
  NotDoubleVerticalBar: $j,
  NotElement: Hj,
  NotEqual: qj,
  NotEqualTilde: Vj,
  NotExists: zj,
  NotGreater: Uj,
  NotGreaterEqual: Wj,
  NotGreaterFullEqual: jj,
  NotGreaterGreater: Gj,
  NotGreaterLess: Kj,
  NotGreaterSlantEqual: Yj,
  NotGreaterTilde: Jj,
  NotHumpDownHump: Zj,
  NotHumpEqual: Xj,
  notin: Qj,
  notindot: eG,
  notinE: tG,
  notinva: nG,
  notinvb: iG,
  notinvc: rG,
  NotLeftTriangleBar: sG,
  NotLeftTriangle: oG,
  NotLeftTriangleEqual: lG,
  NotLess: aG,
  NotLessEqual: cG,
  NotLessGreater: hG,
  NotLessLess: uG,
  NotLessSlantEqual: fG,
  NotLessTilde: dG,
  NotNestedGreaterGreater: pG,
  NotNestedLessLess: gG,
  notni: mG,
  notniva: bG,
  notnivb: yG,
  notnivc: wG,
  NotPrecedes: vG,
  NotPrecedesEqual: xG,
  NotPrecedesSlantEqual: kG,
  NotReverseElement: _G,
  NotRightTriangleBar: SG,
  NotRightTriangle: CG,
  NotRightTriangleEqual: AG,
  NotSquareSubset: DG,
  NotSquareSubsetEqual: EG,
  NotSquareSuperset: TG,
  NotSquareSupersetEqual: MG,
  NotSubset: OG,
  NotSubsetEqual: LG,
  NotSucceeds: RG,
  NotSucceedsEqual: IG,
  NotSucceedsSlantEqual: BG,
  NotSucceedsTilde: NG,
  NotSuperset: PG,
  NotSupersetEqual: FG,
  NotTilde: $G,
  NotTildeEqual: HG,
  NotTildeFullEqual: qG,
  NotTildeTilde: VG,
  NotVerticalBar: zG,
  nparallel: UG,
  npar: WG,
  nparsl: jG,
  npart: GG,
  npolint: KG,
  npr: YG,
  nprcue: JG,
  nprec: ZG,
  npreceq: XG,
  npre: QG,
  nrarrc: eK,
  nrarr: tK,
  nrArr: nK,
  nrarrw: iK,
  nrightarrow: rK,
  nRightarrow: sK,
  nrtri: oK,
  nrtrie: lK,
  nsc: aK,
  nsccue: cK,
  nsce: hK,
  Nscr: uK,
  nscr: fK,
  nshortmid: dK,
  nshortparallel: pK,
  nsim: gK,
  nsime: mK,
  nsimeq: bK,
  nsmid: yK,
  nspar: wK,
  nsqsube: vK,
  nsqsupe: xK,
  nsub: kK,
  nsubE: _K,
  nsube: SK,
  nsubset: CK,
  nsubseteq: AK,
  nsubseteqq: DK,
  nsucc: EK,
  nsucceq: TK,
  nsup: MK,
  nsupE: OK,
  nsupe: LK,
  nsupset: RK,
  nsupseteq: IK,
  nsupseteqq: BK,
  ntgl: NK,
  Ntilde: PK,
  ntilde: FK,
  ntlg: $K,
  ntriangleleft: HK,
  ntrianglelefteq: qK,
  ntriangleright: VK,
  ntrianglerighteq: zK,
  Nu: UK,
  nu: WK,
  num: jK,
  numero: GK,
  numsp: KK,
  nvap: YK,
  nvdash: JK,
  nvDash: ZK,
  nVdash: XK,
  nVDash: QK,
  nvge: eY,
  nvgt: tY,
  nvHarr: nY,
  nvinfin: iY,
  nvlArr: rY,
  nvle: sY,
  nvlt: oY,
  nvltrie: lY,
  nvrArr: aY,
  nvrtrie: cY,
  nvsim: hY,
  nwarhk: uY,
  nwarr: fY,
  nwArr: dY,
  nwarrow: pY,
  nwnear: gY,
  Oacute: mY,
  oacute: bY,
  oast: yY,
  Ocirc: wY,
  ocirc: vY,
  ocir: xY,
  Ocy: kY,
  ocy: _Y,
  odash: SY,
  Odblac: CY,
  odblac: AY,
  odiv: DY,
  odot: EY,
  odsold: TY,
  OElig: MY,
  oelig: OY,
  ofcir: LY,
  Ofr: RY,
  ofr: IY,
  ogon: BY,
  Ograve: NY,
  ograve: PY,
  ogt: FY,
  ohbar: $Y,
  ohm: HY,
  oint: qY,
  olarr: VY,
  olcir: zY,
  olcross: UY,
  oline: WY,
  olt: jY,
  Omacr: GY,
  omacr: KY,
  Omega: YY,
  omega: JY,
  Omicron: ZY,
  omicron: XY,
  omid: QY,
  ominus: eJ,
  Oopf: tJ,
  oopf: nJ,
  opar: iJ,
  OpenCurlyDoubleQuote: rJ,
  OpenCurlyQuote: sJ,
  operp: oJ,
  oplus: lJ,
  orarr: aJ,
  Or: cJ,
  or: hJ,
  ord: uJ,
  order: fJ,
  orderof: dJ,
  ordf: pJ,
  ordm: gJ,
  origof: mJ,
  oror: bJ,
  orslope: yJ,
  orv: wJ,
  oS: vJ,
  Oscr: xJ,
  oscr: kJ,
  Oslash: _J,
  oslash: SJ,
  osol: CJ,
  Otilde: AJ,
  otilde: DJ,
  otimesas: EJ,
  Otimes: TJ,
  otimes: MJ,
  Ouml: OJ,
  ouml: LJ,
  ovbar: RJ,
  OverBar: IJ,
  OverBrace: BJ,
  OverBracket: NJ,
  OverParenthesis: PJ,
  para: FJ,
  parallel: $J,
  par: HJ,
  parsim: qJ,
  parsl: VJ,
  part: zJ,
  PartialD: UJ,
  Pcy: WJ,
  pcy: jJ,
  percnt: GJ,
  period: KJ,
  permil: YJ,
  perp: JJ,
  pertenk: ZJ,
  Pfr: XJ,
  pfr: QJ,
  Phi: eZ,
  phi: tZ,
  phiv: nZ,
  phmmat: iZ,
  phone: rZ,
  Pi: sZ,
  pi: oZ,
  pitchfork: lZ,
  piv: aZ,
  planck: cZ,
  planckh: hZ,
  plankv: uZ,
  plusacir: fZ,
  plusb: dZ,
  pluscir: pZ,
  plus: gZ,
  plusdo: mZ,
  plusdu: bZ,
  pluse: yZ,
  PlusMinus: wZ,
  plusmn: vZ,
  plussim: xZ,
  plustwo: kZ,
  pm: _Z,
  Poincareplane: SZ,
  pointint: CZ,
  popf: AZ,
  Popf: DZ,
  pound: EZ,
  prap: TZ,
  Pr: MZ,
  pr: OZ,
  prcue: LZ,
  precapprox: RZ,
  prec: IZ,
  preccurlyeq: BZ,
  Precedes: NZ,
  PrecedesEqual: PZ,
  PrecedesSlantEqual: FZ,
  PrecedesTilde: $Z,
  preceq: HZ,
  precnapprox: qZ,
  precneqq: VZ,
  precnsim: zZ,
  pre: UZ,
  prE: WZ,
  precsim: jZ,
  prime: GZ,
  Prime: KZ,
  primes: YZ,
  prnap: JZ,
  prnE: ZZ,
  prnsim: XZ,
  prod: QZ,
  Product: eX,
  profalar: tX,
  profline: nX,
  profsurf: iX,
  prop: rX,
  Proportional: sX,
  Proportion: oX,
  propto: lX,
  prsim: aX,
  prurel: cX,
  Pscr: hX,
  pscr: uX,
  Psi: fX,
  psi: dX,
  puncsp: pX,
  Qfr: gX,
  qfr: mX,
  qint: bX,
  qopf: yX,
  Qopf: wX,
  qprime: vX,
  Qscr: xX,
  qscr: kX,
  quaternions: _X,
  quatint: SX,
  quest: CX,
  questeq: AX,
  quot: DX,
  QUOT: EX,
  rAarr: TX,
  race: MX,
  Racute: OX,
  racute: LX,
  radic: RX,
  raemptyv: IX,
  rang: BX,
  Rang: NX,
  rangd: PX,
  range: FX,
  rangle: $X,
  raquo: HX,
  rarrap: qX,
  rarrb: VX,
  rarrbfs: zX,
  rarrc: UX,
  rarr: WX,
  Rarr: jX,
  rArr: GX,
  rarrfs: KX,
  rarrhk: YX,
  rarrlp: JX,
  rarrpl: ZX,
  rarrsim: XX,
  Rarrtl: QX,
  rarrtl: eQ,
  rarrw: tQ,
  ratail: nQ,
  rAtail: iQ,
  ratio: rQ,
  rationals: sQ,
  rbarr: oQ,
  rBarr: lQ,
  RBarr: aQ,
  rbbrk: cQ,
  rbrace: hQ,
  rbrack: uQ,
  rbrke: fQ,
  rbrksld: dQ,
  rbrkslu: pQ,
  Rcaron: gQ,
  rcaron: mQ,
  Rcedil: bQ,
  rcedil: yQ,
  rceil: wQ,
  rcub: vQ,
  Rcy: xQ,
  rcy: kQ,
  rdca: _Q,
  rdldhar: SQ,
  rdquo: CQ,
  rdquor: AQ,
  rdsh: DQ,
  real: EQ,
  realine: TQ,
  realpart: MQ,
  reals: OQ,
  Re: LQ,
  rect: RQ,
  reg: IQ,
  REG: BQ,
  ReverseElement: NQ,
  ReverseEquilibrium: PQ,
  ReverseUpEquilibrium: FQ,
  rfisht: $Q,
  rfloor: HQ,
  rfr: qQ,
  Rfr: VQ,
  rHar: zQ,
  rhard: UQ,
  rharu: WQ,
  rharul: jQ,
  Rho: GQ,
  rho: KQ,
  rhov: YQ,
  RightAngleBracket: JQ,
  RightArrowBar: ZQ,
  rightarrow: XQ,
  RightArrow: QQ,
  Rightarrow: eee,
  RightArrowLeftArrow: tee,
  rightarrowtail: nee,
  RightCeiling: iee,
  RightDoubleBracket: ree,
  RightDownTeeVector: see,
  RightDownVectorBar: oee,
  RightDownVector: lee,
  RightFloor: aee,
  rightharpoondown: cee,
  rightharpoonup: hee,
  rightleftarrows: uee,
  rightleftharpoons: fee,
  rightrightarrows: dee,
  rightsquigarrow: pee,
  RightTeeArrow: gee,
  RightTee: mee,
  RightTeeVector: bee,
  rightthreetimes: yee,
  RightTriangleBar: wee,
  RightTriangle: vee,
  RightTriangleEqual: xee,
  RightUpDownVector: kee,
  RightUpTeeVector: _ee,
  RightUpVectorBar: See,
  RightUpVector: Cee,
  RightVectorBar: Aee,
  RightVector: Dee,
  ring: Eee,
  risingdotseq: Tee,
  rlarr: Mee,
  rlhar: Oee,
  rlm: Lee,
  rmoustache: Ree,
  rmoust: Iee,
  rnmid: Bee,
  roang: Nee,
  roarr: Pee,
  robrk: Fee,
  ropar: $ee,
  ropf: Hee,
  Ropf: qee,
  roplus: Vee,
  rotimes: zee,
  RoundImplies: Uee,
  rpar: Wee,
  rpargt: jee,
  rppolint: Gee,
  rrarr: Kee,
  Rrightarrow: Yee,
  rsaquo: Jee,
  rscr: Zee,
  Rscr: Xee,
  rsh: Qee,
  Rsh: ete,
  rsqb: tte,
  rsquo: nte,
  rsquor: ite,
  rthree: rte,
  rtimes: ste,
  rtri: ote,
  rtrie: lte,
  rtrif: ate,
  rtriltri: cte,
  RuleDelayed: hte,
  ruluhar: ute,
  rx: fte,
  Sacute: dte,
  sacute: pte,
  sbquo: gte,
  scap: mte,
  Scaron: bte,
  scaron: yte,
  Sc: wte,
  sc: vte,
  sccue: xte,
  sce: kte,
  scE: _te,
  Scedil: Ste,
  scedil: Cte,
  Scirc: Ate,
  scirc: Dte,
  scnap: Ete,
  scnE: Tte,
  scnsim: Mte,
  scpolint: Ote,
  scsim: Lte,
  Scy: Rte,
  scy: Ite,
  sdotb: Bte,
  sdot: Nte,
  sdote: Pte,
  searhk: Fte,
  searr: $te,
  seArr: Hte,
  searrow: qte,
  sect: Vte,
  semi: zte,
  seswar: Ute,
  setminus: Wte,
  setmn: jte,
  sext: Gte,
  Sfr: Kte,
  sfr: Yte,
  sfrown: Jte,
  sharp: Zte,
  SHCHcy: Xte,
  shchcy: Qte,
  SHcy: ene,
  shcy: tne,
  ShortDownArrow: nne,
  ShortLeftArrow: ine,
  shortmid: rne,
  shortparallel: sne,
  ShortRightArrow: one,
  ShortUpArrow: lne,
  shy: ane,
  Sigma: cne,
  sigma: hne,
  sigmaf: une,
  sigmav: fne,
  sim: dne,
  simdot: pne,
  sime: gne,
  simeq: mne,
  simg: bne,
  simgE: yne,
  siml: wne,
  simlE: vne,
  simne: xne,
  simplus: kne,
  simrarr: _ne,
  slarr: Sne,
  SmallCircle: Cne,
  smallsetminus: Ane,
  smashp: Dne,
  smeparsl: Ene,
  smid: Tne,
  smile: Mne,
  smt: One,
  smte: Lne,
  smtes: Rne,
  SOFTcy: Ine,
  softcy: Bne,
  solbar: Nne,
  solb: Pne,
  sol: Fne,
  Sopf: $ne,
  sopf: Hne,
  spades: qne,
  spadesuit: Vne,
  spar: zne,
  sqcap: Une,
  sqcaps: Wne,
  sqcup: jne,
  sqcups: Gne,
  Sqrt: Kne,
  sqsub: Yne,
  sqsube: Jne,
  sqsubset: Zne,
  sqsubseteq: Xne,
  sqsup: Qne,
  sqsupe: eie,
  sqsupset: tie,
  sqsupseteq: nie,
  square: iie,
  Square: rie,
  SquareIntersection: sie,
  SquareSubset: oie,
  SquareSubsetEqual: lie,
  SquareSuperset: aie,
  SquareSupersetEqual: cie,
  SquareUnion: hie,
  squarf: uie,
  squ: fie,
  squf: die,
  srarr: pie,
  Sscr: gie,
  sscr: mie,
  ssetmn: bie,
  ssmile: yie,
  sstarf: wie,
  Star: vie,
  star: xie,
  starf: kie,
  straightepsilon: _ie,
  straightphi: Sie,
  strns: Cie,
  sub: Aie,
  Sub: Die,
  subdot: Eie,
  subE: Tie,
  sube: Mie,
  subedot: Oie,
  submult: Lie,
  subnE: Rie,
  subne: Iie,
  subplus: Bie,
  subrarr: Nie,
  subset: Pie,
  Subset: Fie,
  subseteq: $ie,
  subseteqq: Hie,
  SubsetEqual: qie,
  subsetneq: Vie,
  subsetneqq: zie,
  subsim: Uie,
  subsub: Wie,
  subsup: jie,
  succapprox: Gie,
  succ: Kie,
  succcurlyeq: Yie,
  Succeeds: Jie,
  SucceedsEqual: Zie,
  SucceedsSlantEqual: Xie,
  SucceedsTilde: Qie,
  succeq: ere,
  succnapprox: tre,
  succneqq: nre,
  succnsim: ire,
  succsim: rre,
  SuchThat: sre,
  sum: ore,
  Sum: lre,
  sung: are,
  sup1: cre,
  sup2: hre,
  sup3: ure,
  sup: fre,
  Sup: dre,
  supdot: pre,
  supdsub: gre,
  supE: mre,
  supe: bre,
  supedot: yre,
  Superset: wre,
  SupersetEqual: vre,
  suphsol: xre,
  suphsub: kre,
  suplarr: _re,
  supmult: Sre,
  supnE: Cre,
  supne: Are,
  supplus: Dre,
  supset: Ere,
  Supset: Tre,
  supseteq: Mre,
  supseteqq: Ore,
  supsetneq: Lre,
  supsetneqq: Rre,
  supsim: Ire,
  supsub: Bre,
  supsup: Nre,
  swarhk: Pre,
  swarr: Fre,
  swArr: $re,
  swarrow: Hre,
  swnwar: qre,
  szlig: Vre,
  Tab: zre,
  target: Ure,
  Tau: Wre,
  tau: jre,
  tbrk: Gre,
  Tcaron: Kre,
  tcaron: Yre,
  Tcedil: Jre,
  tcedil: Zre,
  Tcy: Xre,
  tcy: Qre,
  tdot: ese,
  telrec: tse,
  Tfr: nse,
  tfr: ise,
  there4: rse,
  therefore: sse,
  Therefore: ose,
  Theta: lse,
  theta: ase,
  thetasym: cse,
  thetav: hse,
  thickapprox: use,
  thicksim: fse,
  ThickSpace: dse,
  ThinSpace: pse,
  thinsp: gse,
  thkap: mse,
  thksim: bse,
  THORN: yse,
  thorn: wse,
  tilde: vse,
  Tilde: xse,
  TildeEqual: kse,
  TildeFullEqual: _se,
  TildeTilde: Sse,
  timesbar: Cse,
  timesb: Ase,
  times: Dse,
  timesd: Ese,
  tint: Tse,
  toea: Mse,
  topbot: Ose,
  topcir: Lse,
  top: Rse,
  Topf: Ise,
  topf: Bse,
  topfork: Nse,
  tosa: Pse,
  tprime: Fse,
  trade: $se,
  TRADE: Hse,
  triangle: qse,
  triangledown: Vse,
  triangleleft: zse,
  trianglelefteq: Use,
  triangleq: Wse,
  triangleright: jse,
  trianglerighteq: Gse,
  tridot: Kse,
  trie: Yse,
  triminus: Jse,
  TripleDot: Zse,
  triplus: Xse,
  trisb: Qse,
  tritime: eoe,
  trpezium: toe,
  Tscr: noe,
  tscr: ioe,
  TScy: roe,
  tscy: soe,
  TSHcy: ooe,
  tshcy: loe,
  Tstrok: aoe,
  tstrok: coe,
  twixt: hoe,
  twoheadleftarrow: uoe,
  twoheadrightarrow: foe,
  Uacute: doe,
  uacute: poe,
  uarr: goe,
  Uarr: moe,
  uArr: boe,
  Uarrocir: yoe,
  Ubrcy: woe,
  ubrcy: voe,
  Ubreve: xoe,
  ubreve: koe,
  Ucirc: _oe,
  ucirc: Soe,
  Ucy: Coe,
  ucy: Aoe,
  udarr: Doe,
  Udblac: Eoe,
  udblac: Toe,
  udhar: Moe,
  ufisht: Ooe,
  Ufr: Loe,
  ufr: Roe,
  Ugrave: Ioe,
  ugrave: Boe,
  uHar: Noe,
  uharl: Poe,
  uharr: Foe,
  uhblk: $oe,
  ulcorn: Hoe,
  ulcorner: qoe,
  ulcrop: Voe,
  ultri: zoe,
  Umacr: Uoe,
  umacr: Woe,
  uml: joe,
  UnderBar: Goe,
  UnderBrace: Koe,
  UnderBracket: Yoe,
  UnderParenthesis: Joe,
  Union: Zoe,
  UnionPlus: Xoe,
  Uogon: Qoe,
  uogon: ele,
  Uopf: tle,
  uopf: nle,
  UpArrowBar: ile,
  uparrow: rle,
  UpArrow: sle,
  Uparrow: ole,
  UpArrowDownArrow: lle,
  updownarrow: ale,
  UpDownArrow: cle,
  Updownarrow: hle,
  UpEquilibrium: ule,
  upharpoonleft: fle,
  upharpoonright: dle,
  uplus: ple,
  UpperLeftArrow: gle,
  UpperRightArrow: mle,
  upsi: ble,
  Upsi: yle,
  upsih: wle,
  Upsilon: vle,
  upsilon: xle,
  UpTeeArrow: kle,
  UpTee: _le,
  upuparrows: Sle,
  urcorn: Cle,
  urcorner: Ale,
  urcrop: Dle,
  Uring: Ele,
  uring: Tle,
  urtri: Mle,
  Uscr: Ole,
  uscr: Lle,
  utdot: Rle,
  Utilde: Ile,
  utilde: Ble,
  utri: Nle,
  utrif: Ple,
  uuarr: Fle,
  Uuml: $le,
  uuml: Hle,
  uwangle: qle,
  vangrt: Vle,
  varepsilon: zle,
  varkappa: Ule,
  varnothing: Wle,
  varphi: jle,
  varpi: Gle,
  varpropto: Kle,
  varr: Yle,
  vArr: Jle,
  varrho: Zle,
  varsigma: Xle,
  varsubsetneq: Qle,
  varsubsetneqq: eae,
  varsupsetneq: tae,
  varsupsetneqq: nae,
  vartheta: iae,
  vartriangleleft: rae,
  vartriangleright: sae,
  vBar: oae,
  Vbar: lae,
  vBarv: aae,
  Vcy: cae,
  vcy: hae,
  vdash: uae,
  vDash: fae,
  Vdash: dae,
  VDash: pae,
  Vdashl: gae,
  veebar: mae,
  vee: bae,
  Vee: yae,
  veeeq: wae,
  vellip: vae,
  verbar: xae,
  Verbar: kae,
  vert: _ae,
  Vert: Sae,
  VerticalBar: Cae,
  VerticalLine: Aae,
  VerticalSeparator: Dae,
  VerticalTilde: Eae,
  VeryThinSpace: Tae,
  Vfr: Mae,
  vfr: Oae,
  vltri: Lae,
  vnsub: Rae,
  vnsup: Iae,
  Vopf: Bae,
  vopf: Nae,
  vprop: Pae,
  vrtri: Fae,
  Vscr: $ae,
  vscr: Hae,
  vsubnE: qae,
  vsubne: Vae,
  vsupnE: zae,
  vsupne: Uae,
  Vvdash: Wae,
  vzigzag: jae,
  Wcirc: Gae,
  wcirc: Kae,
  wedbar: Yae,
  wedge: Jae,
  Wedge: Zae,
  wedgeq: Xae,
  weierp: Qae,
  Wfr: ece,
  wfr: tce,
  Wopf: nce,
  wopf: ice,
  wp: rce,
  wr: sce,
  wreath: oce,
  Wscr: lce,
  wscr: ace,
  xcap: cce,
  xcirc: hce,
  xcup: uce,
  xdtri: fce,
  Xfr: dce,
  xfr: pce,
  xharr: gce,
  xhArr: mce,
  Xi: bce,
  xi: yce,
  xlarr: wce,
  xlArr: vce,
  xmap: xce,
  xnis: kce,
  xodot: _ce,
  Xopf: Sce,
  xopf: Cce,
  xoplus: Ace,
  xotime: Dce,
  xrarr: Ece,
  xrArr: Tce,
  Xscr: Mce,
  xscr: Oce,
  xsqcup: Lce,
  xuplus: Rce,
  xutri: Ice,
  xvee: Bce,
  xwedge: Nce,
  Yacute: Pce,
  yacute: Fce,
  YAcy: $ce,
  yacy: Hce,
  Ycirc: qce,
  ycirc: Vce,
  Ycy: zce,
  ycy: Uce,
  yen: Wce,
  Yfr: jce,
  yfr: Gce,
  YIcy: Kce,
  yicy: Yce,
  Yopf: Jce,
  yopf: Zce,
  Yscr: Xce,
  yscr: Qce,
  YUcy: ehe,
  yucy: the,
  yuml: nhe,
  Yuml: ihe,
  Zacute: rhe,
  zacute: she,
  Zcaron: ohe,
  zcaron: lhe,
  Zcy: ahe,
  zcy: che,
  Zdot: hhe,
  zdot: uhe,
  zeetrf: fhe,
  ZeroWidthSpace: dhe,
  Zeta: phe,
  zeta: ghe,
  zfr: mhe,
  Zfr: bhe,
  ZHcy: yhe,
  zhcy: whe,
  zigrarr: vhe,
  zopf: xhe,
  Zopf: khe,
  Zscr: _he,
  zscr: She,
  zwj: Che,
  zwnj: Ahe
};
(function(n) {
  n.exports = Dhe;
})(lg);
var ag = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/, Xs = {}, Y0 = {};
function Ehe(n) {
  var e, t, i = Y0[n];
  if (i)
    return i;
  for (i = Y0[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? i.push(t) : i.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    i[n.charCodeAt(e)] = n[e];
  return i;
}
function Ah(n, e, t) {
  var i, r, s, o, l, a = "";
  for (typeof e != "string" && (t = e, e = Ah.defaultChars), typeof t > "u" && (t = !0), l = Ehe(e), i = 0, r = n.length; i < r; i++) {
    if (s = n.charCodeAt(i), t && s === 37 && i + 2 < r && /^[0-9a-f]{2}$/i.test(n.slice(i + 1, i + 3))) {
      a += n.slice(i, i + 3), i += 2;
      continue;
    }
    if (s < 128) {
      a += l[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && i + 1 < r && (o = n.charCodeAt(i + 1), o >= 56320 && o <= 57343)) {
        a += encodeURIComponent(n[i] + n[i + 1]), i++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[i]);
  }
  return a;
}
Ah.defaultChars = ";/?:@&=+$,-_.!~*'()#";
Ah.componentChars = "-_.!~*'()";
var The = Ah, J0 = {};
function Mhe(n) {
  var e, t, i = J0[n];
  if (i)
    return i;
  for (i = J0[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), i.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), i[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return i;
}
function Dh(n, e) {
  var t;
  return typeof e != "string" && (e = Dh.defaultChars), t = Mhe(e), n.replace(/(%[a-f0-9]{2})+/gi, function(i) {
    var r, s, o, l, a, c, h, u = "";
    for (r = 0, s = i.length; r < s; r += 3) {
      if (o = parseInt(i.slice(r + 1, r + 3), 16), o < 128) {
        u += t[o];
        continue;
      }
      if ((o & 224) === 192 && r + 3 < s && (l = parseInt(i.slice(r + 4, r + 6), 16), (l & 192) === 128)) {
        h = o << 6 & 1984 | l & 63, h < 128 ? u += "\uFFFD\uFFFD" : u += String.fromCharCode(h), r += 3;
        continue;
      }
      if ((o & 240) === 224 && r + 6 < s && (l = parseInt(i.slice(r + 4, r + 6), 16), a = parseInt(i.slice(r + 7, r + 9), 16), (l & 192) === 128 && (a & 192) === 128)) {
        h = o << 12 & 61440 | l << 6 & 4032 | a & 63, h < 2048 || h >= 55296 && h <= 57343 ? u += "\uFFFD\uFFFD\uFFFD" : u += String.fromCharCode(h), r += 6;
        continue;
      }
      if ((o & 248) === 240 && r + 9 < s && (l = parseInt(i.slice(r + 4, r + 6), 16), a = parseInt(i.slice(r + 7, r + 9), 16), c = parseInt(i.slice(r + 10, r + 12), 16), (l & 192) === 128 && (a & 192) === 128 && (c & 192) === 128)) {
        h = o << 18 & 1835008 | l << 12 & 258048 | a << 6 & 4032 | c & 63, h < 65536 || h > 1114111 ? u += "\uFFFD\uFFFD\uFFFD\uFFFD" : (h -= 65536, u += String.fromCharCode(55296 + (h >> 10), 56320 + (h & 1023))), r += 9;
        continue;
      }
      u += "\uFFFD";
    }
    return u;
  });
}
Dh.defaultChars = ";/?:@&=+$,#";
Dh.componentChars = "";
var Ohe = Dh, Lhe = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function Dc() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var Rhe = /^([a-z0-9.+-]+:)/i, Ihe = /:[0-9]*$/, Bhe = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, Nhe = ["<", ">", '"', "`", " ", "\r", `
`, "	"], Phe = ["{", "}", "|", "\\", "^", "`"].concat(Nhe), Fhe = ["'"].concat(Phe), Z0 = ["%", "/", "?", ";", "#"].concat(Fhe), X0 = ["/", "?", "#"], $he = 255, Q0 = /^[+a-z0-9A-Z_-]{0,63}$/, Hhe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, e1 = {
  javascript: !0,
  "javascript:": !0
}, t1 = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
};
function qhe(n, e) {
  if (n && n instanceof Dc)
    return n;
  var t = new Dc();
  return t.parse(n, e), t;
}
Dc.prototype.parse = function(n, e) {
  var t, i, r, s, o, l = n;
  if (l = l.trim(), !e && n.split("#").length === 1) {
    var a = Bhe.exec(l);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var c = Rhe.exec(l);
  if (c && (c = c[0], r = c.toLowerCase(), this.protocol = c, l = l.substr(c.length)), (e || c || l.match(/^\/\/[^@\/]+@[^@\/]+/)) && (o = l.substr(0, 2) === "//", o && !(c && e1[c]) && (l = l.substr(2), this.slashes = !0)), !e1[c] && (o || c && !t1[c])) {
    var h = -1;
    for (t = 0; t < X0.length; t++)
      s = l.indexOf(X0[t]), s !== -1 && (h === -1 || s < h) && (h = s);
    var u, f;
    for (h === -1 ? f = l.lastIndexOf("@") : f = l.lastIndexOf("@", h), f !== -1 && (u = l.slice(0, f), l = l.slice(f + 1), this.auth = u), h = -1, t = 0; t < Z0.length; t++)
      s = l.indexOf(Z0[t]), s !== -1 && (h === -1 || s < h) && (h = s);
    h === -1 && (h = l.length), l[h - 1] === ":" && h--;
    var d = l.slice(0, h);
    l = l.slice(h), this.parseHost(d), this.hostname = this.hostname || "";
    var p = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!p) {
      var g = this.hostname.split(/\./);
      for (t = 0, i = g.length; t < i; t++) {
        var m = g[t];
        if (!!m && !m.match(Q0)) {
          for (var b = "", y = 0, k = m.length; y < k; y++)
            m.charCodeAt(y) > 127 ? b += "x" : b += m[y];
          if (!b.match(Q0)) {
            var w = g.slice(0, t), x = g.slice(t + 1), v = m.match(Hhe);
            v && (w.push(v[1]), x.unshift(v[2])), x.length && (l = x.join(".") + l), this.hostname = w.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > $he && (this.hostname = ""), p && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var C = l.indexOf("#");
  C !== -1 && (this.hash = l.substr(C), l = l.slice(0, C));
  var B = l.indexOf("?");
  return B !== -1 && (this.search = l.substr(B), l = l.slice(0, B)), l && (this.pathname = l), t1[r] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
Dc.prototype.parseHost = function(n) {
  var e = Ihe.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var Vhe = qhe;
Xs.encode = The;
Xs.decode = Ohe;
Xs.format = Lhe;
Xs.parse = Vhe;
var rr = {}, Ru, n1;
function Ox() {
  return n1 || (n1 = 1, Ru = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Ru;
}
var Iu, i1;
function Lx() {
  return i1 || (i1 = 1, Iu = /[\0-\x1F\x7F-\x9F]/), Iu;
}
var Bu, r1;
function zhe() {
  return r1 || (r1 = 1, Bu = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Bu;
}
var Nu, s1;
function Rx() {
  return s1 || (s1 = 1, Nu = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Nu;
}
var o1;
function Uhe() {
  return o1 || (o1 = 1, rr.Any = Ox(), rr.Cc = Lx(), rr.Cf = zhe(), rr.P = ag, rr.Z = Rx()), rr;
}
(function(n) {
  function e(A) {
    return Object.prototype.toString.call(A);
  }
  function t(A) {
    return e(A) === "[object String]";
  }
  var i = Object.prototype.hasOwnProperty;
  function r(A, j) {
    return i.call(A, j);
  }
  function s(A) {
    var j = Array.prototype.slice.call(arguments, 1);
    return j.forEach(function(q) {
      if (!!q) {
        if (typeof q != "object")
          throw new TypeError(q + "must be object");
        Object.keys(q).forEach(function(we) {
          A[we] = q[we];
        });
      }
    }), A;
  }
  function o(A, j, q) {
    return [].concat(A.slice(0, j), q, A.slice(j + 1));
  }
  function l(A) {
    return !(A >= 55296 && A <= 57343 || A >= 64976 && A <= 65007 || (A & 65535) === 65535 || (A & 65535) === 65534 || A >= 0 && A <= 8 || A === 11 || A >= 14 && A <= 31 || A >= 127 && A <= 159 || A > 1114111);
  }
  function a(A) {
    if (A > 65535) {
      A -= 65536;
      var j = 55296 + (A >> 10), q = 56320 + (A & 1023);
      return String.fromCharCode(j, q);
    }
    return String.fromCharCode(A);
  }
  var c = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, h = /&([a-z#][a-z0-9]{1,31});/gi, u = new RegExp(c.source + "|" + h.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i, d = lg.exports;
  function p(A, j) {
    var q = 0;
    return r(d, j) ? d[j] : j.charCodeAt(0) === 35 && f.test(j) && (q = j[1].toLowerCase() === "x" ? parseInt(j.slice(2), 16) : parseInt(j.slice(1), 10), l(q)) ? a(q) : A;
  }
  function g(A) {
    return A.indexOf("\\") < 0 ? A : A.replace(c, "$1");
  }
  function m(A) {
    return A.indexOf("\\") < 0 && A.indexOf("&") < 0 ? A : A.replace(u, function(j, q, we) {
      return q || p(j, we);
    });
  }
  var b = /[&<>"]/, y = /[&<>"]/g, k = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function w(A) {
    return k[A];
  }
  function x(A) {
    return b.test(A) ? A.replace(y, w) : A;
  }
  var v = /[.?*+^$[\]\\(){}|-]/g;
  function C(A) {
    return A.replace(v, "\\$&");
  }
  function B(A) {
    switch (A) {
      case 9:
      case 32:
        return !0;
    }
    return !1;
  }
  function R(A) {
    if (A >= 8192 && A <= 8202)
      return !0;
    switch (A) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return !0;
    }
    return !1;
  }
  var T = ag;
  function z(A) {
    return T.test(A);
  }
  function se(A) {
    switch (A) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return !0;
      default:
        return !1;
    }
  }
  function ee(A) {
    return A = A.trim().replace(/\s+/g, " "), "\u1E9E".toLowerCase() === "\u1E7E" && (A = A.replace(//g, "\xDF")), A.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Xs, n.lib.ucmicro = Uhe(), n.assign = s, n.isString = t, n.has = r, n.unescapeMd = g, n.unescapeAll = m, n.isValidEntityCode = l, n.fromCodePoint = a, n.escapeHtml = x, n.arrayReplaceAt = o, n.isSpace = B, n.isWhiteSpace = R, n.isMdAsciiPunct = se, n.isPunctChar = z, n.escapeRE = C, n.normalizeReference = ee;
})(re);
var Eh = {}, Whe = function(e, t, i) {
  var r, s, o, l, a = -1, c = e.posMax, h = e.pos;
  for (e.pos = t + 1, r = 1; e.pos < c; ) {
    if (o = e.src.charCodeAt(e.pos), o === 93 && (r--, r === 0)) {
      s = !0;
      break;
    }
    if (l = e.pos, e.md.inline.skipToken(e), o === 91) {
      if (l === e.pos - 1)
        r++;
      else if (i)
        return e.pos = h, -1;
    }
  }
  return s && (a = e.pos), e.pos = h, a;
}, l1 = re.unescapeAll, jhe = function(e, t, i) {
  var r, s, o = 0, l = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(t) === 60) {
    for (t++; t < i; ) {
      if (r = e.charCodeAt(t), r === 10 || r === 60)
        return a;
      if (r === 62)
        return a.pos = t + 1, a.str = l1(e.slice(l + 1, t)), a.ok = !0, a;
      if (r === 92 && t + 1 < i) {
        t += 2;
        continue;
      }
      t++;
    }
    return a;
  }
  for (s = 0; t < i && (r = e.charCodeAt(t), !(r === 32 || r < 32 || r === 127)); ) {
    if (r === 92 && t + 1 < i) {
      if (e.charCodeAt(t + 1) === 32)
        break;
      t += 2;
      continue;
    }
    if (r === 40 && (s++, s > 32))
      return a;
    if (r === 41) {
      if (s === 0)
        break;
      s--;
    }
    t++;
  }
  return l === t || s !== 0 || (a.str = l1(e.slice(l, t)), a.lines = o, a.pos = t, a.ok = !0), a;
}, Ghe = re.unescapeAll, Khe = function(e, t, i) {
  var r, s, o = 0, l = t, a = {
    ok: !1,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (t >= i || (s = e.charCodeAt(t), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (t++, s === 40 && (s = 41); t < i; ) {
    if (r = e.charCodeAt(t), r === s)
      return a.pos = t + 1, a.lines = o, a.str = Ghe(e.slice(l + 1, t)), a.ok = !0, a;
    if (r === 40 && s === 41)
      return a;
    r === 10 ? o++ : r === 92 && t + 1 < i && (t++, e.charCodeAt(t) === 10 && o++), t++;
  }
  return a;
};
Eh.parseLinkLabel = Whe;
Eh.parseLinkDestination = jhe;
Eh.parseLinkTitle = Khe;
var Yhe = re.assign, Jhe = re.unescapeAll, Tr = re.escapeHtml, Wn = {};
Wn.code_inline = function(n, e, t, i, r) {
  var s = n[e];
  return "<code" + r.renderAttrs(s) + ">" + Tr(n[e].content) + "</code>";
};
Wn.code_block = function(n, e, t, i, r) {
  var s = n[e];
  return "<pre" + r.renderAttrs(s) + "><code>" + Tr(n[e].content) + `</code></pre>
`;
};
Wn.fence = function(n, e, t, i, r) {
  var s = n[e], o = s.info ? Jhe(s.info).trim() : "", l = "", a = "", c, h, u, f, d;
  return o && (u = o.split(/(\s+)/g), l = u[0], a = u.slice(2).join("")), t.highlight ? c = t.highlight(s.content, l, a) || Tr(s.content) : c = Tr(s.content), c.indexOf("<pre") === 0 ? c + `
` : o ? (h = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], h < 0 ? f.push(["class", t.langPrefix + l]) : (f[h] = f[h].slice(), f[h][1] += " " + t.langPrefix + l), d = {
    attrs: f
  }, "<pre><code" + r.renderAttrs(d) + ">" + c + `</code></pre>
`) : "<pre><code" + r.renderAttrs(s) + ">" + c + `</code></pre>
`;
};
Wn.image = function(n, e, t, i, r) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = r.renderInlineAsText(s.children, t, i), r.renderToken(n, e, t);
};
Wn.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
Wn.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
Wn.text = function(n, e) {
  return Tr(n[e].content);
};
Wn.html_block = function(n, e) {
  return n[e].content;
};
Wn.html_inline = function(n, e) {
  return n[e].content;
};
function Qs() {
  this.rules = Yhe({}, Wn);
}
Qs.prototype.renderAttrs = function(e) {
  var t, i, r;
  if (!e.attrs)
    return "";
  for (r = "", t = 0, i = e.attrs.length; t < i; t++)
    r += " " + Tr(e.attrs[t][0]) + '="' + Tr(e.attrs[t][1]) + '"';
  return r;
};
Qs.prototype.renderToken = function(e, t, i) {
  var r, s = "", o = !1, l = e[t];
  return l.hidden ? "" : (l.block && l.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (l.nesting === -1 ? "</" : "<") + l.tag, s += this.renderAttrs(l), l.nesting === 0 && i.xhtmlOut && (s += " /"), l.block && (o = !0, l.nesting === 1 && t + 1 < e.length && (r = e[t + 1], (r.type === "inline" || r.hidden || r.nesting === -1 && r.tag === l.tag) && (o = !1))), s += o ? `>
` : ">", s);
};
Qs.prototype.renderInline = function(n, e, t) {
  for (var i, r = "", s = this.rules, o = 0, l = n.length; o < l; o++)
    i = n[o].type, typeof s[i] < "u" ? r += s[i](n, o, e, t, this) : r += this.renderToken(n, o, e);
  return r;
};
Qs.prototype.renderInlineAsText = function(n, e, t) {
  for (var i = "", r = 0, s = n.length; r < s; r++)
    n[r].type === "text" ? i += n[r].content : n[r].type === "image" ? i += this.renderInlineAsText(n[r].children, e, t) : n[r].type === "softbreak" && (i += `
`);
  return i;
};
Qs.prototype.render = function(n, e, t) {
  var i, r, s, o = "", l = this.rules;
  for (i = 0, r = n.length; i < r; i++)
    s = n[i].type, s === "inline" ? o += this.renderInline(n[i].children, e, t) : typeof l[s] < "u" ? o += l[n[i].type](n, i, e, t, this) : o += this.renderToken(n, i, e, t);
  return o;
};
var Zhe = Qs;
function wn() {
  this.__rules__ = [], this.__cache__ = null;
}
wn.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
wn.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    !t.enabled || t.alt.forEach(function(i) {
      e.indexOf(i) < 0 && e.push(i);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(i) {
      !i.enabled || t && i.alt.indexOf(t) < 0 || n.__cache__[t].push(i.fn);
    });
  });
};
wn.prototype.at = function(n, e, t) {
  var i = this.__find__(n), r = t || {};
  if (i === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[i].fn = e, this.__rules__[i].alt = r.alt || [], this.__cache__ = null;
};
wn.prototype.before = function(n, e, t, i) {
  var r = this.__find__(n), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
wn.prototype.after = function(n, e, t, i) {
  var r = this.__find__(n), s = i || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(r + 1, 0, {
    name: e,
    enabled: !0,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
wn.prototype.push = function(n, e, t) {
  var i = t || {};
  this.__rules__.push({
    name: n,
    enabled: !0,
    fn: e,
    alt: i.alt || []
  }), this.__cache__ = null;
};
wn.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(i) {
    var r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !0, t.push(i);
  }, this), this.__cache__ = null, t;
};
wn.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = !1;
  }), this.enable(n, e);
};
wn.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(i) {
    var r = this.__find__(i);
    if (r < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + i);
    }
    this.__rules__[r].enabled = !1, t.push(i);
  }, this), this.__cache__ = null, t;
};
wn.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var cg = wn, Xhe = /\r\n?|\n/g, Qhe = /\0/g, eue = function(e) {
  var t;
  t = e.src.replace(Xhe, `
`), t = t.replace(Qhe, "\uFFFD"), e.src = t;
}, tue = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
}, nue = function(e) {
  var t = e.tokens, i, r, s;
  for (r = 0, s = t.length; r < s; r++)
    i = t[r], i.type === "inline" && e.md.inline.parse(i.content, e.md, e.env, i.children);
}, iue = re.arrayReplaceAt;
function rue(n) {
  return /^<a[>\s]/i.test(n);
}
function sue(n) {
  return /^<\/a\s*>/i.test(n);
}
var oue = function(e) {
  var t, i, r, s, o, l, a, c, h, u, f, d, p, g, m, b, y = e.tokens, k;
  if (!!e.md.options.linkify) {
    for (i = 0, r = y.length; i < r; i++)
      if (!(y[i].type !== "inline" || !e.md.linkify.pretest(y[i].content)))
        for (s = y[i].children, p = 0, t = s.length - 1; t >= 0; t--) {
          if (l = s[t], l.type === "link_close") {
            for (t--; s[t].level !== l.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (l.type === "html_inline" && (rue(l.content) && p > 0 && p--, sue(l.content) && p++), !(p > 0) && l.type === "text" && e.md.linkify.test(l.content)) {
            for (h = l.content, k = e.md.linkify.match(h), a = [], d = l.level, f = 0, c = 0; c < k.length; c++)
              g = k[c].url, m = e.md.normalizeLink(g), e.md.validateLink(m) && (b = k[c].text, k[c].schema ? k[c].schema === "mailto:" && !/^mailto:/i.test(b) ? b = e.md.normalizeLinkText("mailto:" + b).replace(/^mailto:/, "") : b = e.md.normalizeLinkText(b) : b = e.md.normalizeLinkText("http://" + b).replace(/^http:\/\//, ""), u = k[c].index, u > f && (o = new e.Token("text", "", 0), o.content = h.slice(f, u), o.level = d, a.push(o)), o = new e.Token("link_open", "a", 1), o.attrs = [["href", m]], o.level = d++, o.markup = "linkify", o.info = "auto", a.push(o), o = new e.Token("text", "", 0), o.content = b, o.level = d, a.push(o), o = new e.Token("link_close", "a", -1), o.level = --d, o.markup = "linkify", o.info = "auto", a.push(o), f = k[c].lastIndex);
            f < h.length && (o = new e.Token("text", "", 0), o.content = h.slice(f), o.level = d, a.push(o)), y[i].children = s = iue(s, t, a);
          }
        }
  }
}, Ix = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/, lue = /\((c|tm|r|p)\)/i, aue = /\((c|tm|r|p)\)/ig, cue = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function hue(n, e) {
  return cue[e.toLowerCase()];
}
function uue(n) {
  var e, t, i = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !i && (t.content = t.content.replace(aue, hue)), t.type === "link_open" && t.info === "auto" && i--, t.type === "link_close" && t.info === "auto" && i++;
}
function fue(n) {
  var e, t, i = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !i && Ix.test(t.content) && (t.content = t.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013")), t.type === "link_open" && t.info === "auto" && i--, t.type === "link_close" && t.info === "auto" && i++;
}
var due = function(e) {
  var t;
  if (!!e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (lue.test(e.tokens[t].content) && uue(e.tokens[t].children), Ix.test(e.tokens[t].content) && fue(e.tokens[t].children));
}, a1 = re.isWhiteSpace, c1 = re.isPunctChar, h1 = re.isMdAsciiPunct, pue = /['"]/, u1 = /['"]/g, f1 = "\u2019";
function na(n, e, t) {
  return n.substr(0, e) + t + n.substr(e + 1);
}
function gue(n, e) {
  var t, i, r, s, o, l, a, c, h, u, f, d, p, g, m, b, y, k, w, x, v;
  for (w = [], t = 0; t < n.length; t++) {
    for (i = n[t], a = n[t].level, y = w.length - 1; y >= 0 && !(w[y].level <= a); y--)
      ;
    if (w.length = y + 1, i.type !== "text")
      continue;
    r = i.content, o = 0, l = r.length;
    e:
      for (; o < l && (u1.lastIndex = o, s = u1.exec(r), !!s); ) {
        if (m = b = !0, o = s.index + 1, k = s[0] === "'", h = 32, s.index - 1 >= 0)
          h = r.charCodeAt(s.index - 1);
        else
          for (y = t - 1; y >= 0 && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y--)
            if (!!n[y].content) {
              h = n[y].content.charCodeAt(n[y].content.length - 1);
              break;
            }
        if (u = 32, o < l)
          u = r.charCodeAt(o);
        else
          for (y = t + 1; y < n.length && !(n[y].type === "softbreak" || n[y].type === "hardbreak"); y++)
            if (!!n[y].content) {
              u = n[y].content.charCodeAt(0);
              break;
            }
        if (f = h1(h) || c1(String.fromCharCode(h)), d = h1(u) || c1(String.fromCharCode(u)), p = a1(h), g = a1(u), g ? m = !1 : d && (p || f || (m = !1)), p ? b = !1 : f && (g || d || (b = !1)), u === 34 && s[0] === '"' && h >= 48 && h <= 57 && (b = m = !1), m && b && (m = f, b = d), !m && !b) {
          k && (i.content = na(i.content, s.index, f1));
          continue;
        }
        if (b) {
          for (y = w.length - 1; y >= 0 && (c = w[y], !(w[y].level < a)); y--)
            if (c.single === k && w[y].level === a) {
              c = w[y], k ? (x = e.md.options.quotes[2], v = e.md.options.quotes[3]) : (x = e.md.options.quotes[0], v = e.md.options.quotes[1]), i.content = na(i.content, s.index, v), n[c.token].content = na(
                n[c.token].content,
                c.pos,
                x
              ), o += v.length - 1, c.token === t && (o += x.length - 1), r = i.content, l = r.length, w.length = y;
              continue e;
            }
        }
        m ? w.push({
          token: t,
          pos: s.index,
          single: k,
          level: a
        }) : b && k && (i.content = na(i.content, s.index, f1));
      }
  }
}
var mue = function(e) {
  var t;
  if (!!e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !pue.test(e.tokens[t].content) || gue(e.tokens[t].children, e);
};
function eo(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = !1, this.hidden = !1;
}
eo.prototype.attrIndex = function(e) {
  var t, i, r;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, i = 0, r = t.length; i < r; i++)
    if (t[i][0] === e)
      return i;
  return -1;
};
eo.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
eo.prototype.attrSet = function(e, t) {
  var i = this.attrIndex(e), r = [e, t];
  i < 0 ? this.attrPush(r) : this.attrs[i] = r;
};
eo.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), i = null;
  return t >= 0 && (i = this.attrs[t][1]), i;
};
eo.prototype.attrJoin = function(e, t) {
  var i = this.attrIndex(e);
  i < 0 ? this.attrPush([e, t]) : this.attrs[i][1] = this.attrs[i][1] + " " + t;
};
var hg = eo, bue = hg;
function Bx(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = !1, this.md = e;
}
Bx.prototype.Token = bue;
var yue = Bx, wue = cg, Pu = [
  ["normalize", eue],
  ["block", tue],
  ["inline", nue],
  ["linkify", oue],
  ["replacements", due],
  ["smartquotes", mue]
];
function ug() {
  this.ruler = new wue();
  for (var n = 0; n < Pu.length; n++)
    this.ruler.push(Pu[n][0], Pu[n][1]);
}
ug.prototype.process = function(n) {
  var e, t, i;
  for (i = this.ruler.getRules(""), e = 0, t = i.length; e < t; e++)
    i[e](n);
};
ug.prototype.State = yue;
var vue = ug, Fu = re.isSpace;
function $u(n, e) {
  var t = n.bMarks[e] + n.tShift[e], i = n.eMarks[e];
  return n.src.substr(t, i - t);
}
function d1(n) {
  var e = [], t = 0, i = n.length, r, s = !1, o = 0, l = "";
  for (r = n.charCodeAt(t); t < i; )
    r === 124 && (s ? (l += n.substring(o, t - 1), o = t) : (e.push(l + n.substring(o, t)), l = "", o = t + 1)), s = r === 92, t++, r = n.charCodeAt(t);
  return e.push(l + n.substring(o)), e;
}
var xue = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f, d, p, g, m, b, y, k, w, x, v;
  if (t + 2 > i || (h = t + 1, e.sCount[h] < e.blkIndent) || e.sCount[h] - e.blkIndent >= 4 || (l = e.bMarks[h] + e.tShift[h], l >= e.eMarks[h]) || (x = e.src.charCodeAt(l++), x !== 124 && x !== 45 && x !== 58) || l >= e.eMarks[h] || (v = e.src.charCodeAt(l++), v !== 124 && v !== 45 && v !== 58 && !Fu(v)) || x === 45 && Fu(v))
    return !1;
  for (; l < e.eMarks[h]; ) {
    if (s = e.src.charCodeAt(l), s !== 124 && s !== 45 && s !== 58 && !Fu(s))
      return !1;
    l++;
  }
  for (o = $u(e, t + 1), u = o.split("|"), p = [], a = 0; a < u.length; a++) {
    if (g = u[a].trim(), !g) {
      if (a === 0 || a === u.length - 1)
        continue;
      return !1;
    }
    if (!/^:?-+:?$/.test(g))
      return !1;
    g.charCodeAt(g.length - 1) === 58 ? p.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? p.push("left") : p.push("");
  }
  if (o = $u(e, t).trim(), o.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (u = d1(o), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), f = u.length, f === 0 || f !== p.length))
    return !1;
  if (r)
    return !0;
  for (y = e.parentType, e.parentType = "table", w = e.md.block.ruler.getRules("blockquote"), d = e.push("table_open", "table", 1), d.map = m = [t, 0], d = e.push("thead_open", "thead", 1), d.map = [t, t + 1], d = e.push("tr_open", "tr", 1), d.map = [t, t + 1], a = 0; a < u.length; a++)
    d = e.push("th_open", "th", 1), p[a] && (d.attrs = [["style", "text-align:" + p[a]]]), d = e.push("inline", "", 0), d.content = u[a].trim(), d.children = [], d = e.push("th_close", "th", -1);
  for (d = e.push("tr_close", "tr", -1), d = e.push("thead_close", "thead", -1), h = t + 2; h < i && !(e.sCount[h] < e.blkIndent); h++) {
    for (k = !1, a = 0, c = w.length; a < c; a++)
      if (w[a](e, h, i, !0)) {
        k = !0;
        break;
      }
    if (k || (o = $u(e, h).trim(), !o) || e.sCount[h] - e.blkIndent >= 4)
      break;
    for (u = d1(o), u.length && u[0] === "" && u.shift(), u.length && u[u.length - 1] === "" && u.pop(), h === t + 2 && (d = e.push("tbody_open", "tbody", 1), d.map = b = [t + 2, 0]), d = e.push("tr_open", "tr", 1), d.map = [h, h + 1], a = 0; a < f; a++)
      d = e.push("td_open", "td", 1), p[a] && (d.attrs = [["style", "text-align:" + p[a]]]), d = e.push("inline", "", 0), d.content = u[a] ? u[a].trim() : "", d.children = [], d = e.push("td_close", "td", -1);
    d = e.push("tr_close", "tr", -1);
  }
  return b && (d = e.push("tbody_close", "tbody", -1), b[1] = h), d = e.push("table_close", "table", -1), m[1] = h, e.parentType = y, e.line = h, !0;
}, kue = function(e, t, i) {
  var r, s, o;
  if (e.sCount[t] - e.blkIndent < 4)
    return !1;
  for (s = r = t + 1; r < i; ) {
    if (e.isEmpty(r)) {
      r++;
      continue;
    }
    if (e.sCount[r] - e.blkIndent >= 4) {
      r++, s = r;
      continue;
    }
    break;
  }
  return e.line = s, o = e.push("code_block", "code", 0), o.content = e.getLines(t, s, 4 + e.blkIndent, !1) + `
`, o.map = [t, e.line], !0;
}, _ue = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f = !1, d = e.bMarks[t] + e.tShift[t], p = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || d + 3 > p || (s = e.src.charCodeAt(d), s !== 126 && s !== 96) || (c = d, d = e.skipChars(d, s), o = d - c, o < 3) || (u = e.src.slice(c, d), l = e.src.slice(d, p), s === 96 && l.indexOf(String.fromCharCode(s)) >= 0))
    return !1;
  if (r)
    return !0;
  for (a = t; a++, !(a >= i || (d = c = e.bMarks[a] + e.tShift[a], p = e.eMarks[a], d < p && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(d) === s && !(e.sCount[a] - e.blkIndent >= 4) && (d = e.skipChars(d, s), !(d - c < o) && (d = e.skipSpaces(d), !(d < p)))) {
      f = !0;
      break;
    }
  return o = e.sCount[t], e.line = a + (f ? 1 : 0), h = e.push("fence", "code", 0), h.info = l, h.content = e.getLines(t + 1, a, o, !0), h.markup = u, h.map = [t, e.line], !0;
}, p1 = re.isSpace, Sue = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f, d, p, g, m, b, y, k, w, x, v, C, B, R = e.lineMax, T = e.bMarks[t] + e.tShift[t], z = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(T++) !== 62)
    return !1;
  if (r)
    return !0;
  for (a = d = e.sCount[t] + 1, e.src.charCodeAt(T) === 32 ? (T++, a++, d++, s = !1, w = !0) : e.src.charCodeAt(T) === 9 ? (w = !0, (e.bsCount[t] + d) % 4 === 3 ? (T++, a++, d++, s = !1) : s = !0) : w = !1, p = [e.bMarks[t]], e.bMarks[t] = T; T < z && (o = e.src.charCodeAt(T), p1(o)); ) {
    o === 9 ? d += 4 - (d + e.bsCount[t] + (s ? 1 : 0)) % 4 : d++;
    T++;
  }
  for (g = [e.bsCount[t]], e.bsCount[t] = e.sCount[t] + 1 + (w ? 1 : 0), h = T >= z, y = [e.sCount[t]], e.sCount[t] = d - a, k = [e.tShift[t]], e.tShift[t] = T - e.bMarks[t], v = e.md.block.ruler.getRules("blockquote"), b = e.parentType, e.parentType = "blockquote", f = t + 1; f < i && (B = e.sCount[f] < e.blkIndent, T = e.bMarks[f] + e.tShift[f], z = e.eMarks[f], !(T >= z)); f++) {
    if (e.src.charCodeAt(T++) === 62 && !B) {
      for (a = d = e.sCount[f] + 1, e.src.charCodeAt(T) === 32 ? (T++, a++, d++, s = !1, w = !0) : e.src.charCodeAt(T) === 9 ? (w = !0, (e.bsCount[f] + d) % 4 === 3 ? (T++, a++, d++, s = !1) : s = !0) : w = !1, p.push(e.bMarks[f]), e.bMarks[f] = T; T < z && (o = e.src.charCodeAt(T), p1(o)); ) {
        o === 9 ? d += 4 - (d + e.bsCount[f] + (s ? 1 : 0)) % 4 : d++;
        T++;
      }
      h = T >= z, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (w ? 1 : 0), y.push(e.sCount[f]), e.sCount[f] = d - a, k.push(e.tShift[f]), e.tShift[f] = T - e.bMarks[f];
      continue;
    }
    if (h)
      break;
    for (x = !1, l = 0, c = v.length; l < c; l++)
      if (v[l](e, f, i, !0)) {
        x = !0;
        break;
      }
    if (x) {
      e.lineMax = f, e.blkIndent !== 0 && (p.push(e.bMarks[f]), g.push(e.bsCount[f]), k.push(e.tShift[f]), y.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    p.push(e.bMarks[f]), g.push(e.bsCount[f]), k.push(e.tShift[f]), y.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (m = e.blkIndent, e.blkIndent = 0, C = e.push("blockquote_open", "blockquote", 1), C.markup = ">", C.map = u = [t, 0], e.md.block.tokenize(e, t, f), C = e.push("blockquote_close", "blockquote", -1), C.markup = ">", e.lineMax = R, e.parentType = b, u[1] = e.line, l = 0; l < k.length; l++)
    e.bMarks[l + t] = p[l], e.tShift[l + t] = k[l], e.sCount[l + t] = y[l], e.bsCount[l + t] = g[l];
  return e.blkIndent = m, !0;
}, Cue = re.isSpace, Aue = function(e, t, i, r) {
  var s, o, l, a, c = e.bMarks[t] + e.tShift[t], h = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c++), s !== 42 && s !== 45 && s !== 95))
    return !1;
  for (o = 1; c < h; ) {
    if (l = e.src.charCodeAt(c++), l !== s && !Cue(l))
      return !1;
    l === s && o++;
  }
  return o < 3 ? !1 : (r || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(o + 1).join(String.fromCharCode(s))), !0);
}, Nx = re.isSpace;
function g1(n, e) {
  var t, i, r, s;
  return i = n.bMarks[e] + n.tShift[e], r = n.eMarks[e], t = n.src.charCodeAt(i++), t !== 42 && t !== 45 && t !== 43 || i < r && (s = n.src.charCodeAt(i), !Nx(s)) ? -1 : i;
}
function m1(n, e) {
  var t, i = n.bMarks[e] + n.tShift[e], r = i, s = n.eMarks[e];
  if (r + 1 >= s || (t = n.src.charCodeAt(r++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (r >= s)
      return -1;
    if (t = n.src.charCodeAt(r++), t >= 48 && t <= 57) {
      if (r - i >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return r < s && (t = n.src.charCodeAt(r), !Nx(t)) ? -1 : r;
}
function Due(n, e) {
  var t, i, r = n.level + 2;
  for (t = e + 2, i = n.tokens.length - 2; t < i; t++)
    n.tokens[t].level === r && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = !0, n.tokens[t].hidden = !0, t += 2);
}
var Eue = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f, d, p, g, m, b, y, k, w, x, v, C, B, R, T, z, se, ee, A, j, q, we = !1, ce = !0;
  if (e.sCount[t] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[t] - e.listIndent >= 4 && e.sCount[t] < e.blkIndent)
    return !1;
  if (r && e.parentType === "paragraph" && e.sCount[t] >= e.blkIndent && (we = !0), (z = m1(e, t)) >= 0) {
    if (u = !0, ee = e.bMarks[t] + e.tShift[t], b = Number(e.src.slice(ee, z - 1)), we && b !== 1)
      return !1;
  } else if ((z = g1(e, t)) >= 0)
    u = !1;
  else
    return !1;
  if (we && e.skipSpaces(z) >= e.eMarks[t])
    return !1;
  if (m = e.src.charCodeAt(z - 1), r)
    return !0;
  for (g = e.tokens.length, u ? (q = e.push("ordered_list_open", "ol", 1), b !== 1 && (q.attrs = [["start", b]])) : q = e.push("bullet_list_open", "ul", 1), q.map = p = [t, 0], q.markup = String.fromCharCode(m), k = t, se = !1, j = e.md.block.ruler.getRules("list"), v = e.parentType, e.parentType = "list"; k < i; ) {
    for (T = z, y = e.eMarks[k], h = w = e.sCount[k] + z - (e.bMarks[t] + e.tShift[t]); T < y; ) {
      if (s = e.src.charCodeAt(T), s === 9)
        w += 4 - (w + e.bsCount[k]) % 4;
      else if (s === 32)
        w++;
      else
        break;
      T++;
    }
    if (o = T, o >= y ? c = 1 : c = w - h, c > 4 && (c = 1), a = h + c, q = e.push("list_item_open", "li", 1), q.markup = String.fromCharCode(m), q.map = f = [t, 0], u && (q.info = e.src.slice(ee, z - 1)), R = e.tight, B = e.tShift[t], C = e.sCount[t], x = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = !0, e.tShift[t] = o - e.bMarks[t], e.sCount[t] = w, o >= y && e.isEmpty(t + 1) ? e.line = Math.min(e.line + 2, i) : e.md.block.tokenize(e, t, i, !0), (!e.tight || se) && (ce = !1), se = e.line - t > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = x, e.tShift[t] = B, e.sCount[t] = C, e.tight = R, q = e.push("list_item_close", "li", -1), q.markup = String.fromCharCode(m), k = t = e.line, f[1] = k, o = e.bMarks[t], k >= i || e.sCount[k] < e.blkIndent || e.sCount[t] - e.blkIndent >= 4)
      break;
    for (A = !1, l = 0, d = j.length; l < d; l++)
      if (j[l](e, k, i, !0)) {
        A = !0;
        break;
      }
    if (A)
      break;
    if (u) {
      if (z = m1(e, k), z < 0)
        break;
      ee = e.bMarks[k] + e.tShift[k];
    } else if (z = g1(e, k), z < 0)
      break;
    if (m !== e.src.charCodeAt(z - 1))
      break;
  }
  return u ? q = e.push("ordered_list_close", "ol", -1) : q = e.push("bullet_list_close", "ul", -1), q.markup = String.fromCharCode(m), p[1] = k, e.line = k, e.parentType = v, ce && Due(e, g), !0;
}, Tue = re.normalizeReference, ia = re.isSpace, Mue = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f, d, p, g, m, b, y, k, w, x = 0, v = e.bMarks[t] + e.tShift[t], C = e.eMarks[t], B = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(v) !== 91)
    return !1;
  for (; ++v < C; )
    if (e.src.charCodeAt(v) === 93 && e.src.charCodeAt(v - 1) !== 92) {
      if (v + 1 === C || e.src.charCodeAt(v + 1) !== 58)
        return !1;
      break;
    }
  for (a = e.lineMax, k = e.md.block.ruler.getRules("reference"), p = e.parentType, e.parentType = "reference"; B < a && !e.isEmpty(B); B++)
    if (!(e.sCount[B] - e.blkIndent > 3) && !(e.sCount[B] < 0)) {
      for (y = !1, h = 0, u = k.length; h < u; h++)
        if (k[h](e, B, a, !0)) {
          y = !0;
          break;
        }
      if (y)
        break;
    }
  for (b = e.getLines(t, B, e.blkIndent, !1).trim(), C = b.length, v = 1; v < C; v++) {
    if (s = b.charCodeAt(v), s === 91)
      return !1;
    if (s === 93) {
      d = v;
      break;
    } else
      s === 10 ? x++ : s === 92 && (v++, v < C && b.charCodeAt(v) === 10 && x++);
  }
  if (d < 0 || b.charCodeAt(d + 1) !== 58)
    return !1;
  for (v = d + 2; v < C; v++)
    if (s = b.charCodeAt(v), s === 10)
      x++;
    else if (!ia(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(b, v, C), !g.ok || (c = e.md.normalizeLink(g.str), !e.md.validateLink(c)))
    return !1;
  for (v = g.pos, x += g.lines, o = v, l = x, m = v; v < C; v++)
    if (s = b.charCodeAt(v), s === 10)
      x++;
    else if (!ia(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(b, v, C), v < C && m !== v && g.ok ? (w = g.str, v = g.pos, x += g.lines) : (w = "", v = o, x = l); v < C && (s = b.charCodeAt(v), !!ia(s)); )
    v++;
  if (v < C && b.charCodeAt(v) !== 10 && w)
    for (w = "", v = o, x = l; v < C && (s = b.charCodeAt(v), !!ia(s)); )
      v++;
  return v < C && b.charCodeAt(v) !== 10 || (f = Tue(b.slice(1, d)), !f) ? !1 : (r || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: w, href: c }), e.parentType = p, e.line = t + x + 1), !0);
}, Oue = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Th = {}, Lue = "[a-zA-Z_:][a-zA-Z0-9:._-]*", Rue = "[^\"'=<>`\\x00-\\x20]+", Iue = "'[^']*'", Bue = '"[^"]*"', Nue = "(?:" + Rue + "|" + Iue + "|" + Bue + ")", Pue = "(?:\\s+" + Lue + "(?:\\s*=\\s*" + Nue + ")?)", Px = "<[A-Za-z][A-Za-z0-9\\-]*" + Pue + "*\\s*\\/?>", Fx = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>", Fue = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", $ue = "<[?][\\s\\S]*?[?]>", Hue = "<![A-Z]+\\s+[^>]*>", que = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", Vue = new RegExp("^(?:" + Px + "|" + Fx + "|" + Fue + "|" + $ue + "|" + Hue + "|" + que + ")"), zue = new RegExp("^(?:" + Px + "|" + Fx + ")");
Th.HTML_TAG_RE = Vue;
Th.HTML_OPEN_CLOSE_TAG_RE = zue;
var Uue = Oue, Wue = Th.HTML_OPEN_CLOSE_TAG_RE, Xr = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, !0],
  [/^<!--/, /-->/, !0],
  [/^<\?/, /\?>/, !0],
  [/^<![A-Z]/, />/, !0],
  [/^<!\[CDATA\[/, /\]\]>/, !0],
  [new RegExp("^</?(" + Uue.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, !0],
  [new RegExp(Wue.source + "\\s*$"), /^$/, !1]
], jue = function(e, t, i, r) {
  var s, o, l, a, c = e.bMarks[t] + e.tShift[t], h = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(c) !== 60)
    return !1;
  for (a = e.src.slice(c, h), s = 0; s < Xr.length && !Xr[s][0].test(a); s++)
    ;
  if (s === Xr.length)
    return !1;
  if (r)
    return Xr[s][2];
  if (o = t + 1, !Xr[s][1].test(a)) {
    for (; o < i && !(e.sCount[o] < e.blkIndent); o++)
      if (c = e.bMarks[o] + e.tShift[o], h = e.eMarks[o], a = e.src.slice(c, h), Xr[s][1].test(a)) {
        a.length !== 0 && o++;
        break;
      }
  }
  return e.line = o, l = e.push("html_block", "", 0), l.map = [t, o], l.content = e.getLines(t, o, e.blkIndent, !0), !0;
}, b1 = re.isSpace, Gue = function(e, t, i, r) {
  var s, o, l, a, c = e.bMarks[t] + e.tShift[t], h = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(c), s !== 35 || c >= h))
    return !1;
  for (o = 1, s = e.src.charCodeAt(++c); s === 35 && c < h && o <= 6; )
    o++, s = e.src.charCodeAt(++c);
  return o > 6 || c < h && !b1(s) ? !1 : (r || (h = e.skipSpacesBack(h, c), l = e.skipCharsBack(h, 35, c), l > c && b1(e.src.charCodeAt(l - 1)) && (h = l), e.line = t + 1, a = e.push("heading_open", "h" + String(o), 1), a.markup = "########".slice(0, o), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(c, h).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(o), -1), a.markup = "########".slice(0, o)), !0);
}, Kue = function(e, t, i) {
  var r, s, o, l, a, c, h, u, f, d = t + 1, p, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return !1;
  for (p = e.parentType, e.parentType = "paragraph"; d < i && !e.isEmpty(d); d++)
    if (!(e.sCount[d] - e.blkIndent > 3)) {
      if (e.sCount[d] >= e.blkIndent && (c = e.bMarks[d] + e.tShift[d], h = e.eMarks[d], c < h && (f = e.src.charCodeAt(c), (f === 45 || f === 61) && (c = e.skipChars(c, f), c = e.skipSpaces(c), c >= h)))) {
        u = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[d] < 0)) {
        for (s = !1, o = 0, l = g.length; o < l; o++)
          if (g[o](e, d, i, !0)) {
            s = !0;
            break;
          }
        if (s)
          break;
      }
    }
  return u ? (r = e.getLines(t, d, e.blkIndent, !1).trim(), e.line = d + 1, a = e.push("heading_open", "h" + String(u), 1), a.markup = String.fromCharCode(f), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = r, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(u), -1), a.markup = String.fromCharCode(f), e.parentType = p, !0) : !1;
}, Yue = function(e, t) {
  var i, r, s, o, l, a, c = t + 1, h = e.md.block.ruler.getRules("paragraph"), u = e.lineMax;
  for (a = e.parentType, e.parentType = "paragraph"; c < u && !e.isEmpty(c); c++)
    if (!(e.sCount[c] - e.blkIndent > 3) && !(e.sCount[c] < 0)) {
      for (r = !1, s = 0, o = h.length; s < o; s++)
        if (h[s](e, c, u, !0)) {
          r = !0;
          break;
        }
      if (r)
        break;
    }
  return i = e.getLines(t, c, e.blkIndent, !1).trim(), e.line = c, l = e.push("paragraph_open", "p", 1), l.map = [t, e.line], l = e.push("inline", "", 0), l.content = i, l.map = [t, e.line], l.children = [], l = e.push("paragraph_close", "p", -1), e.parentType = a, !0;
}, $x = hg, Mh = re.isSpace;
function jn(n, e, t, i) {
  var r, s, o, l, a, c, h, u;
  for (this.src = n, this.md = e, this.env = t, this.tokens = i, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = !1, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, u = !1, o = l = c = h = 0, a = s.length; l < a; l++) {
    if (r = s.charCodeAt(l), !u)
      if (Mh(r)) {
        c++, r === 9 ? h += 4 - h % 4 : h++;
        continue;
      } else
        u = !0;
    (r === 10 || l === a - 1) && (r !== 10 && l++, this.bMarks.push(o), this.eMarks.push(l), this.tShift.push(c), this.sCount.push(h), this.bsCount.push(0), u = !1, c = 0, h = 0, o = l + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
jn.prototype.push = function(n, e, t) {
  var i = new $x(n, e, t);
  return i.block = !0, t < 0 && this.level--, i.level = this.level, t > 0 && this.level++, this.tokens.push(i), i;
};
jn.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
jn.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
jn.prototype.skipSpaces = function(e) {
  for (var t, i = this.src.length; e < i && (t = this.src.charCodeAt(e), !!Mh(t)); e++)
    ;
  return e;
};
jn.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!Mh(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
jn.prototype.skipChars = function(e, t) {
  for (var i = this.src.length; e < i && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
jn.prototype.skipCharsBack = function(e, t, i) {
  if (e <= i)
    return e;
  for (; e > i; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
jn.prototype.getLines = function(e, t, i, r) {
  var s, o, l, a, c, h, u, f = e;
  if (e >= t)
    return "";
  for (h = new Array(t - e), s = 0; f < t; f++, s++) {
    for (o = 0, u = a = this.bMarks[f], f + 1 < t || r ? c = this.eMarks[f] + 1 : c = this.eMarks[f]; a < c && o < i; ) {
      if (l = this.src.charCodeAt(a), Mh(l))
        l === 9 ? o += 4 - (o + this.bsCount[f]) % 4 : o++;
      else if (a - u < this.tShift[f])
        o++;
      else
        break;
      a++;
    }
    o > i ? h[s] = new Array(o - i + 1).join(" ") + this.src.slice(a, c) : h[s] = this.src.slice(a, c);
  }
  return h.join("");
};
jn.prototype.Token = $x;
var Jue = jn, Zue = cg, ra = [
  ["table", xue, ["paragraph", "reference"]],
  ["code", kue],
  ["fence", _ue, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", Sue, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", Aue, ["paragraph", "reference", "blockquote", "list"]],
  ["list", Eue, ["paragraph", "reference", "blockquote"]],
  ["reference", Mue],
  ["html_block", jue, ["paragraph", "reference", "blockquote"]],
  ["heading", Gue, ["paragraph", "reference", "blockquote"]],
  ["lheading", Kue],
  ["paragraph", Yue]
];
function Oh() {
  this.ruler = new Zue();
  for (var n = 0; n < ra.length; n++)
    this.ruler.push(ra[n][0], ra[n][1], { alt: (ra[n][2] || []).slice() });
}
Oh.prototype.tokenize = function(n, e, t) {
  for (var i, r, s = this.ruler.getRules(""), o = s.length, l = e, a = !1, c = n.md.options.maxNesting; l < t && (n.line = l = n.skipEmptyLines(l), !(l >= t || n.sCount[l] < n.blkIndent)); ) {
    if (n.level >= c) {
      n.line = t;
      break;
    }
    for (r = 0; r < o && (i = s[r](n, l, t, !1), !i); r++)
      ;
    n.tight = !a, n.isEmpty(n.line - 1) && (a = !0), l = n.line, l < t && n.isEmpty(l) && (a = !0, l++, n.line = l);
  }
};
Oh.prototype.parse = function(n, e, t, i) {
  var r;
  !n || (r = new this.State(n, e, t, i), this.tokenize(r, r.line, r.lineMax));
};
Oh.prototype.State = Jue;
var Xue = Oh;
function Que(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return !0;
    default:
      return !1;
  }
}
var efe = function(e, t) {
  for (var i = e.pos; i < e.posMax && !Que(e.src.charCodeAt(i)); )
    i++;
  return i === e.pos ? !1 : (t || (e.pending += e.src.slice(e.pos, i)), e.pos = i, !0);
}, tfe = re.isSpace, nfe = function(e, t) {
  var i, r, s, o = e.pos;
  if (e.src.charCodeAt(o) !== 10)
    return !1;
  if (i = e.pending.length - 1, r = e.posMax, !t)
    if (i >= 0 && e.pending.charCodeAt(i) === 32)
      if (i >= 1 && e.pending.charCodeAt(i - 1) === 32) {
        for (s = i - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (o++; o < r && tfe(e.src.charCodeAt(o)); )
    o++;
  return e.pos = o, !0;
}, ife = re.isSpace, fg = [];
for (var y1 = 0; y1 < 256; y1++)
  fg.push(0);
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  fg[n.charCodeAt(0)] = 1;
});
var rfe = function(e, t) {
  var i, r = e.pos, s = e.posMax;
  if (e.src.charCodeAt(r) !== 92)
    return !1;
  if (r++, r < s) {
    if (i = e.src.charCodeAt(r), i < 256 && fg[i] !== 0)
      return t || (e.pending += e.src[r]), e.pos += 2, !0;
    if (i === 10) {
      for (t || e.push("hardbreak", "br", 0), r++; r < s && (i = e.src.charCodeAt(r), !!ife(i)); )
        r++;
      return e.pos = r, !0;
    }
  }
  return t || (e.pending += "\\"), e.pos++, !0;
}, sfe = function(e, t) {
  var i, r, s, o, l, a, c, h, u = e.pos, f = e.src.charCodeAt(u);
  if (f !== 96)
    return !1;
  for (i = u, u++, r = e.posMax; u < r && e.src.charCodeAt(u) === 96; )
    u++;
  if (s = e.src.slice(i, u), c = s.length, e.backticksScanned && (e.backticks[c] || 0) <= i)
    return t || (e.pending += s), e.pos += c, !0;
  for (l = a = u; (l = e.src.indexOf("`", a)) !== -1; ) {
    for (a = l + 1; a < r && e.src.charCodeAt(a) === 96; )
      a++;
    if (h = a - l, h === c)
      return t || (o = e.push("code_inline", "code", 0), o.markup = s, o.content = e.src.slice(u, l).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, !0;
    e.backticks[h] = l;
  }
  return e.backticksScanned = !0, t || (e.pending += s), e.pos += c, !0;
}, Lh = {};
Lh.tokenize = function(e, t) {
  var i, r, s, o, l, a = e.pos, c = e.src.charCodeAt(a);
  if (t || c !== 126 || (r = e.scanDelims(e.pos, !0), o = r.length, l = String.fromCharCode(c), o < 2))
    return !1;
  for (o % 2 && (s = e.push("text", "", 0), s.content = l, o--), i = 0; i < o; i += 2)
    s = e.push("text", "", 0), s.content = l + l, e.delimiters.push({
      marker: c,
      length: 0,
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function w1(n, e) {
  var t, i, r, s, o, l = [], a = e.length;
  for (t = 0; t < a; t++)
    r = e[t], r.marker === 126 && r.end !== -1 && (s = e[r.end], o = n.tokens[r.token], o.type = "s_open", o.tag = "s", o.nesting = 1, o.markup = "~~", o.content = "", o = n.tokens[s.token], o.type = "s_close", o.tag = "s", o.nesting = -1, o.markup = "~~", o.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && l.push(s.token - 1));
  for (; l.length; ) {
    for (t = l.pop(), i = t + 1; i < n.tokens.length && n.tokens[i].type === "s_close"; )
      i++;
    i--, t !== i && (o = n.tokens[i], n.tokens[i] = n.tokens[t], n.tokens[t] = o);
  }
}
Lh.postProcess = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (w1(e, e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && w1(e, i[t].delimiters);
};
var Rh = {};
Rh.tokenize = function(e, t) {
  var i, r, s, o = e.pos, l = e.src.charCodeAt(o);
  if (t || l !== 95 && l !== 42)
    return !1;
  for (r = e.scanDelims(e.pos, l === 42), i = 0; i < r.length; i++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(l), e.delimiters.push({
      marker: l,
      length: r.length,
      token: e.tokens.length - 1,
      end: -1,
      open: r.can_open,
      close: r.can_close
    });
  return e.pos += r.length, !0;
};
function v1(n, e) {
  var t, i, r, s, o, l, a = e.length;
  for (t = a - 1; t >= 0; t--)
    i = e[t], !(i.marker !== 95 && i.marker !== 42) && i.end !== -1 && (r = e[i.end], l = t > 0 && e[t - 1].end === i.end + 1 && e[t - 1].marker === i.marker && e[t - 1].token === i.token - 1 && e[i.end + 1].token === r.token + 1, o = String.fromCharCode(i.marker), s = n.tokens[i.token], s.type = l ? "strong_open" : "em_open", s.tag = l ? "strong" : "em", s.nesting = 1, s.markup = l ? o + o : o, s.content = "", s = n.tokens[r.token], s.type = l ? "strong_close" : "em_close", s.tag = l ? "strong" : "em", s.nesting = -1, s.markup = l ? o + o : o, s.content = "", l && (n.tokens[e[t - 1].token].content = "", n.tokens[e[i.end + 1].token].content = "", t--));
}
Rh.postProcess = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (v1(e, e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && v1(e, i[t].delimiters);
};
var ofe = re.normalizeReference, Hu = re.isSpace, lfe = function(e, t) {
  var i, r, s, o, l, a, c, h, u, f = "", d = "", p = e.pos, g = e.posMax, m = e.pos, b = !0;
  if (e.src.charCodeAt(e.pos) !== 91 || (l = e.pos + 1, o = e.md.helpers.parseLinkLabel(e, e.pos, !0), o < 0))
    return !1;
  if (a = o + 1, a < g && e.src.charCodeAt(a) === 40) {
    for (b = !1, a++; a < g && (r = e.src.charCodeAt(a), !(!Hu(r) && r !== 10)); a++)
      ;
    if (a >= g)
      return !1;
    if (m = a, c = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), c.ok) {
      for (f = e.md.normalizeLink(c.str), e.md.validateLink(f) ? a = c.pos : f = "", m = a; a < g && (r = e.src.charCodeAt(a), !(!Hu(r) && r !== 10)); a++)
        ;
      if (c = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < g && m !== a && c.ok)
        for (d = c.str, a = c.pos; a < g && (r = e.src.charCodeAt(a), !(!Hu(r) && r !== 10)); a++)
          ;
    }
    (a >= g || e.src.charCodeAt(a) !== 41) && (b = !0), a++;
  }
  if (b) {
    if (typeof e.env.references > "u")
      return !1;
    if (a < g && e.src.charCodeAt(a) === 91 ? (m = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(m, a++) : a = o + 1) : a = o + 1, s || (s = e.src.slice(l, o)), h = e.env.references[ofe(s)], !h)
      return e.pos = p, !1;
    f = h.href, d = h.title;
  }
  return t || (e.pos = l, e.posMax = o, u = e.push("link_open", "a", 1), u.attrs = i = [["href", f]], d && i.push(["title", d]), e.md.inline.tokenize(e), u = e.push("link_close", "a", -1)), e.pos = a, e.posMax = g, !0;
}, afe = re.normalizeReference, qu = re.isSpace, cfe = function(e, t) {
  var i, r, s, o, l, a, c, h, u, f, d, p, g, m = "", b = e.pos, y = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, l = e.md.helpers.parseLinkLabel(e, e.pos + 1, !1), l < 0))
    return !1;
  if (c = l + 1, c < y && e.src.charCodeAt(c) === 40) {
    for (c++; c < y && (r = e.src.charCodeAt(c), !(!qu(r) && r !== 10)); c++)
      ;
    if (c >= y)
      return !1;
    for (g = c, u = e.md.helpers.parseLinkDestination(e.src, c, e.posMax), u.ok && (m = e.md.normalizeLink(u.str), e.md.validateLink(m) ? c = u.pos : m = ""), g = c; c < y && (r = e.src.charCodeAt(c), !(!qu(r) && r !== 10)); c++)
      ;
    if (u = e.md.helpers.parseLinkTitle(e.src, c, e.posMax), c < y && g !== c && u.ok)
      for (f = u.str, c = u.pos; c < y && (r = e.src.charCodeAt(c), !(!qu(r) && r !== 10)); c++)
        ;
    else
      f = "";
    if (c >= y || e.src.charCodeAt(c) !== 41)
      return e.pos = b, !1;
    c++;
  } else {
    if (typeof e.env.references > "u")
      return !1;
    if (c < y && e.src.charCodeAt(c) === 91 ? (g = c + 1, c = e.md.helpers.parseLinkLabel(e, c), c >= 0 ? o = e.src.slice(g, c++) : c = l + 1) : c = l + 1, o || (o = e.src.slice(a, l)), h = e.env.references[afe(o)], !h)
      return e.pos = b, !1;
    m = h.href, f = h.title;
  }
  return t || (s = e.src.slice(a, l), e.md.inline.parse(
    s,
    e.md,
    e.env,
    p = []
  ), d = e.push("image", "img", 0), d.attrs = i = [["src", m], ["alt", ""]], d.children = p, d.content = s, f && i.push(["title", f])), e.pos = c, e.posMax = y, !0;
}, hfe = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/, ufe = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/, ffe = function(e, t) {
  var i, r, s, o, l, a, c = e.pos;
  if (e.src.charCodeAt(c) !== 60)
    return !1;
  for (l = e.pos, a = e.posMax; ; ) {
    if (++c >= a || (o = e.src.charCodeAt(c), o === 60))
      return !1;
    if (o === 62)
      break;
  }
  return i = e.src.slice(l + 1, c), ufe.test(i) ? (r = e.md.normalizeLink(i), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(i), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += i.length + 2, !0) : !1) : hfe.test(i) ? (r = e.md.normalizeLink("mailto:" + i), e.md.validateLink(r) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", r]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(i), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += i.length + 2, !0) : !1) : !1;
}, dfe = Th.HTML_TAG_RE;
function pfe(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var gfe = function(e, t) {
  var i, r, s, o, l = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(l) !== 60 || l + 2 >= s) || (i = e.src.charCodeAt(l + 1), i !== 33 && i !== 63 && i !== 47 && !pfe(i)) || (r = e.src.slice(l).match(dfe), !r) ? !1 : (t || (o = e.push("html_inline", "", 0), o.content = e.src.slice(l, l + r[0].length)), e.pos += r[0].length, !0);
}, x1 = lg.exports, mfe = re.has, bfe = re.isValidEntityCode, k1 = re.fromCodePoint, yfe = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i, wfe = /^&([a-z][a-z0-9]{1,31});/i, vfe = function(e, t) {
  var i, r, s, o = e.pos, l = e.posMax;
  if (e.src.charCodeAt(o) !== 38)
    return !1;
  if (o + 1 < l) {
    if (i = e.src.charCodeAt(o + 1), i === 35) {
      if (s = e.src.slice(o).match(yfe), s)
        return t || (r = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), e.pending += bfe(r) ? k1(r) : k1(65533)), e.pos += s[0].length, !0;
    } else if (s = e.src.slice(o).match(wfe), s && mfe(x1, s[1]))
      return t || (e.pending += x1[s[1]]), e.pos += s[0].length, !0;
  }
  return t || (e.pending += "&"), e.pos++, !0;
};
function _1(n, e) {
  var t, i, r, s, o, l, a, c, h = {}, u = e.length;
  if (!!u) {
    var f = 0, d = -2, p = [];
    for (t = 0; t < u; t++)
      if (r = e[t], p.push(0), (e[f].marker !== r.marker || d !== r.token - 1) && (f = t), d = r.token, r.length = r.length || 0, !!r.close) {
        for (h.hasOwnProperty(r.marker) || (h[r.marker] = [-1, -1, -1, -1, -1, -1]), o = h[r.marker][(r.open ? 3 : 0) + r.length % 3], i = f - p[f] - 1, l = i; i > o; i -= p[i] + 1)
          if (s = e[i], s.marker === r.marker && s.open && s.end < 0 && (a = !1, (s.close || r.open) && (s.length + r.length) % 3 === 0 && (s.length % 3 !== 0 || r.length % 3 !== 0) && (a = !0), !a)) {
            c = i > 0 && !e[i - 1].open ? p[i - 1] + 1 : 0, p[t] = t - i + c, p[i] = c, r.open = !1, s.end = t, s.close = !1, l = -1, d = -2;
            break;
          }
        l !== -1 && (h[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = l);
      }
  }
}
var xfe = function(e) {
  var t, i = e.tokens_meta, r = e.tokens_meta.length;
  for (_1(e, e.delimiters), t = 0; t < r; t++)
    i[t] && i[t].delimiters && _1(e, i[t].delimiters);
}, kfe = function(e) {
  var t, i, r = 0, s = e.tokens, o = e.tokens.length;
  for (t = i = 0; t < o; t++)
    s[t].nesting < 0 && r--, s[t].level = r, s[t].nesting > 0 && r++, s[t].type === "text" && t + 1 < o && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== i && (s[i] = s[t]), i++);
  t !== i && (s.length = i);
}, dg = hg, S1 = re.isWhiteSpace, C1 = re.isPunctChar, A1 = re.isMdAsciiPunct;
function Tl(n, e, t, i) {
  this.src = n, this.env = t, this.md = e, this.tokens = i, this.tokens_meta = Array(i.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = !1;
}
Tl.prototype.pushPending = function() {
  var n = new dg("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
Tl.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var i = new dg(n, e, t), r = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), i.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], r = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(i), this.tokens_meta.push(r), i;
};
Tl.prototype.scanDelims = function(n, e) {
  var t = n, i, r, s, o, l, a, c, h, u, f = !0, d = !0, p = this.posMax, g = this.src.charCodeAt(n);
  for (i = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < p && this.src.charCodeAt(t) === g; )
    t++;
  return s = t - n, r = t < p ? this.src.charCodeAt(t) : 32, c = A1(i) || C1(String.fromCharCode(i)), u = A1(r) || C1(String.fromCharCode(r)), a = S1(i), h = S1(r), h ? f = !1 : u && (a || c || (f = !1)), a ? d = !1 : c && (h || u || (d = !1)), e ? (o = f, l = d) : (o = f && (!d || c), l = d && (!f || u)), {
    can_open: o,
    can_close: l,
    length: s
  };
};
Tl.prototype.Token = dg;
var _fe = Tl, D1 = cg, Vu = [
  ["text", efe],
  ["newline", nfe],
  ["escape", rfe],
  ["backticks", sfe],
  ["strikethrough", Lh.tokenize],
  ["emphasis", Rh.tokenize],
  ["link", lfe],
  ["image", cfe],
  ["autolink", ffe],
  ["html_inline", gfe],
  ["entity", vfe]
], zu = [
  ["balance_pairs", xfe],
  ["strikethrough", Lh.postProcess],
  ["emphasis", Rh.postProcess],
  ["text_collapse", kfe]
];
function Ml() {
  var n;
  for (this.ruler = new D1(), n = 0; n < Vu.length; n++)
    this.ruler.push(Vu[n][0], Vu[n][1]);
  for (this.ruler2 = new D1(), n = 0; n < zu.length; n++)
    this.ruler2.push(zu[n][0], zu[n][1]);
}
Ml.prototype.skipToken = function(n) {
  var e, t, i = n.pos, r = this.ruler.getRules(""), s = r.length, o = n.md.options.maxNesting, l = n.cache;
  if (typeof l[i] < "u") {
    n.pos = l[i];
    return;
  }
  if (n.level < o)
    for (t = 0; t < s && (n.level++, e = r[t](n, !0), n.level--, !e); t++)
      ;
  else
    n.pos = n.posMax;
  e || n.pos++, l[i] = n.pos;
};
Ml.prototype.tokenize = function(n) {
  for (var e, t, i = this.ruler.getRules(""), r = i.length, s = n.posMax, o = n.md.options.maxNesting; n.pos < s; ) {
    if (n.level < o)
      for (t = 0; t < r && (e = i[t](n, !1), !e); t++)
        ;
    if (e) {
      if (n.pos >= s)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Ml.prototype.parse = function(n, e, t, i) {
  var r, s, o, l = new this.State(n, e, t, i);
  for (this.tokenize(l), s = this.ruler2.getRules(""), o = s.length, r = 0; r < o; r++)
    s[r](l);
};
Ml.prototype.State = _fe;
var Sfe = Ml, Uu, E1;
function Cfe() {
  return E1 || (E1 = 1, Uu = function(n) {
    var e = {};
    e.src_Any = Ox().source, e.src_Cc = Lx().source, e.src_Z = Rx().source, e.src_P = ag.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><\uFF5C]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]).|" + (n && n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + ").|;(?!" + e.src_ZCc + ").|\\!+(?!" + e.src_ZCc + "|[!]).|\\?(?!" + e.src_ZCc + "|[?]).)+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + e.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Uu;
}
function ud(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    !t || Object.keys(t).forEach(function(i) {
      n[i] = t[i];
    });
  }), n;
}
function Ih(n) {
  return Object.prototype.toString.call(n);
}
function Afe(n) {
  return Ih(n) === "[object String]";
}
function Dfe(n) {
  return Ih(n) === "[object Object]";
}
function Efe(n) {
  return Ih(n) === "[object RegExp]";
}
function T1(n) {
  return Ih(n) === "[object Function]";
}
function Tfe(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Hx = {
  fuzzyLink: !0,
  fuzzyEmail: !0,
  fuzzyIP: !1
};
function Mfe(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Hx.hasOwnProperty(t);
  }, !1);
}
var Ofe = {
  "http:": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(i) ? i.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(i) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : i.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var i = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(i) ? i.match(t.re.mailto)[0].length : 0;
    }
  }
}, Lfe = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]", Rfe = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function Ife(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function Bfe(n) {
  return function(e, t) {
    var i = e.slice(t);
    return n.test(i) ? i.match(n)[0].length : 0;
  };
}
function M1() {
  return function(n, e) {
    e.normalize(n);
  };
}
function Ec(n) {
  var e = n.re = Cfe()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(Lfe), t.push(e.src_xn), e.src_tlds = t.join("|");
  function i(l) {
    return l.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(i(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(i(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(i(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(i(e.tpl_host_fuzzy_test), "i");
  var r = [];
  n.__compiled__ = {};
  function s(l, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + l + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(l) {
    var a = n.__schemas__[l];
    if (a !== null) {
      var c = { validate: null, link: null };
      if (n.__compiled__[l] = c, Dfe(a)) {
        Efe(a.validate) ? c.validate = Bfe(a.validate) : T1(a.validate) ? c.validate = a.validate : s(l, a), T1(a.normalize) ? c.normalize = a.normalize : a.normalize ? s(l, a) : c.normalize = M1();
        return;
      }
      if (Afe(a)) {
        r.push(l);
        return;
      }
      s(l, a);
    }
  }), r.forEach(function(l) {
    !n.__compiled__[n.__schemas__[l]] || (n.__compiled__[l].validate = n.__compiled__[n.__schemas__[l]].validate, n.__compiled__[l].normalize = n.__compiled__[n.__schemas__[l]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: M1() };
  var o = Object.keys(n.__compiled__).filter(function(l) {
    return l.length > 0 && n.__compiled__[l];
  }).map(Tfe).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + o + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + e.src_ZPCc + "))(" + o + ")", "ig"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), Ife(n);
}
function Nfe(n, e) {
  var t = n.__index__, i = n.__last_index__, r = n.__text_cache__.slice(t, i);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = i + e, this.raw = r, this.text = r, this.url = r;
}
function O1(n, e) {
  var t = new Nfe(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function Qt(n, e) {
  if (!(this instanceof Qt))
    return new Qt(n, e);
  e || Mfe(n) && (e = n, n = {}), this.__opts__ = ud({}, Hx, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = ud({}, Ofe, n), this.__compiled__ = {}, this.__tlds__ = Rfe, this.__tlds_replaced__ = !1, this.re = {}, Ec(this);
}
Qt.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, Ec(this), this;
};
Qt.prototype.set = function(e) {
  return this.__opts__ = ud(this.__opts__, e), this;
};
Qt.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return !1;
  var t, i, r, s, o, l, a, c, h;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], a.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c = e.search(this.re.host_fuzzy_test), c >= 0 && (this.__index__ < 0 || c < this.__index__) && (i = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (o = i.index + i[1].length, (this.__index__ < 0 || o < this.__index__) && (this.__schema__ = "", this.__index__ = o, this.__last_index__ = i.index + i[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (h = e.indexOf("@"), h >= 0 && (r = e.match(this.re.email_fuzzy)) !== null && (o = r.index + r[1].length, l = r.index + r[0].length, (this.__index__ < 0 || o < this.__index__ || o === this.__index__ && l > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = o, this.__last_index__ = l))), this.__index__ >= 0;
};
Qt.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
Qt.prototype.testSchemaAt = function(e, t, i) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, i, this) : 0;
};
Qt.prototype.match = function(e) {
  var t = 0, i = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (i.push(O1(this, t)), t = this.__last_index__);
  for (var r = t ? e.slice(t) : e; this.test(r); )
    i.push(O1(this, t)), r = r.slice(this.__last_index__), t += this.__last_index__;
  return i.length ? i : null;
};
Qt.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(i, r, s) {
    return i !== s[r - 1];
  }).reverse(), Ec(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = !0, Ec(this), this);
};
Qt.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
Qt.prototype.onCompile = function() {
};
var Pfe = Qt;
const ps = 2147483647, Rn = 36, pg = 1, Xo = 26, Ffe = 38, $fe = 700, qx = 72, Vx = 128, zx = "-", Hfe = /^xn--/, qfe = /[^\0-\x7F]/, Vfe = /[\x2E\u3002\uFF0E\uFF61]/g, zfe = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
}, Wu = Rn - pg, In = Math.floor, ju = String.fromCharCode;
function ki(n) {
  throw new RangeError(zfe[n]);
}
function Ufe(n, e) {
  const t = [];
  let i = n.length;
  for (; i--; )
    t[i] = e(n[i]);
  return t;
}
function Ux(n, e) {
  const t = n.split("@");
  let i = "";
  t.length > 1 && (i = t[0] + "@", n = t[1]), n = n.replace(Vfe, ".");
  const r = n.split("."), s = Ufe(r, e).join(".");
  return i + s;
}
function gg(n) {
  const e = [];
  let t = 0;
  const i = n.length;
  for (; t < i; ) {
    const r = n.charCodeAt(t++);
    if (r >= 55296 && r <= 56319 && t < i) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((r & 1023) << 10) + (s & 1023) + 65536) : (e.push(r), t--);
    } else
      e.push(r);
  }
  return e;
}
const Wx = (n) => String.fromCodePoint(...n), Wfe = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : Rn;
}, L1 = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
}, jx = function(n, e, t) {
  let i = 0;
  for (n = t ? In(n / $fe) : n >> 1, n += In(n / e); n > Wu * Xo >> 1; i += Rn)
    n = In(n / Wu);
  return In(i + (Wu + 1) * n / (n + Ffe));
}, mg = function(n) {
  const e = [], t = n.length;
  let i = 0, r = Vx, s = qx, o = n.lastIndexOf(zx);
  o < 0 && (o = 0);
  for (let l = 0; l < o; ++l)
    n.charCodeAt(l) >= 128 && ki("not-basic"), e.push(n.charCodeAt(l));
  for (let l = o > 0 ? o + 1 : 0; l < t; ) {
    const a = i;
    for (let h = 1, u = Rn; ; u += Rn) {
      l >= t && ki("invalid-input");
      const f = Wfe(n.charCodeAt(l++));
      f >= Rn && ki("invalid-input"), f > In((ps - i) / h) && ki("overflow"), i += f * h;
      const d = u <= s ? pg : u >= s + Xo ? Xo : u - s;
      if (f < d)
        break;
      const p = Rn - d;
      h > In(ps / p) && ki("overflow"), h *= p;
    }
    const c = e.length + 1;
    s = jx(i - a, c, a == 0), In(i / c) > ps - r && ki("overflow"), r += In(i / c), i %= c, e.splice(i++, 0, r);
  }
  return String.fromCodePoint(...e);
}, bg = function(n) {
  const e = [];
  n = gg(n);
  const t = n.length;
  let i = Vx, r = 0, s = qx;
  for (const a of n)
    a < 128 && e.push(ju(a));
  const o = e.length;
  let l = o;
  for (o && e.push(zx); l < t; ) {
    let a = ps;
    for (const h of n)
      h >= i && h < a && (a = h);
    const c = l + 1;
    a - i > In((ps - r) / c) && ki("overflow"), r += (a - i) * c, i = a;
    for (const h of n)
      if (h < i && ++r > ps && ki("overflow"), h === i) {
        let u = r;
        for (let f = Rn; ; f += Rn) {
          const d = f <= s ? pg : f >= s + Xo ? Xo : f - s;
          if (u < d)
            break;
          const p = u - d, g = Rn - d;
          e.push(
            ju(L1(d + p % g, 0))
          ), u = In(p / g);
        }
        e.push(ju(L1(u, 0))), s = jx(r, c, l === o), r = 0, ++l;
      }
    ++r, ++i;
  }
  return e.join("");
}, Gx = function(n) {
  return Ux(n, function(e) {
    return Hfe.test(e) ? mg(e.slice(4).toLowerCase()) : e;
  });
}, Kx = function(n) {
  return Ux(n, function(e) {
    return qfe.test(e) ? "xn--" + bg(e) : e;
  });
}, jfe = {
  version: "2.1.0",
  ucs2: {
    decode: gg,
    encode: Wx
  },
  decode: mg,
  encode: bg,
  toASCII: Kx,
  toUnicode: Gx
}, Gfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode: gg,
  ucs2encode: Wx,
  decode: mg,
  encode: bg,
  toASCII: Kx,
  toUnicode: Gx,
  default: jfe
}, Symbol.toStringTag, { value: "Module" })), Kfe = /* @__PURE__ */ lD(Gfe);
var Yfe = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
}, Jfe = {
  options: {
    html: !1,
    xhtmlOut: !1,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
}, Zfe = {
  options: {
    html: !0,
    xhtmlOut: !0,
    breaks: !1,
    langPrefix: "language-",
    linkify: !1,
    typographer: !1,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
}, Bo = re, Xfe = Eh, Qfe = Zhe, ede = vue, tde = Xue, nde = Sfe, ide = Pfe, ur = Xs, Yx = Kfe, rde = {
  default: Yfe,
  zero: Jfe,
  commonmark: Zfe
}, sde = /^(vbscript|javascript|file|data):/, ode = /^data:image\/(gif|png|jpeg|webp);/;
function lde(n) {
  var e = n.trim().toLowerCase();
  return sde.test(e) ? !!ode.test(e) : !0;
}
var Jx = ["http:", "https:", "mailto:"];
function ade(n) {
  var e = ur.parse(n, !0);
  if (e.hostname && (!e.protocol || Jx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Yx.toASCII(e.hostname);
    } catch {
    }
  return ur.encode(ur.format(e));
}
function cde(n) {
  var e = ur.parse(n, !0);
  if (e.hostname && (!e.protocol || Jx.indexOf(e.protocol) >= 0))
    try {
      e.hostname = Yx.toUnicode(e.hostname);
    } catch {
    }
  return ur.decode(ur.format(e), ur.decode.defaultChars + "%");
}
function en(n, e) {
  if (!(this instanceof en))
    return new en(n, e);
  e || Bo.isString(n) || (e = n || {}, n = "default"), this.inline = new nde(), this.block = new tde(), this.core = new ede(), this.renderer = new Qfe(), this.linkify = new ide(), this.validateLink = lde, this.normalizeLink = ade, this.normalizeLinkText = cde, this.utils = Bo, this.helpers = Bo.assign({}, Xfe), this.options = {}, this.configure(n), e && this.set(e);
}
en.prototype.set = function(n) {
  return Bo.assign(this.options, n), this;
};
en.prototype.configure = function(n) {
  var e = this, t;
  if (Bo.isString(n) && (t = n, n = rde[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(i) {
    n.components[i].rules && e[i].ruler.enableOnly(n.components[i].rules), n.components[i].rules2 && e[i].ruler2.enableOnly(n.components[i].rules2);
  }), this;
};
en.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.enable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.enable(n, !0));
  var i = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + i);
  return this;
};
en.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(r) {
    t = t.concat(this[r].ruler.disable(n, !0));
  }, this), t = t.concat(this.inline.ruler2.disable(n, !0));
  var i = n.filter(function(r) {
    return t.indexOf(r) < 0;
  });
  if (i.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + i);
  return this;
};
en.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
en.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
en.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
en.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = !0, this.core.process(t), t.tokens;
};
en.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var hde = en;
(function(n) {
  n.exports = hde;
})(Mx);
const ude = /* @__PURE__ */ oD(Mx.exports), Bh = Ae.button.withConfig({
  displayName: "Buttons__DefaultButton",
  componentId: "sc-temzhj-0"
})(['cursor:pointer;color:#fff;font-family:"Lato",sans-serif;text-transform:uppercase;font-size:12px;font-weight:bold;border:1px solid var(--gray-800);background-color:var(--gray-800);height:40px;display:flex;justify-content:center;align-items:center;padding:0;transition:0.4s ease;border-radius:var(--border-radius);&:not(:disabled):hover{background-color:var(--green-400);border:1px solid var(--green-400);}']), No = Ae(Bh).withConfig({
  displayName: "Buttons__TopbarButton",
  componentId: "sc-temzhj-1"
})(["padding:0px 15px;margin:5px;"]), fde = Ae(Bh).withConfig({
  displayName: "ButtonGroup__GroupButton",
  componentId: "sc-retnx5-0"
})(["color:", ";border:", ";background-color:", ";margin:5px;width:40px;"], (n) => n.$active ? "white" : "var(--gray-900)", (n) => n.$active ? "1px solid var(--green-500)" : "1px solid var(--gray-800)", (n) => n.$active ? "var(--green-500)" : "var(--gray-800)"), R1 = ({
  buttons: n,
  initialClickedId: e = 2,
  clickCallback: t,
  highlightActive: i = !0
}) => {
  const [r, s] = ht(e);
  return yt`
    ${n.map((o, l) => yt`
      <${fde} type="button" key=${o.label} name=${o.label} onClick=${() => {
    i && s(l), t(o.label);
  }} $active=${l === r}>
        <img src=${o.img} alt=${o.label} />
      <//>`)}
  `;
};
console.log("ButtonGroup component loaded");
class Z {
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  replace(e, t, i) {
    let r = [];
    return this.decompose(0, e, r, 2), i.length && i.decompose(0, i.length, r, 3), this.decompose(t, this.length, r, 1), Tn.from(r, this.length - (t - e) + i.length);
  }
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), Tn.from(i, t - e);
  }
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), r = new Po(this), s = new Po(e);
    for (let o = t, l = t; ; ) {
      if (r.next(o), s.next(o), o = 0, r.lineBreak != s.lineBreak || r.done != s.done || r.value != s.value)
        return !1;
      if (l += r.value.length, r.done || l >= i)
        return !0;
    }
  }
  iter(e = 1) {
    return new Po(this, e);
  }
  iterRange(e, t = this.length) {
    return new Zx(this, e, t);
  }
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let r = this.line(e).from;
      i = this.iterRange(r, Math.max(r, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new Xx(i);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  constructor() {
  }
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Z.empty : e.length <= 32 ? new Be(e) : Tn.from(Be.split(e, []));
  }
}
class Be extends Z {
  constructor(e, t = dde(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, r) {
    for (let s = 0; ; s++) {
      let o = this.text[s], l = r + o.length;
      if ((t ? i : l) >= e)
        return new pde(r, l, i, o);
      r = l + 1, i++;
    }
  }
  decompose(e, t, i, r) {
    let s = e <= 0 && t >= this.length ? this : new Be(I1(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (r & 1) {
      let o = i.pop(), l = Xa(s.text, o.text.slice(), 0, s.length);
      if (l.length <= 32)
        i.push(new Be(l, o.length + s.length));
      else {
        let a = l.length >> 1;
        i.push(new Be(l.slice(0, a)), new Be(l.slice(a)));
      }
    } else
      i.push(s);
  }
  replace(e, t, i) {
    if (!(i instanceof Be))
      return super.replace(e, t, i);
    let r = Xa(this.text, Xa(i.text, I1(this.text, 0, e)), t), s = this.length + i.length - (t - e);
    return r.length <= 32 ? new Be(r, s) : Tn.from(Be.split(r, []), s);
  }
  sliceString(e, t = this.length, i = `
`) {
    let r = "";
    for (let s = 0, o = 0; s <= t && o < this.text.length; o++) {
      let l = this.text[o], a = s + l.length;
      s > e && o && (r += i), e < a && t > s && (r += l.slice(Math.max(0, e - s), t - s)), s = a + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], r = -1;
    for (let s of e)
      i.push(s), r += s.length + 1, i.length == 32 && (t.push(new Be(i, r)), i = [], r = -1);
    return r > -1 && t.push(new Be(i, r)), t;
  }
}
class Tn extends Z {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, r) {
    for (let s = 0; ; s++) {
      let o = this.children[s], l = r + o.length, a = i + o.lines - 1;
      if ((t ? a : l) >= e)
        return o.lineInner(e, t, i, r);
      r = l + 1, i = a + 1;
    }
  }
  decompose(e, t, i, r) {
    for (let s = 0, o = 0; o <= t && s < this.children.length; s++) {
      let l = this.children[s], a = o + l.length;
      if (e <= a && t >= o) {
        let c = r & ((o <= e ? 1 : 0) | (a >= t ? 2 : 0));
        o >= e && a <= t && !c ? i.push(l) : l.decompose(e - o, t - o, i, c);
      }
      o = a + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let r = 0, s = 0; r < this.children.length; r++) {
        let o = this.children[r], l = s + o.length;
        if (e >= s && t <= l) {
          let a = o.replace(e - s, t - s, i), c = this.lines - o.lines + a.lines;
          if (a.lines < c >> 5 - 1 && a.lines > c >> 5 + 1) {
            let h = this.children.slice();
            return h[r] = a, new Tn(h, this.length - (t - e) + i.length);
          }
          return super.replace(s, l, a);
        }
        s = l + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let r = "";
    for (let s = 0, o = 0; s < this.children.length && o <= t; s++) {
      let l = this.children[s], a = o + l.length;
      o > e && s && (r += i), e < a && t > o && (r += l.sliceString(e - o, t - o, i)), o = a + 1;
    }
    return r;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Tn))
      return 0;
    let i = 0, [r, s, o, l] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; r += t, s += t) {
      if (r == o || s == l)
        return i;
      let a = this.children[r], c = e.children[s];
      if (a != c)
        return i + a.scanIdentical(c, t);
      i += a.length + 1;
    }
  }
  static from(e, t = e.reduce((i, r) => i + r.length + 1, -1)) {
    let i = 0;
    for (let d of e)
      i += d.lines;
    if (i < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new Be(d, t);
    }
    let r = Math.max(32, i >> 5), s = r << 1, o = r >> 1, l = [], a = 0, c = -1, h = [];
    function u(d) {
      let p;
      if (d.lines > s && d instanceof Tn)
        for (let g of d.children)
          u(g);
      else
        d.lines > o && (a > o || !a) ? (f(), l.push(d)) : d instanceof Be && a && (p = h[h.length - 1]) instanceof Be && d.lines + p.lines <= 32 ? (a += d.lines, c += d.length + 1, h[h.length - 1] = new Be(p.text.concat(d.text), p.length + 1 + d.length)) : (a + d.lines > r && f(), a += d.lines, c += d.length + 1, h.push(d));
    }
    function f() {
      a != 0 && (l.push(h.length == 1 ? h[0] : Tn.from(h, c)), c = -1, a = h.length = 0);
    }
    for (let d of e)
      u(d);
    return f(), l.length == 1 ? l[0] : new Tn(l, t);
  }
}
Z.empty = /* @__PURE__ */ new Be([""], 0);
function dde(n) {
  let e = -1;
  for (let t of n)
    e += t.length + 1;
  return e;
}
function Xa(n, e, t = 0, i = 1e9) {
  for (let r = 0, s = 0, o = !0; s < n.length && r <= i; s++) {
    let l = n[s], a = r + l.length;
    a >= t && (a > i && (l = l.slice(0, i - r)), r < t && (l = l.slice(t - r)), o ? (e[e.length - 1] += l, o = !1) : e.push(l)), r = a + 1;
  }
  return e;
}
function I1(n, e, t) {
  return Xa(n, [""], e, t);
}
class Po {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Be ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, r = this.nodes[i], s = this.offsets[i], o = s >> 1, l = r instanceof Be ? r.text.length : r.children.length;
      if (o == (t > 0 ? l : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (r instanceof Be) {
        let a = r.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = r.children[o + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof Be ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Zx {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new Po(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: r } = this.cursor.next(e);
    return this.pos += (r.length + e) * t, this.value = r.length <= i ? r : t < 0 ? r.slice(r.length - i) : r.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Xx {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: r } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = r, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Z.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Po.prototype[Symbol.iterator] = Zx.prototype[Symbol.iterator] = Xx.prototype[Symbol.iterator] = function() {
  return this;
});
class pde {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.number = i, this.text = r;
  }
  get length() {
    return this.to - this.from;
  }
}
let gs = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((n) => n ? parseInt(n, 36) : 1);
for (let n = 1; n < gs.length; n++)
  gs[n] += gs[n - 1];
function gde(n) {
  for (let e = 1; e < gs.length; e += 2)
    if (gs[e] > n)
      return gs[e - 1] <= n;
  return !1;
}
function B1(n) {
  return n >= 127462 && n <= 127487;
}
const N1 = 8205;
function Le(n, e, t = !0, i = !0) {
  return (t ? Qx : mde)(n, e, i);
}
function Qx(n, e, t) {
  if (e == n.length)
    return e;
  e && ek(n.charCodeAt(e)) && tk(n.charCodeAt(e - 1)) && e--;
  let i = tt(n, e);
  for (e += Ut(i); e < n.length; ) {
    let r = tt(n, e);
    if (i == N1 || r == N1 || t && gde(r))
      e += Ut(r), i = r;
    else if (B1(r)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && B1(tt(n, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function mde(n, e, t) {
  for (; e > 0; ) {
    let i = Qx(n, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function ek(n) {
  return n >= 56320 && n < 57344;
}
function tk(n) {
  return n >= 55296 && n < 56320;
}
function tt(n, e) {
  let t = n.charCodeAt(e);
  if (!tk(t) || e + 1 == n.length)
    return t;
  let i = n.charCodeAt(e + 1);
  return ek(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function yg(n) {
  return n <= 65535 ? String.fromCharCode(n) : (n -= 65536, String.fromCharCode((n >> 10) + 55296, (n & 1023) + 56320));
}
function Ut(n) {
  return n < 65536 ? 1 : 2;
}
const fd = /\r\n?|\n/;
var qe = /* @__PURE__ */ function(n) {
  return n[n.Simple = 0] = "Simple", n[n.TrackDel = 1] = "TrackDel", n[n.TrackBefore = 2] = "TrackBefore", n[n.TrackAfter = 3] = "TrackAfter", n;
}(qe || (qe = {}));
class Hn {
  constructor(e) {
    this.sections = e;
  }
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(e) {
    for (let t = 0, i = 0, r = 0; t < this.sections.length; ) {
      let s = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, r, s), r += s) : r += o, i += s;
    }
  }
  iterChangedRanges(e, t = !1) {
    dd(this, e, t);
  }
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], r = this.sections[t++];
      r < 0 ? e.push(i, r) : e.push(r, i);
    }
    return new Hn(e);
  }
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : nk(this, e);
  }
  mapDesc(e, t = !1) {
    return e.empty ? this : pd(this, e, t);
  }
  mapPos(e, t = -1, i = qe.Simple) {
    let r = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], a = this.sections[o++], c = r + l;
      if (a < 0) {
        if (c > e)
          return s + (e - r);
        s += l;
      } else {
        if (i != qe.Simple && c >= e && (i == qe.TrackDel && r < e && c > e || i == qe.TrackBefore && r < e || i == qe.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !l)
          return e == r || t < 0 ? s : s + a;
        s += a;
      }
      r = c;
    }
    if (e > r)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${r}`);
    return s;
  }
  touchesRange(e, t = e) {
    for (let i = 0, r = 0; i < this.sections.length && r <= t; ) {
      let s = this.sections[i++], o = this.sections[i++], l = r + s;
      if (o >= 0 && r <= t && l >= e)
        return r < e && l > t ? "cover" : !0;
      r = l;
    }
    return !1;
  }
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], r = this.sections[t++];
      e += (e ? " " : "") + i + (r >= 0 ? ":" + r : "");
    }
    return e;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Hn(e);
  }
  static create(e) {
    return new Hn(e);
  }
}
class Oe extends Hn {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return dd(this, (t, i, r, s, o) => e = e.replace(r, r + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return pd(this, e, t, !0);
  }
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let r = 0, s = 0; r < t.length; r += 2) {
      let o = t[r], l = t[r + 1];
      if (l >= 0) {
        t[r] = l, t[r + 1] = o;
        let a = r >> 1;
        for (; i.length < a; )
          i.push(Z.empty);
        i.push(o ? e.slice(s, s + o) : Z.empty);
      }
      s += o;
    }
    return new Oe(t, i);
  }
  compose(e) {
    return this.empty ? e : e.empty ? this : nk(this, e, !0);
  }
  map(e, t = !1) {
    return e.empty ? this : pd(this, e, t, !0);
  }
  iterChanges(e, t = !1) {
    dd(this, e, t);
  }
  get desc() {
    return Hn.create(this.sections);
  }
  filter(e) {
    let t = [], i = [], r = [], s = new Qo(this);
    e:
      for (let o = 0, l = 0; ; ) {
        let a = o == e.length ? 1e9 : e[o++];
        for (; l < a || l == a && s.len == 0; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, a - l);
          ct(r, h, -1);
          let u = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          ct(t, h, u), u > 0 && Ti(i, t, s.text), s.forward(h), l += h;
        }
        let c = e[o++];
        for (; l < c; ) {
          if (s.done)
            break e;
          let h = Math.min(s.len, c - l);
          ct(t, h, -1), ct(r, h, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(h), l += h;
        }
      }
    return {
      changes: new Oe(t, i),
      filtered: Hn.create(r)
    };
  }
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], r = this.sections[t + 1];
      r < 0 ? e.push(i) : r == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  static of(e, t, i) {
    let r = [], s = [], o = 0, l = null;
    function a(h = !1) {
      if (!h && !r.length)
        return;
      o < t && ct(r, t - o, -1);
      let u = new Oe(r, s);
      l = l ? l.compose(u.map(l)) : u, r = [], s = [], o = 0;
    }
    function c(h) {
      if (Array.isArray(h))
        for (let u of h)
          c(u);
      else if (h instanceof Oe) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        a(), l = l ? l.compose(h.map(l)) : h;
      } else {
        let { from: u, to: f = u, insert: d } = h;
        if (u > f || u < 0 || f > t)
          throw new RangeError(`Invalid change range ${u} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? Z.of(d.split(i || fd)) : d : Z.empty, g = p.length;
        if (u == f && g == 0)
          return;
        u < o && a(), u > o && ct(r, u - o, -1), ct(r, f - u, g), Ti(s, r, p), o = f;
      }
    }
    return c(e), a(!l), l;
  }
  static empty(e) {
    return new Oe(e ? [e, -1] : [], []);
  }
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let r = 0; r < e.length; r++) {
      let s = e[r];
      if (typeof s == "number")
        t.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          t.push(s[0], 0);
        else {
          for (; i.length < r; )
            i.push(Z.empty);
          i[r] = Z.of(s.slice(1)), t.push(s[0], i[r].length);
        }
      }
    }
    return new Oe(t, i);
  }
  static createSet(e, t) {
    return new Oe(e, t);
  }
}
function ct(n, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let r = n.length - 2;
  r >= 0 && t <= 0 && t == n[r + 1] ? n[r] += e : e == 0 && n[r] == 0 ? n[r + 1] += t : i ? (n[r] += e, n[r + 1] += t) : n.push(e, t);
}
function Ti(n, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < n.length)
    n[n.length - 1] = n[n.length - 1].append(t);
  else {
    for (; n.length < i; )
      n.push(Z.empty);
    n.push(t);
  }
}
function dd(n, e, t) {
  let i = n.inserted;
  for (let r = 0, s = 0, o = 0; o < n.sections.length; ) {
    let l = n.sections[o++], a = n.sections[o++];
    if (a < 0)
      r += l, s += l;
    else {
      let c = r, h = s, u = Z.empty;
      for (; c += l, h += a, a && i && (u = u.append(i[o - 2 >> 1])), !(t || o == n.sections.length || n.sections[o + 1] < 0); )
        l = n.sections[o++], a = n.sections[o++];
      e(r, c, s, h, u), r = c, s = h;
    }
  }
}
function pd(n, e, t, i = !1) {
  let r = [], s = i ? [] : null, o = new Qo(n), l = new Qo(e);
  for (let a = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let c = Math.min(o.len, l.len);
      ct(r, c, -1), o.forward(c), l.forward(c);
    } else if (l.ins >= 0 && (o.ins < 0 || a == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !t))) {
      let c = l.len;
      for (ct(r, l.ins, -1); c; ) {
        let h = Math.min(o.len, c);
        o.ins >= 0 && a < o.i && o.len <= h && (ct(r, 0, o.ins), s && Ti(s, r, o.text), a = o.i), o.forward(h), c -= h;
      }
      l.next();
    } else if (o.ins >= 0) {
      let c = 0, h = o.len;
      for (; h; )
        if (l.ins == -1) {
          let u = Math.min(h, l.len);
          c += u, h -= u, l.forward(u);
        } else if (l.ins == 0 && l.len < h)
          h -= l.len, l.next();
        else
          break;
      ct(r, c, a < o.i ? o.ins : 0), s && a < o.i && Ti(s, r, o.text), a = o.i, o.forward(o.len - h);
    } else {
      if (o.done && l.done)
        return s ? Oe.createSet(r, s) : Hn.create(r);
      throw new Error("Mismatched change set lengths");
    }
}
function nk(n, e, t = !1) {
  let i = [], r = t ? [] : null, s = new Qo(n), o = new Qo(e);
  for (let l = !1; ; ) {
    if (s.done && o.done)
      return r ? Oe.createSet(i, r) : Hn.create(i);
    if (s.ins == 0)
      ct(i, s.len, 0, l), s.next();
    else if (o.len == 0 && !o.done)
      ct(i, 0, o.ins, l), r && Ti(r, i, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(s.len2, o.len), c = i.length;
        if (s.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          ct(i, a, h, l), r && h && Ti(r, i, o.text);
        } else
          o.ins == -1 ? (ct(i, s.off ? 0 : s.len, a, l), r && Ti(r, i, s.textBit(a))) : (ct(i, s.off ? 0 : s.len, o.off ? 0 : o.ins, l), r && !o.off && Ti(r, i, o.text));
        l = (s.ins > a || o.ins >= 0 && o.len > a) && (l || i.length > c), s.forward2(a), o.forward(a);
      }
    }
  }
}
class Qo {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Z.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? Z.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class fr {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  map(e, t = -1) {
    let i, r;
    return this.empty ? i = r = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), r = e.mapPos(this.to, -1)), i == this.from && r == this.to ? this : new fr(i, r, this.flags);
  }
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return S.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return S.range(this.anchor, i);
  }
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return S.range(e.anchor, e.head);
  }
  static create(e, t, i) {
    return new fr(e, t, i);
  }
}
class S {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  map(e, t = -1) {
    return e.empty ? this : S.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new S([this.main], 0);
  }
  addRange(e, t = !0) {
    return S.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, S.create(i, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new S(e.ranges.map((t) => fr.fromJSON(t)), e.main);
  }
  static single(e, t = e) {
    return new S([S.range(e, t)], 0);
  }
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, r = 0; r < e.length; r++) {
      let s = e[r];
      if (s.empty ? s.from <= i : s.from < i)
        return S.normalized(e.slice(), t);
      i = s.to;
    }
    return new S(e, t);
  }
  static cursor(e, t = 0, i, r) {
    return fr.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (r != null ? r : 33554431) << 5);
  }
  static range(e, t, i, r) {
    let s = (i != null ? i : 33554431) << 5 | (r == null ? 3 : Math.min(2, r));
    return t < e ? fr.create(t, e, 24 | s) : fr.create(e, t, (t > e ? 4 : 0) | s);
  }
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((r, s) => r.from - s.from), t = e.indexOf(i);
    for (let r = 1; r < e.length; r++) {
      let s = e[r], o = e[r - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let l = o.from, a = Math.max(s.to, o.to);
        r <= t && t--, e.splice(--r, 2, s.anchor > s.head ? S.range(a, l) : S.range(l, a));
      }
    }
    return new S(e, t);
  }
}
function ik(n, e) {
  for (let t of n.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let wg = 0;
class E {
  constructor(e, t, i, r, s) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = r, this.id = wg++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  static define(e = {}) {
    return new E(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : vg), !!e.static, e.enables);
  }
  of(e) {
    return new Qa([], this, 0, e);
  }
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Qa(e, this, 1, t);
  }
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Qa(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function vg(n, e) {
  return n == e || n.length == e.length && n.every((t, i) => t === e[i]);
}
class Qa {
  constructor(e, t, i, r) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = r, this.id = wg++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, r = this.facet.compareInput, s = this.id, o = e[s] >> 1, l = this.type == 2, a = !1, c = !1, h = [];
    for (let u of this.dependencies)
      u == "doc" ? a = !0 : u == "selection" ? c = !0 : (((t = e[u.id]) !== null && t !== void 0 ? t : 1) & 1) == 0 && h.push(e[u.id]);
    return {
      create(u) {
        return u.values[o] = i(u), 1;
      },
      update(u, f) {
        if (a && f.docChanged || c && (f.docChanged || f.selection) || gd(u, h)) {
          let d = i(u);
          if (l ? !P1(d, u.values[o], r) : !r(d, u.values[o]))
            return u.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (u, f) => {
        let d, p = f.config.address[s];
        if (p != null) {
          let g = Mc(f, p);
          if (this.dependencies.every((m) => m instanceof E ? f.facet(m) === u.facet(m) : m instanceof Ue ? f.field(m, !1) == u.field(m, !1) : !0) || (l ? P1(d = i(u), g, r) : r(d = i(u), g)))
            return u.values[o] = g, 0;
        } else
          d = i(u);
        return u.values[o] = d, 1;
      }
    };
  }
}
function P1(n, e, t) {
  if (n.length != e.length)
    return !1;
  for (let i = 0; i < n.length; i++)
    if (!t(n[i], e[i]))
      return !1;
  return !0;
}
function gd(n, e) {
  let t = !1;
  for (let i of e)
    Fo(n, i) & 1 && (t = !0);
  return t;
}
function bde(n, e, t) {
  let i = t.map((a) => n[a.id]), r = t.map((a) => a.type), s = i.filter((a) => !(a & 1)), o = n[e.id] >> 1;
  function l(a) {
    let c = [];
    for (let h = 0; h < i.length; h++) {
      let u = Mc(a, i[h]);
      if (r[h] == 2)
        for (let f of u)
          c.push(f);
      else
        c.push(u);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of i)
        Fo(a, c);
      return a.values[o] = l(a), 1;
    },
    update(a, c) {
      if (!gd(a, s))
        return 0;
      let h = l(a);
      return e.compare(h, a.values[o]) ? 0 : (a.values[o] = h, 1);
    },
    reconfigure(a, c) {
      let h = gd(a, i), u = c.config.facets[e.id], f = c.facet(e);
      if (u && !h && vg(t, u))
        return a.values[o] = f, 0;
      let d = l(a);
      return e.compare(d, f) ? (a.values[o] = f, 0) : (a.values[o] = d, 1);
    }
  };
}
const F1 = /* @__PURE__ */ E.define({ static: !0 });
class Ue {
  constructor(e, t, i, r, s) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = r, this.spec = s, this.provides = void 0;
  }
  static define(e) {
    let t = new Ue(wg++, e.create, e.update, e.compare || ((i, r) => i === r), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(F1).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, r) => {
        let s = i.values[t], o = this.updateF(s, r);
        return this.compareF(s, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, r) => r.config.address[this.id] != null ? (i.values[t] = r.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  init(e) {
    return [this, F1.of({ field: this, create: e })];
  }
  get extension() {
    return this;
  }
}
const ar = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function fo(n) {
  return (e) => new rk(e, n);
}
const gi = {
  highest: /* @__PURE__ */ fo(ar.highest),
  high: /* @__PURE__ */ fo(ar.high),
  default: /* @__PURE__ */ fo(ar.default),
  low: /* @__PURE__ */ fo(ar.low),
  lowest: /* @__PURE__ */ fo(ar.lowest)
};
class rk {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class to {
  of(e) {
    return new md(this, e);
  }
  reconfigure(e) {
    return to.reconfigure.of({ compartment: this, extension: e });
  }
  get(e) {
    return e.config.compartments.get(this);
  }
}
class md {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Tc {
  constructor(e, t, i, r, s, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = r, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(0);
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let r = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of yde(e, t, o))
      f instanceof Ue ? r.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let l = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let f of r)
      l[f.id] = c.length << 1, c.push((d) => f.slot(d));
    let h = i == null ? void 0 : i.config.facets;
    for (let f in s) {
      let d = s[f], p = d[0].facet, g = h && h[f] || [];
      if (d.every((m) => m.type == 0))
        if (l[p.id] = a.length << 1 | 1, vg(g, d))
          a.push(i.facet(p));
        else {
          let m = p.combine(d.map((b) => b.value));
          a.push(i && p.compare(m, i.facet(p)) ? i.facet(p) : m);
        }
      else {
        for (let m of d)
          m.type == 0 ? (l[m.id] = a.length << 1 | 1, a.push(m.value)) : (l[m.id] = c.length << 1, c.push((b) => m.dynamicSlot(b)));
        l[p.id] = c.length << 1, c.push((m) => bde(m, p, d));
      }
    }
    let u = c.map((f) => f(l));
    return new Tc(e, o, u, l, a, s);
  }
}
function yde(n, e, t) {
  let i = [[], [], [], [], []], r = /* @__PURE__ */ new Map();
  function s(o, l) {
    let a = r.get(o);
    if (a != null) {
      if (a <= l)
        return;
      let c = i[a].indexOf(o);
      c > -1 && i[a].splice(c, 1), o instanceof md && t.delete(o.compartment);
    }
    if (r.set(o, l), Array.isArray(o))
      for (let c of o)
        s(c, l);
    else if (o instanceof md) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      t.set(o.compartment, c), s(c, l);
    } else if (o instanceof rk)
      s(o.inner, o.prec);
    else if (o instanceof Ue)
      i[l].push(o), o.provides && s(o.provides, l);
    else if (o instanceof Qa)
      i[l].push(o), o.facet.extensions && s(o.facet.extensions, ar.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, l);
    }
  }
  return s(n, ar.default), i.reduce((o, l) => o.concat(l));
}
function Fo(n, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = n.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  n.status[t] = 4;
  let r = n.computeSlot(n, n.config.dynamicSlots[t]);
  return n.status[t] = 2 | r;
}
function Mc(n, e) {
  return e & 1 ? n.config.staticValues[e >> 1] : n.values[e >> 1];
}
const sk = /* @__PURE__ */ E.define(), ok = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e),
  static: !0
}), lk = /* @__PURE__ */ E.define({
  combine: (n) => n.length ? n[0] : void 0,
  static: !0
}), ak = /* @__PURE__ */ E.define(), ck = /* @__PURE__ */ E.define(), hk = /* @__PURE__ */ E.define(), uk = /* @__PURE__ */ E.define({
  combine: (n) => n.length ? n[0] : !1
});
class nn {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static define() {
    return new wde();
  }
}
class wde {
  of(e) {
    return new nn(this, e);
  }
}
class vde {
  constructor(e) {
    this.map = e;
  }
  of(e) {
    return new G(this, e);
  }
}
class G {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new G(this.type, t);
  }
  is(e) {
    return this.type == e;
  }
  static define(e = {}) {
    return new vde(e.map || ((t) => t));
  }
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let r of e) {
      let s = r.map(t);
      s && i.push(s);
    }
    return i;
  }
}
G.reconfigure = /* @__PURE__ */ G.define();
G.appendConfig = /* @__PURE__ */ G.define();
class Ve {
  constructor(e, t, i, r, s, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = r, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, i && ik(i, t.newLength), s.some((l) => l.type == Ve.time) || (this.annotations = s.concat(Ve.time.of(Date.now())));
  }
  static create(e, t, i, r, s, o) {
    return new Ve(e, t, i, r, s, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(e) {
    let t = this.annotation(Ve.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Ve.time = /* @__PURE__ */ nn.define();
Ve.userEvent = /* @__PURE__ */ nn.define();
Ve.addToHistory = /* @__PURE__ */ nn.define();
Ve.remote = /* @__PURE__ */ nn.define();
function xde(n, e) {
  let t = [];
  for (let i = 0, r = 0; ; ) {
    let s, o;
    if (i < n.length && (r == e.length || e[r] >= n[i]))
      s = n[i++], o = n[i++];
    else if (r < e.length)
      s = e[r++], o = e[r++];
    else
      return t;
    !t.length || t[t.length - 1] < s ? t.push(s, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function fk(n, e, t) {
  var i;
  let r, s, o;
  return t ? (r = e.changes, s = Oe.empty(e.changes.length), o = n.changes.compose(e.changes)) : (r = e.changes.map(n.changes), s = n.changes.mapDesc(e.changes, !0), o = n.changes.compose(r)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (i = n.selection) === null || i === void 0 ? void 0 : i.map(r),
    effects: G.mapEffects(n.effects, r).concat(G.mapEffects(e.effects, s)),
    annotations: n.annotations.length ? n.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: n.scrollIntoView || e.scrollIntoView
  };
}
function bd(n, e, t) {
  let i = e.selection, r = ms(e.annotations);
  return e.userEvent && (r = r.concat(Ve.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Oe ? e.changes : Oe.of(e.changes || [], t, n.facet(lk)),
    selection: i && (i instanceof S ? i : S.single(i.anchor, i.head)),
    effects: ms(e.effects),
    annotations: r,
    scrollIntoView: !!e.scrollIntoView
  };
}
function dk(n, e, t) {
  let i = bd(n, e.length ? e[0] : {}, n.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (t = !1);
    let o = !!e[s].sequential;
    i = fk(i, bd(n, e[s], o ? i.changes.newLength : n.doc.length), o);
  }
  let r = Ve.create(n, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return _de(t ? kde(r) : r);
}
function kde(n) {
  let e = n.startState, t = !0;
  for (let r of e.facet(ak)) {
    let s = r(n);
    if (s === !1) {
      t = !1;
      break;
    }
    Array.isArray(s) && (t = t === !0 ? s : xde(t, s));
  }
  if (t !== !0) {
    let r, s;
    if (t === !1)
      s = n.changes.invertedDesc, r = Oe.empty(e.doc.length);
    else {
      let o = n.changes.filter(t);
      r = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    n = Ve.create(e, r, n.selection && n.selection.map(s), G.mapEffects(n.effects, s), n.annotations, n.scrollIntoView);
  }
  let i = e.facet(ck);
  for (let r = i.length - 1; r >= 0; r--) {
    let s = i[r](n);
    s instanceof Ve ? n = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Ve ? n = s[0] : n = dk(e, ms(s), !1);
  }
  return n;
}
function _de(n) {
  let e = n.startState, t = e.facet(hk), i = n;
  for (let r = t.length - 1; r >= 0; r--) {
    let s = t[r](n);
    s && Object.keys(s).length && (i = fk(i, bd(e, s, n.changes.newLength), !0));
  }
  return i == n ? n : Ve.create(e, n.changes, n.selection, i.effects, i.annotations, i.scrollIntoView);
}
const Sde = [];
function ms(n) {
  return n == null ? Sde : Array.isArray(n) ? n : [n];
}
var Ce = /* @__PURE__ */ function(n) {
  return n[n.Word = 0] = "Word", n[n.Space = 1] = "Space", n[n.Other = 2] = "Other", n;
}(Ce || (Ce = {}));
const Cde = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let yd;
try {
  yd = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function Ade(n) {
  if (yd)
    return yd.test(n);
  for (let e = 0; e < n.length; e++) {
    let t = n[e];
    if (/\w/.test(t) || t > "\x80" && (t.toUpperCase() != t.toLowerCase() || Cde.test(t)))
      return !0;
  }
  return !1;
}
function Dde(n) {
  return (e) => {
    if (!/\S/.test(e))
      return Ce.Space;
    if (Ade(e))
      return Ce.Word;
    for (let t = 0; t < n.length; t++)
      if (e.indexOf(n[t]) > -1)
        return Ce.Word;
    return Ce.Other;
  };
}
class J {
  constructor(e, t, i, r, s, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = r, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      Fo(this, l << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Fo(this, i), Mc(this, i);
  }
  update(...e) {
    return dk(this, e, !0);
  }
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: r } = t;
    for (let o of e.effects)
      o.is(to.reconfigure) ? (t && (r = /* @__PURE__ */ new Map(), t.compartments.forEach((l, a) => r.set(a, l)), t = null), r.set(o.value.compartment, o.value.extension)) : o.is(G.reconfigure) ? (t = null, i = o.value) : o.is(G.appendConfig) && (t = null, i = ms(i).concat(o.value));
    let s;
    t ? s = e.startState.values.slice() : (t = Tc.resolve(i, r, this), s = new J(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (l, a) => a.reconfigure(l, this), null).values), new J(t, e.newDoc, e.newSelection, s, (o, l) => l.update(o, e), e);
  }
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: S.cursor(t.from + e.length)
    }));
  }
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), r = this.changes(i.changes), s = [i.range], o = ms(i.effects);
    for (let l = 1; l < t.ranges.length; l++) {
      let a = e(t.ranges[l]), c = this.changes(a.changes), h = c.map(r);
      for (let f = 0; f < l; f++)
        s[f] = s[f].map(h);
      let u = r.mapDesc(c, !0);
      s.push(a.range.map(u)), r = r.compose(h), o = G.mapEffects(o, h).concat(G.mapEffects(ms(a.effects), u));
    }
    return {
      changes: r,
      selection: S.create(s, t.mainIndex),
      effects: o
    };
  }
  changes(e = []) {
    return e instanceof Oe ? e : Oe.of(e, this.doc.length, this.facet(J.lineSeparator));
  }
  toText(e) {
    return Z.of(e.split(this.facet(J.lineSeparator) || fd));
  }
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Fo(this, t), Mc(this, t));
  }
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let r = e[i];
        r instanceof Ue && this.config.address[r.id] != null && (t[i] = r.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let r = [];
    if (i) {
      for (let s in i)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = i[s], l = e[s];
          r.push(o.init((a) => o.spec.fromJSON(l, a)));
        }
    }
    return J.create({
      doc: e.doc,
      selection: S.fromJSON(e.selection),
      extensions: t.extensions ? r.concat([t.extensions]) : r
    });
  }
  static create(e = {}) {
    let t = Tc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof Z ? e.doc : Z.of((e.doc || "").split(t.staticFacet(J.lineSeparator) || fd)), r = e.selection ? e.selection instanceof S ? e.selection : S.single(e.selection.anchor, e.selection.head) : S.single(0);
    return ik(r, i.length), t.staticFacet(ok) || (r = r.asSingle()), new J(t, i, r, t.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  get tabSize() {
    return this.facet(J.tabSize);
  }
  get lineBreak() {
    return this.facet(J.lineSeparator) || `
`;
  }
  get readOnly() {
    return this.facet(uk);
  }
  phrase(e, ...t) {
    for (let i of this.facet(J.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, r) => {
      if (r == "$")
        return "$";
      let s = +(r || 1);
      return !s || s > t.length ? i : t[s - 1];
    })), e;
  }
  languageDataAt(e, t, i = -1) {
    let r = [];
    for (let s of this.facet(sk))
      for (let o of s(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && r.push(o[e]);
    return r;
  }
  charCategorizer(e) {
    return Dde(this.languageDataAt("wordChars", e).join(""));
  }
  wordAt(e) {
    let { text: t, from: i, length: r } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - i, l = e - i;
    for (; o > 0; ) {
      let a = Le(t, o, !1);
      if (s(t.slice(a, o)) != Ce.Word)
        break;
      o = a;
    }
    for (; l < r; ) {
      let a = Le(t, l);
      if (s(t.slice(l, a)) != Ce.Word)
        break;
      l = a;
    }
    return o == l ? null : S.range(o + i, l + i);
  }
}
J.allowMultipleSelections = ok;
J.tabSize = /* @__PURE__ */ E.define({
  combine: (n) => n.length ? n[0] : 4
});
J.lineSeparator = lk;
J.readOnly = uk;
J.phrases = /* @__PURE__ */ E.define({
  compare(n, e) {
    let t = Object.keys(n), i = Object.keys(e);
    return t.length == i.length && t.every((r) => n[r] == e[r]);
  }
});
J.languageData = sk;
J.changeFilter = ak;
J.transactionFilter = ck;
J.transactionExtender = hk;
to.reconfigure = /* @__PURE__ */ G.define();
function Gn(n, e, t = {}) {
  let i = {};
  for (let r of n)
    for (let s of Object.keys(r)) {
      let o = r[s], l = i[s];
      if (l === void 0)
        i[s] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(t, s))
          i[s] = t[s](l, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let r in e)
    i[r] === void 0 && (i[r] = e[r]);
  return i;
}
class ai {
  eq(e) {
    return this == e;
  }
  range(e, t = e) {
    return el.create(e, t, this);
  }
}
ai.prototype.startSide = ai.prototype.endSide = 0;
ai.prototype.point = !1;
ai.prototype.mapMode = qe.TrackDel;
class el {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  static create(e, t, i) {
    return new el(e, t, i);
  }
}
function wd(n, e) {
  return n.from - e.from || n.value.startSide - e.value.startSide;
}
class xg {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = r;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(e, t, i, r = 0) {
    let s = i ? this.to : this.from;
    for (let o = r, l = s.length; ; ) {
      if (o == l)
        return o;
      let a = o + l >> 1, c = s[a] - e || (i ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == o)
        return c >= 0 ? o : l;
      c >= 0 ? l = a : o = a + 1;
    }
  }
  between(e, t, i, r) {
    for (let s = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, s); s < o; s++)
      if (r(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], r = [], s = [], o = -1, l = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], h = this.from[a] + e, u = this.to[a] + e, f, d;
      if (h == u) {
        let p = t.mapPos(h, c.startSide, c.mapMode);
        if (p == null || (f = d = p, c.startSide != c.endSide && (d = t.mapPos(h, c.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(h, c.startSide), d = t.mapPos(u, c.endSide), f > d || f == d && c.startSide > 0 && c.endSide <= 0)
        continue;
      (d - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (l = Math.max(l, d - f)), i.push(c), r.push(f - o), s.push(d - o));
    }
    return { mapped: i.length ? new xg(r, s, i, l) : null, pos: o };
  }
}
class W {
  constructor(e, t, i, r) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = r;
  }
  static create(e, t, i, r) {
    return new W(e, t, i, r);
  }
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: r = 0, filterTo: s = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(wd)), this.isEmpty)
      return t.length ? W.of(t) : this;
    let l = new pk(this, null, -1).goto(0), a = 0, c = [], h = new Vt();
    for (; l.value || a < t.length; )
      if (a < t.length && (l.from - t[a].from || l.startSide - t[a].value.startSide) >= 0) {
        let u = t[a++];
        h.addInner(u.from, u.to, u.value) || c.push(u);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(l.chunkIndex) < t[a].from) && (!o || r > this.chunkEnd(l.chunkIndex) || s < this.chunkPos[l.chunkIndex]) && h.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || r > l.to || s < l.from || o(l.from, l.to, l.value)) && (h.addInner(l.from, l.to, l.value) || c.push(el.create(l.from, l.to, l.value))), l.next());
    return h.finishInner(this.nextLayer.isEmpty && !c.length ? W.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: r, filterTo: s }));
  }
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], r = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], a = this.chunk[o], c = e.touchesRange(l, l + a.length);
      if (c === !1)
        r = Math.max(r, a.maxPoint), t.push(a), i.push(e.mapPos(l));
      else if (c === !0) {
        let { mapped: h, pos: u } = a.map(l, e);
        h && (r = Math.max(r, h.maxPoint), t.push(h), i.push(u));
      }
    }
    let s = this.nextLayer.map(e);
    return t.length == 0 ? s : new W(i, t, s || W.empty, r);
  }
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let r = 0; r < this.chunk.length; r++) {
        let s = this.chunkPos[r], o = this.chunk[r];
        if (t >= s && e <= s + o.length && o.between(s, e - s, t - s, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  iter(e = 0) {
    return tl.from([this]).goto(e);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(e, t = 0) {
    return tl.from(e).goto(t);
  }
  static compare(e, t, i, r, s = -1) {
    let o = e.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), l = t.filter((u) => u.maxPoint > 0 || !u.isEmpty && u.maxPoint >= s), a = $1(o, l, i), c = new po(o, a, s), h = new po(l, a, s);
    i.iterGaps((u, f, d) => H1(c, u, h, f, d, r)), i.empty && i.length == 0 && H1(c, 0, h, 0, 0, r);
  }
  static eq(e, t, i = 0, r) {
    r == null && (r = 1e9 - 1);
    let s = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), o = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let l = $1(s, o), a = new po(s, l, 0).goto(i), c = new po(o, l, 0).goto(i);
    for (; ; ) {
      if (a.to != c.to || !vd(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > r)
        return !0;
      a.next(), c.next();
    }
  }
  static spans(e, t, i, r, s = -1) {
    let o = new po(e, null, s).goto(t), l = t, a = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, i);
      if (o.point) {
        let h = o.activeForPoint(o.to), u = o.pointFrom < t ? h.length + 1 : Math.min(h.length, a);
        r.point(l, c, o.point, h, u, o.pointRank), a = Math.min(o.openEnd(c), h.length);
      } else
        c > l && (r.span(l, c, o.active, a), a = o.openEnd(c));
      if (o.to > i)
        return a + (o.point && o.to > i ? 1 : 0);
      l = o.to, o.next();
    }
  }
  static of(e, t = !1) {
    let i = new Vt();
    for (let r of e instanceof el ? [e] : t ? Ede(e) : e)
      i.add(r.from, r.to, r.value);
    return i.finish();
  }
}
W.empty = /* @__PURE__ */ new W([], [], null, -1);
function Ede(n) {
  if (n.length > 1)
    for (let e = n[0], t = 1; t < n.length; t++) {
      let i = n[t];
      if (wd(e, i) > 0)
        return n.slice().sort(wd);
      e = i;
    }
  return n;
}
W.empty.nextLayer = W.empty;
class Vt {
  finishChunk(e) {
    this.chunks.push(new xg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new Vt())).add(e, t, i);
  }
  addInner(e, t, i) {
    let r = e - this.lastTo || i.startSide - this.last.endSide;
    if (r <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return r < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  finish() {
    return this.finishInner(W.empty);
  }
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = W.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function $1(n, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let s of n)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && i.set(s.chunk[o], s.chunkPos[o]);
  let r = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let l = i.get(s.chunk[o]);
      l != null && (t ? t.mapPos(l) : l) == s.chunkPos[o] && !(t != null && t.touchesRange(l, l + s.chunk[o].length)) && r.add(s.chunk[o]);
    }
  return r;
}
class pk {
  constructor(e, t, i, r = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = r;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let r = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(r) || this.layer.chunkEnd(this.chunkIndex) < e || r.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let r = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < r) && this.setRangeIndex(r);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class tl {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let r = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && r.push(new pk(o, t, i, s));
    return r.length == 1 ? r[0] : new tl(r);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Gu(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Gu(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Gu(this.heap, 0);
    }
  }
}
function Gu(n, e) {
  for (let t = n[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= n.length)
      break;
    let r = n[i];
    if (i + 1 < n.length && r.compare(n[i + 1]) >= 0 && (r = n[i + 1], i++), t.compare(r) < 0)
      break;
    n[i] = t, n[e] = r, e = i;
  }
}
class po {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = tl.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    sa(this.active, e), sa(this.activeTo, e), sa(this.activeRank, e), this.minActive = q1(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: r, rank: s } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= s; )
      t++;
    oa(this.active, t, i), oa(this.activeTo, t, r), oa(this.activeRank, t, s), e && oa(e, t, this.cursor.from), this.minActive = q1(this.active, this.activeTo);
  }
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > e) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && sa(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let r = i.length - 1; r >= 0 && i[r] < e; r--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function H1(n, e, t, i, r, s) {
  n.goto(e), t.goto(i);
  let o = i + r, l = i, a = i - e;
  for (; ; ) {
    let c = n.to + a - t.to || n.endSide - t.endSide, h = c < 0 ? n.to + a : t.to, u = Math.min(h, o);
    if (n.point || t.point ? n.point && t.point && (n.point == t.point || n.point.eq(t.point)) && vd(n.activeForPoint(n.to), t.activeForPoint(t.to)) || s.comparePoint(l, u, n.point, t.point) : u > l && !vd(n.active, t.active) && s.compareRange(l, u, n.active, t.active), h > o)
      break;
    l = h, c <= 0 && n.next(), c >= 0 && t.next();
  }
}
function vd(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] != e[t] && !n[t].eq(e[t]))
      return !1;
  return !0;
}
function sa(n, e) {
  for (let t = e, i = n.length - 1; t < i; t++)
    n[t] = n[t + 1];
  n.pop();
}
function oa(n, e, t) {
  for (let i = n.length - 1; i >= e; i--)
    n[i + 1] = n[i];
  n[e] = t;
}
function q1(n, e) {
  let t = -1, i = 1e9;
  for (let r = 0; r < e.length; r++)
    (e[r] - i || n[r].endSide - n[t].endSide) < 0 && (t = r, i = e[r]);
  return t;
}
function no(n, e, t = n.length) {
  let i = 0;
  for (let r = 0; r < t; )
    n.charCodeAt(r) == 9 ? (i += e - i % e, r++) : (i++, r = Le(n, r));
  return i;
}
function Oc(n, e, t, i) {
  for (let r = 0, s = 0; ; ) {
    if (s >= e)
      return r;
    if (r == n.length)
      break;
    s += n.charCodeAt(r) == 9 ? t - s % t : 1, r = Le(n, r);
  }
  return i === !0 ? -1 : n.length;
}
const xd = "\u037C", V1 = typeof Symbol > "u" ? "__" + xd : Symbol.for(xd), kd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), z1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class Ct {
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function r(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, l, a, c) {
      let h = [], u = /^@(\w+)\b/.exec(o[0]), f = u && u[1] == "keyframes";
      if (u && l == null)
        return a.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          s(
            d.split(/,\s*/).map((g) => o.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            a
          );
        else if (p && typeof p == "object") {
          if (!u)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          s(r(d), p, h, f);
        } else
          p != null && h.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (h.length || f) && a.push((i && !u && !c ? o.map(i) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e)
      s(r(o), e[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let e = z1[V1] || 1;
    return z1[V1] = e + 1, xd + e.toString(36);
  }
  static mount(e, t, i) {
    let r = e[kd], s = i && i.nonce;
    r ? s && r.setNonce(s) : r = new Tde(e, s), r.mount(Array.isArray(t) ? t : [t]);
  }
}
let U1 = /* @__PURE__ */ new Map();
class Tde {
  constructor(e, t) {
    let i = e.ownerDocument || e, r = i.defaultView;
    if (!e.head && e.adoptedStyleSheets && r.CSSStyleSheet) {
      let s = U1.get(i);
      if (s)
        return e.adoptedStyleSheets = [s.sheet, ...e.adoptedStyleSheets], e[kd] = s;
      this.sheet = new r.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], U1.set(i, this);
    } else {
      this.styleTag = i.createElement("style"), t && this.styleTag.setAttribute("nonce", t);
      let s = e.head || e;
      s.insertBefore(this.styleTag, s.firstChild);
    }
    this.modules = [], e[kd] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, r = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], l = this.modules.indexOf(o);
      if (l < r && l > -1 && (this.modules.splice(l, 1), r--, l = -1), l == -1) {
        if (this.modules.splice(r++, 0, o), t)
          for (let a = 0; a < o.rules.length; a++)
            t.insertRule(o.rules[a], i++);
      } else {
        for (; r < l; )
          i += this.modules[r++].rules.length;
        i += o.rules.length, r++;
      }
    }
    if (!t) {
      let s = "";
      for (let o = 0; o < this.modules.length; o++)
        s += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = s;
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var zi = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, nl = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, Mde = typeof navigator < "u" && /Mac/.test(navigator.platform), Ode = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var nt = 0; nt < 10; nt++)
  zi[48 + nt] = zi[96 + nt] = String(nt);
for (var nt = 1; nt <= 24; nt++)
  zi[nt + 111] = "F" + nt;
for (var nt = 65; nt <= 90; nt++)
  zi[nt] = String.fromCharCode(nt + 32), nl[nt] = String.fromCharCode(nt);
for (var Ku in zi)
  nl.hasOwnProperty(Ku) || (nl[Ku] = zi[Ku]);
function Lde(n) {
  var e = Mde && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || Ode && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? nl : zi)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Lc(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function _d(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Rde(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function ec(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return _d(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function il(n) {
  return n.nodeType == 3 ? Mr(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function Rc(n, e, t, i) {
  return t ? W1(n, e, t, i, -1) || W1(n, e, t, i, 1) : !1;
}
function Ic(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function W1(n, e, t, i, r) {
  for (; ; ) {
    if (n == t && e == i)
      return !0;
    if (e == (r < 0 ? 0 : Ui(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Ic(n) + (r < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (r < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = r < 0 ? Ui(n) : 0;
    } else
      return !1;
  }
}
function Ui(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function kg(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function Ide(n) {
  return {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function Bde(n, e, t, i, r, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let h = n, u = !1; h && !u; )
    if (h.nodeType == 1) {
      let f, d = h == a.body;
      if (d)
        f = Ide(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (u = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let m = h.getBoundingClientRect();
        f = {
          left: m.left,
          right: m.left + h.clientWidth,
          top: m.top,
          bottom: m.top + h.clientHeight
        };
      }
      let p = 0, g = 0;
      if (r == "nearest")
        e.top < f.top ? (g = -(f.top - e.top + o), t > 0 && e.bottom > f.bottom + g && (g = e.bottom - f.bottom + g + o)) : e.bottom > f.bottom && (g = e.bottom - f.bottom + o, t < 0 && e.top - g < f.top && (g = -(f.top + g - e.top + o)));
      else {
        let m = e.bottom - e.top, b = f.bottom - f.top;
        g = (r == "center" && m <= b ? e.top + m / 2 - b / 2 : r == "start" || r == "center" && t < 0 ? e.top - o : e.bottom - b + o) - f.top;
      }
      if (i == "nearest" ? e.left < f.left ? (p = -(f.left - e.left + s), t > 0 && e.right > f.right + p && (p = e.right - f.right + p + s)) : e.right > f.right && (p = e.right - f.right + s, t < 0 && e.left < f.left + p && (p = -(f.left + p - e.left + s))) : p = (i == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : i == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, p || g)
        if (d)
          c.scrollBy(p, g);
        else {
          let m = 0, b = 0;
          if (g) {
            let y = h.scrollTop;
            h.scrollTop += g, b = h.scrollTop - y;
          }
          if (p) {
            let y = h.scrollLeft;
            h.scrollLeft += p, m = h.scrollLeft - y;
          }
          e = {
            left: e.left - m,
            top: e.top - b,
            right: e.right - m,
            bottom: e.bottom - b
          }, m && Math.abs(m - p) < 1 && (i = "nearest"), b && Math.abs(b - g) < 1 && (r = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function Nde(n) {
  let e = n.ownerDocument;
  for (let t = n.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class Pde {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? Ui(t) : 0), i, Math.min(e.focusOffset, i ? Ui(i) : 0));
  }
  set(e, t, i, r) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = r;
  }
}
let Qr = null;
function gk(n) {
  if (n.setActive)
    return n.setActive();
  if (Qr)
    return n.focus(Qr);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(Qr == null ? {
    get preventScroll() {
      return Qr = { preventScroll: !0 }, !0;
    }
  } : void 0), !Qr) {
    Qr = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], r = e[t++], s = e[t++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let j1;
function Mr(n, e, t = e) {
  let i = j1 || (j1 = document.createRange());
  return i.setEnd(n, t), i.setStart(n, e), i;
}
function bs(n, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, r = new KeyboardEvent("keydown", i);
  r.synthetic = !0, n.dispatchEvent(r);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, n.dispatchEvent(s), r.defaultPrevented || s.defaultPrevented;
}
function Fde(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function mk(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function $de(n, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Ui(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let r = t.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (t = r, i = Ui(t));
    } else {
      if (t == n)
        return !0;
      i = Ic(t), t = t.parentNode;
    }
}
function bk(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
class xt {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new xt(e.parentNode, Ic(e), t);
  }
  static after(e, t) {
    return new xt(e.parentNode, Ic(e) + 1, t);
  }
}
const _g = [];
class ye {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, r = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = r ? r.nextSibling : i.firstChild)) {
            let l = ye.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = r ? r.nextSibling : i.firstChild, t && !t.written && t.node == i && s != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; s && s != o.dom; )
            s = G1(s);
        else
          i.insertBefore(o.dom, s);
        r = o.dom;
      }
      for (s = r ? r.nextSibling : i.firstChild, s && t && t.node == i && (t.written = !0); s; )
        s = G1(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let r = Ui(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? r = -1 : r = 1), e = s;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !ye.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let o = this.children[r];
      if (o.dom == i)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let r = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = i, h = i; a < this.children.length; a++) {
      let u = this.children[a], f = c + u.length;
      if (c < e && f > t)
        return u.domBoundsAround(e, t, c);
      if (f >= e && r == -1 && (r = a, s = c), c > t && u.dom.parentNode == this.dom) {
        o = a, l = h;
        break;
      }
      h = f, c = f + u.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? i + this.length : l,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = _g) {
    this.markDirty();
    for (let r = e; r < t; r++) {
      let s = this.children[r];
      s.parent == this && s.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new yk(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, r, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ye.prototype.breakAfter = 0;
function G1(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class yk {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function wk(n, e, t, i, r, s, o, l, a) {
  let { children: c } = n, h = c.length ? c[e] : null, u = s.length ? s[s.length - 1] : null, f = u ? u.breakAfter : o;
  if (!(e == i && h && !o && !f && s.length < 2 && h.merge(t, r, s.length ? u : null, t == 0, l, a))) {
    if (i < c.length) {
      let d = c[i];
      d && r < d.length ? (e == i && (d = d.split(r), r = 0), !f && u && d.merge(0, r, u, !0, 0, a) ? s[s.length - 1] = d : (r && d.merge(0, r, null, !1, 0, a), s.push(d))) : d != null && d.breakAfter && (u ? u.breakAfter = 1 : o = 1), i++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && s.length && h.merge(t, h.length, s[0], !1, l, 0) ? h.breakAfter = s.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, l, 0), e++)); e < i && s.length; )
      if (c[i - 1].become(s[s.length - 1]))
        i--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < i || s.length) && n.replaceChildren(e, i, s);
  }
}
function vk(n, e, t, i, r, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: h } = o.findPos(e, -1), u = e - t;
  for (let f of i)
    u += f.length;
  n.length += u, wk(n, c, h, l, a, i, 0, r, s);
}
const ls = "\uFFFF";
class xk {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(J.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += ls;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let s = this.text.length;
      this.readNode(r);
      let o = r.nextSibling;
      if (o == t)
        break;
      let l = ye.get(r), a = ye.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : K1(r)) || K1(o) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (l = r.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(i, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      i = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = ye.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
}
function K1(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
class Y1 {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
let Ft = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Sd = typeof document < "u" ? document : { documentElement: { style: {} } };
const Cd = /* @__PURE__ */ /Edge\/(\d+)/.exec(Ft.userAgent), kk = /* @__PURE__ */ /MSIE \d/.test(Ft.userAgent), Ad = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ft.userAgent), Nh = !!(kk || Ad || Cd), J1 = !Nh && /* @__PURE__ */ /gecko\/(\d+)/i.test(Ft.userAgent), Yu = !Nh && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Ft.userAgent), Z1 = "webkitFontSmoothing" in Sd.documentElement.style, _k = !Nh && /* @__PURE__ */ /Apple Computer/.test(Ft.vendor), X1 = _k && (/* @__PURE__ */ /Mobile\/\w+/.test(Ft.userAgent) || Ft.maxTouchPoints > 2);
var N = {
  mac: X1 || /* @__PURE__ */ /Mac/.test(Ft.platform),
  windows: /* @__PURE__ */ /Win/.test(Ft.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Ft.platform),
  ie: Nh,
  ie_version: kk ? Sd.documentMode || 6 : Ad ? +Ad[1] : Cd ? +Cd[1] : 0,
  gecko: J1,
  gecko_version: J1 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Ft.userAgent) || [0, 0])[1] : 0,
  chrome: !!Yu,
  chrome_version: Yu ? +Yu[1] : 0,
  ios: X1,
  android: /* @__PURE__ */ /Android\b/.test(Ft.userAgent),
  webkit: Z1,
  safari: _k,
  webkit_version: Z1 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Sd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Hde = 256;
class Vn extends ye {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof Vn) || this.length - (t - e) + i.length > Hde || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Vn(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new xt(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return qde(this.dom, e, t);
  }
}
class ci extends ye {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let r of t)
      r.setParent(this);
  }
  setAttrs(e) {
    if (mk(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof ci && i.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (vk(this, e, t, i ? i.children : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, r = -1, s = 0;
    for (let l of this.children) {
      let a = i + l.length;
      a > e && t.push(i < e ? l.split(e - i) : l), r < 0 && i >= e && (r = s), i = a, s++;
    }
    let o = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new ci(this.mark, t, o);
  }
  domAtPos(e) {
    return Sk(this, e);
  }
  coordsAt(e, t) {
    return Ak(this, e, t);
  }
}
function qde(n, e, t) {
  let i = n.nodeValue.length;
  e > i && (e = i);
  let r = e, s = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? N.chrome || N.gecko || (e ? (r--, o = 1) : s < i && (s++, o = -1)) : t < 0 ? r-- : s < i && s++;
  let l = Mr(n, r, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return N.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? kg(a, o < 0) : a || null;
}
class Mi extends ye {
  static create(e, t, i) {
    return new Mi(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let t = Mi.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof Mi) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof Mi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Z.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : Z.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? xt.before(this.dom) : xt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? r.length - 1 : 0; s = r[l], !(e > 0 ? l == 0 : l == r.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return kg(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Is extends ye {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Is && e.side == this.side;
  }
  split() {
    return new Is(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? xt.before(this.dom) : xt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Z.empty;
  }
  get isHidden() {
    return !0;
  }
}
Vn.prototype.children = Mi.prototype.children = Is.prototype.children = _g;
function Sk(n, e) {
  let t = n.dom, { children: i } = n, r = 0;
  for (let s = 0; r < i.length; r++) {
    let o = i[r], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = r; s > 0; s--) {
    let o = i[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = r; s < i.length; s++) {
    let o = i[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new xt(t, 0);
}
function Ck(n, e, t) {
  let i, { children: r } = n;
  t > 0 && e instanceof ci && r.length && (i = r[r.length - 1]) instanceof ci && i.mark.eq(e.mark) ? Ck(i, e.children[0], t - 1) : (r.push(e), e.setParent(n)), n.length += e.length;
}
function Ak(n, e, t) {
  let i = null, r = -1, s = null, o = -1;
  function l(c, h) {
    for (let u = 0, f = 0; u < c.children.length && f <= h; u++) {
      let d = c.children[u], p = f + d.length;
      p >= h && (d.children.length ? l(d, h - f) : (!s || s.isHidden && t > 0) && (p > h || f == p && d.getSide() > 0) ? (s = d, o = h - f) : (f < h || f == p && d.getSide() < 0 && !d.isHidden) && (i = d, r = h - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? i : s) || i || s;
  return a ? a.coordsAt(Math.max(0, a == i ? r : o), t) : Vde(n);
}
function Vde(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = il(e);
  return t[t.length - 1] || null;
}
function Dd(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const Q1 = /* @__PURE__ */ Object.create(null);
function Sg(n, e, t) {
  if (n == e)
    return !0;
  n || (n = Q1), e || (e = Q1);
  let i = Object.keys(n), r = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != r.length - (t && r.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != t && (r.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function Ed(n, e, t) {
  let i = !1;
  if (e)
    for (let r in e)
      t && r in t || (i = !0, r == "style" ? n.style.cssText = "" : n.removeAttribute(r));
  if (t)
    for (let r in t)
      e && e[r] == t[r] || (i = !0, r == "style" ? n.style.cssText = t[r] : n.setAttribute(r, t[r]));
  return i;
}
function zde(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let i = n.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class mi {
  eq(e) {
    return !1;
  }
  updateDOM(e, t) {
    return !1;
  }
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, t, i) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(e) {
  }
}
var Me = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(Me || (Me = {}));
class U extends ai {
  constructor(e, t, i, r) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = r;
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new Ol(e);
  }
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Wi(e, t, t, i, e.widget || null, !1);
  }
  static replace(e) {
    let t = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: s, end: o } = Dk(e, t);
      i = (s ? t ? -3e8 : -1 : 5e8) - 1, r = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Wi(e, i, r, t, e.widget || null, !0);
  }
  static line(e) {
    return new Ll(e);
  }
  static set(e, t = !1) {
    return W.of(e, t);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
U.none = W.empty;
class Ol extends U {
  constructor(e) {
    let { start: t, end: i } = Dk(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof Ol && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Sg(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Ol.prototype.point = !1;
class Ll extends U {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ll && this.spec.class == e.spec.class && Sg(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Ll.prototype.mapMode = qe.TrackBefore;
Ll.prototype.point = !0;
class Wi extends U {
  constructor(e, t, i, r, s, o) {
    super(t, i, s, e), this.block = r, this.isReplace = o, this.mapMode = r ? t <= 0 ? qe.TrackBefore : qe.TrackAfter : qe.TrackDel;
  }
  get type() {
    return this.startSide < this.endSide ? Me.WidgetRange : this.startSide <= 0 ? Me.WidgetBefore : Me.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Wi && Ude(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Wi.prototype.point = !0;
function Dk(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = n;
  return t == null && (t = n.inclusive), i == null && (i = n.inclusive), { start: t != null ? t : e, end: i != null ? i : e };
}
function Ude(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function Td(n, e, t, i = 0) {
  let r = t.length - 1;
  r >= 0 && t[r] + i >= n ? t[r] = Math.max(t[r], e) : t.push(n, e);
}
class wt extends ye {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e, t, i, r, s, o) {
    if (i) {
      if (!(i instanceof wt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), vk(this, e, t, i ? i.children : [], s, o), !0;
  }
  split(e) {
    let t = new wt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: r } = this.childPos(e);
    r && (t.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    !this.dom || (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Sg(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    Ck(this, e, t);
  }
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = Dd(t, this.attrs || {})), i && (this.attrs = Dd({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return Sk(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (mk(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Ed(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let r = this.dom.lastChild;
    for (; r && ye.get(r) instanceof ci; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = ye.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!N.ios || !this.children.some((s) => s instanceof Vn))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof Vn) || /[^ -~]/.test(i.text))
        return null;
      let r = il(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, t = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = Ak(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let o = (s - r.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  get type() {
    return Me.Text;
  }
  static find(e, t) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let s = e.children[i], o = r + s.length;
      if (o >= t) {
        if (s instanceof wt)
          return s;
        if (o > t)
          break;
      }
      r = o + s.breakAfter;
    }
    return null;
  }
}
class wr extends ye {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof wr) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? xt.before(this.dom) : xt.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new wr(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return _g;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Z.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof wr && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.type = e.type, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class $o {
  constructor(e, t, i, r) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof wr && e.type == Me.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new wt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(la(new Is(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let r = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(la(new Vn(this.text.slice(this.textOff, this.textOff + r)), t), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, t, i, r) {
    this.buildText(t - e, i, r), this.pos = t, this.openStart < 0 && (this.openStart = r);
  }
  point(e, t, i, r, s, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Wi) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (i instanceof Wi)
      if (i.block) {
        let { type: a } = i;
        a == Me.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new wr(i.widget || new eb("div"), l, a));
      } else {
        let a = Mi.create(i.widget || new eb("span"), l, l ? 0 : i.startSide), c = this.atCursorPos && !a.isEditable && s <= r.length && (e < t || i.startSide > 0), h = !a.isEditable && (e < t || s > r.length || i.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (u.append(la(new Is(1), r), s), s = r.length + Math.max(0, s - r.length)), u.append(la(a, r), s), this.atCursorPos = h, this.pendingBuffer = h ? e < t || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, i, r, s) {
    let o = new $o(e, t, i, s);
    return o.openEnd = W.spans(r, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function la(n, e) {
  for (let t of e)
    n = new ci(t, [n], n.length);
  return n;
}
class eb extends mi {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const Ek = /* @__PURE__ */ E.define(), Tk = /* @__PURE__ */ E.define(), Mk = /* @__PURE__ */ E.define(), Ok = /* @__PURE__ */ E.define(), Md = /* @__PURE__ */ E.define(), Lk = /* @__PURE__ */ E.define(), Rk = /* @__PURE__ */ E.define(), Ik = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
}), Bk = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
});
class Bc {
  constructor(e, t = "nearest", i = "nearest", r = 5, s = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = r, this.xMargin = s;
  }
  map(e) {
    return e.empty ? this : new Bc(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const tb = /* @__PURE__ */ G.define({ map: (n, e) => n.map(e) });
function Kt(n, e, t) {
  let i = n.facet(Ok);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const Ph = /* @__PURE__ */ E.define({ combine: (n) => n.length ? n[0] : !0 });
let Wde = 0;
const ko = /* @__PURE__ */ E.define();
class Re {
  constructor(e, t, i, r) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.extension = r(this);
  }
  static define(e, t) {
    const { eventHandlers: i, provide: r, decorations: s } = t || {};
    return new Re(Wde++, e, i, (o) => {
      let l = [ko.of(o)];
      return s && l.push(rl.of((a) => {
        let c = a.plugin(o);
        return c ? s(c) : U.none;
      })), r && l.push(r(o)), l;
    });
  }
  static fromClass(e, t) {
    return Re.define((i) => new e(i), t);
  }
}
class Ju {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (Kt(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        Kt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Kt(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Nk = /* @__PURE__ */ E.define(), Cg = /* @__PURE__ */ E.define(), rl = /* @__PURE__ */ E.define(), Ag = /* @__PURE__ */ E.define(), Pk = /* @__PURE__ */ E.define();
function nb(n, e, t) {
  let i = n.state.facet(Pk);
  if (!i.length)
    return i;
  let r = i.map((o) => o instanceof Function ? o(n) : o), s = [];
  return W.spans(r, e, t, {
    point() {
    },
    span(o, l, a, c) {
      let h = s;
      for (let u = a.length - 1; u >= 0; u--, c--) {
        let f = a[u].spec.bidiIsolate, d;
        if (f != null)
          if (c > 0 && h.length && (d = h[h.length - 1]).to == o && d.direction == f)
            d.to = l, h = d.inner;
          else {
            let p = { from: o, to: l, direction: f, inner: [] };
            h.push(p), h = p.inner;
          }
      }
    }
  }), s;
}
const Fk = /* @__PURE__ */ E.define();
function $k(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let s of n.state.facet(Fk)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (r = Math.max(r, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: r };
}
const _o = /* @__PURE__ */ E.define();
class Yt {
  constructor(e, t, i, r) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new Yt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let r = e[t - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let r = 0, s = 0, o = 0, l = 0; ; r++) {
      let a = r == e.length ? null : e[r], c = o - l, h = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < h; ) {
        let u = t[s], f = t[s + 1], d = Math.max(l, u), p = Math.min(h, f);
        if (d <= p && new Yt(d + c, p + c, d, p).addToSet(i), f > h)
          break;
        s += 2;
      }
      if (!a)
        return i;
      new Yt(a.fromA, a.toA, a.fromB, a.toB).addToSet(i), o = a.toA, l = a.toB;
    }
  }
}
class Nc {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Oe.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, o, l, a) => r.push(new Yt(s, o, l, a))), this.changedRanges = r;
  }
  static create(e, t, i) {
    return new Nc(e, t, i);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Te = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(Te || (Te = {}));
const sl = Te.LTR, Hk = Te.RTL;
function qk(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const jde = /* @__PURE__ */ qk("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Gde = /* @__PURE__ */ qk("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Od = /* @__PURE__ */ Object.create(null), xn = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Od[e] = t, Od[t] = -e;
}
function Kde(n) {
  return n <= 247 ? jde[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? Gde[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8203 ? 256 : 64336 <= n && n <= 65023 ? 4 : n == 8204 ? 256 : 1;
}
const Yde = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Oi {
  get dir() {
    return this.level % 2 ? Hk : sl;
  }
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  static find(e, t, i, r) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == i)
          return o;
        (s < 0 || (r != 0 ? r < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function Vk(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let i = n[t], r = e[t];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !Vk(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const ue = [];
function Jde(n, e, t, i, r) {
  for (let s = 0; s <= i.length; s++) {
    let o = s ? i[s - 1].to : e, l = s < i.length ? i[s].from : t, a = s ? 256 : r;
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = Kde(n.charCodeAt(c));
      f == 512 ? f = h : f == 8 && u == 4 && (f = 16), ue[c] = f == 4 ? 2 : f, f & 7 && (u = f), h = f;
    }
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = ue[c];
      if (f == 128)
        c < l - 1 && h == ue[c + 1] && h & 24 ? f = ue[c] = h : ue[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && ue[d] == 64; )
          d++;
        let p = c && h == 8 || d < t && ue[d] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let g = c; g < d; g++)
          ue[g] = p;
        c = d - 1;
      } else
        f == 8 && u == 1 && (ue[c] = 1);
      h = f, f & 7 && (u = f);
    }
  }
}
function Zde(n, e, t, i, r) {
  let s = r == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= i.length; o++) {
    let c = o ? i[o - 1].to : e, h = o < i.length ? i[o].from : t;
    for (let u = c, f, d, p; u < h; u++)
      if (d = Od[f = n.charCodeAt(u)])
        if (d < 0) {
          for (let g = l - 3; g >= 0; g -= 3)
            if (xn[g + 1] == -d) {
              let m = xn[g + 2], b = m & 2 ? r : m & 4 ? m & 1 ? s : r : 0;
              b && (ue[u] = ue[xn[g]] = b), l = g;
              break;
            }
        } else {
          if (xn.length == 189)
            break;
          xn[l++] = u, xn[l++] = f, xn[l++] = a;
        }
      else if ((p = ue[u]) == 2 || p == 1) {
        let g = p == r;
        a = g ? 0 : 1;
        for (let m = l - 3; m >= 0; m -= 3) {
          let b = xn[m + 2];
          if (b & 2)
            break;
          if (g)
            xn[m + 2] |= 2;
          else {
            if (b & 4)
              break;
            xn[m + 2] |= 4;
          }
        }
      }
  }
}
function Xde(n, e, t, i) {
  for (let r = 0, s = i; r <= t.length; r++) {
    let o = r ? t[r - 1].to : n, l = r < t.length ? t[r].from : e;
    for (let a = o; a < l; ) {
      let c = ue[a];
      if (c == 256) {
        let h = a + 1;
        for (; ; )
          if (h == l) {
            if (r == t.length)
              break;
            h = t[r++].to, l = r < t.length ? t[r].from : e;
          } else if (ue[h] == 256)
            h++;
          else
            break;
        let u = s == 1, f = (h < e ? ue[h] : i) == 1, d = u == f ? u ? 1 : 2 : i;
        for (let p = h, g = r, m = g ? t[g - 1].to : n; p > a; )
          p == m && (p = t[--g].from, m = g ? t[g - 1].to : n), ue[--p] = d;
        a = h;
      } else
        s = c, a++;
    }
  }
}
function Ld(n, e, t, i, r, s, o) {
  let l = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let a = e, c = 0; a < t; ) {
      let h = !0, u = !1;
      if (c == s.length || a < s[c].from) {
        let g = ue[a];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? i : i + 1, p = a;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (u)
              break e;
            let g = s[c];
            if (!h)
              for (let m = g.to, b = c + 1; ; ) {
                if (m == t)
                  break e;
                if (b < s.length && s[b].from == m)
                  m = s[b++].to;
                else {
                  if (ue[m] == l)
                    break e;
                  break;
                }
              }
            if (c++, f)
              f.push(g);
            else {
              g.from > a && o.push(new Oi(a, g.from, d));
              let m = g.direction == sl != !(d % 2);
              Rd(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), a = g.to;
            }
            p = g.to;
          } else {
            if (p == t || (h ? ue[p] != l : ue[p] == l))
              break;
            p++;
          }
      f ? Ld(n, a, p, i + 1, r, f, o) : a < p && o.push(new Oi(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let h = !0, u = !1;
      if (!c || a > s[c - 1].to) {
        let g = ue[a - 1];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? i : i + 1, p = a;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (u)
              break e;
            let g = s[--c];
            if (!h)
              for (let m = g.from, b = c; ; ) {
                if (m == e)
                  break e;
                if (b && s[b - 1].to == m)
                  m = s[--b].from;
                else {
                  if (ue[m - 1] == l)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < a && o.push(new Oi(g.to, a, d));
              let m = g.direction == sl != !(d % 2);
              Rd(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), a = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (h ? ue[p - 1] != l : ue[p - 1] == l))
              break;
            p--;
          }
      f ? Ld(n, p, a, i + 1, r, f, o) : p < a && o.push(new Oi(p, a, d)), a = p;
    }
}
function Rd(n, e, t, i, r, s, o) {
  let l = e % 2 ? 2 : 1;
  Jde(n, r, s, i, l), Zde(n, r, s, i, l), Xde(r, s, i, l), Ld(n, r, s, e, t, i, o);
}
function Qde(n, e, t) {
  if (!n)
    return [new Oi(0, 0, e == Hk ? 1 : 0)];
  if (e == sl && !t.length && !Yde.test(n))
    return zk(n.length);
  if (t.length)
    for (; n.length > ue.length; )
      ue[ue.length] = 256;
  let i = [], r = e == sl ? 0 : 1;
  return Rd(n, r, r, t, 0, n.length, i), i;
}
function zk(n) {
  return [new Oi(0, n, 0)];
}
let Uk = "";
function epe(n, e, t, i, r) {
  var s;
  let o = i.head - n.from, l = -1;
  if (o == 0) {
    if (!r || !n.length)
      return null;
    e[0].level != t && (o = e[0].side(!1, t), l = 0);
  } else if (o == n.length) {
    if (r)
      return null;
    let f = e[e.length - 1];
    f.level != t && (o = f.side(!0, t), l = e.length - 1);
  }
  l < 0 && (l = Oi.find(e, o, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc));
  let a = e[l];
  o == a.side(r, t) && (a = e[l += r ? 1 : -1], o = a.side(!r, t));
  let c = r == (a.dir == t), h = Le(n.text, o, c);
  if (Uk = n.text.slice(Math.min(o, h), Math.max(o, h)), h != a.side(r, t))
    return S.cursor(h + n.from, c ? -1 : 1, a.level);
  let u = l == (r ? e.length - 1 : 0) ? null : e[l + (r ? 1 : -1)];
  return !u && a.level != t ? S.cursor(r ? n.to : n.from, r ? -1 : 1, t) : u && u.level < a.level ? S.cursor(u.side(!r, t) + n.from, r ? 1 : -1, u.level) : S.cursor(h + n.from, r ? -1 : 1, a.level);
}
class ib extends ye {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new wt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Yt(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: l, toA: a }) => a < this.minWidthFrom || l > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = this.view.inputState.composing < 0 ? null : npe(this.view, e.changes);
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from: l, to: a } = this.hasComposition;
      t = new Yt(l, a, e.changes.mapPos(l, -1), e.changes.mapPos(a, 1)).addToSet(t.slice());
    }
    this.hasComposition = i ? { from: i.range.fromB, to: i.range.toB } : null, (N.ie || N.chrome) && !i && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let r = this.decorations, s = this.updateDeco(), o = spe(r, s, e.changes);
    return t = Yt.extendWithRanges(t, o), !(this.flags & 7) && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length, i), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = N.chrome || N.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || r.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach((o) => o.flags &= -9);
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof wr && o.widget instanceof rb && s.push(o.dom);
    r.updateGaps(s);
  }
  updateChildren(e, t, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = r.length - 1; ; o--) {
      let l = o >= 0 ? r[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: h, toB: u } = l, f, d, p, g;
      if (i && i.range.fromB < u && i.range.toB > h) {
        let w = $o.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = $o.build(this.view.state.doc, i.range.toB, u, this.decorations, this.dynamicDecorationMap);
        d = w.breakAtStart, p = w.openStart, g = x.openEnd;
        let v = this.compositionView(i);
        x.breakAtStart ? v.breakAfter = 1 : x.content.length && v.merge(v.length, v.length, x.content[0], !1, x.openStart, 0) && (v.breakAfter = x.content[0].breakAfter, x.content.shift()), w.content.length && v.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat(v).concat(x.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = $o.build(this.view.state.doc, h, u, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: b } = s.findPos(c, 1), { i: y, off: k } = s.findPos(a, -1);
      wk(this, y, k, m, b, f, d, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new Vn(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: r } of e.marks)
      t = new ci(r, [t], t.length);
    let i = new wt();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8, this.markedForComposition.add(o);
      let l = ye.get(s);
      l != o && (l && (l.dom = null), o.setDOM(s));
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    t(e.line, r);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = r.childPos(i.off, 1), r = r.children[i.i], t(s >= 0 ? e.marks[s].node : e.text, r);
  }
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, s = !r && ec(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.domAtPos(l.anchor), c = l.empty ? a : this.domAtPos(l.head);
    if (N.gecko && l.empty && !this.hasComposition && tpe(a)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(u, a.node.childNodes[a.offset] || null)), a = c = new xt(u, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || !Rc(a.node, a.offset, h.anchorNode, h.anchorOffset) || !Rc(c.node, c.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      N.android && N.chrome && this.dom.contains(h.focusNode) && ope(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = Lc(this.view.root);
      if (u)
        if (l.empty) {
          if (N.gecko) {
            let f = ipe(a.node, a.offset);
            if (f && f != 3) {
              let d = jk(a.node, a.offset, f == 1 ? 1 : -1);
              d && (a = new xt(d, f == 1 ? 0 : d.nodeValue.length));
            }
          }
          u.collapse(a.node, a.offset), l.bidiLevel != null && h.caretBidiLevel != null && (h.caretBidiLevel = l.bidiLevel);
        } else if (u.extend) {
          u.collapse(a.node, a.offset);
          try {
            u.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(f);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new xt(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new xt(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = Lc(e.root), { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = wt.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    i.collapse(h.node, h.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && i.collapse(r, s);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = ye.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let r = this.children[t];
      if (i < r.length || r instanceof wt)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, r = this.children.length - 1; ; r--) {
      let s = this.children[r], o = i - s.breakAfter - s.length;
      if (e > o || e == o && s.type != Me.WidgetBefore && s.type != Me.WidgetAfter && (!r || t == 2 || this.children[r - 1].breakAfter || this.children[r - 1].type == Me.WidgetBefore && t > -2))
        return s.coordsAt(e - o, t);
      i = o;
    }
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), r = this.children[t];
    if (!(r instanceof wt))
      return null;
    for (; r.children.length; ) {
      let { i: l, off: a } = r.childPos(i, 1);
      for (; ; l++) {
        if (l == r.children.length)
          return null;
        if ((r = r.children[l]).length)
          break;
      }
      i = a;
    }
    if (!(r instanceof Vn))
      return null;
    let s = Le(r.text, i);
    if (s == i)
      return null;
    let o = Mr(r.dom, i, s).getClientRects();
    return !o.length || o[0].top >= o[0].bottom ? null : o[0];
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: r } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == Te.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let u = this.children[h], f = c + u.length;
      if (f > r)
        break;
      if (c >= i) {
        let d = u.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = u.dom.lastChild, g = p ? il(p) : [];
          if (g.length) {
            let m = g[g.length - 1], b = a ? m.right - d.left : d.right - m.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Te.RTL : Te.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof wt) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = il(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, r = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new yk(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let s = r == t.viewports.length ? null : t.viewports[r], o = s ? s.from - 1 : this.length;
      if (o > i) {
        let l = t.lineBlockAt(o).bottom - t.lineBlockAt(i).top;
        e.push(U.replace({
          widget: new rb(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return U.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(rl).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), r;
    if (!i)
      return;
    !t.empty && (r = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let s = $k(this.view), o = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    };
    Bde(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Te.LTR);
  }
}
function tpe(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
class rb extends mi {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function Wk(n) {
  let e = n.observer.selectionRange, t = e.focusNode && jk(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = ye.get(t), r, s;
  if (i instanceof Vn)
    r = i.posAtStart, s = r + i.length;
  else {
    e:
      for (let o = 0, l = t; ; ) {
        for (let c = l.previousSibling, h; c; c = c.previousSibling) {
          if (h = ye.get(c)) {
            r = s = h.posAtEnd + o;
            break e;
          }
          let u = new xk([], n.state);
          if (u.readNode(c), u.text.indexOf(ls) > -1)
            return null;
          o += u.text.length;
        }
        if (l = l.parentNode, !l)
          return null;
        let a = ye.get(l);
        if (a) {
          r = s = a.posAtStart + o;
          break;
        }
      }
  }
  return { from: r, to: s, node: t };
}
function npe(n, e) {
  let t = Wk(n);
  if (!t)
    return null;
  let { from: i, to: r, node: s } = t, o = e.mapPos(i, -1), l = e.mapPos(r, 1), a = s.nodeValue;
  if (/[\n\r]/.test(a))
    return null;
  if (l - o != a.length) {
    let f = e.mapPos(i, 1), d = e.mapPos(r, -1);
    if (d - f == a.length)
      o = f, l = d;
    else if (n.state.doc.sliceString(l - a.length, l) == a)
      o = l - a.length;
    else if (n.state.doc.sliceString(o, o + a.length) == a)
      l = o + a.length;
    else
      return null;
  }
  let { main: c } = n.state.selection;
  if (n.state.doc.sliceString(o, l) != a || o > c.head || l < c.head)
    return null;
  let h = [], u = new Yt(i, r, o, l);
  for (let f = s.parentNode; ; f = f.parentNode) {
    let d = ye.get(f);
    if (d instanceof ci)
      h.push({ node: f, deco: d.mark });
    else {
      if (d instanceof wt || f.nodeName == "DIV" && f.parentNode == n.contentDOM)
        return { range: u, text: s, marks: h, line: f };
      if (f != n.contentDOM)
        h.push({ node: f, deco: new Ol({
          inclusive: !0,
          attributes: zde(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function jk(n, e, t) {
  if (t <= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && r > 0)
        i = i.childNodes[r - 1], r = Ui(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && r < i.childNodes.length && t >= 0)
        i = i.childNodes[r], r = 0;
      else
        break;
    }
  return null;
}
function ipe(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let rpe = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Td(e, t, this.changes);
  }
  comparePoint(e, t) {
    Td(e, t, this.changes);
  }
};
function spe(n, e, t) {
  let i = new rpe();
  return W.compare(n, e, t, i), i.changes;
}
function ope(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function lpe(n, e, t = 1) {
  let i = n.charCategorizer(e), r = n.doc.lineAt(e), s = e - r.from;
  if (r.length == 0)
    return S.cursor(e);
  s == 0 ? t = 1 : s == r.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = Le(r.text, s, !1) : l = Le(r.text, s);
  let a = i(r.text.slice(o, l));
  for (; o > 0; ) {
    let c = Le(r.text, o, !1);
    if (i(r.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < r.length; ) {
    let c = Le(r.text, l);
    if (i(r.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return S.range(o + r.from, l + r.from);
}
function ape(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function cpe(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function Zu(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function sb(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function ob(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function Id(n, e, t) {
  let i, r, s, o, l = !1, a, c, h, u;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let g = il(p);
    for (let m = 0; m < g.length; m++) {
      let b = g[m];
      r && Zu(r, b) && (b = sb(ob(b, r.bottom), r.top));
      let y = ape(e, b), k = cpe(t, b);
      if (y == 0 && k == 0)
        return p.nodeType == 3 ? lb(p, e, t) : Id(p, e, t);
      if (!i || o > k || o == k && s > y) {
        i = p, r = b, s = y, o = k;
        let w = k ? t < b.top ? -1 : 1 : y ? e < b.left ? -1 : 1 : 0;
        l = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      y == 0 ? t > b.bottom && (!h || h.bottom < b.bottom) ? (a = p, h = b) : t < b.top && (!u || u.top > b.top) && (c = p, u = b) : h && Zu(h, b) ? h = ob(h, b.bottom) : u && Zu(u, b) && (u = sb(u, b.top));
    }
  }
  if (h && h.bottom >= t ? (i = a, r = h) : u && u.top <= t && (i = c, r = u), !i)
    return { node: n, offset: 0 };
  let f = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return lb(i, f, t);
  if (l && i.contentEditable != "false")
    return Id(i, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function lb(n, e, t) {
  let i = n.nodeValue.length, r = -1, s = 1e9, o = 0;
  for (let l = 0; l < i; l++) {
    let a = Mr(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let h = a[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let u = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && u < s) {
        let f = e >= (h.left + h.right) / 2, d = f;
        if ((N.chrome || N.gecko) && Mr(n, l).getBoundingClientRect().left == h.right && (d = !f), u <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        r = l + (d ? 1 : 0), s = u;
      }
    }
  }
  return { node: n, offset: r > -1 ? r : o > 0 ? n.nodeValue.length : 0 };
}
function Gk(n, e, t, i = -1) {
  var r, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: h, y: u } = e, f = u - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let w = n.viewState.heightOracle.textHeight / 2, x = !1; a = n.elementAtHeight(f), a.type != Me.Text; )
    for (; f = i > 0 ? a.bottom + w : a.top - w, !(f >= 0 && f <= c); ) {
      if (x)
        return t ? null : 0;
      x = !0, i = -i;
    }
  u = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : ab(n, o, a, h, u);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : ab(n, o, a, h, u);
  let p = n.dom.ownerDocument, g = n.root.elementFromPoint ? n.root : p, m = g.elementFromPoint(h, u);
  m && !n.contentDOM.contains(m) && (m = null), m || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), m = g.elementFromPoint(h, u), m && !n.contentDOM.contains(m) && (m = null));
  let b, y = -1;
  if (m && ((r = n.docView.nearest(m)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(h, u);
      w && ({ offsetNode: b, offset: y } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(h, u);
      w && ({ startContainer: b, startOffset: y } = w, (!n.contentDOM.contains(b) || N.safari && hpe(b, y, h) || N.chrome && upe(b, y, h)) && (b = void 0));
    }
  }
  if (!b || !n.docView.dom.contains(b)) {
    let w = wt.find(n.docView, d);
    if (!w)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: y } = Id(w.dom, h, u));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = k.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, y) + k.posAtStart;
}
function ab(n, e, t, i, r) {
  let s = Math.round((i - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((r - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + Oc(o, s, n.state.tabSize);
}
function hpe(n, e, t) {
  let i;
  if (n.nodeType != 3 || e != (i = n.nodeValue.length))
    return !1;
  for (let r = n.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return Mr(n, i - 1, i).getBoundingClientRect().left > t;
}
function upe(n, e, t) {
  if (e != 0)
    return !1;
  for (let r = n; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Mr(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function Bd(n, e) {
  let t = n.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == Me.Text))
        return i;
  }
  return t;
}
function fpe(n, e, t, i) {
  let r = Bd(n, e.head), s = !i || r.type != Me.Text || !(n.lineWrapping || r.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(r.from), a = n.posAtCoords({
      x: t == (l == Te.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return S.cursor(a, t ? -1 : 1);
  }
  return S.cursor(t ? r.to : r.from, t ? -1 : 1);
}
function cb(n, e, t, i) {
  let r = n.state.doc.lineAt(e.head), s = n.bidiSpans(r), o = n.textDirectionAt(r.from);
  for (let l = e, a = null; ; ) {
    let c = epe(r, s, o, l, t), h = Uk;
    if (!c) {
      if (r.number == (t ? n.state.doc.lines : 1))
        return l;
      h = `
`, r = n.state.doc.line(r.number + (t ? 1 : -1)), s = n.bidiSpans(r), c = S.cursor(t ? r.from : r.to);
    }
    if (a) {
      if (!a(h))
        return l;
    } else {
      if (!i)
        return c;
      a = i(h);
    }
    l = c;
  }
}
function dpe(n, e, t) {
  let i = n.state.charCategorizer(e), r = i(t);
  return (s) => {
    let o = i(s);
    return r == Ce.Space && (r = o), r == o;
  };
}
function ppe(n, e, t, i) {
  let r = e.head, s = t ? 1 : -1;
  if (r == (t ? n.state.doc.length : 0))
    return S.cursor(r, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(r), h = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(r);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (r - d.from))), l = (s < 0 ? d.top : d.bottom) + h;
  }
  let u = a.left + o, f = i != null ? i : n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, g = Gk(n, { x: u, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? g < r : g > r))
      return S.cursor(g, e.assoc, void 0, o);
  }
}
function tc(n, e, t) {
  for (; ; ) {
    let i = 0;
    for (let r of n)
      r.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = i || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, i = a;
        }
      });
    if (!i)
      return e;
  }
}
function Xu(n, e, t) {
  let i = tc(n.state.facet(Ag).map((r) => r(n)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : S.cursor(i, i < t.from ? 1 : -1);
}
class gpe {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null;
    let t = (i, r) => {
      this.ignoreDuringComposition(r) || r.type == "keydown" && this.keydown(e, r) || (this.mustFlushObserver(r) && e.observer.forceFlush(), this.runCustomHandlers(r.type, e, r) ? r.preventDefault() : i(e, r));
    };
    for (let i in ze) {
      let r = ze[i];
      e.contentDOM.addEventListener(i, (s) => {
        hb(e, s) && t(r, s);
      }, Nd[i]), this.registeredEvents.push(i);
    }
    e.scrollDOM.addEventListener("mousedown", (i) => {
      if (i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && (t(ze.mousedown, i), !i.defaultPrevented && i.button == 2)) {
        let r = e.contentDOM.style.minHeight;
        e.contentDOM.style.minHeight = "100%", setTimeout(() => e.contentDOM.style.minHeight = r, 200);
      }
    }), e.scrollDOM.addEventListener("drop", (i) => {
      i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && t(ze.drop, i);
    }), N.chrome && N.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, N.safari && e.contentDOM.addEventListener("input", () => null);
  }
  ensureHandlers(e, t) {
    var i;
    let r;
    this.customHandlers = [];
    for (let s of t)
      if (r = (i = s.update(e).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: s.value, handlers: r });
        for (let o in r)
          this.registeredEvents.indexOf(o) < 0 && o != "scroll" && (this.registeredEvents.push(o), e.contentDOM.addEventListener(o, (l) => {
            !hb(e, l) || this.runCustomHandlers(o, e, l) && l.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, i) {
    for (let r of this.customHandlers) {
      let s = r.handlers[e];
      if (s)
        try {
          if (s.call(r.plugin, i, t) || i.defaultPrevented)
            return !0;
        } catch (o) {
          Kt(t.state, o);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let r = i.handlers.scroll;
      if (r)
        try {
          r.call(i.plugin, t, e);
        } catch (s) {
          Kt(e.state, s);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && Yk.indexOf(t.keyCode) < 0 && (e.inputState.lastEscPress = 0), N.android && N.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let i;
    return N.ios && !t.synthetic && !t.altKey && !t.metaKey && ((i = Kk.find((r) => r.keyCode == t.keyCode)) && !t.ctrlKey || mpe.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = i || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, bs(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : N.safari && !N.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const Kk = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], mpe = "dthko", Yk = [16, 17, 18, 20, 91, 92, 224, 225], aa = 6;
function ca(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function bpe(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class ype {
  constructor(e, t, i, r) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = Nde(e.contentDOM), this.atoms = e.state.facet(Ag).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(J.allowMultipleSelections) && wpe(e, t), this.dragging = xpe(e, t) && Qk(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && bpe(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, r = 0, s = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = $k(this.view);
    e.clientX - o.left <= s.left + aa ? i = -ca(s.left - e.clientX) : e.clientX + o.right >= s.right - aa && (i = ca(e.clientX - s.right)), e.clientY - o.top <= s.top + aa ? r = -ca(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - aa && (r = ca(e.clientY - s.bottom)), this.setScrollSpeed(i, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], s = null;
      if (r.empty) {
        let o = tc(this.atoms, r.from, 0);
        o != r.from && (s = S.cursor(o, -1));
      } else {
        let o = tc(this.atoms, r.from, -1), l = tc(this.atoms, r.to, 1);
        (o != r.from || l != r.to) && (s = S.range(r.from == r.anchor ? o : l, r.from == r.head ? o : l));
      }
      s && (t || (t = e.ranges.slice()), t[i] = s);
    }
    return t ? S.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection) || i.main.assoc != t.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function wpe(n, e) {
  let t = n.state.facet(Ek);
  return t.length ? t[0](e) : N.mac ? e.metaKey : e.ctrlKey;
}
function vpe(n, e) {
  let t = n.state.facet(Tk);
  return t.length ? t[0](e) : N.mac ? !e.altKey : !e.ctrlKey;
}
function xpe(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let i = Lc(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function hb(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = ye.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const ze = /* @__PURE__ */ Object.create(null), Nd = /* @__PURE__ */ Object.create(null), Jk = N.ie && N.ie_version < 15 || N.ios && N.webkit_version < 604;
function kpe(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), Zk(n, t.value);
  }, 50);
}
function Zk(n, e) {
  let { state: t } = n, i, r = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (Pd != null && t.selection.ranges.every((a) => a.empty) && Pd == s.toString()) {
    let a = -1;
    i = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == a)
        return { range: c };
      a = h.from;
      let u = t.toText((o ? s.line(r++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: S.cursor(c.from + u.length)
      };
    });
  } else
    o ? i = t.changeByRange((a) => {
      let c = s.line(r++);
      return {
        changes: { from: a.from, to: a.to, insert: c.text },
        range: S.cursor(a.from + c.length)
      };
    }) : i = t.replaceSelection(s);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
ze.keydown = (n, e) => {
  n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (n.inputState.lastEscPress = Date.now());
};
ze.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
ze.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
Nd.touchstart = Nd.touchmove = { passive: !0 };
ze.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let i of n.state.facet(Mk))
    if (t = i(n, e), t)
      break;
  if (!t && e.button == 0 && (t = Cpe(n, e)), t) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new ype(n, e, t, i)), i && n.observer.ignore(() => gk(n.contentDOM)), n.inputState.mouseSelection && n.inputState.mouseSelection.start(e);
  }
};
function ub(n, e, t, i) {
  if (i == 1)
    return S.cursor(e, t);
  if (i == 2)
    return lpe(n.state, e, t);
  {
    let r = wt.find(n.docView, e), s = n.state.doc.lineAt(r ? r.posAtEnd : e), o = r ? r.posAtStart : s.from, l = r ? r.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, S.range(o, l);
  }
}
let Xk = (n, e) => n >= e.top && n <= e.bottom, fb = (n, e, t) => Xk(e, t) && n >= t.left && n <= t.right;
function _pe(n, e, t, i) {
  let r = wt.find(n.docView, e);
  if (!r)
    return 1;
  let s = e - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let o = r.coordsAt(s, -1);
  if (o && fb(t, i, o))
    return -1;
  let l = r.coordsAt(s, 1);
  return l && fb(t, i, l) ? 1 : o && Xk(i, o) ? -1 : 1;
}
function db(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: _pe(n, t, e.clientX, e.clientY) };
}
const Spe = N.ie && N.ie_version <= 11;
let pb = null, gb = 0, mb = 0;
function Qk(n) {
  if (!Spe)
    return n.detail;
  let e = pb, t = mb;
  return pb = n, mb = Date.now(), gb = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (gb + 1) % 3 : 1;
}
function Cpe(n, e) {
  let t = db(n, e), i = Qk(e), r = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), r = r.map(s.changes));
    },
    get(s, o, l) {
      let a = db(n, s), c, h = ub(n, a.pos, a.bias, i);
      if (t.pos != a.pos && !o) {
        let u = ub(n, t.pos, t.bias, i), f = Math.min(u.from, h.from), d = Math.max(u.to, h.to);
        h = f < h.from ? S.range(f, d) : S.range(d, f);
      }
      return o ? r.replaceRange(r.main.extend(h.from, h.to)) : l && i == 1 && r.ranges.length > 1 && (c = Ape(r, a.pos)) ? c : l ? r.addRange(h) : S.create([h]);
    }
  };
}
function Ape(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: i, to: r } = n.ranges[t];
    if (i <= e && r >= e)
      return S.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
ze.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state, { mouseSelection: i } = n.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", n.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function bb(n, e, t, i) {
  if (!t)
    return;
  let r = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: s } = n.inputState, o = i && s && s.dragging && vpe(n, e) ? { from: s.dragging.from, to: s.dragging.to } : null, l = { from: r, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(r, -1), head: a.mapPos(r, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  });
}
ze.drop = (n, e) => {
  if (!e.dataTransfer)
    return;
  if (n.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), r = 0, s = () => {
      ++r == t.length && bb(n, e, i.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
  } else
    bb(n, e, e.dataTransfer.getData("Text"), !0);
};
ze.paste = (n, e) => {
  if (n.state.readOnly)
    return e.preventDefault();
  n.observer.flush();
  let t = Jk ? null : e.clipboardData;
  t ? (Zk(n, t.getData("text/plain") || t.getData("text/uri-text")), e.preventDefault()) : kpe(n);
};
function Dpe(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
function Epe(n) {
  let e = [], t = [], i = !1;
  for (let r of n.selection.ranges)
    r.empty || (e.push(n.sliceDoc(r.from, r.to)), t.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > r && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), r = o.number;
    }
    i = !0;
  }
  return { text: e.join(n.lineBreak), ranges: t, linewise: i };
}
let Pd = null;
ze.copy = ze.cut = (n, e) => {
  let { text: t, ranges: i, linewise: r } = Epe(n.state);
  if (!t && !r)
    return;
  Pd = r ? t : null;
  let s = Jk ? null : e.clipboardData;
  s ? (e.preventDefault(), s.clearData(), s.setData("text/plain", t)) : Dpe(n, t), e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
const e_ = /* @__PURE__ */ nn.define();
function t_(n, e) {
  let t = [];
  for (let i of n.facet(Rk)) {
    let r = i(n, e);
    r && t.push(r);
  }
  return t ? n.update({ effects: t, annotations: e_.of(!0) }) : null;
}
function n_(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = t_(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
ze.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), n_(n);
};
ze.blur = (n) => {
  n.observer.clearSelectionRange(), n_(n);
};
ze.compositionstart = ze.compositionupdate = (n) => {
  n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0);
};
ze.compositionend = (n) => {
  n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, N.chrome && N.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50);
};
ze.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
ze.beforeinput = (n, e) => {
  var t;
  let i;
  if (N.chrome && N.android && (i = Kk.find((r) => r.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let r = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
};
const yb = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Tpe {
  constructor(e) {
    this.lineWrapping = e, this.doc = Z.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return yb.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (t = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, r, s, o) {
    let l = yb.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = i, this.textHeight = r, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return a;
  }
}
class Mpe {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Mn {
  constructor(e, t, i, r, s) {
    this.from = e, this.length = t, this.top = i, this.height = r, this._content = s;
  }
  get type() {
    return typeof this._content == "number" ? Me.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof Wi ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Mn(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var xe = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(xe || (xe = {}));
const nc = 1e-3;
class kt {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > nc && (e.heightChanged = !0), this.height = t);
  }
  replace(e, t, i) {
    return kt.of(i);
  }
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, r) {
    let s = this, o = i.doc;
    for (let l = r.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: h, toB: u } = r[l], f = s.lineAt(a, xe.ByPosNoHeight, i.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, xe.ByPosNoHeight, i, 0, 0);
      for (u += d.to - c, c = d.to; l > 0 && f.from <= r[l - 1].toA; )
        a = r[l - 1].fromA, h = r[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, xe.ByPosNoHeight, i, 0, 0));
      h += f.from - a, a = f.from;
      let p = Dg.build(i.setDoc(o), e, h, u);
      s = s.replace(a, c, p);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new Bt(0, 0);
  }
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, r = 0, s = 0;
    for (; ; )
      if (t == i)
        if (r > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), i += 1 + l.break, r -= l.size;
        } else if (s > r * 2) {
          let l = e[i];
          l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, s -= l.size;
        } else
          break;
      else if (r < s) {
        let l = e[t++];
        l && (r += l.size);
      } else {
        let l = e[--i];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new Ope(kt.of(e.slice(0, t)), o, kt.of(e.slice(i)));
  }
}
kt.prototype.size = 1;
class i_ extends kt {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, r) {
    return new Mn(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, r, s) {
    return this.blockAt(0, i, r, s);
  }
  forEachLine(e, t, i, r, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, i, r, s));
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more && this.setHeight(e, r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Bt extends i_ {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, r) {
    return new Mn(r, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Bt || r instanceof Qe && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof Qe ? r = new Bt(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : kt.of(i);
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more ? this.setHeight(e, r.heights[r.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Qe extends kt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, r = e.doc.lineAt(t + this.length).number, s = r - i + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: i, lastLine: r, perLine: o, perChar: l };
  }
  blockAt(e, t, i, r) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, r);
    if (t.lineWrapping) {
      let c = r + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), h = t.doc.lineAt(c), u = l + h.length * a, f = Math.max(i, e - u / 2);
      return new Mn(h.from, h.length, f, u, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - i) / l))), { from: h, length: u } = t.doc.line(s + c);
      return new Mn(h, u, i + l * c, l, 0);
    }
  }
  lineAt(e, t, i, r, s) {
    if (t == xe.ByHeight)
      return this.blockAt(e, i, r, s);
    if (t == xe.ByPosNoHeight) {
      let { from: d, to: p } = i.doc.lineAt(e);
      return new Mn(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(i, s), c = i.doc.lineAt(e), h = l + c.length * a, u = c.number - o, f = r + l * u + a * (c.from - s - u);
    return new Mn(c.from, c.length, Math.max(r, Math.min(f, r + this.height - h)), h, 0);
  }
  forEachLine(e, t, i, r, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(i, s);
    for (let h = e, u = r; h <= t; ) {
      let f = i.doc.lineAt(h);
      if (h == e) {
        let p = f.number - l;
        u += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new Mn(f.from, f.length, u, d, 0)), u += d, h = f.to + 1;
    }
  }
  replace(e, t, i) {
    let r = this.length - t;
    if (r > 0) {
      let s = i[i.length - 1];
      s instanceof Qe ? i[i.length - 1] = new Qe(s.length + r) : i.push(null, new Qe(r - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof Qe ? i[0] = new Qe(e + s.length) : i.unshift(new Qe(e - 1), null);
    }
    return kt.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new Qe(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Qe(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, r) {
    let s = t + this.length;
    if (r && r.from <= t + this.length && r.more) {
      let o = [], l = Math.max(t, r.from), a = -1;
      for (r.from > t && o.push(new Qe(r.from - t - 1).updateHeight(e, t)); l <= s && r.more; ) {
        let h = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let u = r.heights[r.index++];
        a == -1 ? a = u : Math.abs(u - a) >= nc && (a = -2);
        let f = new Bt(h, u);
        f.outdated = !1, o.push(f), l += h + 1;
      }
      l <= s && o.push(null, new Qe(s - l).updateHeight(e, l));
      let c = kt.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= nc || Math.abs(a - this.heightMetrics(e, t).perLine) >= nc) && (e.heightChanged = !0), c;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Ope extends kt {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, r) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, t, i, r) : this.right.blockAt(e, t, s, r + this.left.length + this.break);
  }
  lineAt(e, t, i, r, s) {
    let o = r + this.left.height, l = s + this.left.length + this.break, a = t == xe.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, i, r, s) : this.right.lineAt(e, t, i, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let h = t == xe.ByPosNoHeight ? xe.ByPosNoHeight : xe.ByPos;
    return a ? c.join(this.right.lineAt(l, h, i, o, l)) : this.left.lineAt(l, h, i, r, s).join(c);
  }
  forEachLine(e, t, i, r, s, o) {
    let l = r + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, i, r, s, o), t >= a && this.right.forEachLine(e, t, i, l, a, o);
    else {
      let c = this.lineAt(a, xe.ByPos, i, r, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, r, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, i, l, a, o);
    }
  }
  replace(e, t, i) {
    let r = this.left.length + this.break;
    if (t < r)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, t - r, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of i)
      s.push(l);
    if (e > 0 && wb(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), wb(s, l);
    }
    return kt.of(s);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < r && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? kt.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, r) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return r && r.from <= t + s.length && r.more ? a = s = s.updateHeight(e, t, i, r) : s.updateHeight(e, t, i), r && r.from <= l + o.length && r.more ? a = o = o.updateHeight(e, l, i, r) : o.updateHeight(e, l, i), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function wb(n, e) {
  let t, i;
  n[e] == null && (t = n[e - 1]) instanceof Qe && (i = n[e + 1]) instanceof Qe && n.splice(e - 1, 3, new Qe(t.length + 1 + i.length));
}
const Lpe = 5;
class Dg {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof Bt ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Bt(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new i_(o, r, i)) : (o || s || r >= Lpe) && this.addLineDeco(r, s, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Bt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new Qe(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Bt)
      return e;
    let t = new Bt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    var t;
    this.enterLine();
    let i = (t = e.deco) === null || t === void 0 ? void 0 : t.type;
    i == Me.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, i != Me.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Bt) && !this.isCovered ? this.nodes.push(new Bt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof Bt && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  static build(e, t, i, r) {
    let s = new Dg(i, e);
    return W.spans(t, i, r, s, 0), s.finish(i);
  }
}
function Rpe(n, e, t) {
  let i = new Ipe();
  return W.compare(n, e, t, i, 0), i.changes;
}
class Ipe {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, r) {
    (e < t || i && i.heightRelevant || r && r.heightRelevant) && Td(e, t, this.changes, 5);
  }
}
function Bpe(n, e) {
  let t = n.getBoundingClientRect(), i = n.ownerDocument, r = i.defaultView || window, s = Math.max(0, t.left), o = Math.min(r.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(r.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let h = c, u = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && u.overflow != "visible") {
        let f = h.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = c == n.parentNode ? f.bottom : Math.min(a, f.bottom);
      }
      c = u.position == "absolute" || u.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function Npe(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Qu {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], s = t[i];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return U.replace({ widget: new Ppe(this.size, e) }).range(this.from, this.to);
  }
}
class Ppe extends mi {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class vb {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = xb, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Te.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Cg).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Tpe(t), this.stateDeco = e.facet(rl).filter((i) => typeof i != "function"), this.heightMap = kt.empty().applyChanges(this.stateDeco, Z.empty, this.heightOracle.setDoc(e.doc), [new Yt(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = U.set(this.lineGaps.map((i) => i.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
        let { from: s, to: o } = this.lineBlockAt(r);
        e.push(new ha(s, o));
      }
    }
    this.viewports = e.sort((i, r) => i.from - r.from), this.scaler = this.heightMap.height <= 7e6 ? xb : new Hpe(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : So(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(rl).filter((h) => typeof h != "function");
    let r = e.changedRanges, s = Yt.extendWithRanges(r, Rpe(i, this.stateDeco, e ? e.changes : Oe.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = !e.changes.empty || e.flags & 2 || a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Bk) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), r = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Te.RTL : Te.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, h = 0, u = parseInt(i.paddingTop) || 0, f = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != u || this.paddingBottom != f) && (this.paddingTop = u, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8), this.scrollTop != e.scrollDOM.scrollTop && (this.scrollAnchorHeight = -1, this.scrollTop = e.scrollDOM.scrollTop), this.scrolledToBottom = bk(e.scrollDOM);
    let d = (this.printing ? Npe : Bpe)(t, this.paddingTop), p = d.top - this.pixelViewport.top, g = d.bottom - this.pixelViewport.bottom;
    this.pixelViewport = d;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (a = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let b = l.width;
    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), a) {
      let k = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(k) && (o = !0), o || r.lineWrapping && Math.abs(b - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: w, charWidth: x, textHeight: v } = e.docView.measureTextSize();
        o = w > 0 && r.refresh(s, w, x, v, b / x, k), o && (e.docView.minWidth = 0, c |= 8);
      }
      p > 0 && g > 0 ? h = Math.max(p, g) : p < 0 && g < 0 && (h = Math.min(p, g)), r.heightChanged = !1;
      for (let w of this.viewports) {
        let x = w.from == this.viewport.from ? k : e.docView.measureVisibleLineHeights(w);
        this.heightMap = (o ? kt.empty().applyChanges(this.stateDeco, Z.empty, this.heightOracle, [new Yt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, o, new Mpe(w.from, x));
      }
      r.heightChanged && (c |= 2);
    }
    let y = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return y && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (c & 2 || y) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new ha(r.lineAt(o - i * 1e3, xe.ByHeight, s, 0, 0).from, r.lineAt(l + (1 - i) * 1e3, xe.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = r.lineAt(c, xe.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (u.top + u.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = u.top : f = u.bottom - h, a = new ha(r.lineAt(f - 1e3 / 2, xe.ByHeight, s, 0, 0).from, r.lineAt(f + h + 1e3 / 2, xe.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), r = t.mapPos(e.to, 1);
    return new ha(this.heightMap.lineAt(i, xe.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, xe.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, xe.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, xe.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || r <= o - Math.max(10, Math.min(-i, 250))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(i, 250))) && r > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let r of e)
      t.touchesRange(r.from, r.to) || i.push(new Qu(t.mapPos(r.from), t.mapPos(r.to), r.size));
    return i;
  }
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, s = r >> 1, o = r << 1;
    if (this.defaultTextDirection != Te.LTR && !i)
      return [];
    let l = [], a = (c, h, u, f) => {
      if (h - c < s)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let m of p)
        if (m > c && m < h) {
          a(c, m - 10, u, f), a(m + 10, h, u, f);
          return;
        }
      let g = $pe(e, (m) => m.from >= u.from && m.to <= u.to && Math.abs(m.from - c) < s && Math.abs(m.to - h) < s && !p.some((b) => m.from < b && m.to > b));
      if (!g) {
        if (h < u.to && t && i && t.visibleRanges.some((m) => m.from <= h && m.to >= h)) {
          let m = t.moveToLineBoundary(S.cursor(h), !1, !0).head;
          m > c && (h = m);
        }
        g = new Qu(c, h, this.gapSize(u, c, h, f));
      }
      l.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let h = Fpe(c.from, c.to, this.stateDeco);
      if (h.total < o)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (i) {
        let p = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (u != null) {
          let b = fa(h, u), y = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          g = b - y, m = b + y;
        } else
          g = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        f = ua(h, g), d = ua(h, m);
      } else {
        let p = h.total * this.heightOracle.charWidth, g = r * this.heightOracle.charWidth, m, b;
        if (u != null) {
          let y = fa(h, u), k = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = y - k, b = y + k;
        } else
          m = (this.pixelViewport.left - g) / p, b = (this.pixelViewport.right + g) / p;
        f = ua(h, m), d = ua(h, b);
      }
      f > c.from && a(c.from, f, c, h), d < c.to && a(d, c.to, c, h);
    }
    return l;
  }
  gapSize(e, t, i, r) {
    let s = fa(r, i) - fa(r, t);
    return this.heightOracle.lineWrapping ? e.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Qu.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = U.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    W.spans(e, this.viewport.from, this.viewport.to, {
      span(r, s) {
        t.push({ from: r, to: s });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((r, s) => r.from != t[s].from || r.to != t[s].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || So(this.heightMap.lineAt(e, xe.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return So(this.heightMap.lineAt(this.scaler.fromDOM(e), xe.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return So(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class ha {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function Fpe(n, e, t) {
  let i = [], r = n, s = 0;
  return W.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > r && (i.push({ from: r, to: o }), s += o - r), r = l;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), s += e - r), { total: s, ranges: i };
}
function ua({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(n * t);
  for (let r = 0; ; r++) {
    let { from: s, to: o } = e[r], l = o - s;
    if (i <= l)
      return s + i;
    i -= l;
  }
}
function fa(n, e) {
  let t = 0;
  for (let { from: i, to: r } of n.ranges) {
    if (e <= r) {
      t += e - i;
      break;
    }
    t += r - i;
  }
  return t / n.total;
}
function $pe(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const xb = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class Hpe {
  constructor(e, t, i) {
    let r = 0, s = 0, o = 0;
    this.viewports = i.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, xe.ByPos, e, 0, 0).top, h = t.lineAt(a, xe.ByPos, e, 0, 0).bottom;
      return r += h - c, { from: l, to: a, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (t.height - r);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return r + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return i + (e - r) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, r = s.domBottom;
    }
  }
}
function So(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), i = e.toDOM(n.bottom);
  return new Mn(n.from, n.length, t, i - t, Array.isArray(n._content) ? n._content.map((r) => So(r, e)) : n._content);
}
const da = /* @__PURE__ */ E.define({ combine: (n) => n.join(" ") }), Fd = /* @__PURE__ */ E.define({ combine: (n) => n.indexOf(!0) > -1 }), $d = /* @__PURE__ */ Ct.newName(), r_ = /* @__PURE__ */ Ct.newName(), s_ = /* @__PURE__ */ Ct.newName(), o_ = { "&light": "." + r_, "&dark": "." + s_ };
function Hd(n, e, t) {
  return new Ct(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return n;
        if (!t || !t[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return t[r];
      }) : n + " " + i;
    }
  });
}
const qpe = /* @__PURE__ */ Hd("." + $d, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, o_);
class Vpe {
  constructor(e, t, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let l = s || o ? [] : Wpe(e), a = new xk(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = jpe(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !_d(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !_d(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset);
      this.newSel = S.single(c, a);
    }
  }
}
function l_(n, e) {
  let t, { newSel: i } = e, r = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = r.from, c = null;
    (s === 8 || N.android && e.text.length < l - o) && (a = r.to, c = "end");
    let h = Upe(n.state.doc.sliceString(o, l, ls), e.text, a - o, c);
    h && (N.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == ls + ls && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: Z.of(e.text.slice(h.from, h.toB).split(ls))
    });
  } else
    i && (!n.hasFocus && n.state.facet(Ph) || i.main.eq(r)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !r.empty && i && i.main.empty ? t = { from: r.from, to: r.to, insert: n.state.doc.slice(r.from, r.to) } : t && t.from >= r.from && t.to <= r.to && (t.from != r.from || t.to != r.to) && r.to - r.from - (t.to - t.from) <= 4 ? t = {
    from: r.from,
    to: r.to,
    insert: n.state.doc.slice(r.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, r.to))
  } : (N.mac || N.android) && t && t.from == t.to && t.from == r.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: Z.of([" "]) }) : N.chrome && t && t.from == t.to && t.from == r.head && t.insert.toString() == `
 ` && n.lineWrapping && (i && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: Z.of([" "]) }), t) {
    if (N.ios && n.inputState.flushIOSKey(n) || N.android && (t.from == r.from && t.to == r.to && t.insert.length == 1 && t.insert.lines == 2 && bs(n.contentDOM, "Enter", 13) || (t.from == r.from - 1 && t.to == r.to && t.insert.length == 0 || s == 8 && t.insert.length < t.to - t.from) && bs(n.contentDOM, "Backspace", 8) || t.from == r.from && t.to == r.to + 1 && t.insert.length == 0 && bs(n.contentDOM, "Delete", 46)))
      return !0;
    let o = t.insert.toString();
    n.inputState.composing >= 0 && n.inputState.composing++;
    let l, a = () => l || (l = zpe(n, t, i));
    return n.state.facet(Lk).some((c) => c(n, t.from, t.to, o, a)) || n.dispatch(a()), !0;
  } else if (i && !i.main.eq(r)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function zpe(n, e, t) {
  let i, r = n.state, s = r.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? r.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
    i = r.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a));
  } else {
    let l = r.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (r.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), h = Wk(n) || n.state.doc.lineAt(s.head), u = s.to - e.to, f = s.to - s.from;
      i = r.changeByRange((d) => {
        if (d.from == s.from && d.to == s.to)
          return { changes: l, range: a || d.map(l) };
        let p = d.to - u, g = p - c.length;
        if (d.to - d.from != f || n.state.sliceDoc(g, p) != c || h && d.to >= h.from && d.from <= h.to)
          return { range: d };
        let m = r.changes({ from: g, to: p, insert: e.insert }), b = d.to - s.to;
        return {
          changes: m,
          range: a ? S.range(Math.max(0, a.anchor + b), Math.max(0, a.head + b)) : d.map(m)
        };
      });
    } else
      i = {
        changes: l,
        selection: a && r.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
function Upe(n, e, t, i) {
  let r = Math.min(n.length, e.length), s = 0;
  for (; s < r && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == r && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function Wpe(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: r, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new Y1(t, i)), (r != t || s != i) && e.push(new Y1(r, s))), e;
}
function jpe(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, i = n.length == 2 ? n[1].pos : t;
  return t > -1 && i > -1 ? S.single(t + e, i + e) : null;
}
const Gpe = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, ef = N.ie && N.ie_version <= 11;
class Kpe {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new Pde(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (N.ie && N.ie_version <= 11 || N.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), ef && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(Ph) ? i.root.activeElement != this.dom : !ec(i.dom, r))
      return;
    let s = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (N.ie && N.ie_version <= 11 || N.android && N.chrome) && !i.state.selection.main.empty && r.focusNode && Rc(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = N.safari && e.root.nodeType == 11 && Rde(this.dom.ownerDocument) == this.dom && Ype(this.view) || Lc(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = ec(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && $de(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Gpe), ef && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    !this.active || (this.active = !1, this.observer.disconnect(), ef && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && bs(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, r = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      !o || (o.typeOver && (r = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), r = this.selectionChanged && ec(this.dom, this.selectionRange);
    return e < 0 && !r ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new Vpe(this.view, e, t, i));
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let i = this.view.state, r = l_(this.view, t);
    return this.view.state == i && this.view.update([]), r;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = kb(t, e.previousSibling || e.target.previousSibling, -1), r = kb(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: r ? t.posBefore(r) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i, r;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(), (r = this.resizeContent) === null || r === void 0 || r.disconnect();
    for (let s of this.scrollTargets)
      s.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function kb(n, e, t) {
  for (; e; ) {
    let i = ye.get(e);
    if (i && i.parent == n)
      return i;
    let r = e.parentNode;
    e = r != n.dom ? r : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function Ype(n) {
  let e = null;
  function t(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (n.contentDOM.addEventListener("beforeinput", t, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, r = e.startOffset, s = e.endContainer, o = e.endOffset, l = n.docView.domAtPos(n.state.selection.main.anchor);
  return Rc(l.node, l.offset, s, o) && ([i, r, s, o] = [s, o, i, r]), { anchorNode: i, anchorOffset: r, focusNode: s, focusOffset: o };
}
class I {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((i) => i.forEach((r) => t(r, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || Fde(e.parent) || document, this.viewState = new vb(e.state || J.create(e)), this.plugins = this.state.facet(ko).map((i) => new Ju(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Kpe(this), this.inputState = new gpe(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new ib(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Ve ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, r, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(e_)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = t_(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(J.phrases) != this.state.facet(J.phrases))
      return this.setState(s);
    r = Nc.create(this, s, e), r.flags |= l;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (u && (u = u.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          u = new Bc(d.empty ? d : S.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(tb) && (u = d.value);
      }
      this.viewState.update(r, u), this.bidiCache = Pc.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), t = this.docView.update(r), this.state.facet(_o) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(da) != r.state.facet(da) && (this.viewState.mustMeasureContent = !0), (t || i || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !r.empty)
      for (let f of this.state.facet(Md))
        f(r);
    (a || h) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), h && !l_(this, h) && c.force && bs(this.contentDOM, c.key, c.keyCode);
    });
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new vb(e), this.plugins = e.facet(ko).map((i) => new Ju(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new ib(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(ko), i = e.state.facet(ko);
    if (t != i) {
      let r = [];
      for (let s of i) {
        let o = t.indexOf(s);
        if (o < 0)
          r.push(new Ju(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, r.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = r, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
  }
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, { scrollTop: r } = i, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    r != this.viewState.scrollTop && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (bk(i))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(r);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Kt(this.state, p), _b;
          }
        }), u = Nc.create(this, this.state, []), f = !1;
        u.flags |= a, t ? t.flags |= a : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), f = this.docView.update(u));
        for (let d = 0; d < c.length; d++)
          if (h[d] != _b)
            try {
              let p = c[d];
              p.write && p.write(h[d], this);
            } catch (p) {
              Kt(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                r = i.scrollTop = r + p, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(Md))
        l(t);
  }
  get themeClasses() {
    return $d + " " + (this.state.facet(Fd) ? s_ : r_) + " " + this.state.facet(da);
  }
  updateAttrs() {
    let e = Sb(this, Nk, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Ph) ? "true" : "false",
      class: "cm-content",
      style: `${N.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Sb(this, Cg, t);
    let i = this.observer.ignore(() => {
      let r = Ed(this.contentDOM, this.contentAttrs, t), s = Ed(this.dom, this.editorAttrs, e);
      return r || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(I.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(_o);
    let e = this.state.facet(I.cspNonce);
    Ct.mount(this.root, this.styleModules.concat(qpe).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, t, i) {
    return Xu(this, e, cb(this, e, t, i));
  }
  moveByGroup(e, t) {
    return Xu(this, e, cb(this, e, t, (i) => dpe(this, e.head, i)));
  }
  moveToLineBoundary(e, t, i = !0) {
    return fpe(this, e, t, i);
  }
  moveVertically(e, t, i) {
    return Xu(this, e, ppe(this, e, t, i));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), Gk(this, e, t);
  }
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), s = this.bidiSpans(r), o = s[Oi.find(s, e - r.from, -1, t)];
    return kg(i, o.dir == Te.LTR == t > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(Ik) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > Jpe)
      return zk(e.length);
    let t = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || Vk(s.isolates, i = nb(this, e.from, e.to))))
        return s.order;
    i || (i = nb(this, e.from, e.to));
    let r = Qde(e.text, t, i);
    return this.bidiCache.push(new Pc(e.from, e.to, t, i, !0, r)), r;
  }
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || N.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      gk(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  static scrollIntoView(e, t = {}) {
    return tb.of(new Bc(typeof e == "number" ? S.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  static domEventHandlers(e) {
    return Re.define(() => ({}), { eventHandlers: e });
  }
  static theme(e, t) {
    let i = Ct.newName(), r = [da.of(i), _o.of(Hd(`.${i}`, e))];
    return t && t.dark && r.push(Fd.of(!0)), r;
  }
  static baseTheme(e) {
    return gi.lowest(_o.of(Hd("." + $d, e, o_)));
  }
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), r = i && ye.get(i) || ye.get(e);
    return ((t = r == null ? void 0 : r.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
I.styleModule = _o;
I.inputHandler = Lk;
I.focusChangeEffect = Rk;
I.perLineTextDirection = Ik;
I.exceptionSink = Ok;
I.updateListener = Md;
I.editable = Ph;
I.mouseSelectionStyle = Mk;
I.dragMovesSelection = Tk;
I.clickAddsSelectionRange = Ek;
I.decorations = rl;
I.atomicRanges = Ag;
I.bidiIsolatedRanges = Pk;
I.scrollMargins = Fk;
I.darkTheme = Fd;
I.cspNonce = /* @__PURE__ */ E.define({ combine: (n) => n.length ? n[0] : "" });
I.contentAttributes = Cg;
I.editorAttributes = Nk;
I.lineWrapping = /* @__PURE__ */ I.contentAttributes.of({ class: "cm-lineWrapping" });
I.announce = /* @__PURE__ */ G.define();
const Jpe = 4096, _b = {};
class Pc {
  constructor(e, t, i, r, s, o) {
    this.from = e, this.to = t, this.dir = i, this.isolates = r, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : Te.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == r && !t.touchesRange(o.from, o.to) && i.push(new Pc(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function Sb(n, e, t) {
  for (let i = n.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let s = i[r], o = typeof s == "function" ? s(n) : s;
    o && Dd(o, t);
  }
  return t;
}
const Zpe = N.mac ? "mac" : N.windows ? "win" : N.linux ? "linux" : "key";
function Xpe(n, e) {
  const t = n.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let r, s, o, l;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      l = !0;
    else if (/^a(lt)?$/i.test(c))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? l = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return r && (i = "Alt-" + i), s && (i = "Ctrl-" + i), l && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function pa(n, e, t) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t !== !1 && e.shiftKey && (n = "Shift-" + n), n;
}
const Qpe = /* @__PURE__ */ gi.default(/* @__PURE__ */ I.domEventHandlers({
  keydown(n, e) {
    return c_(a_(e.state), n, e, "editor");
  }
})), ol = /* @__PURE__ */ E.define({ enables: Qpe }), Cb = /* @__PURE__ */ new WeakMap();
function a_(n) {
  let e = n.facet(ol), t = Cb.get(e);
  return t || Cb.set(e, t = nge(e.reduce((i, r) => i.concat(r), []))), t;
}
function ege(n, e, t) {
  return c_(a_(n.state), e, n, t);
}
let Ai = null;
const tge = 4e3;
function nge(n, e = Zpe) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), r = (o, l) => {
    let a = i[o];
    if (a == null)
      i[o] = l;
    else if (a != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, l, a, c, h) => {
    var u, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = l.split(/ (?!$)/).map((b) => Xpe(b, e));
    for (let b = 1; b < p.length; b++) {
      let y = p.slice(0, b).join(" ");
      r(y, !0), d[y] || (d[y] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(k) => {
          let w = Ai = { view: k, prefix: y, scope: o };
          return setTimeout(() => {
            Ai == w && (Ai = null);
          }, tge), !0;
        }]
      });
    }
    let g = p.join(" ");
    r(g, !1);
    let m = d[g] || (d[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (u = d._any) === null || u === void 0 ? void 0 : u.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    a && m.run.push(a), c && (m.preventDefault = !0), h && (m.stopPropagation = !0);
  };
  for (let o of n) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of l) {
        let h = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let u in h)
          h[u].run.push(o.any);
      }
    let a = o[e] || o.key;
    if (!!a)
      for (let c of l)
        s(c, a, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + a, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
function c_(n, e, t, i) {
  let r = Lde(e), s = tt(r, 0), o = Ut(s) == r.length && r != " ", l = "", a = !1, c = !1, h = !1;
  Ai && Ai.view == t && Ai.scope == i && (l = Ai.prefix + " ", Yk.indexOf(e.keyCode) < 0 && (c = !0, Ai = null));
  let u = /* @__PURE__ */ new Set(), f = (m) => {
    if (m) {
      for (let b of m.run)
        if (!u.has(b) && (u.add(b), b(t, e)))
          return m.stopPropagation && (h = !0), !0;
      m.preventDefault && (m.stopPropagation && (h = !0), c = !0);
    }
    return !1;
  }, d = n[i], p, g;
  return d && (f(d[l + pa(r, e, !o)]) ? a = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && !(N.windows && e.ctrlKey && e.altKey) && (p = zi[e.keyCode]) && p != r ? (f(d[l + pa(p, e, !0)]) || e.shiftKey && (g = nl[e.keyCode]) != r && g != p && f(d[l + pa(g, e, !1)])) && (a = !0) : o && e.shiftKey && f(d[l + pa(r, e, !0)]) && (a = !0), !a && f(d._any) && (a = !0)), c && (a = !0), a && h && e.stopPropagation(), a;
}
class Rl {
  constructor(e, t, i, r, s) {
    this.className = e, this.left = t, this.top = i, this.width = r, this.height = s;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  static forRange(e, t, i) {
    if (i.empty) {
      let r = e.coordsAtPos(i.head, i.assoc || 1);
      if (!r)
        return [];
      let s = h_(e);
      return [new Rl(t, r.left - s.left, r.top - s.top, null, r.bottom - r.top)];
    } else
      return ige(e, t, i);
  }
}
function h_(n) {
  let e = n.scrollDOM.getBoundingClientRect();
  return { left: (n.textDirection == Te.LTR ? e.left : e.right - n.scrollDOM.clientWidth) - n.scrollDOM.scrollLeft, top: e.top - n.scrollDOM.scrollTop };
}
function Ab(n, e, t) {
  let i = S.cursor(e);
  return {
    from: Math.max(t.from, n.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, n.moveToLineBoundary(i, !0, !0).from),
    type: Me.Text
  };
}
function ige(n, e, t) {
  if (t.to <= n.viewport.from || t.from >= n.viewport.to)
    return [];
  let i = Math.max(t.from, n.viewport.from), r = Math.min(t.to, n.viewport.to), s = n.textDirection == Te.LTR, o = n.contentDOM, l = o.getBoundingClientRect(), a = h_(n), c = o.querySelector(".cm-line"), h = c && window.getComputedStyle(c), u = l.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), f = l.right - (h ? parseInt(h.paddingRight) : 0), d = Bd(n, i), p = Bd(n, r), g = d.type == Me.Text ? d : null, m = p.type == Me.Text ? p : null;
  if (g && (n.lineWrapping || d.widgetLineBreaks) && (g = Ab(n, i, g)), m && (n.lineWrapping || p.widgetLineBreaks) && (m = Ab(n, r, m)), g && m && g.from == m.from)
    return y(k(t.from, t.to, g));
  {
    let x = g ? k(t.from, null, g) : w(d, !1), v = m ? k(null, t.to, m) : w(p, !0), C = [];
    return (g || d).to < (m || p).from - (g && m ? 1 : 0) || d.widgetLineBreaks > 1 && x.bottom + n.defaultLineHeight / 2 < v.top ? C.push(b(u, x.bottom, f, v.top)) : x.bottom < v.top && n.elementAtHeight((x.bottom + v.top) / 2).type == Me.Text && (x.bottom = v.top = (x.bottom + v.top) / 2), y(x).concat(C).concat(y(v));
  }
  function b(x, v, C, B) {
    return new Rl(e, x - a.left, v - a.top - 0.01, C - x, B - v + 0.01);
  }
  function y({ top: x, bottom: v, horizontal: C }) {
    let B = [];
    for (let R = 0; R < C.length; R += 2)
      B.push(b(C[R], x, C[R + 1], v));
    return B;
  }
  function k(x, v, C) {
    let B = 1e9, R = -1e9, T = [];
    function z(A, j, q, we, ce) {
      let le = n.coordsAtPos(A, A == C.to ? -2 : 2), he = n.coordsAtPos(q, q == C.from ? 2 : -2);
      !le || !he || (B = Math.min(le.top, he.top, B), R = Math.max(le.bottom, he.bottom, R), ce == Te.LTR ? T.push(s && j ? u : le.left, s && we ? f : he.right) : T.push(!s && we ? u : he.left, !s && j ? f : le.right));
    }
    let se = x != null ? x : C.from, ee = v != null ? v : C.to;
    for (let A of n.visibleRanges)
      if (A.to > se && A.from < ee)
        for (let j = Math.max(A.from, se), q = Math.min(A.to, ee); ; ) {
          let we = n.state.doc.lineAt(j);
          for (let ce of n.bidiSpans(we)) {
            let le = ce.from + we.from, he = ce.to + we.from;
            if (le >= q)
              break;
            he > j && z(Math.max(le, j), x == null && le <= se, Math.min(he, q), v == null && he >= ee, ce.dir);
          }
          if (j = we.to + 1, j >= q)
            break;
        }
    return T.length == 0 && z(se, x == null, ee, v == null, n.textDirection), { top: B, bottom: R, horizontal: T };
  }
  function w(x, v) {
    let C = l.top + (v ? x.top : x.bottom);
    return { top: C, bottom: C, horizontal: [] };
  }
}
function rge(n, e) {
  return n.constructor == e.constructor && n.eq(e);
}
class sge {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(ic) != e.state.facet(ic) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(ic);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !rge(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let r of e)
        r.update && t && r.constructor && this.drawn[i].constructor && r.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(r.draw(), t);
      for (; t; ) {
        let r = t.nextSibling;
        t.remove(), t = r;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const ic = /* @__PURE__ */ E.define();
function u_(n) {
  return [
    Re.define((e) => new sge(e, n)),
    ic.of(n)
  ];
}
const f_ = !N.ios, ll = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function oge(n = {}) {
  return [
    ll.of(n),
    lge,
    age,
    cge,
    Bk.of(!0)
  ];
}
function d_(n) {
  return n.startState.facet(ll) != n.state.facet(ll);
}
const lge = /* @__PURE__ */ u_({
  above: !0,
  markers(n) {
    let { state: e } = n, t = e.facet(ll), i = [];
    for (let r of e.selection.ranges) {
      let s = r == e.selection.main;
      if (r.empty ? !s || f_ : t.drawRangeCursor) {
        let o = s ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", l = r.empty ? r : S.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (let a of Rl.forRange(n, o, l))
          i.push(a);
      }
    }
    return i;
  },
  update(n, e) {
    n.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = d_(n);
    return t && Db(n.state, e), n.docChanged || n.selectionSet || t;
  },
  mount(n, e) {
    Db(e.state, n);
  },
  class: "cm-cursorLayer"
});
function Db(n, e) {
  e.style.animationDuration = n.facet(ll).cursorBlinkRate + "ms";
}
const age = /* @__PURE__ */ u_({
  above: !1,
  markers(n) {
    return n.state.selection.ranges.map((e) => e.empty ? [] : Rl.forRange(n, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(n, e) {
    return n.docChanged || n.selectionSet || n.viewportChanged || d_(n);
  },
  class: "cm-selectionLayer"
}), p_ = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
f_ && (p_[".cm-line"].caretColor = "transparent !important");
const cge = /* @__PURE__ */ gi.highest(/* @__PURE__ */ I.theme(p_)), g_ = /* @__PURE__ */ G.define({
  map(n, e) {
    return n == null ? null : e.mapPos(n);
  }
}), Co = /* @__PURE__ */ Ue.define({
  create() {
    return null;
  },
  update(n, e) {
    return n != null && (n = e.changes.mapPos(n)), e.effects.reduce((t, i) => i.is(g_) ? i.value : t, n);
  }
}), hge = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.view = n, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(n) {
    var e;
    let t = n.state.field(Co);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (n.startState.field(Co) != t || n.docChanged || n.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let n = this.view.state.field(Co), e = n != null && this.view.coordsAtPos(n);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(n) {
    this.cursor && (n ? (this.cursor.style.left = n.left + "px", this.cursor.style.top = n.top + "px", this.cursor.style.height = n.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(n) {
    this.view.state.field(Co) != n && this.view.dispatch({ effects: g_.of(n) });
  }
}, {
  eventHandlers: {
    dragover(n) {
      this.setDropPos(this.view.posAtCoords({ x: n.clientX, y: n.clientY }));
    },
    dragleave(n) {
      (n.target == this.view.contentDOM || !this.view.contentDOM.contains(n.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function uge() {
  return [Co, hge];
}
function Eb(n, e, t, i, r) {
  e.lastIndex = 0;
  for (let s = n.iterRange(t, i), o = t, l; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; l = e.exec(s.value); )
        r(o + l.index, l);
}
function fge(n, e) {
  let t = n.visibleRanges;
  if (t.length == 1 && t[0].from == n.viewport.from && t[0].to == n.viewport.to)
    return t;
  let i = [];
  for (let { from: r, to: s } of t)
    r = Math.max(n.state.doc.lineAt(r).from, r - e), s = Math.min(n.state.doc.lineAt(s).to, s + e), i.length && i[i.length - 1].to >= r ? i[i.length - 1].to = s : i.push({ from: r, to: s });
  return i;
}
class dge {
  constructor(e) {
    const { regexp: t, decoration: i, decorate: r, boundary: s, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, r)
      this.addMatch = (l, a, c, h) => r(h, c, c + l[0].length, l, a);
    else if (typeof i == "function")
      this.addMatch = (l, a, c, h) => {
        let u = i(l, a, c);
        u && h(c, c + l[0].length, u);
      };
    else if (i)
      this.addMatch = (l, a, c, h) => h(c, c + l[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  createDeco(e) {
    let t = new Vt(), i = t.add.bind(t);
    for (let { from: r, to: s } of fge(e, this.maxLength))
      Eb(e.state.doc, this.regexp, r, s, (o, l) => this.addMatch(l, e, o, i));
    return t.finish();
  }
  updateDeco(e, t) {
    let i = 1e9, r = -1;
    return e.docChanged && e.changes.iterChanges((s, o, l, a) => {
      a > e.view.viewport.from && l < e.view.viewport.to && (i = Math.min(l, i), r = Math.max(a, r));
    }), e.viewportChanged || r - i > 1e3 ? this.createDeco(e.view) : r > -1 ? this.updateRange(e.view, t.map(e.changes), i, r) : t;
  }
  updateRange(e, t, i, r) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, i), l = Math.min(s.to, r);
      if (l > o) {
        let a = e.state.doc.lineAt(o), c = a.to < l ? e.state.doc.lineAt(l) : a, h = Math.max(s.from, a.from), u = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > a.from; o--)
            if (this.boundary.test(a.text[o - 1 - a.from])) {
              h = o;
              break;
            }
          for (; l < c.to; l++)
            if (this.boundary.test(c.text[l - c.from])) {
              u = l;
              break;
            }
        }
        let f = [], d, p = (g, m, b) => f.push(b.range(g, m));
        if (a == c)
          for (this.regexp.lastIndex = h - a.from; (d = this.regexp.exec(a.text)) && d.index < u - a.from; )
            this.addMatch(d, e, d.index + a.from, p);
        else
          Eb(e.state.doc, this.regexp, h, u, (g, m) => this.addMatch(m, e, g, p));
        t = t.update({ filterFrom: h, filterTo: u, filter: (g, m) => g < h || m > u, add: f });
      }
    }
    return t;
  }
}
const qd = /x/.unicode != null ? "gu" : "g", pge = /* @__PURE__ */ new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, qd), gge = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let tf = null;
function mge() {
  var n;
  if (tf == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    tf = ((n = e.tabSize) !== null && n !== void 0 ? n : e.MozTabSize) != null;
  }
  return tf || !1;
}
const rc = /* @__PURE__ */ E.define({
  combine(n) {
    let e = Gn(n, {
      render: null,
      specialChars: pge,
      addSpecialChars: null
    });
    return (e.replaceTabs = !mge()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, qd)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, qd)), e;
  }
});
function bge(n = {}) {
  return [rc.of(n), yge()];
}
let Tb = null;
function yge() {
  return Tb || (Tb = Re.fromClass(class {
    constructor(n) {
      this.view = n, this.decorations = U.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(n.state.facet(rc)), this.decorations = this.decorator.createDeco(n);
    }
    makeDecorator(n) {
      return new dge({
        regexp: n.specialChars,
        decoration: (e, t, i) => {
          let { doc: r } = t.state, s = tt(e[0], 0);
          if (s == 9) {
            let o = r.lineAt(i), l = t.state.tabSize, a = no(o.text, l, i - o.from);
            return U.replace({ widget: new kge((l - a % l) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = U.replace({ widget: new xge(n, s) }));
        },
        boundary: n.replaceTabs ? void 0 : /[^]/
      });
    }
    update(n) {
      let e = n.state.facet(rc);
      n.startState.facet(rc) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(n.view)) : this.decorations = this.decorator.updateDeco(n, this.decorations);
    }
  }, {
    decorations: (n) => n.decorations
  }));
}
const wge = "\u2022";
function vge(n) {
  return n >= 32 ? wge : n == 10 ? "\u2424" : String.fromCharCode(9216 + n);
}
class xge extends mi {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = vge(this.code), i = e.state.phrase("Control character") + " " + (gge[this.code] || "0x" + this.code.toString(16)), r = this.options.render && this.options.render(this.code, i, t);
    if (r)
      return r;
    let s = document.createElement("span");
    return s.textContent = t, s.title = i, s.setAttribute("aria-label", i), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class kge extends mi {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function _ge() {
  return Cge;
}
const Sge = /* @__PURE__ */ U.line({ class: "cm-activeLine" }), Cge = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.docChanged || n.selectionSet) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = -1, t = [];
    for (let i of n.state.selection.ranges) {
      let r = n.lineBlockAt(i.head);
      r.from > e && (t.push(Sge.range(r.from)), e = r.from);
    }
    return U.set(t);
  }
}, {
  decorations: (n) => n.decorations
}), Vd = 2e3;
function Age(n, e, t) {
  let i = Math.min(e.line, t.line), r = Math.max(e.line, t.line), s = [];
  if (e.off > Vd || t.off > Vd || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), l = Math.max(e.off, t.off);
    for (let a = i; a <= r; a++) {
      let c = n.doc.line(a);
      c.length <= l && s.push(S.range(c.from + o, c.to + l));
    }
  } else {
    let o = Math.min(e.col, t.col), l = Math.max(e.col, t.col);
    for (let a = i; a <= r; a++) {
      let c = n.doc.line(a), h = Oc(c.text, o, n.tabSize, !0);
      if (h < 0)
        s.push(S.cursor(c.to));
      else {
        let u = Oc(c.text, l, n.tabSize);
        s.push(S.range(c.from + h, c.from + u));
      }
    }
  }
  return s;
}
function Dge(n, e) {
  let t = n.coordsAtPos(n.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / n.defaultCharacterWidth)) : -1;
}
function Mb(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = n.state.doc.lineAt(t), r = t - i.from, s = r > Vd ? -1 : r == i.length ? Dge(n, e.clientX) : no(i.text, n.state.tabSize, t - i.from);
  return { line: i.number, col: s, off: r };
}
function Ege(n, e) {
  let t = Mb(n, e), i = n.state.selection;
  return t ? {
    update(r) {
      if (r.docChanged) {
        let s = r.changes.mapPos(r.startState.doc.line(t.line).from), o = r.state.doc.lineAt(s);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(r.changes);
      }
    },
    get(r, s, o) {
      let l = Mb(n, r);
      if (!l)
        return i;
      let a = Age(n.state, t, l);
      return a.length ? o ? S.create(a.concat(i.ranges)) : S.create(a) : i;
    }
  } : null;
}
function Tge(n) {
  let e = (n == null ? void 0 : n.eventFilter) || ((t) => t.altKey && t.button == 0);
  return I.mouseSelectionStyle.of((t, i) => e(i) ? Ege(t, i) : null);
}
const Mge = {
  Alt: [18, (n) => !!n.altKey],
  Control: [17, (n) => !!n.ctrlKey],
  Shift: [16, (n) => !!n.shiftKey],
  Meta: [91, (n) => !!n.metaKey]
}, Oge = { style: "cursor: crosshair" };
function Lge(n = {}) {
  let [e, t] = Mge[n.key || "Alt"], i = Re.fromClass(class {
    constructor(r) {
      this.view = r, this.isDown = !1;
    }
    set(r) {
      this.isDown != r && (this.isDown = r, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(r) {
        this.set(r.keyCode == e || t(r));
      },
      keyup(r) {
        (r.keyCode == e || !t(r)) && this.set(!1);
      },
      mousemove(r) {
        this.set(t(r));
      }
    }
  });
  return [
    i,
    I.contentAttributes.of((r) => {
      var s;
      return !((s = r.plugin(i)) === null || s === void 0) && s.isDown ? Oge : null;
    })
  ];
}
const ga = "-10000px";
class m_ {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((r) => r), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    var t;
    let i = e.state.facet(this.facet), r = i.filter((o) => o);
    if (i === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(e);
      return !1;
    }
    let s = [];
    for (let o = 0; o < r.length; o++) {
      let l = r[o], a = -1;
      if (!!l) {
        for (let c = 0; c < this.tooltips.length; c++) {
          let h = this.tooltips[c];
          h && h.create == l.create && (a = c);
        }
        if (a < 0)
          s[o] = this.createTooltipView(l);
        else {
          let c = s[o] = this.tooltipViews[a];
          c.update && c.update(e);
        }
      }
    }
    for (let o of this.tooltipViews)
      s.indexOf(o) < 0 && (o.dom.remove(), (t = o.destroy) === null || t === void 0 || t.call(o));
    return this.input = i, this.tooltips = r, this.tooltipViews = s, !0;
  }
}
function Rge(n) {
  let { win: e } = n;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const nf = /* @__PURE__ */ E.define({
  combine: (n) => {
    var e, t, i;
    return {
      position: N.ios ? "absolute" : ((e = n.find((r) => r.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = n.find((r) => r.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = n.find((r) => r.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Rge
    };
  }
}), Ob = /* @__PURE__ */ new WeakMap(), b_ = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.view = n, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = n.state.facet(nf);
    this.position = e.position, this.parent = e.parent, this.classes = n.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new m_(n, Eg, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), n.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let n of this.manager.tooltipViews)
        this.intersectionObserver.observe(n.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(n) {
    n.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(n);
    e && this.observeIntersection();
    let t = e || n.geometryChanged, i = n.state.facet(nf);
    if (i.position != this.position) {
      this.position = i.position;
      for (let r of this.manager.tooltipViews)
        r.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let r of this.manager.tooltipViews)
        this.container.appendChild(r.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(n) {
    let e = n.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), n.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = ga, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var n, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (n = t.destroy) === null || n === void 0 || n.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let n = this.view.dom.getBoundingClientRect();
    return {
      editor: n,
      parent: this.parent ? this.container.getBoundingClientRect() : n,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(nf).tooltipSpace(this.view)
    };
  }
  writeMeasure(n) {
    var e;
    let { editor: t, space: i } = n, r = [];
    for (let s = 0; s < this.manager.tooltips.length; s++) {
      let o = this.manager.tooltips[s], l = this.manager.tooltipViews[s], { dom: a } = l, c = n.pos[s], h = n.size[s];
      if (!c || c.bottom <= Math.max(t.top, i.top) || c.top >= Math.min(t.bottom, i.bottom) || c.right < Math.max(t.left, i.left) - 0.1 || c.left > Math.min(t.right, i.right) + 0.1) {
        a.style.top = ga;
        continue;
      }
      let u = o.arrow ? l.dom.querySelector(".cm-tooltip-arrow") : null, f = u ? 7 : 0, d = h.right - h.left, p = (e = Ob.get(l)) !== null && e !== void 0 ? e : h.bottom - h.top, g = l.offset || Bge, m = this.view.textDirection == Te.LTR, b = h.width > i.right - i.left ? m ? i.left : i.right - h.width : m ? Math.min(c.left - (u ? 14 : 0) + g.x, i.right - d) : Math.max(i.left, c.left - d + (u ? 14 : 0) - g.x), y = !!o.above;
      !o.strictSide && (y ? c.top - (h.bottom - h.top) - g.y < i.top : c.bottom + (h.bottom - h.top) + g.y > i.bottom) && y == i.bottom - c.bottom > c.top - i.top && (y = !y);
      let k = (y ? c.top - i.top : i.bottom - c.bottom) - f;
      if (k < p && l.resize !== !1) {
        if (k < this.view.defaultLineHeight) {
          a.style.top = ga;
          continue;
        }
        Ob.set(l, p), a.style.height = (p = k) + "px";
      } else
        a.style.height && (a.style.height = "");
      let w = y ? c.top - p - f - g.y : c.bottom + f + g.y, x = b + d;
      if (l.overlap !== !0)
        for (let v of r)
          v.left < x && v.right > b && v.top < w + p && v.bottom > w && (w = y ? v.top - p - 2 - f : v.bottom + f + 2);
      this.position == "absolute" ? (a.style.top = w - n.parent.top + "px", a.style.left = b - n.parent.left + "px") : (a.style.top = w + "px", a.style.left = b + "px"), u && (u.style.left = `${c.left + (m ? g.x : -g.x) - (b + 14 - 7)}px`), l.overlap !== !0 && r.push({ left: b, top: w, right: x, bottom: w + p }), a.classList.toggle("cm-tooltip-above", y), a.classList.toggle("cm-tooltip-below", !y), l.positioned && l.positioned(n.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let n of this.manager.tooltipViews)
        n.dom.style.top = ga;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Ige = /* @__PURE__ */ I.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Bge = { x: 0, y: 0 }, Eg = /* @__PURE__ */ E.define({
  enables: [b_, Ige]
}), Fc = /* @__PURE__ */ E.define();
class Tg {
  static create(e) {
    return new Tg(e);
  }
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new m_(e, Fc, (t) => this.createHostedView(t));
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
}
const Nge = /* @__PURE__ */ Eg.compute([Fc], (n) => {
  let e = n.facet(Fc).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Tg.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Pge {
  constructor(e, t, i, r, s) {
    this.view = e, this.source = t, this.field = i, this.setHover = r, this.hoverTime = s, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: e, lastMove: t } = this, i = e.docView.nearest(t.target);
    if (!i)
      return;
    let r, s = 1;
    if (i instanceof Mi)
      r = i.posAtStart;
    else {
      if (r = e.posAtCoords(t), r == null)
        return;
      let l = e.coordsAtPos(r);
      if (!l || t.y < l.top || t.y > l.bottom || t.x < l.left - e.defaultCharacterWidth || t.x > l.right + e.defaultCharacterWidth)
        return;
      let a = e.bidiSpans(e.state.doc.lineAt(r)).find((h) => h.from <= r && h.to >= r), c = a && a.dir == Te.RTL ? -1 : 1;
      s = t.x < l.left ? -c : c;
    }
    let o = this.source(e, r, s);
    if (o != null && o.then) {
      let l = this.pending = { pos: r };
      o.then((a) => {
        this.pending == l && (this.pending = null, a && e.dispatch({ effects: this.setHover.of(a) }));
      }, (a) => Kt(e.state, a, "hover tooltip"));
    } else
      o && e.dispatch({ effects: this.setHover.of(o) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !Lb(this.lastMove.target) || this.pending) {
      let { pos: r } = i || this.pending, s = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : r;
      (r == s ? this.view.posAtCoords(this.lastMove) != r : !Fge(this.view, r, s, e.clientX, e.clientY, 6)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !Lb(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function Lb(n) {
  for (let e = n; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function Fge(n, e, t, i, r, s) {
  let o = document.createRange(), l = n.domAtPos(e), a = n.domAtPos(t);
  o.setEnd(a.node, a.offset), o.setStart(l.node, l.offset);
  let c = o.getClientRects();
  o.detach();
  for (let h = 0; h < c.length; h++) {
    let u = c[h];
    if (Math.max(u.top - r, r - u.bottom, u.left - i, i - u.right) <= s)
      return !0;
  }
  return !1;
}
function $ge(n, e = {}) {
  let t = G.define(), i = Ue.define({
    create() {
      return null;
    },
    update(r, s) {
      if (r && (e.hideOnChange && (s.docChanged || s.selection) || e.hideOn && e.hideOn(s, r)))
        return null;
      if (r && s.docChanged) {
        let o = s.changes.mapPos(r.pos, -1, qe.TrackDel);
        if (o == null)
          return null;
        let l = Object.assign(/* @__PURE__ */ Object.create(null), r);
        l.pos = o, r.end != null && (l.end = s.changes.mapPos(r.end)), r = l;
      }
      for (let o of s.effects)
        o.is(t) && (r = o.value), o.is(Hge) && (r = null);
      return r;
    },
    provide: (r) => Fc.from(r)
  });
  return [
    i,
    Re.define((r) => new Pge(r, n, i, t, e.hoverTime || 300)),
    Nge
  ];
}
function y_(n, e) {
  let t = n.plugin(b_);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const Hge = /* @__PURE__ */ G.define(), Rb = /* @__PURE__ */ E.define({
  combine(n) {
    let e, t;
    for (let i of n)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function al(n, e) {
  let t = n.plugin(w_), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const w_ = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.input = n.state.facet(cl), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(n));
    let e = n.state.facet(Rb);
    this.top = new ma(n, !0, e.topContainer), this.bottom = new ma(n, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(n) {
    let e = n.state.facet(Rb);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new ma(n.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new ma(n.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = n.state.facet(cl);
    if (t != this.input) {
      let i = t.filter((a) => a), r = [], s = [], o = [], l = [];
      for (let a of i) {
        let c = this.specs.indexOf(a), h;
        c < 0 ? (h = a(n.view), l.push(h)) : (h = this.panels[c], h.update && h.update(n)), r.push(h), (h.top ? s : o).push(h);
      }
      this.specs = i, this.panels = r, this.top.sync(s), this.bottom.sync(o);
      for (let a of l)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(n);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (n) => I.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class ma {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Ib(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Ib(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Ib(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const cl = /* @__PURE__ */ E.define({
  enables: w_
});
class hi extends ai {
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  eq(e) {
    return !1;
  }
  destroy(e) {
  }
}
hi.prototype.elementClass = "";
hi.prototype.toDOM = void 0;
hi.prototype.mapMode = qe.TrackBefore;
hi.prototype.startSide = hi.prototype.endSide = -1;
hi.prototype.point = !0;
const sc = /* @__PURE__ */ E.define(), qge = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => W.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Ho = /* @__PURE__ */ E.define();
function Vge(n) {
  return [v_(), Ho.of(Object.assign(Object.assign({}, qge), n))];
}
const zd = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
});
function v_(n) {
  let e = [
    zge
  ];
  return n && n.fixed === !1 && e.push(zd.of(!0)), e;
}
const zge = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = n.state.facet(Ho).map((e) => new Nb(n, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !n.state.facet(zd), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(zd) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && this.dom.remove();
    let t = W.iter(this.view.state.facet(sc), this.view.viewport.from), i = [], r = this.gutters.map((s) => new Uge(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == Me.Text && o) {
            Ud(t, i, l.from);
            for (let a of r)
              a.line(this.view, l, i);
            o = !1;
          } else if (l.widget)
            for (let a of r)
              a.widget(this.view, l);
      } else if (s.type == Me.Text) {
        Ud(t, i, s.from);
        for (let o of r)
          o.line(this.view, s, i);
      }
    for (let s of r)
      s.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(n) {
    let e = n.startState.facet(Ho), t = n.state.facet(Ho), i = n.docChanged || n.heightChanged || n.viewportChanged || !W.eq(n.startState.facet(sc), n.state.facet(sc), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let r of this.gutters)
        r.update(n) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? r.push(new Nb(this.view, s)) : (this.gutters[o].update(n), r.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
      for (let s of r)
        this.dom.appendChild(s.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => I.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Te.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function Bb(n) {
  return Array.isArray(n) ? n : [n];
}
function Ud(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class Uge {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = W.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: r } = this, s = t.top - this.height;
    if (this.i == r.elements.length) {
      let o = new x_(e, t.height, s, i);
      r.elements.push(o), r.dom.appendChild(o.dom);
    } else
      r.elements[this.i].update(e, t.height, s, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let r = [];
    Ud(this.cursor, r, t.from), i.length && (r = r.concat(i));
    let s = this.gutter.config.lineMarker(e, t, r);
    s && r.unshift(s);
    let o = this.gutter;
    r.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, r);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Nb {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let s = r.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = r.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, l, r) && r.preventDefault();
      });
    this.markers = Bb(t.markers(e)), t.initialSpacer && (this.spacer = new x_(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = Bb(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !W.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class x_ {
  constructor(e, t, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, r);
  }
  update(e, t, i, r) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), Wge(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let h = a.elementClass;
        h && (i += " " + h);
        for (let u = o; u < this.markers.length; u++)
          if (this.markers[u].compare(a)) {
            l = u, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(r);
          let u = r.nextSibling;
          r.remove(), r = u;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(a.toDOM(e), r)), c && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Wge(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
const jge = /* @__PURE__ */ E.define(), as = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let r in t) {
          let s = i[r], o = t[r];
          i[r] = s ? (l, a, c) => s(l, a, c) || o(l, a, c) : o;
        }
        return i;
      }
    });
  }
});
class rf extends hi {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function sf(n, e) {
  return n.state.facet(as).formatNumber(e, n.state);
}
const Gge = /* @__PURE__ */ Ho.compute([as], (n) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(jge);
  },
  lineMarker(e, t, i) {
    return i.some((r) => r.toDOM) ? null : new rf(sf(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(as) != e.state.facet(as),
  initialSpacer(e) {
    return new rf(sf(e, Pb(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = sf(t.view, Pb(t.view.state.doc.lines));
    return i == e.number ? e : new rf(i);
  },
  domEventHandlers: n.facet(as).domEventHandlers
}));
function Kge(n = {}) {
  return [
    as.of(n),
    v_(),
    Gge
  ];
}
function Pb(n) {
  let e = 9;
  for (; e < n; )
    e = e * 10 + 9;
  return e;
}
const Yge = /* @__PURE__ */ new class extends hi {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), Jge = /* @__PURE__ */ sc.compute(["selection"], (n) => {
  let e = [], t = -1;
  for (let i of n.selection.ranges) {
    let r = n.doc.lineAt(i.head).from;
    r > t && (t = r, e.push(Yge.range(r)));
  }
  return W.of(e);
});
function Zge() {
  return Jge;
}
const Xge = 1024;
let Qge = 0;
class of {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class te {
  constructor(e = {}) {
    this.id = Qge++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = tn.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
te.closedBy = new te({ deserialize: (n) => n.split(" ") });
te.openedBy = new te({ deserialize: (n) => n.split(" ") });
te.group = new te({ deserialize: (n) => n.split(" ") });
te.contextHash = new te({ perNode: !0 });
te.lookAhead = new te({ perNode: !0 });
te.mounted = new te({ perNode: !0 });
const eme = /* @__PURE__ */ Object.create(null);
class tn {
  constructor(e, t, i, r = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = r;
  }
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : eme, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), r = new tn(e.name || "", t, e.id, i);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(r)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[s[0].id] = s[1];
        }
    }
    return r;
  }
  prop(e) {
    return this.props[e.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(te.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let r of i.split(" "))
        t[r] = e[i];
    return (i) => {
      for (let r = i.prop(te.group), s = -1; s < (r ? r.length : 0); s++) {
        let o = t[s < 0 ? i.name : r[s]];
        if (o)
          return o;
      }
    };
  }
}
tn.none = new tn("", /* @__PURE__ */ Object.create(null), 0, 8);
const ba = /* @__PURE__ */ new WeakMap(), Fb = /* @__PURE__ */ new WeakMap();
var it;
(function(n) {
  n[n.ExcludeBuffers = 1] = "ExcludeBuffers", n[n.IncludeAnonymous = 2] = "IncludeAnonymous", n[n.IgnoreMounts = 4] = "IgnoreMounts", n[n.IgnoreOverlays = 8] = "IgnoreOverlays";
})(it || (it = {}));
class ft {
  constructor(e, t, i, r, s) {
    if (this.type = e, this.children = t, this.positions = i, this.length = r, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of s)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  toString() {
    let e = this.prop(te.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let r = i.toString();
      r && (t && (t += ","), t += r);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  cursor(e = 0) {
    return new qc(this.topNode, e);
  }
  cursorAt(e, t = 0, i = 0) {
    let r = ba.get(this) || this.topNode, s = new qc(r);
    return s.moveTo(e, t), ba.set(this, s._tree), s;
  }
  get topNode() {
    return new ri(this, 0, 0, null);
  }
  resolve(e, t = 0) {
    let i = Bs(ba.get(this) || this.topNode, e, t, !1);
    return ba.set(this, i), i;
  }
  resolveInner(e, t = 0) {
    let i = Bs(Fb.get(this) || this.topNode, e, t, !0);
    return Fb.set(this, i), i;
  }
  iterate(e) {
    let { enter: t, leave: i, from: r = 0, to: s = this.length } = e, o = e.mode || 0, l = (o & it.IncludeAnonymous) > 0;
    for (let a = this.cursor(o | it.IncludeAnonymous); ; ) {
      let c = !1;
      if (a.from <= s && a.to >= r && (!l && a.type.isAnonymous || t(a) !== !1)) {
        if (a.firstChild())
          continue;
        c = !0;
      }
      for (; c && i && (l || !a.type.isAnonymous) && i(a), !a.nextSibling(); ) {
        if (!a.parent())
          return;
        c = !0;
      }
    }
  }
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  balance(e = {}) {
    return this.children.length <= 8 ? this : Lg(tn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, r) => new ft(this.type, t, i, r, this.propValues), e.makeTree || ((t, i, r) => new ft(tn.none, t, i, r)));
  }
  static build(e) {
    return nme(e);
  }
}
ft.empty = new ft(tn.none, [], [], 0);
class Mg {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Mg(this.buffer, this.index);
  }
}
class qr {
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  get type() {
    return tn.none;
  }
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], r = this.set.types[t], s = r.name;
    if (/\W/.test(s) && !r.isError && (s = JSON.stringify(s)), e += 4, i == e)
      return s;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  findChild(e, t, i, r, s) {
    let { buffer: o } = this, l = -1;
    for (let a = e; a != t && !(k_(s, r, o[a + 1], o[a + 2]) && (l = a, i > 0)); a = o[a + 3])
      ;
    return l;
  }
  slice(e, t, i) {
    let r = this.buffer, s = new Uint16Array(t - e), o = 0;
    for (let l = e, a = 0; l < t; ) {
      s[a++] = r[l++], s[a++] = r[l++] - i;
      let c = s[a++] = r[l++] - i;
      s[a++] = r[l++] - e, o = Math.max(o, c);
    }
    return new qr(s, o, this.set);
  }
}
function k_(n, e, t, i) {
  switch (n) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function __(n, e) {
  let t = n.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (n = t, t = i.prevSibling) : t = i;
  }
  return n;
}
function Bs(n, e, t, i) {
  for (var r; n.from == n.to || (t < 1 ? n.from >= e : n.from > e) || (t > -1 ? n.to <= e : n.to < e); ) {
    let o = !i && n instanceof ri && n.index < 0 ? null : n.parent;
    if (!o)
      return n;
    n = o;
  }
  let s = i ? 0 : it.IgnoreOverlays;
  if (i)
    for (let o = n, l = o.parent; l; o = l, l = o.parent)
      o instanceof ri && o.index < 0 && ((r = l.enter(e, t, s)) === null || r === void 0 ? void 0 : r.from) != o.from && (n = l);
  for (; ; ) {
    let o = n.enter(e, t, s);
    if (!o)
      return n;
    n = o;
  }
}
class ri {
  constructor(e, t, i, r) {
    this._tree = e, this.from = t, this.index = i, this._parent = r;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, r, s = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: a } = o._tree, c = t > 0 ? l.length : -1; e != c; e += t) {
        let h = l[e], u = a[e] + o.from;
        if (!!k_(r, i, u, u + h.length)) {
          if (h instanceof qr) {
            if (s & it.ExcludeBuffers)
              continue;
            let f = h.findChild(0, h.buffer.length, t, i - u, r);
            if (f > -1)
              return new Li(new tme(o, h, e, u), null, f);
          } else if (s & it.IncludeAnonymous || !h.type.isAnonymous || Og(h)) {
            let f;
            if (!(s & it.IgnoreMounts) && h.props && (f = h.prop(te.mounted)) && !f.overlay)
              return new ri(f.tree, u, e, o);
            let d = new ri(h, u, e, o);
            return s & it.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? h.children.length - 1 : 0, t, i, r);
          }
        }
      }
      if (s & it.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(e) {
    return this.nextChild(0, 1, e, 2);
  }
  childBefore(e) {
    return this.nextChild(this._tree.children.length - 1, -1, e, -2);
  }
  enter(e, t, i = 0) {
    let r;
    if (!(i & it.IgnoreOverlays) && (r = this._tree.prop(te.mounted)) && r.overlay) {
      let s = e - this.from;
      for (let { from: o, to: l } of r.overlay)
        if ((t > 0 ? o <= s : o < s) && (t < 0 ? l >= s : l > s))
          return new ri(r.tree, r.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  cursor(e = 0) {
    return new qc(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return Bs(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Bs(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return __(this, e);
  }
  getChild(e, t = null, i = null) {
    let r = $c(this, e, t, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return $c(this, e, t, i);
  }
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Hc(this, e);
  }
}
function $c(n, e, t, i) {
  let r = n.cursor(), s = [];
  if (!r.firstChild())
    return s;
  if (t != null) {
    for (; !r.type.is(t); )
      if (!r.nextSibling())
        return s;
  }
  for (; ; ) {
    if (i != null && r.type.is(i))
      return s;
    if (r.type.is(e) && s.push(r.node), !r.nextSibling())
      return i == null ? s : [];
  }
}
function Hc(n, e, t = e.length - 1) {
  for (let i = n.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class tme {
  constructor(e, t, i, r) {
    this.parent = e, this.buffer = t, this.index = i, this.start = r;
  }
}
class Li {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.context.start, i);
    return s < 0 ? null : new Li(this.context, this, s);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(e) {
    return this.child(1, e, 2);
  }
  childBefore(e) {
    return this.child(-1, e, -2);
  }
  enter(e, t, i = 0) {
    if (i & it.ExcludeBuffers)
      return null;
    let { buffer: r } = this.context, s = r.findChild(this.index + 4, r.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return s < 0 ? null : new Li(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + e, e, 0, 4);
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Li(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Li(this.context, this._parent, e.findChild(t, this.index, -1, 0, 4));
  }
  cursor(e = 0) {
    return new qc(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, r = this.index + 4, s = i.buffer[this.index + 3];
    if (s > r) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(r, s, o)), t.push(0);
    }
    return new ft(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return Bs(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Bs(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return __(this, e);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let r = $c(this, e, t, i);
    return r.length ? r[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return $c(this, e, t, i);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Hc(this, e);
  }
}
class qc {
  get name() {
    return this.type.name;
  }
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ri)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: r } = this.buffer;
    return this.type = t || r.set.types[r.buffer[e]], this.from = i + r.buffer[e + 1], this.to = i + r.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof ri ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: r } = this.buffer, s = r.findChild(this.index + 4, r.buffer[this.index + 3], e, t - this.buffer.start, i);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(e) {
    return this.enterChild(1, e, 2);
  }
  childBefore(e) {
    return this.enterChild(-1, e, -2);
  }
  enter(e, t, i = this.mode) {
    return this.buffer ? i & it.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & it.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & it.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let r = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != r)
        return this.yieldBuf(t.findChild(r, this.index, -1, 0, 4));
    } else {
      let r = t.buffer[this.index + 3];
      if (r < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(r);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: r } = this;
    if (r) {
      if (e > 0) {
        if (this.index < r.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (r.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = r);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let s = t + e, o = e < 0 ? -1 : i._tree.children.length; s != o; s += e) {
          let l = i._tree.children[s];
          if (this.mode & it.IncludeAnonymous || l instanceof qr || !l.type.isAnonymous || Og(l))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(e, 0, 4))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  next(e = !0) {
    return this.move(1, e);
  }
  prev(e = !0) {
    return this.move(-1, e);
  }
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer) {
      e:
        for (let r = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == r) {
              if (r == this.index)
                return o;
              t = o, i = s + 1;
              break e;
            }
          r = this.stack[--s];
        }
    }
    for (let r = i; r < this.stack.length; r++)
      t = new Li(this.buffer, t, this.stack[r]);
    return this.bufferNode = new Li(this.buffer, t, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(e, t) {
    for (let i = 0; ; ) {
      let r = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (r = !0);
      }
      for (; r && t && t(this), r = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, r = !0;
      }
    }
  }
  matchContext(e) {
    if (!this.buffer)
      return Hc(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let r = e.length - 1, s = this.stack.length - 1; r >= 0; s--) {
      if (s < 0)
        return Hc(this.node, e, r);
      let o = i[t.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[r] && e[r] != o.name)
          return !1;
        r--;
      }
    }
    return !0;
  }
}
function Og(n) {
  return n.children.some((e) => e instanceof qr || !e.type.isAnonymous || Og(e));
}
function nme(n) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: r = Xge, reused: s = [], minRepeatType: o = i.types.length } = n, l = Array.isArray(t) ? new Mg(t, t.length) : t, a = i.types, c = 0, h = 0;
  function u(w, x, v, C, B) {
    let { id: R, start: T, end: z, size: se } = l, ee = h;
    for (; se < 0; )
      if (l.next(), se == -1) {
        let ce = s[R];
        v.push(ce), C.push(T - w);
        return;
      } else if (se == -3) {
        c = R;
        return;
      } else if (se == -4) {
        h = R;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${se}`);
    let A = a[R], j, q, we = T - w;
    if (z - T <= r && (q = g(l.pos - x, B))) {
      let ce = new Uint16Array(q.size - q.skip), le = l.pos - q.size, he = ce.length;
      for (; l.pos > le; )
        he = m(q.start, ce, he);
      j = new qr(ce, z - q.start, i), we = q.start - w;
    } else {
      let ce = l.pos - se;
      l.next();
      let le = [], he = [], De = R >= o ? R : -1, ae = 0, sn = z;
      for (; l.pos > ce; )
        De >= 0 && l.id == De && l.size >= 0 ? (l.end <= sn - r && (d(le, he, T, ae, l.end, sn, De, ee), ae = le.length, sn = l.end), l.next()) : u(T, ce, le, he, De);
      if (De >= 0 && ae > 0 && ae < le.length && d(le, he, T, ae, T, sn, De, ee), le.reverse(), he.reverse(), De > -1 && ae > 0) {
        let ge = f(A);
        j = Lg(A, le, he, 0, le.length, 0, z - T, ge, ge);
      } else
        j = p(A, le, he, z - T, ee - z);
    }
    v.push(j), C.push(we);
  }
  function f(w) {
    return (x, v, C) => {
      let B = 0, R = x.length - 1, T, z;
      if (R >= 0 && (T = x[R]) instanceof ft) {
        if (!R && T.type == w && T.length == C)
          return T;
        (z = T.prop(te.lookAhead)) && (B = v[R] + T.length + z);
      }
      return p(w, x, v, C, B);
    };
  }
  function d(w, x, v, C, B, R, T, z) {
    let se = [], ee = [];
    for (; w.length > C; )
      se.push(w.pop()), ee.push(x.pop() + v - B);
    w.push(p(i.types[T], se, ee, R - B, z - R)), x.push(B - v);
  }
  function p(w, x, v, C, B = 0, R) {
    if (c) {
      let T = [te.contextHash, c];
      R = R ? [T].concat(R) : [T];
    }
    if (B > 25) {
      let T = [te.lookAhead, B];
      R = R ? [T].concat(R) : [T];
    }
    return new ft(w, x, v, C, R);
  }
  function g(w, x) {
    let v = l.fork(), C = 0, B = 0, R = 0, T = v.end - r, z = { size: 0, start: 0, skip: 0 };
    e:
      for (let se = v.pos - w; v.pos > se; ) {
        let ee = v.size;
        if (v.id == x && ee >= 0) {
          z.size = C, z.start = B, z.skip = R, R += 4, C += 4, v.next();
          continue;
        }
        let A = v.pos - ee;
        if (ee < 0 || A < se || v.start < T)
          break;
        let j = v.id >= o ? 4 : 0, q = v.start;
        for (v.next(); v.pos > A; ) {
          if (v.size < 0)
            if (v.size == -3)
              j += 4;
            else
              break e;
          else
            v.id >= o && (j += 4);
          v.next();
        }
        B = q, C += ee, R += j;
      }
    return (x < 0 || C == w) && (z.size = C, z.start = B, z.skip = R), z.size > 4 ? z : void 0;
  }
  function m(w, x, v) {
    let { id: C, start: B, end: R, size: T } = l;
    if (l.next(), T >= 0 && C < o) {
      let z = v;
      if (T > 4) {
        let se = l.pos - (T - 4);
        for (; l.pos > se; )
          v = m(w, x, v);
      }
      x[--v] = z, x[--v] = R - w, x[--v] = B - w, x[--v] = C;
    } else
      T == -3 ? c = C : T == -4 && (h = C);
    return v;
  }
  let b = [], y = [];
  for (; l.pos > 0; )
    u(n.start || 0, n.bufferStart || 0, b, y, -1);
  let k = (e = n.length) !== null && e !== void 0 ? e : b.length ? y[0] + b[0].length : 0;
  return new ft(a[n.topID], b.reverse(), y.reverse(), k);
}
const $b = /* @__PURE__ */ new WeakMap();
function oc(n, e) {
  if (!n.isAnonymous || e instanceof qr || e.type != n)
    return 1;
  let t = $b.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != n || !(i instanceof ft)) {
        t = 1;
        break;
      }
      t += oc(n, i);
    }
    $b.set(e, t);
  }
  return t;
}
function Lg(n, e, t, i, r, s, o, l, a) {
  let c = 0;
  for (let p = i; p < r; p++)
    c += oc(n, e[p]);
  let h = Math.ceil(c * 1.5 / 8), u = [], f = [];
  function d(p, g, m, b, y) {
    for (let k = m; k < b; ) {
      let w = k, x = g[k], v = oc(n, p[k]);
      for (k++; k < b; k++) {
        let C = oc(n, p[k]);
        if (v + C >= h)
          break;
        v += C;
      }
      if (k == w + 1) {
        if (v > h) {
          let C = p[w];
          d(C.children, C.positions, 0, C.children.length, g[w] + y);
          continue;
        }
        u.push(p[w]);
      } else {
        let C = g[k - 1] + p[k - 1].length - x;
        u.push(Lg(n, p, g, w, k, x, C, null, a));
      }
      f.push(x + y - s);
    }
  }
  return d(e, t, i, r, 0), (l || a)(u, f, o);
}
class vr {
  constructor(e, t, i, r, s = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = r, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(e, t = [], i = !1) {
    let r = [new vr(0, e.length, e, 0, !1, i)];
    for (let s of t)
      s.to > e.length && r.push(s);
    return r;
  }
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let r = [], s = 1, o = e.length ? e[0] : null;
    for (let l = 0, a = 0, c = 0; ; l++) {
      let h = l < t.length ? t[l] : null, u = h ? h.fromA : 1e9;
      if (u - a >= i)
        for (; o && o.from < u; ) {
          let f = o;
          if (a >= f.from || u <= f.to || c) {
            let d = Math.max(f.from, a) - c, p = Math.min(f.to, u) - c;
            f = d >= p ? null : new vr(d, p, f.tree, f.offset + c, l > 0, !!h);
          }
          if (f && r.push(f), o.to > u)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!h)
        break;
      a = h.toA, c = h.toA - h.toB;
    }
    return r;
  }
}
class ime {
  startParse(e, t, i) {
    return typeof e == "string" && (e = new rme(e)), i = i ? i.length ? i.map((r) => new of(r.from, r.to)) : [new of(0, 0)] : [new of(0, e.length)], this.createParse(e, t || [], i);
  }
  parse(e, t, i) {
    let r = this.startParse(e, t, i);
    for (; ; ) {
      let s = r.advance();
      if (s)
        return s;
    }
  }
}
class rme {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
new te({ perNode: !0 });
let sme = 0;
class En {
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = sme++;
  }
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new En([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  static defineModifier() {
    let e = new Vc();
    return (t) => t.modified.indexOf(e) > -1 ? t : Vc.get(t.base || t, t.modified.concat(e).sort((i, r) => i.id - r.id));
  }
}
let ome = 0;
class Vc {
  constructor() {
    this.instances = [], this.id = ome++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((l) => l.base == e && lme(t, l.modified));
    if (i)
      return i;
    let r = [], s = new En(r, e, t);
    for (let l of t)
      l.instances.push(s);
    let o = ame(t);
    for (let l of e.set)
      if (!l.modified.length)
        for (let a of o)
          r.push(Vc.get(l, a));
    return s;
  }
}
function lme(n, e) {
  return n.length == e.length && n.every((t, i) => t == e[i]);
}
function ame(n) {
  let e = [[]];
  for (let t = 0; t < n.length; t++)
    for (let i = 0, r = e.length; i < r; i++)
      e.push(e[i].concat(n[t]));
  return e.sort((t, i) => i.length - t.length);
}
function cme(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let i = n[t];
    Array.isArray(i) || (i = [i]);
    for (let r of t.split(" "))
      if (r) {
        let s = [], o = 2, l = r;
        for (let u = 0; ; ) {
          if (l == "..." && u > 0 && u + 3 == r.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!f)
            throw new RangeError("Invalid path: " + r);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), u += f[0].length, u == r.length)
            break;
          let d = r[u++];
          if (u == r.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + r);
          l = r.slice(u);
        }
        let a = s.length - 1, c = s[a];
        if (!c)
          throw new RangeError("Invalid path: " + r);
        let h = new zc(i, o, a > 0 ? s.slice(0, a) : null);
        e[c] = h.sort(e[c]);
      }
  }
  return S_.add(e);
}
const S_ = new te();
class zc {
  constructor(e, t, i, r) {
    this.tags = e, this.mode = t, this.context = i, this.next = r;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
zc.empty = new zc([], 2, null);
function C_(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let s of n)
    if (!Array.isArray(s.tag))
      t[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        t[o.id] = s.class;
  let { scope: i, all: r = null } = e || {};
  return {
    style: (s) => {
      let o = r;
      for (let l of s)
        for (let a of l.set) {
          let c = t[a.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function hme(n, e) {
  let t = null;
  for (let i of n) {
    let r = i.style(e);
    r && (t = t ? t + " " + r : r);
  }
  return t;
}
function ume(n, e, t, i = 0, r = n.length) {
  let s = new fme(i, Array.isArray(e) ? e : [e], t);
  s.highlightRange(n.cursor(), i, r, "", s.highlighters), s.flush(r);
}
class fme {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, r, s) {
    let { type: o, from: l, to: a } = e;
    if (l >= i || a <= t)
      return;
    o.isTop && (s = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let c = r, h = dme(e) || zc.empty, u = hme(s, h.tags);
    if (u && (c && (c += " "), c += u, h.mode == 1 && (r += (r ? " " : "") + u)), this.startSpan(Math.max(t, l), c), h.opaque)
      return;
    let f = e.tree && e.tree.prop(te.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + l, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(f.tree.type)), g = e.firstChild();
      for (let m = 0, b = l; ; m++) {
        let y = m < f.overlay.length ? f.overlay[m] : null, k = y ? y.from + l : a, w = Math.max(t, b), x = Math.min(i, k);
        if (w < x && g)
          for (; e.from < x && (this.highlightRange(e, w, x, r, s), this.startSpan(Math.min(x, e.to), c), !(e.to >= k || !e.nextSibling())); )
            ;
        if (!y || k > i)
          break;
        b = y.to + l, b > t && (this.highlightRange(d.cursor(), Math.max(t, y.from + l), Math.min(i, b), "", p), this.startSpan(Math.min(i, b), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (r = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, r, s), this.startSpan(Math.min(i, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function dme(n) {
  let e = n.type.prop(S_);
  for (; e && e.context && !n.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const M = En.define, ya = M(), _i = M(), Hb = M(_i), qb = M(_i), Si = M(), wa = M(Si), lf = M(Si), An = M(), sr = M(An), kn = M(), _n = M(), Wd = M(), go = M(Wd), va = M(), L = {
  comment: ya,
  lineComment: M(ya),
  blockComment: M(ya),
  docComment: M(ya),
  name: _i,
  variableName: M(_i),
  typeName: Hb,
  tagName: M(Hb),
  propertyName: qb,
  attributeName: M(qb),
  className: M(_i),
  labelName: M(_i),
  namespace: M(_i),
  macroName: M(_i),
  literal: Si,
  string: wa,
  docString: M(wa),
  character: M(wa),
  attributeValue: M(wa),
  number: lf,
  integer: M(lf),
  float: M(lf),
  bool: M(Si),
  regexp: M(Si),
  escape: M(Si),
  color: M(Si),
  url: M(Si),
  keyword: kn,
  self: M(kn),
  null: M(kn),
  atom: M(kn),
  unit: M(kn),
  modifier: M(kn),
  operatorKeyword: M(kn),
  controlKeyword: M(kn),
  definitionKeyword: M(kn),
  moduleKeyword: M(kn),
  operator: _n,
  derefOperator: M(_n),
  arithmeticOperator: M(_n),
  logicOperator: M(_n),
  bitwiseOperator: M(_n),
  compareOperator: M(_n),
  updateOperator: M(_n),
  definitionOperator: M(_n),
  typeOperator: M(_n),
  controlOperator: M(_n),
  punctuation: Wd,
  separator: M(Wd),
  bracket: go,
  angleBracket: M(go),
  squareBracket: M(go),
  paren: M(go),
  brace: M(go),
  content: An,
  heading: sr,
  heading1: M(sr),
  heading2: M(sr),
  heading3: M(sr),
  heading4: M(sr),
  heading5: M(sr),
  heading6: M(sr),
  contentSeparator: M(An),
  list: M(An),
  quote: M(An),
  emphasis: M(An),
  strong: M(An),
  link: M(An),
  monospace: M(An),
  strikethrough: M(An),
  inserted: M(),
  deleted: M(),
  changed: M(),
  invalid: M(),
  meta: va,
  documentMeta: M(va),
  annotation: M(va),
  processingInstruction: M(va),
  definition: En.defineModifier(),
  constant: En.defineModifier(),
  function: En.defineModifier(),
  standard: En.defineModifier(),
  local: En.defineModifier(),
  special: En.defineModifier()
};
C_([
  { tag: L.link, class: "tok-link" },
  { tag: L.heading, class: "tok-heading" },
  { tag: L.emphasis, class: "tok-emphasis" },
  { tag: L.strong, class: "tok-strong" },
  { tag: L.keyword, class: "tok-keyword" },
  { tag: L.atom, class: "tok-atom" },
  { tag: L.bool, class: "tok-bool" },
  { tag: L.url, class: "tok-url" },
  { tag: L.labelName, class: "tok-labelName" },
  { tag: L.inserted, class: "tok-inserted" },
  { tag: L.deleted, class: "tok-deleted" },
  { tag: L.literal, class: "tok-literal" },
  { tag: L.string, class: "tok-string" },
  { tag: L.number, class: "tok-number" },
  { tag: [L.regexp, L.escape, L.special(L.string)], class: "tok-string2" },
  { tag: L.variableName, class: "tok-variableName" },
  { tag: L.local(L.variableName), class: "tok-variableName tok-local" },
  { tag: L.definition(L.variableName), class: "tok-variableName tok-definition" },
  { tag: L.special(L.variableName), class: "tok-variableName2" },
  { tag: L.definition(L.propertyName), class: "tok-propertyName tok-definition" },
  { tag: L.typeName, class: "tok-typeName" },
  { tag: L.namespace, class: "tok-namespace" },
  { tag: L.className, class: "tok-className" },
  { tag: L.macroName, class: "tok-macroName" },
  { tag: L.propertyName, class: "tok-propertyName" },
  { tag: L.operator, class: "tok-operator" },
  { tag: L.comment, class: "tok-comment" },
  { tag: L.meta, class: "tok-meta" },
  { tag: L.invalid, class: "tok-invalid" },
  { tag: L.punctuation, class: "tok-punctuation" }
]);
var af;
const Ao = /* @__PURE__ */ new te(), pme = /* @__PURE__ */ new te();
class Bn {
  constructor(e, t, i = [], r = "") {
    this.data = e, this.name = r, J.prototype.hasOwnProperty("tree") || Object.defineProperty(J.prototype, "tree", { get() {
      return pt(this);
    } }), this.parser = t, this.extension = [
      ji.of(this),
      J.languageData.of((s, o, l) => {
        let a = Vb(s, o, l), c = a.type.prop(Ao);
        if (!c)
          return [];
        let h = s.facet(c), u = a.type.prop(pme);
        if (u) {
          let f = a.resolve(o - a.from, l);
          for (let d of u)
            if (d.test(f, s)) {
              let p = s.facet(d.facet);
              return d.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  isActiveAt(e, t, i = -1) {
    return Vb(e, t, i).type.prop(Ao) == this.data;
  }
  findRegions(e) {
    let t = e.facet(ji);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], r = (s, o) => {
      if (s.prop(Ao) == this.data) {
        i.push({ from: o, to: o + s.length });
        return;
      }
      let l = s.prop(te.mounted);
      if (l) {
        if (l.tree.prop(Ao) == this.data) {
          if (l.overlay)
            for (let a of l.overlay)
              i.push({ from: a.from + o, to: a.to + o });
          else
            i.push({ from: o, to: o + s.length });
          return;
        } else if (l.overlay) {
          let a = i.length;
          if (r(l.tree, l.overlay[0].from + o), i.length > a)
            return;
        }
      }
      for (let a = 0; a < s.children.length; a++) {
        let c = s.children[a];
        c instanceof ft && r(c, s.positions[a] + o);
      }
    };
    return r(pt(e), 0), i;
  }
  get allowsNesting() {
    return !0;
  }
}
Bn.setState = /* @__PURE__ */ G.define();
function Vb(n, e, t) {
  let i = n.facet(ji), r = pt(n).topNode;
  if (!i || i.allowsNesting)
    for (let s = r; s; s = s.enter(e, t, it.ExcludeBuffers))
      s.type.isTop && (r = s);
  return r;
}
function pt(n) {
  let e = n.field(Bn.state, !1);
  return e ? e.tree : ft.empty;
}
class gme {
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let mo = null;
class Uc {
  constructor(e, t, i = [], r, s, o, l, a) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = r, this.treeLen = s, this.viewport = o, this.skipped = l, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  static create(e, t, i) {
    return new Uc(e, t, [], ft.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new gme(this.state.doc), this.fragments);
  }
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != ft.empty && this.isDone(t != null ? t : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let r = Date.now() + e;
        e = () => Date.now() > r;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let r = this.parse.advance();
        if (r)
          if (this.fragments = this.withoutTempSkipped(vr.addTree(r, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = r, this.parse = null, this.treeLen < (t != null ? t : this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(vr.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = mo;
    mo = this;
    try {
      return e();
    } finally {
      mo = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = zb(e, t.from, t.to);
    return e;
  }
  changes(e, t) {
    let { fragments: i, tree: r, treeLen: s, viewport: o, skipped: l } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, h, u, f) => a.push({ fromA: c, toA: h, fromB: u, toB: f })), i = vr.applyChanges(i, a), r = ft.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let c of this.skipped) {
          let h = e.mapPos(c.from, 1), u = e.mapPos(c.to, -1);
          h < u && l.push({ from: h, to: u });
        }
      }
    }
    return new Uc(this.parser, t, i, r, s, o, l, this.scheduleOn);
  }
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: r, to: s } = this.skipped[i];
      r < e.to && s > e.from && (this.fragments = zb(this.fragments, r, s), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  static getSkippingParser(e) {
    return new class extends ime {
      createParse(t, i, r) {
        let s = r[0].from, o = r[r.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let a = mo;
            if (a) {
              for (let c of r)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new ft(tn.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  static get() {
    return mo;
  }
}
function zb(n, e, t) {
  return vr.applyChanges(n, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Ns {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new Ns(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = Uc.create(e.facet(ji).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new Ns(i);
  }
}
Bn.state = /* @__PURE__ */ Ue.define({
  create: Ns.init,
  update(n, e) {
    for (let t of e.effects)
      if (t.is(Bn.setState))
        return t.value;
    return e.startState.facet(ji) != e.state.facet(ji) ? Ns.init(e.state) : n.apply(e);
  }
});
let A_ = (n) => {
  let e = setTimeout(() => n(), 500);
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (A_ = (n) => {
  let e = -1, t = setTimeout(() => {
    e = requestIdleCallback(n, { timeout: 500 - 100 });
  }, 100);
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const cf = typeof navigator < "u" && ((af = navigator.scheduling) === null || af === void 0 ? void 0 : af.isInputPending) ? () => navigator.scheduling.isInputPending() : null, mme = /* @__PURE__ */ Re.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Bn.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Bn.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = A_(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: r } } = this.view, s = i.field(Bn.state);
    if (s.tree == s.context.tree && s.context.isDone(r + 1e5))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !cf ? Math.max(25, e.timeRemaining() - 5) : 1e9), l = s.context.treeLen < r && i.doc.length > r + 1e3, a = s.context.work(() => cf && cf() || Date.now() > o, r + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: Bn.setState.of(new Ns(s.context)) })), this.chunkBudget > 0 && !(a && !l) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Kt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), ji = /* @__PURE__ */ E.define({
  combine(n) {
    return n.length ? n[0] : null;
  },
  enables: (n) => [
    Bn.state,
    mme,
    I.contentAttributes.compute([n], (e) => {
      let t = e.facet(n);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
}), bme = /* @__PURE__ */ E.define(), Rg = /* @__PURE__ */ E.define({
  combine: (n) => {
    if (!n.length)
      return "  ";
    let e = n[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(n[0]));
    return e;
  }
});
function Wc(n) {
  let e = n.facet(Rg);
  return e.charCodeAt(0) == 9 ? n.tabSize * e.length : e.length;
}
function hl(n, e) {
  let t = "", i = n.tabSize, r = n.facet(Rg)[0];
  if (r == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    r = " ";
  }
  for (let s = 0; s < e; s++)
    t += r;
  return t;
}
function Ig(n, e) {
  n instanceof J && (n = new Fh(n));
  for (let i of n.state.facet(bme)) {
    let r = i(n, e);
    if (r !== void 0)
      return r;
  }
  let t = pt(n.state);
  return t.length >= e ? wme(n, t, e) : null;
}
class Fh {
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = Wc(e);
  }
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: r, simulateDoubleBreak: s } = this.options;
    return r != null && r >= i.from && r <= i.to ? s && r == e ? { text: "", from: e } : (t < 0 ? r < e : r <= e) ? { text: i.text.slice(r - i.from), from: r } : { text: i.text.slice(0, r - i.from), from: i.from } : i;
  }
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: r } = this.lineAt(e, t);
    return i.slice(e - r, Math.min(i.length, e + 100 - r));
  }
  column(e, t = 1) {
    let { text: i, from: r } = this.lineAt(e, t), s = this.countColumn(i, e - r), o = this.options.overrideIndentation ? this.options.overrideIndentation(r) : -1;
    return o > -1 && (s += o - this.countColumn(i, i.search(/\S|$/))), s;
  }
  countColumn(e, t = e.length) {
    return no(e, this.state.tabSize, t);
  }
  lineIndent(e, t = 1) {
    let { text: i, from: r } = this.lineAt(e, t), s = this.options.overrideIndentation;
    if (s) {
      let o = s(r);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const yme = /* @__PURE__ */ new te();
function wme(n, e, t) {
  return D_(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, n);
}
function vme(n) {
  return n.pos == n.options.simulateBreak && n.options.simulateDoubleBreak;
}
function xme(n) {
  let e = n.type.prop(yme);
  if (e)
    return e;
  let t = n.firstChild, i;
  if (t && (i = t.type.prop(te.closedBy))) {
    let r = n.lastChild, s = r && i.indexOf(r.name) > -1;
    return (o) => Cme(o, !0, 1, void 0, s && !vme(o) ? r.from : void 0);
  }
  return n.parent == null ? kme : null;
}
function D_(n, e, t) {
  for (; n; n = n.parent) {
    let i = xme(n);
    if (i)
      return i(Bg.create(t, e, n));
  }
  return null;
}
function kme() {
  return 0;
}
class Bg extends Fh {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  static create(e, t, i) {
    return new Bg(e, t, i);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (_me(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  continue() {
    let e = this.node.parent;
    return e ? D_(e, this.pos, this.base) : 0;
  }
}
function _me(n, e) {
  for (let t = e; t; t = t.parent)
    if (n == t)
      return !0;
  return !1;
}
function Sme(n) {
  let e = n.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let r = n.options.simulateBreak, s = n.state.doc.lineAt(t.from), o = r == null || r <= s.from ? s.to : Math.min(s.to, r);
  for (let l = t.to; ; ) {
    let a = e.childAfter(l);
    if (!a || a == i)
      return null;
    if (!a.type.isSkipped)
      return a.from < o ? t : null;
    l = a.to;
  }
}
function Cme(n, e, t, i, r) {
  let s = n.textAfter, o = s.match(/^\s*/)[0].length, l = i && s.slice(o, o + i.length) == i || r == n.pos + o, a = e ? Sme(n) : null;
  return a ? l ? n.column(a.from) : n.column(a.to) : n.baseIndent + (l ? 0 : n.unit * t);
}
const Ame = 200;
function Dme() {
  return J.transactionFilter.of((n) => {
    if (!n.docChanged || !n.isUserEvent("input.type") && !n.isUserEvent("input.complete"))
      return n;
    let e = n.startState.languageDataAt("indentOnInput", n.startState.selection.main.head);
    if (!e.length)
      return n;
    let t = n.newDoc, { head: i } = n.newSelection.main, r = t.lineAt(i);
    if (i > r.from + Ame)
      return n;
    let s = t.sliceString(r.from, i);
    if (!e.some((c) => c.test(s)))
      return n;
    let { state: o } = n, l = -1, a = [];
    for (let { head: c } of o.selection.ranges) {
      let h = o.doc.lineAt(c);
      if (h.from == l)
        continue;
      l = h.from;
      let u = Ig(o, h.from);
      if (u == null)
        continue;
      let f = /^\s*/.exec(h.text)[0], d = hl(o, u);
      f != d && a.push({ from: h.from, to: h.from + f.length, insert: d });
    }
    return a.length ? [n, { changes: a, sequential: !0 }] : n;
  });
}
const Eme = /* @__PURE__ */ E.define(), Tme = /* @__PURE__ */ new te();
function Mme(n, e, t) {
  let i = pt(n);
  if (i.length < t)
    return null;
  let r = i.resolveInner(t, 1), s = null;
  for (let o = r; o; o = o.parent) {
    if (o.to <= t || o.from > t)
      continue;
    if (s && o.from < e)
      break;
    let l = o.type.prop(Tme);
    if (l && (o.to < i.length - 50 || i.length == n.doc.length || !Ome(o))) {
      let a = l(o, n);
      a && a.from <= t && a.from >= e && a.to > t && (s = a);
    }
  }
  return s;
}
function Ome(n) {
  let e = n.lastChild;
  return e && e.to == n.to && e.type.isError;
}
function jc(n, e, t) {
  for (let i of n.facet(Eme)) {
    let r = i(n, e, t);
    if (r)
      return r;
  }
  return Mme(n, e, t);
}
function E_(n, e) {
  let t = e.mapPos(n.from, 1), i = e.mapPos(n.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const $h = /* @__PURE__ */ G.define({ map: E_ }), Il = /* @__PURE__ */ G.define({ map: E_ });
function T_(n) {
  let e = [];
  for (let { head: t } of n.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(n.lineBlockAt(t));
  return e;
}
const Or = /* @__PURE__ */ Ue.define({
  create() {
    return U.none;
  },
  update(n, e) {
    n = n.map(e.changes);
    for (let t of e.effects)
      if (t.is($h) && !Lme(n, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Ng), r = i ? U.replace({ widget: new $me(i(e.state, t.value)) }) : Ub;
        n = n.update({ add: [r.range(t.value.from, t.value.to)] });
      } else
        t.is(Il) && (n = n.update({
          filter: (i, r) => t.value.from != i || t.value.to != r,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      n.between(i, i, (r, s) => {
        r < i && s > i && (t = !0);
      }), t && (n = n.update({
        filterFrom: i,
        filterTo: i,
        filter: (r, s) => s <= i || r >= i
      }));
    }
    return n;
  },
  provide: (n) => I.decorations.from(n),
  toJSON(n, e) {
    let t = [];
    return n.between(0, e.doc.length, (i, r) => {
      t.push(i, r);
    }), t;
  },
  fromJSON(n) {
    if (!Array.isArray(n) || n.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < n.length; ) {
      let i = n[t++], r = n[t++];
      if (typeof i != "number" || typeof r != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Ub.range(i, r));
    }
    return U.set(e, !0);
  }
});
function Gc(n, e, t) {
  var i;
  let r = null;
  return (i = n.field(Or, !1)) === null || i === void 0 || i.between(e, t, (s, o) => {
    (!r || r.from > s) && (r = { from: s, to: o });
  }), r;
}
function Lme(n, e, t) {
  let i = !1;
  return n.between(e, e, (r, s) => {
    r == e && s == t && (i = !0);
  }), i;
}
function M_(n, e) {
  return n.field(Or, !1) ? e : e.concat(G.appendConfig.of(L_()));
}
const Rme = (n) => {
  for (let e of T_(n)) {
    let t = jc(n.state, e.from, e.to);
    if (t)
      return n.dispatch({ effects: M_(n.state, [$h.of(t), O_(n, t)]) }), !0;
  }
  return !1;
}, Ime = (n) => {
  if (!n.state.field(Or, !1))
    return !1;
  let e = [];
  for (let t of T_(n)) {
    let i = Gc(n.state, t.from, t.to);
    i && e.push(Il.of(i), O_(n, i, !1));
  }
  return e.length && n.dispatch({ effects: e }), e.length > 0;
};
function O_(n, e, t = !0) {
  let i = n.state.doc.lineAt(e.from).number, r = n.state.doc.lineAt(e.to).number;
  return I.announce.of(`${n.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${n.state.phrase("to")} ${r}.`);
}
const Bme = (n) => {
  let { state: e } = n, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let r = n.lineBlockAt(i), s = jc(e, r.from, r.to);
    s && t.push($h.of(s)), i = (s ? n.lineBlockAt(s.to) : r).to + 1;
  }
  return t.length && n.dispatch({ effects: M_(n.state, t) }), !!t.length;
}, Nme = (n) => {
  let e = n.state.field(Or, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, n.state.doc.length, (i, r) => {
    t.push(Il.of({ from: i, to: r }));
  }), n.dispatch({ effects: t }), !0;
}, Pme = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Rme },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Ime },
  { key: "Ctrl-Alt-[", run: Bme },
  { key: "Ctrl-Alt-]", run: Nme }
], Fme = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "\u2026"
}, Ng = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, Fme);
  }
});
function L_(n) {
  let e = [Or, Vme];
  return n && e.push(Ng.of(n)), e;
}
function R_(n, e) {
  let { state: t } = n, i = t.facet(Ng), r = (o) => {
    let l = n.lineBlockAt(n.posAtDOM(o.target)), a = Gc(n.state, l.from, l.to);
    a && n.dispatch({ effects: Il.of(a) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(n, r, e);
  let s = document.createElement("span");
  return s.textContent = i.placeholderText, s.setAttribute("aria-label", t.phrase("folded code")), s.title = t.phrase("unfold"), s.className = "cm-foldPlaceholder", s.onclick = r, s;
}
const Ub = /* @__PURE__ */ U.replace({ widget: /* @__PURE__ */ new class extends mi {
  toDOM(n) {
    return R_(n, null);
  }
}() });
class $me extends mi {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return R_(e, this.value);
  }
}
const Hme = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class hf extends hi {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function qme(n = {}) {
  let e = Object.assign(Object.assign({}, Hme), n), t = new hf(e, !0), i = new hf(e, !1), r = Re.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(ji) != o.state.facet(ji) || o.startState.field(Or, !1) != o.state.field(Or, !1) || pt(o.startState) != pt(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new Vt();
      for (let a of o.viewportLineBlocks) {
        let c = Gc(o.state, a.from, a.to) ? i : jc(o.state, a.from, a.to) ? t : null;
        c && l.add(a.from, a.from, c);
      }
      return l.finish();
    }
  }), { domEventHandlers: s } = e;
  return [
    r,
    Vge({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(r)) === null || l === void 0 ? void 0 : l.markers) || W.empty;
      },
      initialSpacer() {
        return new hf(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, s), { click: (o, l, a) => {
        if (s.click && s.click(o, l, a))
          return !0;
        let c = Gc(o.state, l.from, l.to);
        if (c)
          return o.dispatch({ effects: Il.of(c) }), !0;
        let h = jc(o.state, l.from, l.to);
        return h ? (o.dispatch({ effects: $h.of(h) }), !0) : !1;
      } })
    }),
    L_()
  ];
}
const Vme = /* @__PURE__ */ I.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Hh {
  constructor(e, t) {
    this.specs = e;
    let i;
    function r(l) {
      let a = Ct.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + a] = l, a;
    }
    const s = typeof t.all == "string" ? t.all : t.all ? r(t.all) : void 0, o = t.scope;
    this.scope = o instanceof Bn ? (l) => l.prop(Ao) == o.data : o ? (l) => l == o : void 0, this.style = C_(e.map((l) => ({
      tag: l.tag,
      class: l.class || r(Object.assign({}, l, { tag: null }))
    })), {
      all: s
    }).style, this.module = i ? new Ct(i) : null, this.themeType = t.themeType;
  }
  static define(e, t) {
    return new Hh(e, t || {});
  }
}
const jd = /* @__PURE__ */ E.define(), I_ = /* @__PURE__ */ E.define({
  combine(n) {
    return n.length ? [n[0]] : null;
  }
});
function uf(n) {
  let e = n.facet(jd);
  return e.length ? e : n.facet(I_);
}
function zme(n, e) {
  let t = [Wme], i;
  return n instanceof Hh && (n.module && t.push(I.styleModule.of(n.module)), i = n.themeType), e != null && e.fallback ? t.push(I_.of(n)) : i ? t.push(jd.computeN([I.darkTheme], (r) => r.facet(I.darkTheme) == (i == "dark") ? [n] : [])) : t.push(jd.of(n)), t;
}
class Ume {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = pt(e.state), this.decorations = this.buildDeco(e, uf(e.state));
  }
  update(e) {
    let t = pt(e.state), i = uf(e.state), r = i != uf(e.startState);
    t.length < e.view.viewport.to && !r && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || r) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return U.none;
    let i = new Vt();
    for (let { from: r, to: s } of e.visibleRanges)
      ume(this.tree, t, (o, l, a) => {
        i.add(o, l, this.markCache[a] || (this.markCache[a] = U.mark({ class: a })));
      }, r, s);
    return i.finish();
  }
}
const Wme = /* @__PURE__ */ gi.high(/* @__PURE__ */ Re.fromClass(Ume, {
  decorations: (n) => n.decorations
})), jme = /* @__PURE__ */ Hh.define([
  {
    tag: L.meta,
    color: "#404740"
  },
  {
    tag: L.link,
    textDecoration: "underline"
  },
  {
    tag: L.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: L.emphasis,
    fontStyle: "italic"
  },
  {
    tag: L.strong,
    fontWeight: "bold"
  },
  {
    tag: L.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: L.keyword,
    color: "#708"
  },
  {
    tag: [L.atom, L.bool, L.url, L.contentSeparator, L.labelName],
    color: "#219"
  },
  {
    tag: [L.literal, L.inserted],
    color: "#164"
  },
  {
    tag: [L.string, L.deleted],
    color: "#a11"
  },
  {
    tag: [L.regexp, L.escape, /* @__PURE__ */ L.special(L.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ L.definition(L.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ L.local(L.variableName),
    color: "#30a"
  },
  {
    tag: [L.typeName, L.namespace],
    color: "#085"
  },
  {
    tag: L.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ L.special(L.variableName), L.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ L.definition(L.propertyName),
    color: "#00c"
  },
  {
    tag: L.comment,
    color: "#940"
  },
  {
    tag: L.invalid,
    color: "#f00"
  }
]), Gme = /* @__PURE__ */ I.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), B_ = 1e4, N_ = "()[]{}", P_ = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, {
      afterCursor: !0,
      brackets: N_,
      maxScanDistance: B_,
      renderMatch: Jme
    });
  }
}), Kme = /* @__PURE__ */ U.mark({ class: "cm-matchingBracket" }), Yme = /* @__PURE__ */ U.mark({ class: "cm-nonmatchingBracket" });
function Jme(n) {
  let e = [], t = n.matched ? Kme : Yme;
  return e.push(t.range(n.start.from, n.start.to)), n.end && e.push(t.range(n.end.from, n.end.to)), e;
}
const Zme = /* @__PURE__ */ Ue.define({
  create() {
    return U.none;
  },
  update(n, e) {
    if (!e.docChanged && !e.selection)
      return n;
    let t = [], i = e.state.facet(P_);
    for (let r of e.state.selection.ranges) {
      if (!r.empty)
        continue;
      let s = Nn(e.state, r.head, -1, i) || r.head > 0 && Nn(e.state, r.head - 1, 1, i) || i.afterCursor && (Nn(e.state, r.head, 1, i) || r.head < e.state.doc.length && Nn(e.state, r.head + 1, -1, i));
      s && (t = t.concat(i.renderMatch(s, e.state)));
    }
    return U.set(t, !0);
  },
  provide: (n) => I.decorations.from(n)
}), Xme = [
  Zme,
  Gme
];
function Qme(n = {}) {
  return [P_.of(n), Xme];
}
const e0e = /* @__PURE__ */ new te();
function Gd(n, e, t) {
  let i = n.prop(e < 0 ? te.openedBy : te.closedBy);
  if (i)
    return i;
  if (n.name.length == 1) {
    let r = t.indexOf(n.name);
    if (r > -1 && r % 2 == (e < 0 ? 1 : 0))
      return [t[r + e]];
  }
  return null;
}
function Kd(n) {
  let e = n.type.prop(e0e);
  return e ? e(n.node) : n;
}
function Nn(n, e, t, i = {}) {
  let r = i.maxScanDistance || B_, s = i.brackets || N_, o = pt(n), l = o.resolveInner(e, t);
  for (let a = l; a; a = a.parent) {
    let c = Gd(a.type, t, s);
    if (c && a.from < a.to) {
      let h = Kd(a);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return t0e(n, e, t, a, h, c, s);
    }
  }
  return n0e(n, e, t, o, l.type, r, s);
}
function t0e(n, e, t, i, r, s, o) {
  let l = i.parent, a = { from: r.from, to: r.to }, c = 0, h = l == null ? void 0 : l.cursor();
  if (h && (t < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (t < 0 ? h.to <= i.from : h.from >= i.to) {
        if (c == 0 && s.indexOf(h.type.name) > -1 && h.from < h.to) {
          let u = Kd(h);
          return { start: a, end: u ? { from: u.from, to: u.to } : void 0, matched: !0 };
        } else if (Gd(h.type, t, o))
          c++;
        else if (Gd(h.type, -t, o)) {
          if (c == 0) {
            let u = Kd(h);
            return {
              start: a,
              end: u && u.from < u.to ? { from: u.from, to: u.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: a, matched: !1 };
}
function n0e(n, e, t, i, r, s, o) {
  let l = t < 0 ? n.sliceDoc(e - 1, e) : n.sliceDoc(e, e + 1), a = o.indexOf(l);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = n.doc.iterRange(e, t > 0 ? n.doc.length : 0), u = 0;
  for (let f = 0; !h.next().done && f <= s; ) {
    let d = h.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let g = t > 0 ? 0 : d.length - 1, m = t > 0 ? d.length : -1; g != m; g += t) {
      let b = o.indexOf(d[g]);
      if (!(b < 0 || i.resolveInner(p + g, 1).type != r))
        if (b % 2 == 0 == t > 0)
          u++;
        else {
          if (u == 1)
            return { start: c, end: { from: p + g, to: p + g + 1 }, matched: b >> 1 == a >> 1 };
          u--;
        }
    }
    t > 0 && (f += d.length);
  }
  return h.done ? { start: c, matched: !1 } : null;
}
const i0e = /* @__PURE__ */ Object.create(null), Wb = [tn.none], jb = [], r0e = /* @__PURE__ */ Object.create(null);
for (let [n, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  r0e[n] = /* @__PURE__ */ s0e(i0e, e);
function ff(n, e) {
  jb.indexOf(n) > -1 || (jb.push(n), console.warn(e));
}
function s0e(n, e) {
  let t = null;
  for (let s of e.split(".")) {
    let o = n[s] || L[s];
    o ? typeof o == "function" ? t ? t = o(t) : ff(s, `Modifier ${s} used at start of tag`) : t ? ff(s, `Tag ${s} used as modifier`) : t = o : ff(s, `Unknown highlighting tag ${s}`);
  }
  if (!t)
    return 0;
  let i = e.replace(/ /g, "_"), r = tn.define({
    id: Wb.length,
    name: i,
    props: [cme({ [i]: t })]
  });
  return Wb.push(r), r.id;
}
const o0e = (n) => {
  let { state: e } = n, t = e.doc.lineAt(e.selection.main.from), i = Fg(n.state, t.from);
  return i.line ? l0e(n) : i.block ? c0e(n) : !1;
};
function Pg(n, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let r = n(e, t);
    return r ? (i(t.update(r)), !0) : !1;
  };
}
const l0e = /* @__PURE__ */ Pg(f0e, 0), a0e = /* @__PURE__ */ Pg(F_, 0), c0e = /* @__PURE__ */ Pg((n, e) => F_(n, e, u0e(e)), 0);
function Fg(n, e) {
  let t = n.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const bo = 50;
function h0e(n, { open: e, close: t }, i, r) {
  let s = n.sliceDoc(i - bo, i), o = n.sliceDoc(r, r + bo), l = /\s*$/.exec(s)[0].length, a = /^\s*/.exec(o)[0].length, c = s.length - l;
  if (s.slice(c - e.length, c) == e && o.slice(a, a + t.length) == t)
    return {
      open: { pos: i - l, margin: l && 1 },
      close: { pos: r + a, margin: a && 1 }
    };
  let h, u;
  r - i <= 2 * bo ? h = u = n.sliceDoc(i, r) : (h = n.sliceDoc(i, i + bo), u = n.sliceDoc(r - bo, r));
  let f = /^\s*/.exec(h)[0].length, d = /\s*$/.exec(u)[0].length, p = u.length - d - t.length;
  return h.slice(f, f + e.length) == e && u.slice(p, p + t.length) == t ? {
    open: {
      pos: i + f + e.length,
      margin: /\s/.test(h.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: r - d - t.length,
      margin: /\s/.test(u.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function u0e(n) {
  let e = [];
  for (let t of n.selection.ranges) {
    let i = n.doc.lineAt(t.from), r = t.to <= i.to ? i : n.doc.lineAt(t.to), s = e.length - 1;
    s >= 0 && e[s].to > i.from ? e[s].to = r.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: r.to });
  }
  return e;
}
function F_(n, e, t = e.selection.ranges) {
  let i = t.map((s) => Fg(e, s.from).block);
  if (!i.every((s) => s))
    return null;
  let r = t.map((s, o) => h0e(e, i[o], s.from, s.to));
  if (n != 2 && !r.every((s) => s))
    return { changes: e.changes(t.map((s, o) => r[o] ? [] : [{ from: s.from, insert: i[o].open + " " }, { from: s.to, insert: " " + i[o].close }])) };
  if (n != 1 && r.some((s) => s)) {
    let s = [];
    for (let o = 0, l; o < r.length; o++)
      if (l = r[o]) {
        let a = i[o], { open: c, close: h } = l;
        s.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: h.pos - h.margin, to: h.pos + a.close.length });
      }
    return { changes: s };
  }
  return null;
}
function f0e(n, e, t = e.selection.ranges) {
  let i = [], r = -1;
  for (let { from: s, to: o } of t) {
    let l = i.length, a = 1e9, c = Fg(e, s).line;
    if (!!c) {
      for (let h = s; h <= o; ) {
        let u = e.doc.lineAt(h);
        if (u.from > r && (s == o || o > u.from)) {
          r = u.from;
          let f = /^\s*/.exec(u.text)[0].length, d = f == u.length, p = u.text.slice(f, f + c.length) == c ? f : -1;
          f < u.text.length && f < a && (a = f), i.push({ line: u, comment: p, token: c, indent: f, empty: d, single: !1 });
        }
        h = u.to + 1;
      }
      if (a < 1e9)
        for (let h = l; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = a);
      i.length == l + 1 && (i[l].single = !0);
    }
  }
  if (n != 2 && i.some((s) => s.comment < 0 && (!s.empty || s.single))) {
    let s = [];
    for (let { line: l, token: a, indent: c, empty: h, single: u } of i)
      (u || !h) && s.push({ from: l.from + c, insert: a + " " });
    let o = e.changes(s);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (n != 1 && i.some((s) => s.comment >= 0)) {
    let s = [];
    for (let { line: o, comment: l, token: a } of i)
      if (l >= 0) {
        let c = o.from + l, h = c + a.length;
        o.text[h - o.from] == " " && h++, s.push({ from: c, to: h });
      }
    return { changes: s };
  }
  return null;
}
const Yd = /* @__PURE__ */ nn.define(), d0e = /* @__PURE__ */ nn.define(), p0e = /* @__PURE__ */ E.define(), $_ = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, r) => e(i, r) || t(i, r)
    });
  }
});
function g0e(n) {
  let e = 0;
  return n.iterChangedRanges((t, i) => e = i), e;
}
const H_ = /* @__PURE__ */ Ue.define({
  create() {
    return Pn.empty;
  },
  update(n, e) {
    let t = e.state.facet($_), i = e.annotation(Yd);
    if (i) {
      let a = e.docChanged ? S.single(g0e(e.changes)) : void 0, c = Ot.fromTransaction(e, a), h = i.side, u = h == 0 ? n.undone : n.done;
      return c ? u = Kc(u, u.length, t.minDepth, c) : u = z_(u, e.startState.selection), new Pn(h == 0 ? i.rest : u, h == 0 ? u : i.rest);
    }
    let r = e.annotation(d0e);
    if ((r == "full" || r == "before") && (n = n.isolate()), e.annotation(Ve.addToHistory) === !1)
      return e.changes.empty ? n : n.addMapping(e.changes.desc);
    let s = Ot.fromTransaction(e), o = e.annotation(Ve.time), l = e.annotation(Ve.userEvent);
    return s ? n = n.addChanges(s, o, l, t, e) : e.selection && (n = n.addSelection(e.startState.selection, o, l, t.newGroupDelay)), (r == "full" || r == "after") && (n = n.isolate()), n;
  },
  toJSON(n) {
    return { done: n.done.map((e) => e.toJSON()), undone: n.undone.map((e) => e.toJSON()) };
  },
  fromJSON(n) {
    return new Pn(n.done.map(Ot.fromJSON), n.undone.map(Ot.fromJSON));
  }
});
function m0e(n = {}) {
  return [
    H_,
    $_.of(n),
    I.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? q_ : e.inputType == "historyRedo" ? Jd : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function qh(n, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let r = t.field(H_, !1);
    if (!r)
      return !1;
    let s = r.pop(n, t, e);
    return s ? (i(s), !0) : !1;
  };
}
const q_ = /* @__PURE__ */ qh(0, !1), Jd = /* @__PURE__ */ qh(1, !1), b0e = /* @__PURE__ */ qh(0, !0), y0e = /* @__PURE__ */ qh(1, !0);
class Ot {
  constructor(e, t, i, r, s) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = r, this.selectionsAfter = s;
  }
  setSelAfter(e) {
    return new Ot(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((r) => r.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ot(e.changes && Oe.fromJSON(e.changes), [], e.mapped && Hn.fromJSON(e.mapped), e.startSelection && S.fromJSON(e.startSelection), e.selectionsAfter.map(S.fromJSON));
  }
  static fromTransaction(e, t) {
    let i = Gt;
    for (let r of e.startState.facet(p0e)) {
      let s = r(e);
      s.length && (i = i.concat(s));
    }
    return !i.length && e.changes.empty ? null : new Ot(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, Gt);
  }
  static selection(e) {
    return new Ot(void 0, Gt, void 0, void 0, e);
  }
}
function Kc(n, e, t, i) {
  let r = e + 1 > t + 20 ? e - t - 1 : 0, s = n.slice(r, e);
  return s.push(i), s;
}
function w0e(n, e) {
  let t = [], i = !1;
  return n.iterChangedRanges((r, s) => t.push(r, s)), e.iterChangedRanges((r, s, o, l) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], h = t[a++];
      l >= c && o <= h && (i = !0);
    }
  }), i;
}
function v0e(n, e) {
  return n.ranges.length == e.ranges.length && n.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function V_(n, e) {
  return n.length ? e.length ? n.concat(e) : n : e;
}
const Gt = [], x0e = 200;
function z_(n, e) {
  if (n.length) {
    let t = n[n.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - x0e));
    return i.length && i[i.length - 1].eq(e) ? n : (i.push(e), Kc(n, n.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Ot.selection([e])];
}
function k0e(n) {
  let e = n[n.length - 1], t = n.slice();
  return t[n.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function df(n, e) {
  if (!n.length)
    return n;
  let t = n.length, i = Gt;
  for (; t; ) {
    let r = _0e(n[t - 1], e, i);
    if (r.changes && !r.changes.empty || r.effects.length) {
      let s = n.slice(0, t);
      return s[t - 1] = r, s;
    } else
      e = r.mapped, t--, i = r.selectionsAfter;
  }
  return i.length ? [Ot.selection(i)] : Gt;
}
function _0e(n, e, t) {
  let i = V_(n.selectionsAfter.length ? n.selectionsAfter.map((l) => l.map(e)) : Gt, t);
  if (!n.changes)
    return Ot.selection(i);
  let r = n.changes.map(e), s = e.mapDesc(n.changes, !0), o = n.mapped ? n.mapped.composeDesc(s) : s;
  return new Ot(r, G.mapEffects(n.effects, e), o, n.startSelection.map(s), i);
}
const S0e = /^(input\.type|delete)($|\.)/;
class Pn {
  constructor(e, t, i = 0, r = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = r;
  }
  isolate() {
    return this.prevTime ? new Pn(this.done, this.undone) : this;
  }
  addChanges(e, t, i, r, s) {
    let o = this.done, l = o[o.length - 1];
    return l && l.changes && !l.changes.empty && e.changes && (!i || S0e.test(i)) && (!l.selectionsAfter.length && t - this.prevTime < r.newGroupDelay && r.joinToEvent(s, w0e(l.changes, e.changes)) || i == "input.type.compose") ? o = Kc(o, o.length - 1, r.minDepth, new Ot(e.changes.compose(l.changes), V_(e.effects, l.effects), l.mapped, l.startSelection, Gt)) : o = Kc(o, o.length, r.minDepth, e), new Pn(o, Gt, t, i);
  }
  addSelection(e, t, i, r) {
    let s = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Gt;
    return s.length > 0 && t - this.prevTime < r && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && v0e(s[s.length - 1], e) ? this : new Pn(z_(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Pn(df(this.done, e), df(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let r = e == 0 ? this.done : this.undone;
    if (r.length == 0)
      return null;
    let s = r[r.length - 1];
    if (i && s.selectionsAfter.length)
      return t.update({
        selection: s.selectionsAfter[s.selectionsAfter.length - 1],
        annotations: Yd.of({ side: e, rest: k0e(r) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (s.changes) {
      let o = r.length == 1 ? Gt : r.slice(0, r.length - 1);
      return s.mapped && (o = df(o, s.mapped)), t.update({
        changes: s.changes,
        selection: s.startSelection,
        effects: s.effects,
        annotations: Yd.of({ side: e, rest: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Pn.empty = /* @__PURE__ */ new Pn(Gt, Gt);
const C0e = [
  { key: "Mod-z", run: q_, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Jd, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Jd, preventDefault: !0 },
  { key: "Mod-u", run: b0e, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: y0e, preventDefault: !0 }
];
function io(n, e) {
  return S.create(n.ranges.map(e), n.mainIndex);
}
function Kn(n, e) {
  return n.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function vn({ state: n, dispatch: e }, t) {
  let i = io(n.selection, t);
  return i.eq(n.selection) ? !1 : (e(Kn(n, i)), !0);
}
function Vh(n, e) {
  return S.cursor(e ? n.to : n.from);
}
function U_(n, e) {
  return vn(n, (t) => t.empty ? n.moveByChar(t, e) : Vh(t, e));
}
function mt(n) {
  return n.textDirectionAt(n.state.selection.main.head) == Te.LTR;
}
const W_ = (n) => U_(n, !mt(n)), j_ = (n) => U_(n, mt(n));
function G_(n, e) {
  return vn(n, (t) => t.empty ? n.moveByGroup(t, e) : Vh(t, e));
}
const A0e = (n) => G_(n, !mt(n)), D0e = (n) => G_(n, mt(n));
function E0e(n, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(n.sliceDoc(e.from, e.to))) || e.firstChild;
}
function zh(n, e, t) {
  let i = pt(n).resolveInner(e.head), r = t ? te.closedBy : te.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? i.childAfter(a) : i.childBefore(a);
    if (!c)
      break;
    E0e(n, c, r) ? i = c : a = t ? c.to : c.from;
  }
  let s = i.type.prop(r), o, l;
  return s && (o = t ? Nn(n, i.from, 1) : Nn(n, i.to, -1)) && o.matched ? l = t ? o.end.to : o.end.from : l = t ? i.to : i.from, S.cursor(l, t ? -1 : 1);
}
const T0e = (n) => vn(n, (e) => zh(n.state, e, !mt(n))), M0e = (n) => vn(n, (e) => zh(n.state, e, mt(n)));
function K_(n, e) {
  return vn(n, (t) => {
    if (!t.empty)
      return Vh(t, e);
    let i = n.moveVertically(t, e);
    return i.head != t.head ? i : n.moveToLineBoundary(t, e);
  });
}
const Y_ = (n) => K_(n, !1), J_ = (n) => K_(n, !0);
function Z_(n) {
  let e = n.scrollDOM.clientHeight < n.scrollDOM.scrollHeight - 2, t = 0, i = 0, r;
  if (e) {
    for (let s of n.state.facet(I.scrollMargins)) {
      let o = s(n);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    r = n.scrollDOM.clientHeight - t - i;
  } else
    r = (n.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(n.defaultLineHeight, r - 5)
  };
}
function X_(n, e) {
  let t = Z_(n), { state: i } = n, r = io(i.selection, (o) => o.empty ? n.moveVertically(o, e, t.height) : Vh(o, e));
  if (r.eq(i.selection))
    return !1;
  let s;
  if (t.selfScroll) {
    let o = n.coordsAtPos(i.selection.main.head), l = n.scrollDOM.getBoundingClientRect(), a = l.top + t.marginTop, c = l.bottom - t.marginBottom;
    o && o.top > a && o.bottom < c && (s = I.scrollIntoView(r.main.head, { y: "start", yMargin: o.top - a }));
  }
  return n.dispatch(Kn(i, r), { effects: s }), !0;
}
const Gb = (n) => X_(n, !1), Zd = (n) => X_(n, !0);
function Xi(n, e, t) {
  let i = n.lineBlockAt(e.head), r = n.moveToLineBoundary(e, t);
  if (r.head == e.head && r.head != (t ? i.to : i.from) && (r = n.moveToLineBoundary(e, t, !1)), !t && r.head == i.from && i.length) {
    let s = /^\s*/.exec(n.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    s && e.head != i.from + s && (r = S.cursor(i.from + s));
  }
  return r;
}
const O0e = (n) => vn(n, (e) => Xi(n, e, !0)), L0e = (n) => vn(n, (e) => Xi(n, e, !1)), R0e = (n) => vn(n, (e) => Xi(n, e, !mt(n))), I0e = (n) => vn(n, (e) => Xi(n, e, mt(n))), B0e = (n) => vn(n, (e) => S.cursor(n.lineBlockAt(e.head).from, 1)), N0e = (n) => vn(n, (e) => S.cursor(n.lineBlockAt(e.head).to, -1));
function P0e(n, e, t) {
  let i = !1, r = io(n.selection, (s) => {
    let o = Nn(n, s.head, -1) || Nn(n, s.head, 1) || s.head > 0 && Nn(n, s.head - 1, 1) || s.head < n.doc.length && Nn(n, s.head + 1, -1);
    if (!o || !o.end)
      return s;
    i = !0;
    let l = o.start.from == s.head ? o.end.to : o.end.from;
    return t ? S.range(s.anchor, l) : S.cursor(l);
  });
  return i ? (e(Kn(n, r)), !0) : !1;
}
const F0e = ({ state: n, dispatch: e }) => P0e(n, e, !1);
function rn(n, e) {
  let t = io(n.state.selection, (i) => {
    let r = e(i);
    return S.range(i.anchor, r.head, r.goalColumn, r.bidiLevel || void 0);
  });
  return t.eq(n.state.selection) ? !1 : (n.dispatch(Kn(n.state, t)), !0);
}
function Q_(n, e) {
  return rn(n, (t) => n.moveByChar(t, e));
}
const eS = (n) => Q_(n, !mt(n)), tS = (n) => Q_(n, mt(n));
function nS(n, e) {
  return rn(n, (t) => n.moveByGroup(t, e));
}
const $0e = (n) => nS(n, !mt(n)), H0e = (n) => nS(n, mt(n)), q0e = (n) => rn(n, (e) => zh(n.state, e, !mt(n))), V0e = (n) => rn(n, (e) => zh(n.state, e, mt(n)));
function iS(n, e) {
  return rn(n, (t) => n.moveVertically(t, e));
}
const rS = (n) => iS(n, !1), sS = (n) => iS(n, !0);
function oS(n, e) {
  return rn(n, (t) => n.moveVertically(t, e, Z_(n).height));
}
const Kb = (n) => oS(n, !1), Yb = (n) => oS(n, !0), z0e = (n) => rn(n, (e) => Xi(n, e, !0)), U0e = (n) => rn(n, (e) => Xi(n, e, !1)), W0e = (n) => rn(n, (e) => Xi(n, e, !mt(n))), j0e = (n) => rn(n, (e) => Xi(n, e, mt(n))), G0e = (n) => rn(n, (e) => S.cursor(n.lineBlockAt(e.head).from)), K0e = (n) => rn(n, (e) => S.cursor(n.lineBlockAt(e.head).to)), Jb = ({ state: n, dispatch: e }) => (e(Kn(n, { anchor: 0 })), !0), Zb = ({ state: n, dispatch: e }) => (e(Kn(n, { anchor: n.doc.length })), !0), Xb = ({ state: n, dispatch: e }) => (e(Kn(n, { anchor: n.selection.main.anchor, head: 0 })), !0), Qb = ({ state: n, dispatch: e }) => (e(Kn(n, { anchor: n.selection.main.anchor, head: n.doc.length })), !0), Y0e = ({ state: n, dispatch: e }) => (e(n.update({ selection: { anchor: 0, head: n.doc.length }, userEvent: "select" })), !0), J0e = ({ state: n, dispatch: e }) => {
  let t = Wh(n).map(({ from: i, to: r }) => S.range(i, Math.min(r + 1, n.doc.length)));
  return e(n.update({ selection: S.create(t), userEvent: "select" })), !0;
}, Z0e = ({ state: n, dispatch: e }) => {
  let t = io(n.selection, (i) => {
    var r;
    let s = pt(n).resolveInner(i.head, 1);
    for (; !(s.from < i.from && s.to >= i.to || s.to > i.to && s.from <= i.from || !(!((r = s.parent) === null || r === void 0) && r.parent)); )
      s = s.parent;
    return S.range(s.to, s.from);
  });
  return e(Kn(n, t)), !0;
}, X0e = ({ state: n, dispatch: e }) => {
  let t = n.selection, i = null;
  return t.ranges.length > 1 ? i = S.create([t.main]) : t.main.empty || (i = S.create([S.cursor(t.main.head)])), i ? (e(Kn(n, i)), !0) : !1;
};
function Uh(n, e) {
  if (n.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = n, r = i.changeByRange((s) => {
    let { from: o, to: l } = s;
    if (o == l) {
      let a = e(o);
      a < o ? (t = "delete.backward", a = xa(n, a, !1)) : a > o && (t = "delete.forward", a = xa(n, a, !0)), o = Math.min(o, a), l = Math.max(l, a);
    } else
      o = xa(n, o, !1), l = xa(n, l, !0);
    return o == l ? { range: s } : { changes: { from: o, to: l }, range: S.cursor(o) };
  });
  return r.changes.empty ? !1 : (n.dispatch(i.update(r, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? I.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function xa(n, e, t) {
  if (n instanceof I)
    for (let i of n.state.facet(I.atomicRanges).map((r) => r(n)))
      i.between(e, e, (r, s) => {
        r < e && s > e && (e = t ? s : r);
      });
  return e;
}
const lS = (n, e) => Uh(n, (t) => {
  let { state: i } = n, r = i.doc.lineAt(t), s, o;
  if (!e && t > r.from && t < r.from + 200 && !/[^ \t]/.test(s = r.text.slice(0, t - r.from))) {
    if (s[s.length - 1] == "	")
      return t - 1;
    let l = no(s, i.tabSize), a = l % Wc(i) || Wc(i);
    for (let c = 0; c < a && s[s.length - 1 - c] == " "; c++)
      t--;
    o = t;
  } else
    o = Le(r.text, t - r.from, e, e) + r.from, o == t && r.number != (e ? i.doc.lines : 1) && (o += e ? 1 : -1);
  return o;
}), Xd = (n) => lS(n, !1), aS = (n) => lS(n, !0), cS = (n, e) => Uh(n, (t) => {
  let i = t, { state: r } = n, s = r.doc.lineAt(i), o = r.charCategorizer(i);
  for (let l = null; ; ) {
    if (i == (e ? s.to : s.from)) {
      i == t && s.number != (e ? r.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let a = Le(s.text, i - s.from, e) + s.from, c = s.text.slice(Math.min(i, a) - s.from, Math.max(i, a) - s.from), h = o(c);
    if (l != null && h != l)
      break;
    (c != " " || i != t) && (l = h), i = a;
  }
  return i;
}), hS = (n) => cS(n, !1), Q0e = (n) => cS(n, !0), uS = (n) => Uh(n, (e) => {
  let t = n.lineBlockAt(e).to;
  return e < t ? t : Math.min(n.state.doc.length, e + 1);
}), e1e = (n) => Uh(n, (e) => {
  let t = n.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), t1e = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Z.of(["", ""]) },
    range: S.cursor(i.from)
  }));
  return e(n.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, n1e = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = n.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == n.doc.length)
      return { range: i };
    let r = i.from, s = n.doc.lineAt(r), o = r == s.from ? r - 1 : Le(s.text, r - s.from, !1) + s.from, l = r == s.to ? r + 1 : Le(s.text, r - s.from, !0) + s.from;
    return {
      changes: { from: o, to: l, insert: n.doc.slice(r, l).append(n.doc.slice(o, r)) },
      range: S.cursor(l)
    };
  });
  return t.changes.empty ? !1 : (e(n.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Wh(n) {
  let e = [], t = -1;
  for (let i of n.selection.ranges) {
    let r = n.doc.lineAt(i.from), s = n.doc.lineAt(i.to);
    if (!i.empty && i.to == s.from && (s = n.doc.lineAt(i.to - 1)), t >= r.number) {
      let o = e[e.length - 1];
      o.to = s.to, o.ranges.push(i);
    } else
      e.push({ from: r.from, to: s.to, ranges: [i] });
    t = s.number + 1;
  }
  return e;
}
function fS(n, e, t) {
  if (n.readOnly)
    return !1;
  let i = [], r = [];
  for (let s of Wh(n)) {
    if (t ? s.to == n.doc.length : s.from == 0)
      continue;
    let o = n.doc.lineAt(t ? s.to + 1 : s.from - 1), l = o.length + 1;
    if (t) {
      i.push({ from: s.to, to: o.to }, { from: s.from, insert: o.text + n.lineBreak });
      for (let a of s.ranges)
        r.push(S.range(Math.min(n.doc.length, a.anchor + l), Math.min(n.doc.length, a.head + l)));
    } else {
      i.push({ from: o.from, to: s.from }, { from: s.to, insert: n.lineBreak + o.text });
      for (let a of s.ranges)
        r.push(S.range(a.anchor - l, a.head - l));
    }
  }
  return i.length ? (e(n.update({
    changes: i,
    scrollIntoView: !0,
    selection: S.create(r, n.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const i1e = ({ state: n, dispatch: e }) => fS(n, e, !1), r1e = ({ state: n, dispatch: e }) => fS(n, e, !0);
function dS(n, e, t) {
  if (n.readOnly)
    return !1;
  let i = [];
  for (let r of Wh(n))
    t ? i.push({ from: r.from, insert: n.doc.slice(r.from, r.to) + n.lineBreak }) : i.push({ from: r.to, insert: n.lineBreak + n.doc.slice(r.from, r.to) });
  return e(n.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const s1e = ({ state: n, dispatch: e }) => dS(n, e, !1), o1e = ({ state: n, dispatch: e }) => dS(n, e, !0), l1e = (n) => {
  if (n.state.readOnly)
    return !1;
  let { state: e } = n, t = e.changes(Wh(e).map(({ from: r, to: s }) => (r > 0 ? r-- : s < e.doc.length && s++, { from: r, to: s }))), i = io(e.selection, (r) => n.moveVertically(r, !0)).map(t);
  return n.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function a1e(n, e) {
  if (/\(\)|\[\]|\{\}/.test(n.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = pt(n).resolveInner(e), i = t.childBefore(e), r = t.childAfter(e), s;
  return i && r && i.to <= e && r.from >= e && (s = i.type.prop(te.closedBy)) && s.indexOf(r.name) > -1 && n.doc.lineAt(i.to).from == n.doc.lineAt(r.from).from && !/\S/.test(n.sliceDoc(i.to, r.from)) ? { from: i.to, to: r.from } : null;
}
const c1e = /* @__PURE__ */ pS(!1), h1e = /* @__PURE__ */ pS(!0);
function pS(n) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((r) => {
      let { from: s, to: o } = r, l = e.doc.lineAt(s), a = !n && s == o && a1e(e, s);
      n && (s = o = (o <= l.to ? l : e.doc.lineAt(o)).to);
      let c = new Fh(e, { simulateBreak: s, simulateDoubleBreak: !!a }), h = Ig(c, s);
      for (h == null && (h = no(/^\s*/.exec(e.doc.lineAt(s).text)[0], e.tabSize)); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      a ? { from: s, to: o } = a : s > l.from && s < l.from + 100 && !/\S/.test(l.text.slice(0, s)) && (s = l.from);
      let u = ["", hl(e, h)];
      return a && u.push(hl(e, c.lineIndent(l.from, -1))), {
        changes: { from: s, to: o, insert: Z.of(u) },
        range: S.cursor(s + 1 + u[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function $g(n, e) {
  let t = -1;
  return n.changeByRange((i) => {
    let r = [];
    for (let o = i.from; o <= i.to; ) {
      let l = n.doc.lineAt(o);
      l.number > t && (i.empty || i.to > l.from) && (e(l, r, i), t = l.number), o = l.to + 1;
    }
    let s = n.changes(r);
    return {
      changes: r,
      range: S.range(s.mapPos(i.anchor, 1), s.mapPos(i.head, 1))
    };
  });
}
const u1e = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new Fh(n, { overrideIndentation: (s) => {
    let o = t[s];
    return o == null ? -1 : o;
  } }), r = $g(n, (s, o, l) => {
    let a = Ig(i, s.from);
    if (a == null)
      return;
    /\S/.test(s.text) || (a = 0);
    let c = /^\s*/.exec(s.text)[0], h = hl(n, a);
    (c != h || l.from < s.from + c.length) && (t[s.from] = a, o.push({ from: s.from, to: s.from + c.length, insert: h }));
  });
  return r.changes.empty || e(n.update(r, { userEvent: "indent" })), !0;
}, gS = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update($g(n, (t, i) => {
  i.push({ from: t.from, insert: n.facet(Rg) });
}), { userEvent: "input.indent" })), !0), mS = ({ state: n, dispatch: e }) => n.readOnly ? !1 : (e(n.update($g(n, (t, i) => {
  let r = /^\s*/.exec(t.text)[0];
  if (!r)
    return;
  let s = no(r, n.tabSize), o = 0, l = hl(n, Math.max(0, s - Wc(n)));
  for (; o < r.length && o < l.length && r.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + r.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), f1e = [
  { key: "Ctrl-b", run: W_, shift: eS, preventDefault: !0 },
  { key: "Ctrl-f", run: j_, shift: tS },
  { key: "Ctrl-p", run: Y_, shift: rS },
  { key: "Ctrl-n", run: J_, shift: sS },
  { key: "Ctrl-a", run: B0e, shift: G0e },
  { key: "Ctrl-e", run: N0e, shift: K0e },
  { key: "Ctrl-d", run: aS },
  { key: "Ctrl-h", run: Xd },
  { key: "Ctrl-k", run: uS },
  { key: "Ctrl-Alt-h", run: hS },
  { key: "Ctrl-o", run: t1e },
  { key: "Ctrl-t", run: n1e },
  { key: "Ctrl-v", run: Zd }
], d1e = /* @__PURE__ */ [
  { key: "ArrowLeft", run: W_, shift: eS, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: A0e, shift: $0e, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: R0e, shift: W0e, preventDefault: !0 },
  { key: "ArrowRight", run: j_, shift: tS, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: D0e, shift: H0e, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: I0e, shift: j0e, preventDefault: !0 },
  { key: "ArrowUp", run: Y_, shift: rS, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Jb, shift: Xb },
  { mac: "Ctrl-ArrowUp", run: Gb, shift: Kb },
  { key: "ArrowDown", run: J_, shift: sS, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Zb, shift: Qb },
  { mac: "Ctrl-ArrowDown", run: Zd, shift: Yb },
  { key: "PageUp", run: Gb, shift: Kb },
  { key: "PageDown", run: Zd, shift: Yb },
  { key: "Home", run: L0e, shift: U0e, preventDefault: !0 },
  { key: "Mod-Home", run: Jb, shift: Xb },
  { key: "End", run: O0e, shift: z0e, preventDefault: !0 },
  { key: "Mod-End", run: Zb, shift: Qb },
  { key: "Enter", run: c1e },
  { key: "Mod-a", run: Y0e },
  { key: "Backspace", run: Xd, shift: Xd },
  { key: "Delete", run: aS },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: hS },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Q0e },
  { mac: "Mod-Backspace", run: e1e },
  { mac: "Mod-Delete", run: uS }
].concat(/* @__PURE__ */ f1e.map((n) => ({ mac: n.key, run: n.run, shift: n.shift }))), p1e = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: T0e, shift: q0e },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: M0e, shift: V0e },
  { key: "Alt-ArrowUp", run: i1e },
  { key: "Shift-Alt-ArrowUp", run: s1e },
  { key: "Alt-ArrowDown", run: r1e },
  { key: "Shift-Alt-ArrowDown", run: o1e },
  { key: "Escape", run: X0e },
  { key: "Mod-Enter", run: h1e },
  { key: "Alt-l", mac: "Ctrl-l", run: J0e },
  { key: "Mod-i", run: Z0e, preventDefault: !0 },
  { key: "Mod-[", run: mS },
  { key: "Mod-]", run: gS },
  { key: "Mod-Alt-\\", run: u1e },
  { key: "Shift-Mod-k", run: l1e },
  { key: "Shift-Mod-\\", run: F0e },
  { key: "Mod-/", run: o0e },
  { key: "Alt-A", run: a0e }
].concat(d1e), g1e = { key: "Tab", run: gS, shift: mS };
function be() {
  var n = arguments[0];
  typeof n == "string" && (n = document.createElement(n));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var r = t[i];
        typeof r == "string" ? n.setAttribute(i, r) : r != null && (n[i] = r);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    bS(n, arguments[e]);
  return n;
}
function bS(n, e) {
  if (typeof e == "string")
    n.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      n.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        bS(n, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const ey = typeof String.prototype.normalize == "function" ? (n) => n.normalize("NFKD") : (n) => n;
class Ps {
  constructor(e, t, i = 0, r = e.length, s, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, r), this.bufferStart = i, this.normalize = s ? (l) => s(ey(l)) : ey, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return tt(this.buffer, this.bufferPos);
  }
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = yg(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Ut(e);
      let r = this.normalize(t);
      for (let s = 0, o = i; ; s++) {
        let l = r.charCodeAt(s), a = this.match(l, o);
        if (s == r.length - 1) {
          if (a)
            return this.value = a, this;
          break;
        }
        o == i && s < t.length && t.charCodeAt(s) == l && o++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let r = 0; r < this.matches.length; r += 2) {
      let s = this.matches[r], o = !1;
      this.query.charCodeAt(s) == e && (s == this.query.length - 1 ? i = { from: this.matches[r + 1], to: t + 1 } : (this.matches[r]++, o = !0)), o || (this.matches.splice(r, 2), r -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferPos) && (i = null), i;
  }
}
typeof Symbol < "u" && (Ps.prototype[Symbol.iterator] = function() {
  return this;
});
const yS = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Hg = "gm" + (/x/.unicode == null ? "" : "u");
class wS {
  constructor(e, t, i, r = 0, s = e.length) {
    if (this.text = e, this.to = s, this.curLine = "", this.done = !1, this.value = yS, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new vS(e, t, i, r, s);
    this.re = new RegExp(t, Hg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(r);
    this.curLineStart = o.from, this.matchPos = Yc(e, r), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, r = i + t[0].length;
        if (this.matchPos = Yc(this.text, r + (i == r ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < r || i > this.value.to) && (!this.test || this.test(i, r, t)))
          return this.value = { from: i, to: r, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const pf = /* @__PURE__ */ new WeakMap();
class ys {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let r = pf.get(e);
    if (!r || r.from >= i || r.to <= t) {
      let l = new ys(t, e.sliceString(t, i));
      return pf.set(e, l), l;
    }
    if (r.from == t && r.to == i)
      return r;
    let { text: s, from: o } = r;
    return o > t && (s = e.sliceString(t, o) + s, o = t), r.to < i && (s += e.sliceString(r.to, i)), pf.set(e, new ys(o, s)), new ys(t, s.slice(t - o, i - o));
  }
}
class vS {
  constructor(e, t, i, r, s) {
    this.text = e, this.to = s, this.done = !1, this.value = yS, this.matchPos = Yc(e, r), this.re = new RegExp(t, Hg + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = ys.get(e, r, this.chunkEnd(r + 5e3));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, r = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, r, t)))
          return this.value = { from: i, to: r, match: t }, this.matchPos = Yc(this.text, r + (i == r ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = ys.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (wS.prototype[Symbol.iterator] = vS.prototype[Symbol.iterator] = function() {
  return this;
});
function m1e(n) {
  try {
    return new RegExp(n, Hg), !0;
  } catch {
    return !1;
  }
}
function Yc(n, e) {
  if (e >= n.length)
    return e;
  let t = n.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function Qd(n) {
  let e = be("input", { class: "cm-textfield", name: "line" }), t = be("form", {
    class: "cm-gotoLine",
    onkeydown: (r) => {
      r.keyCode == 27 ? (r.preventDefault(), n.dispatch({ effects: Jc.of(!1) }), n.focus()) : r.keyCode == 13 && (r.preventDefault(), i());
    },
    onsubmit: (r) => {
      r.preventDefault(), i();
    }
  }, be("label", n.state.phrase("Go to line"), ": ", e), " ", be("button", { class: "cm-button", type: "submit" }, n.state.phrase("go")));
  function i() {
    let r = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!r)
      return;
    let { state: s } = n, o = s.doc.lineAt(s.selection.main.head), [, l, a, c, h] = r, u = c ? +c.slice(1) : 0, f = a ? +a : o.number;
    if (a && h) {
      let g = f / 100;
      l && (g = g * (l == "-" ? -1 : 1) + o.number / s.doc.lines), f = Math.round(s.doc.lines * g);
    } else
      a && l && (f = f * (l == "-" ? -1 : 1) + o.number);
    let d = s.doc.line(Math.max(1, Math.min(s.doc.lines, f))), p = S.cursor(d.from + Math.max(0, Math.min(u, d.length)));
    n.dispatch({
      effects: [Jc.of(!1), I.scrollIntoView(p.from, { y: "center" })],
      selection: p
    }), n.focus();
  }
  return { dom: t };
}
const Jc = /* @__PURE__ */ G.define(), ty = /* @__PURE__ */ Ue.define({
  create() {
    return !0;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(Jc) && (n = t.value);
    return n;
  },
  provide: (n) => cl.from(n, (e) => e ? Qd : null)
}), b1e = (n) => {
  let e = al(n, Qd);
  if (!e) {
    let t = [Jc.of(!0)];
    n.state.field(ty, !1) == null && t.push(G.appendConfig.of([ty, y1e])), n.dispatch({ effects: t }), e = al(n, Qd);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, y1e = /* @__PURE__ */ I.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), w1e = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, xS = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, w1e, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function v1e(n) {
  let e = [C1e, S1e];
  return n && e.push(xS.of(n)), e;
}
const x1e = /* @__PURE__ */ U.mark({ class: "cm-selectionMatch" }), k1e = /* @__PURE__ */ U.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function ny(n, e, t, i) {
  return (t == 0 || n(e.sliceDoc(t - 1, t)) != Ce.Word) && (i == e.doc.length || n(e.sliceDoc(i, i + 1)) != Ce.Word);
}
function _1e(n, e, t, i) {
  return n(e.sliceDoc(t, t + 1)) == Ce.Word && n(e.sliceDoc(i - 1, i)) == Ce.Word;
}
const S1e = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.decorations = this.getDeco(n);
  }
  update(n) {
    (n.selectionSet || n.docChanged || n.viewportChanged) && (this.decorations = this.getDeco(n.view));
  }
  getDeco(n) {
    let e = n.state.facet(xS), { state: t } = n, i = t.selection;
    if (i.ranges.length > 1)
      return U.none;
    let r = i.main, s, o = null;
    if (r.empty) {
      if (!e.highlightWordAroundCursor)
        return U.none;
      let a = t.wordAt(r.head);
      if (!a)
        return U.none;
      o = t.charCategorizer(r.head), s = t.sliceDoc(a.from, a.to);
    } else {
      let a = r.to - r.from;
      if (a < e.minSelectionLength || a > 200)
        return U.none;
      if (e.wholeWords) {
        if (s = t.sliceDoc(r.from, r.to), o = t.charCategorizer(r.head), !(ny(o, t, r.from, r.to) && _1e(o, t, r.from, r.to)))
          return U.none;
      } else if (s = t.sliceDoc(r.from, r.to).trim(), !s)
        return U.none;
    }
    let l = [];
    for (let a of n.visibleRanges) {
      let c = new Ps(t.doc, s, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: h, to: u } = c.value;
        if ((!o || ny(o, t, h, u)) && (r.empty && h <= r.from && u >= r.to ? l.push(k1e.range(h, u)) : (h >= r.to || u <= r.from) && l.push(x1e.range(h, u)), l.length > e.maxMatches))
          return U.none;
      }
    }
    return U.set(l);
  }
}, {
  decorations: (n) => n.decorations
}), C1e = /* @__PURE__ */ I.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), A1e = ({ state: n, dispatch: e }) => {
  let { selection: t } = n, i = S.create(t.ranges.map((r) => n.wordAt(r.head) || S.cursor(r.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(n.update({ selection: i })), !0);
};
function D1e(n, e) {
  let { main: t, ranges: i } = n.selection, r = n.wordAt(t.head), s = r && r.from == t.from && r.to == t.to;
  for (let o = !1, l = new Ps(n.doc, e, i[i.length - 1].to); ; )
    if (l.next(), l.done) {
      if (o)
        return null;
      l = new Ps(n.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((a) => a.from == l.value.from))
        continue;
      if (s) {
        let a = n.wordAt(l.value.from);
        if (!a || a.from != l.value.from || a.to != l.value.to)
          continue;
      }
      return l.value;
    }
}
const E1e = ({ state: n, dispatch: e }) => {
  let { ranges: t } = n.selection;
  if (t.some((s) => s.from === s.to))
    return A1e({ state: n, dispatch: e });
  let i = n.sliceDoc(t[0].from, t[0].to);
  if (n.selection.ranges.some((s) => n.sliceDoc(s.from, s.to) != i))
    return !1;
  let r = D1e(n, i);
  return r ? (e(n.update({
    selection: n.selection.addRange(S.range(r.from, r.to), !1),
    effects: I.scrollIntoView(r.to)
  })), !0) : !1;
}, ro = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new H1e(e),
      scrollToMatch: (e) => I.scrollIntoView(e)
    });
  }
});
class kS {
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || m1e(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  create() {
    return this.regexp ? new L1e(this) : new M1e(this);
  }
  getCursor(e, t = 0, i) {
    let r = e.doc ? e : J.create({ doc: e });
    return i == null && (i = r.doc.length), this.regexp ? is(this, r, t, i) : ns(this, r, t, i);
  }
}
class _S {
  constructor(e) {
    this.spec = e;
  }
}
function ns(n, e, t, i) {
  return new Ps(e.doc, n.unquoted, t, i, n.caseSensitive ? void 0 : (r) => r.toLowerCase(), n.wholeWord ? T1e(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function T1e(n, e) {
  return (t, i, r, s) => ((s > t || s + r.length < i) && (s = Math.max(0, t - 2), r = n.sliceString(s, Math.min(n.length, i + 2))), (e(Zc(r, t - s)) != Ce.Word || e(Xc(r, t - s)) != Ce.Word) && (e(Xc(r, i - s)) != Ce.Word || e(Zc(r, i - s)) != Ce.Word));
}
class M1e extends _S {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let r = ns(this.spec, e, i, e.doc.length).nextOverlapping();
    return r.done && (r = ns(this.spec, e, 0, t).nextOverlapping()), r.done ? null : r.value;
  }
  prevMatchInRange(e, t, i) {
    for (let r = i; ; ) {
      let s = Math.max(t, r - 1e4 - this.spec.unquoted.length), o = ns(this.spec, e, s, r), l = null;
      for (; !o.nextOverlapping().done; )
        l = o.value;
      if (l)
        return l;
      if (s == t)
        return null;
      r -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = ns(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, t, i, r) {
    let s = ns(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
function is(n, e, t, i) {
  return new wS(e.doc, n.search, {
    ignoreCase: !n.caseSensitive,
    test: n.wholeWord ? O1e(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function Zc(n, e) {
  return n.slice(Le(n, e, !1), e);
}
function Xc(n, e) {
  return n.slice(e, Le(n, e));
}
function O1e(n) {
  return (e, t, i) => !i[0].length || (n(Zc(i.input, i.index)) != Ce.Word || n(Xc(i.input, i.index)) != Ce.Word) && (n(Xc(i.input, i.index + i[0].length)) != Ce.Word || n(Zc(i.input, i.index + i[0].length)) != Ce.Word);
}
class L1e extends _S {
  nextMatch(e, t, i) {
    let r = is(this.spec, e, i, e.doc.length).next();
    return r.done && (r = is(this.spec, e, 0, t).next()), r.done ? null : r.value;
  }
  prevMatchInRange(e, t, i) {
    for (let r = 1; ; r++) {
      let s = Math.max(t, i - r * 1e4), o = is(this.spec, e, s, i), l = null;
      for (; !o.next().done; )
        l = o.value;
      if (l && (s == t || l.from > s + 10))
        return l;
      if (s == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t));
  }
  matchAll(e, t) {
    let i = is(this.spec, e, 0, e.doc.length), r = [];
    for (; !i.next().done; ) {
      if (r.length >= t)
        return null;
      r.push(i.value);
    }
    return r;
  }
  highlight(e, t, i, r) {
    let s = is(this.spec, e, Math.max(0, t - 250), Math.min(i + 250, e.doc.length));
    for (; !s.next().done; )
      r(s.value.from, s.value.to);
  }
}
const ul = /* @__PURE__ */ G.define(), qg = /* @__PURE__ */ G.define(), Ni = /* @__PURE__ */ Ue.define({
  create(n) {
    return new gf(ep(n).create(), null);
  },
  update(n, e) {
    for (let t of e.effects)
      t.is(ul) ? n = new gf(t.value.create(), n.panel) : t.is(qg) && (n = new gf(n.query, t.value ? Vg : null));
    return n;
  },
  provide: (n) => cl.from(n, (e) => e.panel)
});
class gf {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const R1e = /* @__PURE__ */ U.mark({ class: "cm-searchMatch" }), I1e = /* @__PURE__ */ U.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), B1e = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.view = n, this.decorations = this.highlight(n.state.field(Ni));
  }
  update(n) {
    let e = n.state.field(Ni);
    (e != n.startState.field(Ni) || n.docChanged || n.selectionSet || n.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: n, panel: e }) {
    if (!e || !n.spec.valid)
      return U.none;
    let { view: t } = this, i = new Vt();
    for (let r = 0, s = t.visibleRanges, o = s.length; r < o; r++) {
      let { from: l, to: a } = s[r];
      for (; r < o - 1 && a > s[r + 1].from - 2 * 250; )
        a = s[++r].to;
      n.highlight(t.state, l, a, (c, h) => {
        let u = t.state.selection.ranges.some((f) => f.from == c && f.to == h);
        i.add(c, h, u ? I1e : R1e);
      });
    }
    return i.finish();
  }
}, {
  decorations: (n) => n.decorations
});
function Bl(n) {
  return (e) => {
    let t = e.state.field(Ni, !1);
    return t && t.query.spec.valid ? n(e, t) : AS(e);
  };
}
const Qc = /* @__PURE__ */ Bl((n, { query: e }) => {
  let { to: t } = n.state.selection.main, i = e.nextMatch(n.state, t, t);
  if (!i)
    return !1;
  let r = S.single(i.from, i.to), s = n.state.facet(ro);
  return n.dispatch({
    selection: r,
    effects: [zg(n, i), s.scrollToMatch(r.main, n)],
    userEvent: "select.search"
  }), CS(n), !0;
}), eh = /* @__PURE__ */ Bl((n, { query: e }) => {
  let { state: t } = n, { from: i } = t.selection.main, r = e.prevMatch(t, i, i);
  if (!r)
    return !1;
  let s = S.single(r.from, r.to), o = n.state.facet(ro);
  return n.dispatch({
    selection: s,
    effects: [zg(n, r), o.scrollToMatch(s.main, n)],
    userEvent: "select.search"
  }), CS(n), !0;
}), N1e = /* @__PURE__ */ Bl((n, { query: e }) => {
  let t = e.matchAll(n.state, 1e3);
  return !t || !t.length ? !1 : (n.dispatch({
    selection: S.create(t.map((i) => S.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), P1e = ({ state: n, dispatch: e }) => {
  let t = n.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: r } = t.main, s = [], o = 0;
  for (let l = new Ps(n.doc, n.sliceDoc(i, r)); !l.next().done; ) {
    if (s.length > 1e3)
      return !1;
    l.value.from == i && (o = s.length), s.push(S.range(l.value.from, l.value.to));
  }
  return e(n.update({
    selection: S.create(s, o),
    userEvent: "select.search.matches"
  })), !0;
}, iy = /* @__PURE__ */ Bl((n, { query: e }) => {
  let { state: t } = n, { from: i, to: r } = t.selection.main;
  if (t.readOnly)
    return !1;
  let s = e.nextMatch(t, i, i);
  if (!s)
    return !1;
  let o = [], l, a, c = [];
  if (s.from == i && s.to == r && (a = t.toText(e.getReplacement(s)), o.push({ from: s.from, to: s.to, insert: a }), s = e.nextMatch(t, s.from, s.to), c.push(I.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), s) {
    let h = o.length == 0 || o[0].from >= s.to ? 0 : s.to - s.from - a.length;
    l = S.single(s.from - h, s.to - h), c.push(zg(n, s)), c.push(t.facet(ro).scrollToMatch(l.main, n));
  }
  return n.dispatch({
    changes: o,
    selection: l,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), F1e = /* @__PURE__ */ Bl((n, { query: e }) => {
  if (n.state.readOnly)
    return !1;
  let t = e.matchAll(n.state, 1e9).map((r) => {
    let { from: s, to: o } = r;
    return { from: s, to: o, insert: e.getReplacement(r) };
  });
  if (!t.length)
    return !1;
  let i = n.state.phrase("replaced $ matches", t.length) + ".";
  return n.dispatch({
    changes: t,
    effects: I.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Vg(n) {
  return n.state.facet(ro).createPanel(n);
}
function ep(n, e) {
  var t, i, r, s, o;
  let l = n.selection.main, a = l.empty || l.to > l.from + 100 ? "" : n.sliceDoc(l.from, l.to);
  if (e && !a)
    return e;
  let c = n.facet(ro);
  return new kS({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : c.literal) ? a : a.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : c.caseSensitive,
    literal: (r = e == null ? void 0 : e.literal) !== null && r !== void 0 ? r : c.literal,
    regexp: (s = e == null ? void 0 : e.regexp) !== null && s !== void 0 ? s : c.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : c.wholeWord
  });
}
function SS(n) {
  let e = al(n, Vg);
  return e && e.dom.querySelector("[main-field]");
}
function CS(n) {
  let e = SS(n);
  e && e == n.root.activeElement && e.select();
}
const AS = (n) => {
  let e = n.state.field(Ni, !1);
  if (e && e.panel) {
    let t = SS(n);
    if (t && t != n.root.activeElement) {
      let i = ep(n.state, e.query.spec);
      i.valid && n.dispatch({ effects: ul.of(i) }), t.focus(), t.select();
    }
  } else
    n.dispatch({ effects: [
      qg.of(!0),
      e ? ul.of(ep(n.state, e.query.spec)) : G.appendConfig.of(V1e)
    ] });
  return !0;
}, DS = (n) => {
  let e = n.state.field(Ni, !1);
  if (!e || !e.panel)
    return !1;
  let t = al(n, Vg);
  return t && t.dom.contains(n.root.activeElement) && n.focus(), n.dispatch({ effects: qg.of(!1) }), !0;
}, $1e = [
  { key: "Mod-f", run: AS, scope: "editor search-panel" },
  { key: "F3", run: Qc, shift: eh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Qc, shift: eh, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: DS, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: P1e },
  { key: "Alt-g", run: b1e },
  { key: "Mod-d", run: E1e, preventDefault: !0 }
];
class H1e {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Ni).query.spec;
    this.commit = this.commit.bind(this), this.searchField = be("input", {
      value: t.search,
      placeholder: Rt(e, "Find"),
      "aria-label": Rt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = be("input", {
      value: t.replace,
      placeholder: Rt(e, "Replace"),
      "aria-label": Rt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = be("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = be("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = be("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(r, s, o) {
      return be("button", { class: "cm-button", name: r, onclick: s, type: "button" }, o);
    }
    this.dom = be("div", { onkeydown: (r) => this.keydown(r), class: "cm-search" }, [
      this.searchField,
      i("next", () => Qc(e), [Rt(e, "next")]),
      i("prev", () => eh(e), [Rt(e, "previous")]),
      i("select", () => N1e(e), [Rt(e, "all")]),
      be("label", null, [this.caseField, Rt(e, "match case")]),
      be("label", null, [this.reField, Rt(e, "regexp")]),
      be("label", null, [this.wordField, Rt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        be("br"),
        this.replaceField,
        i("replace", () => iy(e), [Rt(e, "replace")]),
        i("replaceAll", () => F1e(e), [Rt(e, "replace all")])
      ],
      be("button", {
        name: "close",
        onclick: () => DS(e),
        "aria-label": Rt(e, "close"),
        type: "button"
      }, ["\xD7"])
    ]);
  }
  commit() {
    let e = new kS({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ul.of(e) }));
  }
  keydown(e) {
    ege(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? eh : Qc)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), iy(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(ul) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(ro).top;
  }
}
function Rt(n, e) {
  return n.state.phrase(e);
}
const ka = 30, _a = /[\s\.,:;?!]/;
function zg(n, { from: e, to: t }) {
  let i = n.state.doc.lineAt(e), r = n.state.doc.lineAt(t).to, s = Math.max(i.from, e - ka), o = Math.min(r, t + ka), l = n.state.sliceDoc(s, o);
  if (s != i.from) {
    for (let a = 0; a < ka; a++)
      if (!_a.test(l[a + 1]) && _a.test(l[a])) {
        l = l.slice(a);
        break;
      }
  }
  if (o != r) {
    for (let a = l.length - 1; a > l.length - ka; a--)
      if (!_a.test(l[a - 1]) && _a.test(l[a])) {
        l = l.slice(0, a);
        break;
      }
  }
  return I.announce.of(`${n.state.phrase("current match")}. ${l} ${n.state.phrase("on line")} ${i.number}.`);
}
const q1e = /* @__PURE__ */ I.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), V1e = [
  Ni,
  /* @__PURE__ */ gi.low(B1e),
  q1e
];
class ES {
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  tokenBefore(e) {
    let t = pt(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), r = t.text.slice(i - t.from, this.pos - t.from), s = r.search(TS(e, !1));
    return s < 0 ? null : { from: i + s, to: this.pos, text: r.slice(s) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function ry(n) {
  let e = Object.keys(n).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function z1e(n) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: r } of n) {
    e[r[0]] = !0;
    for (let s = 1; s < r.length; s++)
      t[r[s]] = !0;
  }
  let i = ry(e) + ry(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function U1e(n) {
  let e = n.map((r) => typeof r == "string" ? { label: r } : r), [t, i] = e.every((r) => /^\w+$/.test(r.label)) ? [/\w*$/, /\w+$/] : z1e(e);
  return (r) => {
    let s = r.matchBefore(i);
    return s || r.explicit ? { from: s ? s.from : r.pos, options: e, validFor: t } : null;
  };
}
class sy {
  constructor(e, t, i, r) {
    this.completion = e, this.source = t, this.match = i, this.score = r;
  }
}
function Pi(n) {
  return n.selection.main.from;
}
function TS(n, e) {
  var t;
  let { source: i } = n, r = e && i[0] != "^", s = i[i.length - 1] != "$";
  return !r && !s ? n : new RegExp(`${r ? "^" : ""}(?:${i})${s ? "$" : ""}`, (t = n.flags) !== null && t !== void 0 ? t : n.ignoreCase ? "i" : "");
}
const W1e = /* @__PURE__ */ nn.define();
function j1e(n, e, t, i) {
  let { main: r } = n.selection, s = t - r.from, o = i - r.from;
  return Object.assign(Object.assign({}, n.changeByRange((l) => l != r && t != i && n.sliceDoc(l.from + s, l.from + o) != n.sliceDoc(t, i) ? { range: l } : {
    changes: { from: l.from + s, to: i == r.from ? l.to : l.from + o, insert: e },
    range: S.cursor(l.from + s + e.length)
  })), { userEvent: "input.complete" });
}
const oy = /* @__PURE__ */ new WeakMap();
function G1e(n) {
  if (!Array.isArray(n))
    return n;
  let e = oy.get(n);
  return e || oy.set(n, e = U1e(n)), e;
}
const Ug = /* @__PURE__ */ G.define(), fl = /* @__PURE__ */ G.define();
class K1e {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = tt(e, t), r = Ut(i);
      this.chars.push(i);
      let s = e.slice(t, t + r), o = s.toUpperCase();
      this.folded.push(tt(o == s ? s.toLowerCase() : o, 0)), t += r;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: i, any: r, precise: s, byWord: o } = this;
    if (t.length == 1) {
      let y = tt(e, 0), k = Ut(y), w = k == e.length ? 0 : -100;
      if (y != t[0])
        if (y == i[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, k]);
    }
    let l = e.indexOf(this.pattern);
    if (l == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let a = t.length, c = 0;
    if (l < 0) {
      for (let y = 0, k = Math.min(e.length, 200); y < k && c < a; ) {
        let w = tt(e, y);
        (w == t[c] || w == i[c]) && (r[c++] = y), y += Ut(w);
      }
      if (c < a)
        return !1;
    }
    let h = 0, u = 0, f = !1, d = 0, p = -1, g = -1, m = /[a-z]/.test(e), b = !0;
    for (let y = 0, k = Math.min(e.length, 200), w = 0; y < k && u < a; ) {
      let x = tt(e, y);
      l < 0 && (h < a && x == t[h] && (s[h++] = y), d < a && (x == t[d] || x == i[d] ? (d == 0 && (p = y), g = y + 1, d++) : d = 0));
      let v, C = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (v = yg(x)) != v.toLowerCase() ? 1 : v != v.toUpperCase() ? 2 : 0;
      (!y || C == 1 && m || w == 0 && C != 0) && (t[u] == x || i[u] == x && (f = !0) ? o[u++] = y : o.length && (b = !1)), w = C, y += Ut(x);
    }
    return u == a && o[0] == 0 && b ? this.result(-100 + (f ? -200 : 0), o, e) : d == a && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : l > -1 ? this.ret(-700 - e.length, [l, l + this.pattern.length]) : d == a ? this.ret(-200 + -700 - e.length, [p, g]) : u == a ? this.result(-100 + (f ? -200 : 0) + -700 + (b ? 0 : -1100), o, e) : t.length == 2 ? !1 : this.result((r[0] ? -700 : 0) + -200 + -1100, r, e);
  }
  result(e, t, i) {
    let r = [], s = 0;
    for (let o of t) {
      let l = o + (this.astral ? Ut(tt(i, o)) : 1);
      s && r[s - 1] == o ? r[s - 1] = l : (r[s++] = o, r[s++] = l);
    }
    return this.ret(e - i.length, r);
  }
}
const Lt = /* @__PURE__ */ E.define({
  combine(n) {
    return Gn(n, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: Y1e,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => ly(e(i), t(i)),
      optionClass: (e, t) => (i) => ly(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function ly(n, e) {
  return n ? e ? n + " " + e : n : e;
}
function Y1e(n, e, t, i, r) {
  let s = n.textDirection == Te.RTL, o = s, l = !1, a = "top", c, h, u = e.left - r.left, f = r.right - e.right, d = i.right - i.left, p = i.bottom - i.top;
  if (o && u < Math.min(d, f) ? o = !1 : !o && f < Math.min(d, u) && (o = !0), d <= (o ? u : f))
    c = Math.max(r.top, Math.min(t.top, r.bottom - p)) - e.top, h = Math.min(400, o ? u : f);
  else {
    l = !0, h = Math.min(400, (s ? e.right : r.right - e.left) - 30);
    let g = r.bottom - e.bottom;
    g >= p || g > e.top ? c = t.bottom - e.top : (a = "bottom", c = e.bottom - t.top);
  }
  return {
    style: `${a}: ${c}px; max-width: ${h}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function J1e(n) {
  let e = n.addToOptions.slice();
  return n.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((r) => "cm-completionIcon-" + r)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, r) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let o = t.displayLabel || t.label, l = 0;
      for (let a = 0; a < r.length; ) {
        let c = r[a++], h = r[a++];
        c > l && s.appendChild(document.createTextNode(o.slice(l, c)));
        let u = s.appendChild(document.createElement("span"));
        u.appendChild(document.createTextNode(o.slice(c, h))), u.className = "cm-completionMatchedText", l = h;
      }
      return l < o.length && s.appendChild(document.createTextNode(o.slice(l))), s;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function ay(n, e, t) {
  if (n <= t)
    return { from: 0, to: n };
  if (e < 0 && (e = 0), e <= n >> 1) {
    let r = Math.floor(e / t);
    return { from: r * t, to: (r + 1) * t };
  }
  let i = Math.floor((n - e) / t);
  return { from: n - (i + 1) * t, to: n - i * t };
}
class Z1e {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (a) => this.placeInfo(a),
      key: this
    }, this.space = null, this.currentClass = "";
    let r = e.state.field(t), { options: s, selected: o } = r.open, l = e.state.facet(Lt);
    this.optionContent = J1e(l), this.optionClass = l.optionClass, this.tooltipClass = l.tooltipClass, this.range = ay(s.length, o, l.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (a) => {
      for (let c = a.target, h; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (h = /-(\d+)$/.exec(c.id)) && +h[1] < s.length) {
          this.applyCompletion(e, s[+h[1]]), a.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (a) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Lt).closeOnBlur && a.relatedTarget != e.contentDOM && e.dispatch({ effects: fl.of(null) });
    }), this.list = this.dom.appendChild(this.createListBox(s, r.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, i, r;
    let s = e.state.field(this.stateField), o = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), s != o && (this.updateSel(), ((t = s.open) === null || t === void 0 ? void 0 : t.disabled) != ((i = o.open) === null || i === void 0 ? void 0 : i.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((r = s.open) === null || r === void 0) && r.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = ay(t.options.length, t.selected, this.view.state.facet(Lt).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    })), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: r } = i;
      if (!r)
        return;
      let s = typeof r == "string" ? document.createTextNode(r) : r(i);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => Kt(this.view.state, o, "completion info")) : this.addInfoPane(s, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: r, destroy: s } = e;
      i.appendChild(r), this.infoDestroy = s || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, r = this.range.from; i; i = i.nextSibling, r++)
      i.nodeName != "LI" || !i.id ? r-- : r == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && Q1e(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), r = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return r.top > Math.min(s.bottom, t.bottom) - 10 || r.bottom < Math.max(s.top, t.top) + 10 ? null : this.view.state.facet(Lt).positionInfo(this.view, t, r, i, s);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const r = document.createElement("ul");
    r.id = t, r.setAttribute("role", "listbox"), r.setAttribute("aria-expanded", "true"), r.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: l, match: a } = e[o], { section: c } = l;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > i.from || i.from == 0))
          if (s = f, typeof c != "string" && c.header)
            r.appendChild(c.header(c));
          else {
            let d = r.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const h = r.appendChild(document.createElement("li"));
      h.id = t + "-" + o, h.setAttribute("role", "option");
      let u = this.optionClass(l);
      u && (h.className = u);
      for (let f of this.optionContent) {
        let d = f(l, this.view.state, a);
        d && h.appendChild(d);
      }
    }
    return i.from && r.classList.add("cm-completionListIncompleteTop"), i.to < e.length && r.classList.add("cm-completionListIncompleteBottom"), r;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function X1e(n, e) {
  return (t) => new Z1e(t, n, e);
}
function Q1e(n, e) {
  let t = n.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? n.scrollTop -= t.top - i.top : i.bottom > t.bottom && (n.scrollTop += i.bottom - t.bottom);
}
function cy(n) {
  return (n.boost || 0) * 100 + (n.apply ? 10 : 0) + (n.info ? 5 : 0) + (n.type ? 1 : 0);
}
function ebe(n, e) {
  let t = [], i = null, r = (a) => {
    t.push(a);
    let { section: c } = a.completion;
    if (c) {
      i || (i = []);
      let h = typeof c == "string" ? c : c.name;
      i.some((u) => u.name == h) || i.push(typeof c == "string" ? { name: h } : c);
    }
  };
  for (let a of n)
    if (a.hasResult()) {
      let c = a.result.getMatch;
      if (a.result.filter === !1)
        for (let h of a.result.options)
          r(new sy(h, a.source, c ? c(h) : [], 1e9 - t.length));
      else {
        let h = new K1e(e.sliceDoc(a.from, a.to));
        for (let u of a.result.options)
          if (h.match(u.label)) {
            let f = u.displayLabel ? c ? c(u, h.matched) : [] : h.matched;
            r(new sy(u, a.source, f, h.score + (u.boost || 0)));
          }
      }
    }
  if (i) {
    let a = /* @__PURE__ */ Object.create(null), c = 0, h = (u, f) => {
      var d, p;
      return ((d = u.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (u.name < f.name ? -1 : 1);
    };
    for (let u of i.sort(h))
      c -= 1e5, a[u.name] = c;
    for (let u of t) {
      let { section: f } = u.completion;
      f && (u.score += a[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [], o = null, l = e.facet(Lt).compareCompletions;
  for (let a of t.sort((c, h) => h.score - c.score || l(c.completion, h.completion))) {
    let c = a.completion;
    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(a) : cy(a.completion) > cy(o) && (s[s.length - 1] = a), o = a.completion;
  }
  return s;
}
class cs {
  constructor(e, t, i, r, s, o) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = r, this.selected = s, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new cs(this.options, hy(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, r, s) {
    let o = ebe(e, t);
    if (!o.length)
      return r && e.some((a) => a.state == 1) ? new cs(r.options, r.attrs, r.tooltip, r.timestamp, r.selected, !0) : null;
    let l = t.facet(Lt).selectOnOpen ? 0 : -1;
    if (r && r.selected != l && r.selected != -1) {
      let a = r.options[r.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == a) {
          l = c;
          break;
        }
    }
    return new cs(o, hy(i, l), {
      pos: e.reduce((a, c) => c.hasResult() ? Math.min(a, c.from) : a, 1e8),
      create: X1e(Pt, LS),
      above: s.aboveCursor
    }, r ? r.timestamp : Date.now(), l, !1);
  }
  map(e) {
    return new cs(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class th {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new th(ibe, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(Lt), s = (i.override || t.languageDataAt("autocomplete", Pi(t)).map(G1e)).map((l) => (this.active.find((c) => c.source == l) || new Dt(l, this.active.some((c) => c.state != 0) ? 1 : 0)).update(e, i));
    s.length == this.active.length && s.every((l, a) => l == this.active[a]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((l) => l.hasResult() && e.changes.touchesRange(l.from, l.to)) || !tbe(s, this.active) ? o = cs.build(s, t, this.id, o, i) : o && o.disabled && !s.some((l) => l.state == 1) && (o = null), !o && s.every((l) => l.state != 1) && s.some((l) => l.hasResult()) && (s = s.map((l) => l.hasResult() ? new Dt(l.source, 0) : l));
    for (let l of e.effects)
      l.is(OS) && (o = o && o.setSelected(l.value, this.id));
    return s == this.active && o == this.open ? this : new th(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : nbe;
  }
}
function tbe(n, e) {
  if (n == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < n.length && !n[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let r = t == n.length, s = i == e.length;
    if (r || s)
      return r == s;
    if (n[t++].result != e[i++].result)
      return !1;
  }
}
const nbe = {
  "aria-autocomplete": "list"
};
function hy(n, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": n
  };
  return e > -1 && (t["aria-activedescendant"] = n + "-" + e), t;
}
const ibe = [];
function tp(n) {
  return n.isUserEvent("input.type") ? "input" : n.isUserEvent("delete.backward") ? "delete" : null;
}
class Dt {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = tp(e), r = this;
    i ? r = r.handleUserEvent(e, i, t) : e.docChanged ? r = r.handleChange(e) : e.selection && r.state != 0 && (r = new Dt(r.source, 0));
    for (let s of e.effects)
      if (s.is(Ug))
        r = new Dt(r.source, 1, s.value ? Pi(e.state) : -1);
      else if (s.is(fl))
        r = new Dt(r.source, 0);
      else if (s.is(MS))
        for (let o of s.value)
          o.source == r.source && (r = o);
    return r;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new Dt(this.source, 1);
  }
  handleChange(e) {
    return e.changes.touchesRange(Pi(e.startState)) ? new Dt(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Dt(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class ws extends Dt {
  constructor(e, t, i, r, s) {
    super(e, 2, t), this.result = i, this.from = r, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var r;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), l = Pi(e.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > o || t == "delete" && Pi(e.startState) == this.from)
      return new Dt(this.source, t == "input" && i.activateOnTyping ? 1 : 0);
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return rbe(this.result.validFor, e.state, s, o) ? new ws(this.source, a, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new ES(e.state, l, a >= 0))) ? new ws(this.source, a, c, c.from, (r = c.to) !== null && r !== void 0 ? r : Pi(e.state)) : new Dt(this.source, 1, a);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Dt(this.source, 0) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new ws(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function rbe(n, e, t, i) {
  if (!n)
    return !1;
  let r = e.sliceDoc(t, i);
  return typeof n == "function" ? n(r, t, i, e) : TS(n, !0).test(r);
}
const MS = /* @__PURE__ */ G.define({
  map(n, e) {
    return n.map((t) => t.map(e));
  }
}), OS = /* @__PURE__ */ G.define(), Pt = /* @__PURE__ */ Ue.define({
  create() {
    return th.start();
  },
  update(n, e) {
    return n.update(e);
  },
  provide: (n) => [
    Eg.from(n, (e) => e.tooltip),
    I.contentAttributes.from(n, (e) => e.attrs)
  ]
});
function LS(n, e) {
  const t = e.completion.apply || e.completion.label;
  let i = n.state.field(Pt).active.find((r) => r.source == e.source);
  return i instanceof ws ? (typeof t == "string" ? n.dispatch(Object.assign(Object.assign({}, j1e(n.state, t, i.from, i.to)), { annotations: W1e.of(e.completion) })) : t(n, e.completion, i.from, i.to), !0) : !1;
}
function Sa(n, e = "option") {
  return (t) => {
    let i = t.state.field(Pt, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(Lt).interactionDelay)
      return !1;
    let r = 1, s;
    e == "page" && (s = y_(t, i.open.tooltip)) && (r = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, l = i.open.selected > -1 ? i.open.selected + r * (n ? 1 : -1) : n ? 0 : o - 1;
    return l < 0 ? l = e == "page" ? 0 : o - 1 : l >= o && (l = e == "page" ? o - 1 : 0), t.dispatch({ effects: OS.of(l) }), !0;
  };
}
const sbe = (n) => {
  let e = n.state.field(Pt, !1);
  return n.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < n.state.facet(Lt).interactionDelay ? !1 : LS(n, e.open.options[e.open.selected]);
}, obe = (n) => n.state.field(Pt, !1) ? (n.dispatch({ effects: Ug.of(!0) }), !0) : !1, lbe = (n) => {
  let e = n.state.field(Pt, !1);
  return !e || !e.active.some((t) => t.state != 0) ? !1 : (n.dispatch({ effects: fl.of(null) }), !0);
};
class abe {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const uy = 50, cbe = 50, hbe = 1e3, ube = /* @__PURE__ */ Re.fromClass(class {
  constructor(n) {
    this.view = n, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of n.state.field(Pt).active)
      e.state == 1 && this.startQuery(e);
  }
  update(n) {
    let e = n.state.field(Pt);
    if (!n.selectionSet && !n.docChanged && n.startState.field(Pt) == e)
      return;
    let t = n.transactions.some((i) => (i.selection || i.docChanged) && !tp(i));
    for (let i = 0; i < this.running.length; i++) {
      let r = this.running[i];
      if (t || r.updates.length + n.transactions.length > cbe && Date.now() - r.time > hbe) {
        for (let s of r.context.abortListeners)
          try {
            s();
          } catch (o) {
            Kt(this.view.state, o);
          }
        r.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        r.updates.push(...n.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((r) => r.active.source == i.source)) ? setTimeout(() => this.startUpdate(), uy) : -1, this.composing != 0)
      for (let i of n.transactions)
        tp(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: n } = this.view, e = n.field(Pt);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(n) {
    let { state: e } = this.view, t = Pi(e), i = new ES(e, t, n.explicitPos == t), r = new abe(n, i);
    this.running.push(r), Promise.resolve(n.source(i)).then((s) => {
      r.context.aborted || (r.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: fl.of(null) }), Kt(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((n) => n.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), uy));
  }
  accept() {
    var n;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Lt);
    for (let i = 0; i < this.running.length; i++) {
      let r = this.running[i];
      if (r.done === void 0)
        continue;
      if (this.running.splice(i--, 1), r.done) {
        let o = new ws(r.active.source, r.active.explicitPos, r.done, r.done.from, (n = r.done.to) !== null && n !== void 0 ? n : Pi(r.updates.length ? r.updates[0].startState : this.view.state));
        for (let l of r.updates)
          o = o.update(l, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(Pt).active.find((o) => o.source == r.active.source);
      if (s && s.state == 1)
        if (r.done == null) {
          let o = new Dt(r.active.source, 0);
          for (let l of r.updates)
            o = o.update(l, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: MS.of(e) });
  }
}, {
  eventHandlers: {
    blur(n) {
      let e = this.view.state.field(Pt, !1);
      if (e && e.tooltip && this.view.state.facet(Lt).closeOnBlur) {
        let t = e.open && y_(this.view, e.open.tooltip);
        (!t || !t.dom.contains(n.relatedTarget)) && this.view.dispatch({ effects: fl.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Ug.of(!1) }), 20), this.composing = 0;
    }
  }
}), fbe = /* @__PURE__ */ I.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
}), dl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, dr = /* @__PURE__ */ G.define({
  map(n, e) {
    let t = e.mapPos(n, -1, qe.TrackAfter);
    return t == null ? void 0 : t;
  }
}), Wg = /* @__PURE__ */ new class extends ai {
}();
Wg.startSide = 1;
Wg.endSide = -1;
const RS = /* @__PURE__ */ Ue.define({
  create() {
    return W.empty;
  },
  update(n, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (n = W.empty);
    }
    n = n.map(e.changes);
    for (let t of e.effects)
      t.is(dr) && (n = n.update({ add: [Wg.range(t.value, t.value + 1)] }));
    return n;
  }
});
function dbe() {
  return [gbe, RS];
}
const mf = "()[]{}<>";
function IS(n) {
  for (let e = 0; e < mf.length; e += 2)
    if (mf.charCodeAt(e) == n)
      return mf.charAt(e + 1);
  return yg(n < 128 ? n : n + 1);
}
function BS(n, e) {
  return n.languageDataAt("closeBrackets", e)[0] || dl;
}
const pbe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), gbe = /* @__PURE__ */ I.inputHandler.of((n, e, t, i) => {
  if ((pbe ? n.composing : n.compositionStarted) || n.state.readOnly)
    return !1;
  let r = n.state.selection.main;
  if (i.length > 2 || i.length == 2 && Ut(tt(i, 0)) == 1 || e != r.from || t != r.to)
    return !1;
  let s = ybe(n.state, i);
  return s ? (n.dispatch(s), !0) : !1;
}), mbe = ({ state: n, dispatch: e }) => {
  if (n.readOnly)
    return !1;
  let i = BS(n, n.selection.main.head).brackets || dl.brackets, r = null, s = n.changeByRange((o) => {
    if (o.empty) {
      let l = wbe(n.doc, o.head);
      for (let a of i)
        if (a == l && jh(n.doc, o.head) == IS(tt(a, 0)))
          return {
            changes: { from: o.head - a.length, to: o.head + a.length },
            range: S.cursor(o.head - a.length)
          };
    }
    return { range: r = o };
  });
  return r || e(n.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !r;
}, bbe = [
  { key: "Backspace", run: mbe }
];
function ybe(n, e) {
  let t = BS(n, n.selection.main.head), i = t.brackets || dl.brackets;
  for (let r of i) {
    let s = IS(tt(r, 0));
    if (e == r)
      return s == r ? kbe(n, r, i.indexOf(r + r + r) > -1, t) : vbe(n, r, s, t.before || dl.before);
    if (e == s && NS(n, n.selection.main.from))
      return xbe(n, r, s);
  }
  return null;
}
function NS(n, e) {
  let t = !1;
  return n.field(RS).between(0, n.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function jh(n, e) {
  let t = n.sliceString(e, e + 2);
  return t.slice(0, Ut(tt(t, 0)));
}
function wbe(n, e) {
  let t = n.sliceString(e - 2, e);
  return Ut(tt(t, 0)) == t.length ? t : t.slice(1);
}
function vbe(n, e, t, i) {
  let r = null, s = n.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: dr.of(o.to + e.length),
        range: S.range(o.anchor + e.length, o.head + e.length)
      };
    let l = jh(n.doc, o.head);
    return !l || /\s/.test(l) || i.indexOf(l) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: dr.of(o.head + e.length),
      range: S.cursor(o.head + e.length)
    } : { range: r = o };
  });
  return r ? null : n.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function xbe(n, e, t) {
  let i = null, r = n.changeByRange((s) => s.empty && jh(n.doc, s.head) == t ? {
    changes: { from: s.head, to: s.head + t.length, insert: t },
    range: S.cursor(s.head + t.length)
  } : i = { range: s });
  return i ? null : n.update(r, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function kbe(n, e, t, i) {
  let r = i.stringPrefixes || dl.stringPrefixes, s = null, o = n.changeByRange((l) => {
    if (!l.empty)
      return {
        changes: [{ insert: e, from: l.from }, { insert: e, from: l.to }],
        effects: dr.of(l.to + e.length),
        range: S.range(l.anchor + e.length, l.head + e.length)
      };
    let a = l.head, c = jh(n.doc, a), h;
    if (c == e) {
      if (fy(n, a))
        return {
          changes: { insert: e + e, from: a },
          effects: dr.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (NS(n, a)) {
        let f = t && n.sliceDoc(a, a + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: a, to: a + f.length, insert: f },
          range: S.cursor(a + f.length)
        };
      }
    } else {
      if (t && n.sliceDoc(a - 2 * e.length, a) == e + e && (h = dy(n, a - 2 * e.length, r)) > -1 && fy(n, h))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: dr.of(a + e.length),
          range: S.cursor(a + e.length)
        };
      if (n.charCategorizer(a)(c) != Ce.Word && dy(n, a, r) > -1 && !_be(n, a, e, r))
        return {
          changes: { insert: e + e, from: a },
          effects: dr.of(a + e.length),
          range: S.cursor(a + e.length)
        };
    }
    return { range: s = l };
  });
  return s ? null : n.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function fy(n, e) {
  let t = pt(n).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function _be(n, e, t, i) {
  let r = pt(n).resolveInner(e, -1), s = i.reduce((o, l) => Math.max(o, l.length), 0);
  for (let o = 0; o < 5; o++) {
    let l = n.sliceDoc(r.from, Math.min(r.to, r.from + t.length + s)), a = l.indexOf(t);
    if (!a || a > -1 && i.indexOf(l.slice(0, a)) > -1) {
      let h = r.firstChild;
      for (; h && h.from == r.from && h.to - h.from > t.length + a; ) {
        if (n.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let c = r.to == e && r.parent;
    if (!c)
      break;
    r = c;
  }
  return !1;
}
function dy(n, e, t) {
  let i = n.charCategorizer(e);
  if (i(n.sliceDoc(e - 1, e)) != Ce.Word)
    return e;
  for (let r of t) {
    let s = e - r.length;
    if (n.sliceDoc(s, e) == r && i(n.sliceDoc(s - 1, s)) != Ce.Word)
      return s;
  }
  return -1;
}
function Sbe(n = {}) {
  return [
    Pt,
    Lt.of(n),
    ube,
    Cbe,
    fbe
  ];
}
const PS = [
  { key: "Ctrl-Space", run: obe },
  { key: "Escape", run: lbe },
  { key: "ArrowDown", run: /* @__PURE__ */ Sa(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Sa(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Sa(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Sa(!1, "page") },
  { key: "Enter", run: sbe }
], Cbe = /* @__PURE__ */ gi.highest(/* @__PURE__ */ ol.computeN([Lt], (n) => n.facet(Lt).defaultKeymap ? [PS] : []));
class Abe {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class cr {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let r = e, s = i.facet(HS).markerFilter;
    s && (r = s(r));
    let o = U.set(r.map((l) => l.from == l.to || l.from == l.to - 1 && i.doc.lineAt(l.from).to == l.from ? U.widget({
      widget: new Bbe(l),
      diagnostic: l
    }).range(l.from) : U.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity + (l.markClass ? " " + l.markClass : "") },
      diagnostic: l
    }).range(l.from, l.to)), !0);
    return new cr(o, t, Fs(o));
  }
}
function Fs(n, e = null, t = 0) {
  let i = null;
  return n.between(t, 1e9, (r, s, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new Abe(r, s, o.diagnostic), !1;
  }), i;
}
function Dbe(n, e) {
  let t = n.startState.doc.lineAt(e.pos);
  return !!(n.effects.some((i) => i.is(FS)) || n.changes.touchesRange(t.from, t.to));
}
function Ebe(n, e) {
  return n.field(Ht, !1) ? e : e.concat(G.appendConfig.of(Fbe));
}
const FS = /* @__PURE__ */ G.define(), jg = /* @__PURE__ */ G.define(), $S = /* @__PURE__ */ G.define(), Ht = /* @__PURE__ */ Ue.define({
  create() {
    return new cr(U.none, null, null);
  },
  update(n, e) {
    if (e.docChanged) {
      let t = n.diagnostics.map(e.changes), i = null;
      if (n.selected) {
        let r = e.changes.mapPos(n.selected.from, 1);
        i = Fs(t, n.selected.diagnostic, r) || Fs(t, null, r);
      }
      n = new cr(t, n.panel, i);
    }
    for (let t of e.effects)
      t.is(FS) ? n = cr.init(t.value, n.panel, e.state) : t.is(jg) ? n = new cr(n.diagnostics, t.value ? Gh.open : null, n.selected) : t.is($S) && (n = new cr(n.diagnostics, n.panel, t.value));
    return n;
  },
  provide: (n) => [
    cl.from(n, (e) => e.panel),
    I.decorations.from(n, (e) => e.diagnostics)
  ]
}), Tbe = /* @__PURE__ */ U.mark({ class: "cm-lintRange cm-lintRange-active" });
function Mbe(n, e, t) {
  let { diagnostics: i } = n.state.field(Ht), r = [], s = 2e8, o = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: h }) => {
    e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)) && (r.push(h.diagnostic), s = Math.min(a, s), o = Math.max(c, o));
  });
  let l = n.state.facet(HS).tooltipFilter;
  return l && (r = l(r)), r.length ? {
    pos: s,
    end: o,
    above: n.state.doc.lineAt(s).to < o,
    create() {
      return { dom: Obe(n, r) };
    }
  } : null;
}
function Obe(n, e) {
  return be("ul", { class: "cm-tooltip-lint" }, e.map((t) => VS(n, t, !1)));
}
const Lbe = (n) => {
  let e = n.state.field(Ht, !1);
  (!e || !e.panel) && n.dispatch({ effects: Ebe(n.state, [jg.of(!0)]) });
  let t = al(n, Gh.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, py = (n) => {
  let e = n.state.field(Ht, !1);
  return !e || !e.panel ? !1 : (n.dispatch({ effects: jg.of(!1) }), !0);
}, Rbe = (n) => {
  let e = n.state.field(Ht, !1);
  if (!e)
    return !1;
  let t = n.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (n.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, Ibe = [
  { key: "Mod-Shift-m", run: Lbe, preventDefault: !0 },
  { key: "F8", run: Rbe }
], HS = /* @__PURE__ */ E.define({
  combine(n) {
    return Object.assign({ sources: n.map((e) => e.source) }, Gn(n.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function qS(n) {
  let e = [];
  if (n)
    e:
      for (let { name: t } of n) {
        for (let i = 0; i < t.length; i++) {
          let r = t[i];
          if (/[a-zA-Z]/.test(r) && !e.some((s) => s.toLowerCase() == r.toLowerCase())) {
            e.push(r);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function VS(n, e, t) {
  var i;
  let r = t ? qS(e.actions) : [];
  return be("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, be("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((s, o) => {
    let l = !1, a = (f) => {
      if (f.preventDefault(), l)
        return;
      l = !0;
      let d = Fs(n.state.field(Ht).diagnostics, e);
      d && s.apply(n, d.from, d.to);
    }, { name: c } = s, h = r[o] ? c.indexOf(r[o]) : -1, u = h < 0 ? c : [
      c.slice(0, h),
      be("u", c.slice(h, h + 1)),
      c.slice(h + 1)
    ];
    return be("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: a,
      onmousedown: a,
      "aria-label": ` Action: ${c}${h < 0 ? "" : ` (access key "${r[o]})"`}.`
    }, u);
  }), e.source && be("div", { class: "cm-diagnosticSource" }, e.source));
}
class Bbe extends mi {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return be("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class gy {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = VS(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Gh {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (r) => {
      if (r.keyCode == 27)
        py(this.view), this.view.focus();
      else if (r.keyCode == 38 || r.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (r.keyCode == 40 || r.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (r.keyCode == 36)
        this.moveSelection(0);
      else if (r.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (r.keyCode == 13)
        this.view.focus();
      else if (r.keyCode >= 65 && r.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: s } = this.items[this.selectedIndex], o = qS(s.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == r.keyCode) {
            let a = Fs(this.view.state.field(Ht).diagnostics, s);
            a && s.actions[l].apply(e, a.from, a.to);
          }
      } else
        return;
      r.preventDefault();
    }, i = (r) => {
      for (let s = 0; s < this.items.length; s++)
        this.items[s].dom.contains(r.target) && this.moveSelection(s);
    };
    this.list = be("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = be("div", { class: "cm-panel-lint" }, this.list, be("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => py(this.view)
    }, "\xD7")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(Ht).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(Ht), i = 0, r = !1, s = null;
    for (e.between(0, this.view.state.doc.length, (o, l, { spec: a }) => {
      let c = -1, h;
      for (let u = i; u < this.items.length; u++)
        if (this.items[u].diagnostic == a.diagnostic) {
          c = u;
          break;
        }
      c < 0 ? (h = new gy(this.view, a.diagnostic), this.items.splice(i, 0, h), r = !0) : (h = this.items[c], c > i && (this.items.splice(i, c - i), r = !0)), t && h.diagnostic == t.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), s = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      r = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new gy(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), r = !0), s ? (this.list.setAttribute("aria-activedescendant", s.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: s.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        o.top < l.top ? this.list.scrollTop -= l.top - o.top : o.bottom > l.bottom && (this.list.scrollTop += o.bottom - l.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), r && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(Ht), i = Fs(t.diagnostics, this.items[e].diagnostic);
    !i || this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: $S.of(i)
    });
  }
  static open(e) {
    return new Gh(e);
  }
}
function Nbe(n, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(n)}</svg>')`;
}
function Ca(n) {
  return Nbe(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${n}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Pbe = /* @__PURE__ */ I.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Ca("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Ca("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Ca("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ Ca("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), Fbe = [
  Ht,
  /* @__PURE__ */ I.decorations.compute([Ht], (n) => {
    let { selected: e, panel: t } = n.field(Ht);
    return !e || !t || e.from == e.to ? U.none : U.set([
      Tbe.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ $ge(Mbe, { hideOn: Dbe }),
  Pbe
], np = /* @__PURE__ */ (() => [
  Kge(),
  Zge(),
  bge(),
  m0e(),
  qme(),
  oge(),
  uge(),
  J.allowMultipleSelections.of(!0),
  Dme(),
  zme(jme, { fallback: !0 }),
  Qme(),
  dbe(),
  Sbe(),
  Tge(),
  Lge(),
  _ge(),
  v1e(),
  ol.of([
    ...bbe,
    ...p1e,
    ...$1e,
    ...C0e,
    ...Pme,
    ...PS,
    ...Ibe
  ])
])(), un = () => /* @__PURE__ */ new Map(), ip = (n) => {
  const e = un();
  return n.forEach((t, i) => {
    e.set(i, t);
  }), e;
}, bi = (n, e, t) => {
  let i = n.get(e);
  return i === void 0 && n.set(e, i = t()), i;
}, $be = (n, e) => {
  const t = [];
  for (const [i, r] of n)
    t.push(e(r, i));
  return t;
}, Hbe = (n, e) => {
  for (const [t, i] of n)
    if (e(i, t))
      return !0;
  return !1;
}, Lr = () => /* @__PURE__ */ new Set(), bf = (n) => n[n.length - 1], qbe = (n, e) => {
  for (let t = 0; t < e.length; t++)
    n.push(e[t]);
}, Gi = Array.from, Vbe = (n, e) => {
  for (let t = 0; t < n.length; t++)
    if (e(n[t], t, n))
      return !0;
  return !1;
}, rp = Array.isArray;
class Kh {
  constructor() {
    this._observers = un();
  }
  on(e, t) {
    bi(this._observers, e, Lr).add(t);
  }
  once(e, t) {
    const i = (...r) => {
      this.off(e, i), t(...r);
    };
    this.on(e, i);
  }
  off(e, t) {
    const i = this._observers.get(e);
    i !== void 0 && (i.delete(t), i.size === 0 && this._observers.delete(e));
  }
  emit(e, t) {
    return Gi((this._observers.get(e) || un()).values()).forEach((i) => i(...t));
  }
  destroy() {
    this._observers = un();
  }
}
const ui = Math.floor, lc = Math.abs, Yh = (n, e) => n < e ? n : e, Qi = (n, e) => n > e ? n : e, zbe = Math.pow, zS = (n) => n !== 0 ? n < 0 : 1 / n < 0, Ube = String.fromCharCode, Wbe = (n) => n.toLowerCase(), jbe = /^\s*/g, Gbe = (n) => n.replace(jbe, ""), Kbe = /([A-Z])/g, my = (n, e) => Gbe(n.replace(Kbe, (t) => `${e}${Wbe(t)}`)), Ybe = (n) => {
  const e = unescape(encodeURIComponent(n)), t = e.length, i = new Uint8Array(t);
  for (let r = 0; r < t; r++)
    i[r] = e.codePointAt(r);
  return i;
}, pl = typeof TextEncoder < "u" ? new TextEncoder() : null, Jbe = (n) => pl.encode(n), Zbe = pl ? Jbe : Ybe;
let qo = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
qo && qo.decode(new Uint8Array()).length === 1 && (qo = null);
const by = (n) => n === void 0 ? null : n;
class Xbe {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  setItem(e, t) {
    this.map.set(e, t);
  }
  getItem(e) {
    return this.map.get(e);
  }
}
let US = new Xbe(), Gg = !0;
try {
  typeof localStorage < "u" && (US = localStorage, Gg = !1);
} catch {
}
const WS = US, Qbe = (n) => Gg || addEventListener("storage", n), eye = (n) => Gg || removeEventListener("storage", n), tye = Object.assign, nye = Object.keys, iye = (n, e) => {
  for (const t in n)
    e(n[t], t);
}, rye = (n, e) => {
  const t = [];
  for (const i in n)
    t.push(e(n[i], i));
  return t;
}, nh = (n) => nye(n).length, sye = (n) => {
  for (const e in n)
    return !1;
  return !0;
}, oye = (n, e) => {
  for (const t in n)
    if (!e(n[t], t))
      return !1;
  return !0;
}, jS = (n, e) => Object.prototype.hasOwnProperty.call(n, e), lye = (n, e) => n === e || nh(n) === nh(e) && oye(n, (t, i) => (t !== void 0 || jS(e, i)) && e[i] === t), Kg = (n, e, t = 0) => {
  try {
    for (; t < n.length; t++)
      n[t](...e);
  } finally {
    t < n.length && Kg(n, e, t + 1);
  }
}, aye = (n) => n, cye = (n, e) => n === e, Vo = (n, e) => {
  if (n == null || e == null)
    return cye(n, e);
  if (n.constructor !== e.constructor)
    return !1;
  if (n === e)
    return !0;
  switch (n.constructor) {
    case ArrayBuffer:
      n = new Uint8Array(n), e = new Uint8Array(e);
    case Uint8Array: {
      if (n.byteLength !== e.byteLength)
        return !1;
      for (let t = 0; t < n.length; t++)
        if (n[t] !== e[t])
          return !1;
      break;
    }
    case Set: {
      if (n.size !== e.size)
        return !1;
      for (const t of n)
        if (!e.has(t))
          return !1;
      break;
    }
    case Map: {
      if (n.size !== e.size)
        return !1;
      for (const t of n.keys())
        if (!e.has(t) || !Vo(n.get(t), e.get(t)))
          return !1;
      break;
    }
    case Object:
      if (nh(n) !== nh(e))
        return !1;
      for (const t in n)
        if (!jS(n, t) || !Vo(n[t], e[t]))
          return !1;
      break;
    case Array:
      if (n.length !== e.length)
        return !1;
      for (let t = 0; t < n.length; t++)
        if (!Vo(n[t], e[t]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, hye = (n, e) => e.includes(n), $s = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name), GS = typeof window < "u" && typeof document < "u" && !$s;
typeof navigator < "u" && /Mac/.test(navigator.platform);
let Sn;
const uye = () => {
  if (Sn === void 0)
    if ($s) {
      Sn = un();
      const n = process.argv;
      let e = null;
      for (let t = 0; t < n.length; t++) {
        const i = n[t];
        i[0] === "-" ? (e !== null && Sn.set(e, ""), e = i) : e !== null && (Sn.set(e, i), e = null);
      }
      e !== null && Sn.set(e, "");
    } else
      typeof location == "object" ? (Sn = un(), (location.search || "?").slice(1).split("&").forEach((n) => {
        if (n.length !== 0) {
          const [e, t] = n.split("=");
          Sn.set(`--${my(e, "-")}`, t), Sn.set(`-${my(e, "-")}`, t);
        }
      })) : Sn = un();
  return Sn;
}, sp = (n) => uye().has(n), op = (n) => by($s ? {}[n.toUpperCase()] : WS.getItem(n)), fye = (n) => sp("--" + n) || op(n) !== null;
fye("production");
const yy = $s && hye({}.FORCE_COLOR, ["true", "1", "2"]), dye = !sp("no-colors") && (!$s || process.stdout.isTTY || yy) && (!$s || sp("color") || yy || op("COLORTERM") !== null || (op("TERM") || "").includes("color")), wy = 1, vy = 2, yf = 4, wf = 8, gl = 32, si = 64, qt = 128, Jh = 31, lp = 63, xr = 127, pye = 2147483647, KS = Number.MAX_SAFE_INTEGER, gye = Number.isInteger || ((n) => typeof n == "number" && isFinite(n) && ui(n) === n), Ki = (n) => new Error(n), qn = () => {
  throw Ki("Method unimplemented");
}, gn = () => {
  throw Ki("Unexpected case");
}, YS = Ki("Unexpected end of array"), JS = Ki("Integer out of Range");
class Zh {
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const er = (n) => new Zh(n), mye = (n) => n.pos !== n.arr.length, bye = (n, e) => {
  const t = Zg(n.arr.buffer, n.pos + n.arr.byteOffset, e);
  return n.pos += e, t;
}, lt = (n) => bye(n, K(n)), Hs = (n) => n.arr[n.pos++], K = (n) => {
  let e = 0, t = 1;
  const i = n.arr.length;
  for (; n.pos < i; ) {
    const r = n.arr[n.pos++];
    if (e = e + (r & xr) * t, t *= 128, r < qt)
      return e;
    if (e > KS)
      throw JS;
  }
  throw YS;
}, Yg = (n) => {
  let e = n.arr[n.pos++], t = e & lp, i = 64;
  const r = (e & si) > 0 ? -1 : 1;
  if ((e & qt) === 0)
    return r * t;
  const s = n.arr.length;
  for (; n.pos < s; ) {
    if (e = n.arr[n.pos++], t = t + (e & xr) * i, i *= 128, e < qt)
      return r * t;
    if (t > KS)
      throw JS;
  }
  throw YS;
}, yye = (n) => {
  let e = K(n);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(Hs(n));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(Hs(n));
    else
      for (; e > 0; ) {
        const i = e < 1e4 ? e : 1e4, r = n.arr.subarray(n.pos, n.pos + i);
        n.pos += i, t += String.fromCodePoint.apply(null, r), e -= i;
      }
    return decodeURIComponent(escape(t));
  }
}, wye = (n) => qo.decode(lt(n)), Fi = qo ? wye : yye, Jg = (n, e) => {
  const t = new DataView(n.arr.buffer, n.arr.byteOffset + n.pos, e);
  return n.pos += e, t;
}, vye = (n) => Jg(n, 4).getFloat32(0, !1), xye = (n) => Jg(n, 8).getFloat64(0, !1), kye = (n) => Jg(n, 8).getBigInt64(0, !1), _ye = [
  (n) => {
  },
  (n) => null,
  Yg,
  vye,
  xye,
  kye,
  (n) => !1,
  (n) => !0,
  Fi,
  (n) => {
    const e = K(n), t = {};
    for (let i = 0; i < e; i++) {
      const r = Fi(n);
      t[r] = ml(n);
    }
    return t;
  },
  (n) => {
    const e = K(n), t = [];
    for (let i = 0; i < e; i++)
      t.push(ml(n));
    return t;
  },
  lt
], ml = (n) => _ye[127 - Hs(n)](n);
class xy extends Zh {
  constructor(e, t) {
    super(e), this.reader = t, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), mye(this) ? this.count = K(this) + 1 : this.count = -1), this.count--, this.s;
  }
}
class ac extends Zh {
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Yg(this);
      const e = zS(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = K(this) + 2);
    }
    return this.count--, this.s;
  }
}
class vf extends Zh {
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  read() {
    if (this.count === 0) {
      const e = Yg(this), t = e & 1;
      this.diff = ui(e / 2), this.count = 1, t && (this.count = K(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class Sye {
  constructor(e) {
    this.decoder = new ac(e), this.str = Fi(this.decoder), this.spos = 0;
  }
  read() {
    const e = this.spos + this.decoder.read(), t = this.str.slice(this.spos, e);
    return this.spos = e, t;
  }
}
const ZS = (n) => new Uint8Array(n), Zg = (n, e, t) => new Uint8Array(n, e, t), Cye = (n) => new Uint8Array(n), Aye = (n) => {
  let e = "";
  for (let t = 0; t < n.byteLength; t++)
    e += Ube(n[t]);
  return btoa(e);
}, Dye = (n) => Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("base64"), Eye = (n) => {
  const e = atob(n), t = ZS(e.length);
  for (let i = 0; i < e.length; i++)
    t[i] = e.charCodeAt(i);
  return t;
}, Tye = (n) => {
  const e = Buffer.from(n, "base64");
  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}, Mye = GS ? Aye : Dye, Oye = GS ? Eye : Tye, Lye = (n) => {
  const e = ZS(n.byteLength);
  return e.set(n), e;
};
class Nl {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const at = () => new Nl(), Xg = (n) => {
  let e = n.cpos;
  for (let t = 0; t < n.bufs.length; t++)
    e += n.bufs[t].length;
  return e;
}, Ee = (n) => {
  const e = new Uint8Array(Xg(n));
  let t = 0;
  for (let i = 0; i < n.bufs.length; i++) {
    const r = n.bufs[i];
    e.set(r, t), t += r.length;
  }
  return e.set(Zg(n.cbuf.buffer, 0, n.cpos), t), e;
}, Rye = (n, e) => {
  const t = n.cbuf.length;
  t - n.cpos < e && (n.bufs.push(Zg(n.cbuf.buffer, 0, n.cpos)), n.cbuf = new Uint8Array(Qi(t, e) * 2), n.cpos = 0);
}, Je = (n, e) => {
  const t = n.cbuf.length;
  n.cpos === t && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(t * 2), n.cpos = 0), n.cbuf[n.cpos++] = e;
}, ap = Je, V = (n, e) => {
  for (; e > xr; )
    Je(n, qt | xr & e), e = ui(e / 128);
  Je(n, xr & e);
}, Qg = (n, e) => {
  const t = zS(e);
  for (t && (e = -e), Je(n, (e > lp ? qt : 0) | (t ? si : 0) | lp & e), e = ui(e / 64); e > 0; )
    Je(n, (e > xr ? qt : 0) | xr & e), e = ui(e / 128);
}, cp = new Uint8Array(3e4), Iye = cp.length / 3, Bye = (n, e) => {
  if (e.length < Iye) {
    const t = pl.encodeInto(e, cp).written || 0;
    V(n, t);
    for (let i = 0; i < t; i++)
      Je(n, cp[i]);
  } else
    Ie(n, Zbe(e));
}, Nye = (n, e) => {
  const t = unescape(encodeURIComponent(e)), i = t.length;
  V(n, i);
  for (let r = 0; r < i; r++)
    Je(n, t.codePointAt(r));
}, kr = pl && pl.encodeInto ? Bye : Nye, Xh = (n, e) => {
  const t = n.cbuf.length, i = n.cpos, r = Yh(t - i, e.length), s = e.length - r;
  n.cbuf.set(e.subarray(0, r), i), n.cpos += r, s > 0 && (n.bufs.push(n.cbuf), n.cbuf = new Uint8Array(Qi(t * 2, s)), n.cbuf.set(e.subarray(r)), n.cpos = s);
}, Ie = (n, e) => {
  V(n, e.byteLength), Xh(n, e);
}, em = (n, e) => {
  Rye(n, e);
  const t = new DataView(n.cbuf.buffer, n.cpos, e);
  return n.cpos += e, t;
}, Pye = (n, e) => em(n, 4).setFloat32(0, e, !1), Fye = (n, e) => em(n, 8).setFloat64(0, e, !1), $ye = (n, e) => em(n, 8).setBigInt64(0, e, !1), ky = new DataView(new ArrayBuffer(4)), Hye = (n) => (ky.setFloat32(0, n), ky.getFloat32(0) === n), bl = (n, e) => {
  switch (typeof e) {
    case "string":
      Je(n, 119), kr(n, e);
      break;
    case "number":
      gye(e) && lc(e) <= pye ? (Je(n, 125), Qg(n, e)) : Hye(e) ? (Je(n, 124), Pye(n, e)) : (Je(n, 123), Fye(n, e));
      break;
    case "bigint":
      Je(n, 122), $ye(n, e);
      break;
    case "object":
      if (e === null)
        Je(n, 126);
      else if (rp(e)) {
        Je(n, 117), V(n, e.length);
        for (let t = 0; t < e.length; t++)
          bl(n, e[t]);
      } else if (e instanceof Uint8Array)
        Je(n, 116), Ie(n, e);
      else {
        Je(n, 118);
        const t = Object.keys(e);
        V(n, t.length);
        for (let i = 0; i < t.length; i++) {
          const r = t[i];
          kr(n, r), bl(n, e[r]);
        }
      }
      break;
    case "boolean":
      Je(n, e ? 120 : 121);
      break;
    default:
      Je(n, 127);
  }
};
class _y extends Nl {
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && V(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const Sy = (n) => {
  n.count > 0 && (Qg(n.encoder, n.count === 1 ? n.s : -n.s), n.count > 1 && V(n.encoder, n.count - 2));
};
class cc {
  constructor() {
    this.encoder = new Nl(), this.s = 0, this.count = 0;
  }
  write(e) {
    this.s === e ? this.count++ : (Sy(this), this.count = 1, this.s = e);
  }
  toUint8Array() {
    return Sy(this), Ee(this.encoder);
  }
}
const Cy = (n) => {
  if (n.count > 0) {
    const e = n.diff * 2 + (n.count === 1 ? 0 : 1);
    Qg(n.encoder, e), n.count > 1 && V(n.encoder, n.count - 2);
  }
};
class xf {
  constructor() {
    this.encoder = new Nl(), this.s = 0, this.count = 0, this.diff = 0;
  }
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (Cy(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  toUint8Array() {
    return Cy(this), Ee(this.encoder);
  }
}
class qye {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new cc();
  }
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new Nl();
    return this.sarr.push(this.s), this.s = "", kr(e, this.sarr.join("")), Xh(e, this.lensE.toUint8Array()), Ee(e);
  }
}
const Vye = crypto.getRandomValues.bind(crypto), XS = () => Vye(new Uint32Array(1))[0], zye = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, Uye = () => zye.replace(
  /[018]/g,
  (n) => (n ^ XS() & 15 >> n / 4).toString(16)
), Yi = Date.now, Ay = (n) => new Promise(n);
Promise.all.bind(Promise);
class Wye {
  constructor(e, t) {
    this.left = e, this.right = t;
  }
}
const It = (n, e) => new Wye(n, e), jye = (n, e) => n.forEach((t) => e(t.left, t.right)), Yn = typeof document < "u" ? document : {}, Gye = (n) => Yn.createElement(n), Kye = () => Yn.createDocumentFragment(), Yye = (n) => Yn.createTextNode(n);
typeof DOMParser < "u" && new DOMParser();
const Jye = (n, e) => (jye(e, (t, i) => {
  i === !1 ? n.removeAttribute(t) : i === !0 ? n.setAttribute(t, "") : n.setAttribute(t, i);
}), n), Zye = (n) => {
  const e = Kye();
  for (let t = 0; t < n.length; t++)
    QS(e, n[t]);
  return e;
}, Xye = (n, e) => (QS(n, Zye(e)), n), kf = (n, e = [], t = []) => Xye(Jye(Gye(n), e), t), Aa = Yye, Qye = (n) => $be(n, (e, t) => `${t}:${e};`).join(""), QS = (n, e) => n.appendChild(e);
Yn.ELEMENT_NODE;
Yn.TEXT_NODE;
Yn.CDATA_SECTION_NODE;
Yn.COMMENT_NODE;
Yn.DOCUMENT_NODE;
Yn.DOCUMENT_TYPE_NODE;
Yn.DOCUMENT_FRAGMENT_NODE;
const yi = Symbol, eC = yi(), tC = yi(), ewe = yi(), twe = yi(), nwe = yi(), nC = yi(), iwe = yi(), iC = yi(), rwe = yi(), swe = (n) => {
  const e = [];
  let t = 0;
  for (; t < n.length; t++) {
    const i = n[t];
    i.constructor === String || i.constructor === Number || i.constructor === Object && e.push(JSON.stringify(i));
  }
  return e;
}, owe = {
  [eC]: It("font-weight", "bold"),
  [tC]: It("font-weight", "normal"),
  [ewe]: It("color", "blue"),
  [nwe]: It("color", "green"),
  [twe]: It("color", "grey"),
  [nC]: It("color", "red"),
  [iwe]: It("color", "purple"),
  [iC]: It("color", "orange"),
  [rwe]: It("color", "black")
}, lwe = (n) => {
  const e = [], t = [], i = un();
  let r = [], s = 0;
  for (; s < n.length; s++) {
    const o = n[s], l = owe[o];
    if (l !== void 0)
      i.set(l.left, l.right);
    else if (o.constructor === String || o.constructor === Number) {
      const a = Qye(i);
      s > 0 || a.length > 0 ? (e.push("%c" + o), t.push(a)) : e.push(o);
    } else
      break;
  }
  for (s > 0 && (r = t, r.unshift(e.join(""))); s < n.length; s++) {
    const o = n[s];
    o instanceof Symbol || r.push(o);
  }
  return r;
}, awe = dye ? lwe : swe, cwe = (...n) => {
  console.log(...awe(n)), hwe.forEach((e) => e.print(n));
}, hwe = Lr(), rC = (n) => ({
  [Symbol.iterator]() {
    return this;
  },
  next: n
}), uwe = (n, e) => rC(() => {
  let t;
  do
    t = n.next();
  while (!t.done && !e(t.value));
  return t;
}), _f = (n, e) => rC(() => {
  const { done: t, value: i } = n.next();
  return { done: t, value: t ? void 0 : e(i) };
});
class tm {
  constructor(e, t) {
    this.clock = e, this.len = t;
  }
}
class so {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const qs = (n, e, t) => e.clients.forEach((i, r) => {
  const s = n.doc.store.clients.get(r);
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    wC(n, s, l.clock, l.len, t);
  }
}), fwe = (n, e) => {
  let t = 0, i = n.length - 1;
  for (; t <= i; ) {
    const r = ui((t + i) / 2), s = n[r], o = s.clock;
    if (o <= e) {
      if (e < o + s.len)
        return r;
      t = r + 1;
    } else
      i = r - 1;
  }
  return null;
}, Pl = (n, e) => {
  const t = n.clients.get(e.client);
  return t !== void 0 && fwe(t, e.clock) !== null;
}, nm = (n) => {
  n.clients.forEach((e) => {
    e.sort((r, s) => r.clock - s.clock);
    let t, i;
    for (t = 1, i = 1; t < e.length; t++) {
      const r = e[i - 1], s = e[t];
      r.clock + r.len >= s.clock ? r.len = Qi(r.len, s.clock + s.len - r.clock) : (i < t && (e[i] = s), i++);
    }
    e.length = i;
  });
}, hp = (n) => {
  const e = new so();
  for (let t = 0; t < n.length; t++)
    n[t].clients.forEach((i, r) => {
      if (!e.clients.has(r)) {
        const s = i.slice();
        for (let o = t + 1; o < n.length; o++)
          qbe(s, n[o].clients.get(r) || []);
        e.clients.set(r, s);
      }
    });
  return nm(e), e;
}, yl = (n, e, t, i) => {
  bi(n.clients, e, () => []).push(new tm(t, i));
}, sC = () => new so(), dwe = (n) => {
  const e = sC();
  return n.clients.forEach((t, i) => {
    const r = [];
    for (let s = 0; s < t.length; s++) {
      const o = t[s];
      if (o.deleted) {
        const l = o.id.clock;
        let a = o.length;
        if (s + 1 < t.length)
          for (let c = t[s + 1]; s + 1 < t.length && c.deleted; c = t[++s + 1])
            a += c.length;
        r.push(new tm(l, a));
      }
    }
    r.length > 0 && e.clients.set(i, r);
  }), e;
}, oo = (n, e) => {
  V(n.restEncoder, e.clients.size), Gi(e.clients.entries()).sort((t, i) => i[0] - t[0]).forEach(([t, i]) => {
    n.resetDsCurVal(), V(n.restEncoder, t);
    const r = i.length;
    V(n.restEncoder, r);
    for (let s = 0; s < r; s++) {
      const o = i[s];
      n.writeDsClock(o.clock), n.writeDsLen(o.len);
    }
  });
}, im = (n) => {
  const e = new so(), t = K(n.restDecoder);
  for (let i = 0; i < t; i++) {
    n.resetDsCurVal();
    const r = K(n.restDecoder), s = K(n.restDecoder);
    if (s > 0) {
      const o = bi(e.clients, r, () => []);
      for (let l = 0; l < s; l++)
        o.push(new tm(n.readDsClock(), n.readDsLen()));
    }
  }
  return e;
}, Dy = (n, e, t) => {
  const i = new so(), r = K(n.restDecoder);
  for (let s = 0; s < r; s++) {
    n.resetDsCurVal();
    const o = K(n.restDecoder), l = K(n.restDecoder), a = t.clients.get(o) || [], c = Pe(t, o);
    for (let h = 0; h < l; h++) {
      const u = n.readDsClock(), f = u + n.readDsLen();
      if (u < c) {
        c < f && yl(i, o, c, f - c);
        let d = zn(a, u), p = a[d];
        for (!p.deleted && p.id.clock < u && (a.splice(d + 1, 0, hh(e, p, u - p.id.clock)), d++); d < a.length && (p = a[d++], p.id.clock < f); )
          p.deleted || (f < p.id.clock + p.length && a.splice(d, 0, hh(e, p, f - p.id.clock)), p.delete(e));
      } else
        yl(i, o, u, f - u);
    }
  }
  if (i.clients.size > 0) {
    const s = new Rr();
    return V(s.restEncoder, 0), oo(s, i), s.toUint8Array();
  }
  return null;
}, oC = XS;
class lo extends Kh {
  constructor({ guid: e = Uye(), collectionid: t = null, gc: i = !0, gcFilter: r = () => !0, meta: s = null, autoLoad: o = !1, shouldLoad: l = !0 } = {}) {
    super(), this.gc = i, this.gcFilter = r, this.clientID = oC(), this.guid = e, this.collectionid = t, this.share = /* @__PURE__ */ new Map(), this.store = new bC(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = l, this.autoLoad = o, this.meta = s, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = Ay((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const a = () => Ay((c) => {
      const h = (u) => {
        (u === void 0 || u === !0) && (this.off("sync", h), c());
      };
      this.on("sync", h);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = a()), this.isSynced = c === void 0 || c === !0, this.isLoaded || this.emit("load", []);
    }), this.whenSynced = a();
  }
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && de(e.parent.doc, (t) => {
      t.subdocsLoaded.add(this);
    }, null, !0), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(Gi(this.subdocs).map((e) => e.guid));
  }
  transact(e, t = null) {
    return de(this, e, t);
  }
  get(e, t = st) {
    const i = bi(this.share, e, () => {
      const s = new t();
      return s._integrate(this, null), s;
    }), r = i.constructor;
    if (t !== st && r !== t)
      if (r === st) {
        const s = new t();
        s._map = i._map, i._map.forEach((o) => {
          for (; o !== null; o = o.left)
            o.parent = s;
        }), s._start = i._start;
        for (let o = s._start; o !== null; o = o.right)
          o.parent = s;
        return s._length = i._length, this.share.set(e, s), s._integrate(this, null), s;
      } else
        throw new Error(`Type with the name ${e} has already been defined with a different constructor`);
    return i;
  }
  getArray(e = "") {
    return this.get(e, xs);
  }
  getText(e = "") {
    return this.get(e, Us);
  }
  getMap(e = "") {
    return this.get(e, zs);
  }
  getXmlFragment(e = "") {
    return this.get(e, Ir);
  }
  toJSON() {
    const e = {};
    return this.share.forEach((t, i) => {
      e[i] = t.toJSON();
    }), e;
  }
  destroy() {
    Gi(this.subdocs).forEach((t) => t.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const t = e.content;
      t.doc = new lo({ guid: this.guid, ...t.opts, shouldLoad: !1 }), t.doc._item = e, de(e.parent.doc, (i) => {
        const r = t.doc;
        e.deleted || i.subdocsAdded.add(r), i.subdocsRemoved.add(this);
      }, null, !0);
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
  on(e, t) {
    super.on(e, t);
  }
  off(e, t) {
    super.off(e, t);
  }
}
class lC {
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  readDsClock() {
    return K(this.restDecoder);
  }
  readDsLen() {
    return K(this.restDecoder);
  }
}
class aC extends lC {
  readLeftID() {
    return Y(K(this.restDecoder), K(this.restDecoder));
  }
  readRightID() {
    return Y(K(this.restDecoder), K(this.restDecoder));
  }
  readClient() {
    return K(this.restDecoder);
  }
  readInfo() {
    return Hs(this.restDecoder);
  }
  readString() {
    return Fi(this.restDecoder);
  }
  readParentInfo() {
    return K(this.restDecoder) === 1;
  }
  readTypeRef() {
    return K(this.restDecoder);
  }
  readLen() {
    return K(this.restDecoder);
  }
  readAny() {
    return ml(this.restDecoder);
  }
  readBuf() {
    return Lye(lt(this.restDecoder));
  }
  readJSON() {
    return JSON.parse(Fi(this.restDecoder));
  }
  readKey() {
    return Fi(this.restDecoder);
  }
}
class pwe {
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  readDsClock() {
    return this.dsCurrVal += K(this.restDecoder), this.dsCurrVal;
  }
  readDsLen() {
    const e = K(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Vs extends pwe {
  constructor(e) {
    super(e), this.keys = [], K(e), this.keyClockDecoder = new vf(lt(e)), this.clientDecoder = new ac(lt(e)), this.leftClockDecoder = new vf(lt(e)), this.rightClockDecoder = new vf(lt(e)), this.infoDecoder = new xy(lt(e), Hs), this.stringDecoder = new Sye(lt(e)), this.parentInfoDecoder = new xy(lt(e), Hs), this.typeRefDecoder = new ac(lt(e)), this.lenDecoder = new ac(lt(e));
  }
  readLeftID() {
    return new vs(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  readRightID() {
    return new vs(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  readClient() {
    return this.clientDecoder.read();
  }
  readInfo() {
    return this.infoDecoder.read();
  }
  readString() {
    return this.stringDecoder.read();
  }
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  readLen() {
    return this.lenDecoder.read();
  }
  readAny() {
    return ml(this.restDecoder);
  }
  readBuf() {
    return lt(this.restDecoder);
  }
  readJSON() {
    return ml(this.restDecoder);
  }
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const t = this.stringDecoder.read();
      return this.keys.push(t), t;
    }
  }
}
class cC {
  constructor() {
    this.restEncoder = at();
  }
  toUint8Array() {
    return Ee(this.restEncoder);
  }
  resetDsCurVal() {
  }
  writeDsClock(e) {
    V(this.restEncoder, e);
  }
  writeDsLen(e) {
    V(this.restEncoder, e);
  }
}
class Fl extends cC {
  writeLeftID(e) {
    V(this.restEncoder, e.client), V(this.restEncoder, e.clock);
  }
  writeRightID(e) {
    V(this.restEncoder, e.client), V(this.restEncoder, e.clock);
  }
  writeClient(e) {
    V(this.restEncoder, e);
  }
  writeInfo(e) {
    ap(this.restEncoder, e);
  }
  writeString(e) {
    kr(this.restEncoder, e);
  }
  writeParentInfo(e) {
    V(this.restEncoder, e ? 1 : 0);
  }
  writeTypeRef(e) {
    V(this.restEncoder, e);
  }
  writeLen(e) {
    V(this.restEncoder, e);
  }
  writeAny(e) {
    bl(this.restEncoder, e);
  }
  writeBuf(e) {
    Ie(this.restEncoder, e);
  }
  writeJSON(e) {
    kr(this.restEncoder, JSON.stringify(e));
  }
  writeKey(e) {
    kr(this.restEncoder, e);
  }
}
class hC {
  constructor() {
    this.restEncoder = at(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Ee(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  writeDsClock(e) {
    const t = e - this.dsCurrVal;
    this.dsCurrVal = e, V(this.restEncoder, t);
  }
  writeDsLen(e) {
    e === 0 && gn(), V(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class Rr extends hC {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new xf(), this.clientEncoder = new cc(), this.leftClockEncoder = new xf(), this.rightClockEncoder = new xf(), this.infoEncoder = new _y(ap), this.stringEncoder = new qye(), this.parentInfoEncoder = new _y(ap), this.typeRefEncoder = new cc(), this.lenEncoder = new cc();
  }
  toUint8Array() {
    const e = at();
    return V(e, 0), Ie(e, this.keyClockEncoder.toUint8Array()), Ie(e, this.clientEncoder.toUint8Array()), Ie(e, this.leftClockEncoder.toUint8Array()), Ie(e, this.rightClockEncoder.toUint8Array()), Ie(e, Ee(this.infoEncoder)), Ie(e, this.stringEncoder.toUint8Array()), Ie(e, Ee(this.parentInfoEncoder)), Ie(e, this.typeRefEncoder.toUint8Array()), Ie(e, this.lenEncoder.toUint8Array()), Xh(e, Ee(this.restEncoder)), Ee(e);
  }
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  writeString(e) {
    this.stringEncoder.write(e);
  }
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  writeAny(e) {
    bl(this.restEncoder, e);
  }
  writeBuf(e) {
    Ie(this.restEncoder, e);
  }
  writeJSON(e) {
    bl(this.restEncoder, e);
  }
  writeKey(e) {
    const t = this.keyMap.get(e);
    t === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(t);
  }
}
const gwe = (n, e, t, i) => {
  i = Qi(i, e[0].id.clock);
  const r = zn(e, i);
  V(n.restEncoder, e.length - r), n.writeClient(t), V(n.restEncoder, i);
  const s = e[r];
  s.write(n, i - s.id.clock);
  for (let o = r + 1; o < e.length; o++)
    e[o].write(n, 0);
}, rm = (n, e, t) => {
  const i = /* @__PURE__ */ new Map();
  t.forEach((r, s) => {
    Pe(e, s) > r && i.set(s, r);
  }), Qh(e).forEach((r, s) => {
    t.has(s) || i.set(s, 0);
  }), V(n.restEncoder, i.size), Gi(i.entries()).sort((r, s) => s[0] - r[0]).forEach(([r, s]) => {
    gwe(n, e.clients.get(r), r, s);
  });
}, mwe = (n, e) => {
  const t = un(), i = K(n.restDecoder);
  for (let r = 0; r < i; r++) {
    const s = K(n.restDecoder), o = new Array(s), l = n.readClient();
    let a = K(n.restDecoder);
    t.set(l, { i: 0, refs: o });
    for (let c = 0; c < s; c++) {
      const h = n.readInfo();
      switch (Jh & h) {
        case 0: {
          const u = n.readLen();
          o[c] = new Wt(Y(l, a), u), a += u;
          break;
        }
        case 10: {
          const u = K(n.restDecoder);
          o[c] = new jt(Y(l, a), u), a += u;
          break;
        }
        default: {
          const u = (h & (si | qt)) === 0, f = new pe(
            Y(l, a),
            null,
            (h & qt) === qt ? n.readLeftID() : null,
            null,
            (h & si) === si ? n.readRightID() : null,
            u ? n.readParentInfo() ? e.get(n.readString()) : n.readLeftID() : null,
            u && (h & gl) === gl ? n.readString() : null,
            $C(n, h)
          );
          o[c] = f, a += f.length;
        }
      }
    }
  }
  return t;
}, bwe = (n, e, t) => {
  const i = [];
  let r = Gi(t.keys()).sort((d, p) => d - p);
  if (r.length === 0)
    return null;
  const s = () => {
    if (r.length === 0)
      return null;
    let d = t.get(r[r.length - 1]);
    for (; d.refs.length === d.i; )
      if (r.pop(), r.length > 0)
        d = t.get(r[r.length - 1]);
      else
        return null;
    return d;
  };
  let o = s();
  if (o === null && i.length === 0)
    return null;
  const l = new bC(), a = /* @__PURE__ */ new Map(), c = (d, p) => {
    const g = a.get(d);
    (g == null || g > p) && a.set(d, p);
  };
  let h = o.refs[o.i++];
  const u = /* @__PURE__ */ new Map(), f = () => {
    for (const d of i) {
      const p = d.id.client, g = t.get(p);
      g ? (g.i--, l.clients.set(p, g.refs.slice(g.i)), t.delete(p), g.i = 0, g.refs = []) : l.clients.set(p, [d]), r = r.filter((m) => m !== p);
    }
    i.length = 0;
  };
  for (; ; ) {
    if (h.constructor !== jt) {
      const p = bi(u, h.id.client, () => Pe(e, h.id.client)) - h.id.clock;
      if (p < 0)
        i.push(h), c(h.id.client, h.id.clock - 1), f();
      else {
        const g = h.getMissing(n, e);
        if (g !== null) {
          i.push(h);
          const m = t.get(g) || { refs: [], i: 0 };
          if (m.refs.length === m.i)
            c(g, Pe(e, g)), f();
          else {
            h = m.refs[m.i++];
            continue;
          }
        } else
          (p === 0 || p < h.length) && (h.integrate(n, p), u.set(h.id.client, h.id.clock + h.length));
      }
    }
    if (i.length > 0)
      h = i.pop();
    else if (o !== null && o.i < o.refs.length)
      h = o.refs[o.i++];
    else {
      if (o = s(), o === null)
        break;
      h = o.refs[o.i++];
    }
  }
  if (l.clients.size > 0) {
    const d = new Rr();
    return rm(d, l, /* @__PURE__ */ new Map()), V(d.restEncoder, 0), { missing: a, update: d.toUint8Array() };
  }
  return null;
}, ywe = (n, e) => rm(n, e.doc.store, e.beforeState), wwe = (n, e, t, i = new Vs(n)) => de(e, (r) => {
  r.local = !1;
  let s = !1;
  const o = r.doc, l = o.store, a = mwe(i, o), c = bwe(r, l, a), h = l.pendingStructs;
  if (h) {
    for (const [f, d] of h.missing)
      if (d < Pe(l, f)) {
        s = !0;
        break;
      }
    if (c) {
      for (const [f, d] of c.missing) {
        const p = h.missing.get(f);
        (p == null || p > d) && h.missing.set(f, d);
      }
      h.update = rh([h.update, c.update]);
    }
  } else
    l.pendingStructs = c;
  const u = Dy(i, r, l);
  if (l.pendingDs) {
    const f = new Vs(er(l.pendingDs));
    K(f.restDecoder);
    const d = Dy(f, r, l);
    u && d ? l.pendingDs = rh([u, d]) : l.pendingDs = u || d;
  } else
    l.pendingDs = u;
  if (s) {
    const f = l.pendingStructs.update;
    l.pendingStructs = null, uC(r.doc, f);
  }
}, t, !1), uC = (n, e, t, i = Vs) => {
  const r = er(e);
  wwe(r, n, t, new i(r));
}, vwe = (n, e, t) => uC(n, e, t, aC), xwe = (n, e, t = /* @__PURE__ */ new Map()) => {
  rm(n, e.store, t), oo(n, dwe(e.store));
}, kwe = (n, e = new Uint8Array([0]), t = new Rr()) => {
  const i = fC(e);
  xwe(t, n, i);
  const r = [t.toUint8Array()];
  if (n.store.pendingDs && r.push(n.store.pendingDs), n.store.pendingStructs && r.push(Vwe(n.store.pendingStructs.update, e)), r.length > 1) {
    if (t.constructor === Fl)
      return Hwe(r.map((s, o) => o === 0 ? s : Uwe(s)));
    if (t.constructor === Rr)
      return rh(r);
  }
  return r[0];
}, _we = (n, e) => kwe(n, e, new Fl()), Swe = (n) => {
  const e = /* @__PURE__ */ new Map(), t = K(n.restDecoder);
  for (let i = 0; i < t; i++) {
    const r = K(n.restDecoder), s = K(n.restDecoder);
    e.set(r, s);
  }
  return e;
}, fC = (n) => Swe(new lC(er(n))), dC = (n, e) => (V(n.restEncoder, e.size), Gi(e.entries()).sort((t, i) => i[0] - t[0]).forEach(([t, i]) => {
  V(n.restEncoder, t), V(n.restEncoder, i);
}), n), Cwe = (n, e) => dC(n, Qh(e.store)), Awe = (n, e = new hC()) => (n instanceof Map ? dC(e, n) : Cwe(e, n), e.toUint8Array()), Dwe = (n) => Awe(n, new cC());
class Ewe {
  constructor() {
    this.l = [];
  }
}
const Ey = () => new Ewe(), Ty = (n, e) => n.l.push(e), My = (n, e) => {
  const t = n.l, i = t.length;
  n.l = t.filter((r) => e !== r), i === n.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, pC = (n, e, t) => Kg(n.l, [e, t]);
class vs {
  constructor(e, t) {
    this.client = e, this.clock = t;
  }
}
const hs = (n, e) => n === e || n !== null && e !== null && n.client === e.client && n.clock === e.clock, Y = (n, e) => new vs(n, e), gC = (n) => {
  for (const [e, t] of n.doc.share.entries())
    if (t === n)
      return e;
  throw gn();
}, ih = (n, e) => {
  for (; e !== null; ) {
    if (e.parent === n)
      return !0;
    e = e.parent._item;
  }
  return !1;
};
class mC {
  constructor(e, t, i, r = 0) {
    this.type = e, this.tname = t, this.item = i, this.assoc = r;
  }
}
const Oy = (n) => {
  const e = {};
  return n.type && (e.type = n.type), n.tname && (e.tname = n.tname), n.item && (e.item = n.item), n.assoc != null && (e.assoc = n.assoc), e;
}, wl = (n) => new mC(n.type == null ? null : Y(n.type.client, n.type.clock), n.tname || null, n.item == null ? null : Y(n.item.client, n.item.clock), n.assoc == null ? 0 : n.assoc);
class Twe {
  constructor(e, t, i = 0) {
    this.type = e, this.index = t, this.assoc = i;
  }
}
const Mwe = (n, e, t = 0) => new Twe(n, e, t), Da = (n, e, t) => {
  let i = null, r = null;
  return n._item === null ? r = gC(n) : i = Y(n._item.id.client, n._item.id.clock), new mC(i, r, e, t);
}, up = (n, e, t = 0) => {
  let i = n._start;
  if (t < 0) {
    if (e === 0)
      return Da(n, null, t);
    e--;
  }
  for (; i !== null; ) {
    if (!i.deleted && i.countable) {
      if (i.length > e)
        return Da(n, Y(i.id.client, i.id.clock + e), t);
      e -= i.length;
    }
    if (i.right === null && t < 0)
      return Da(n, i.lastId, t);
    i = i.right;
  }
  return Da(n, null, t);
}, fp = (n, e) => {
  const t = e.store, i = n.item, r = n.type, s = n.tname, o = n.assoc;
  let l = null, a = 0;
  if (i !== null) {
    if (Pe(t, i.client) <= i.clock)
      return null;
    const c = mp(t, i), h = c.item;
    if (!(h instanceof pe))
      return null;
    if (l = h.parent, l._item === null || !l._item.deleted) {
      a = h.deleted || !h.countable ? 0 : c.diff + (o >= 0 ? 0 : 1);
      let u = h.left;
      for (; u !== null; )
        !u.deleted && u.countable && (a += u.length), u = u.left;
    }
  } else {
    if (s !== null)
      l = e.get(s);
    else if (r !== null) {
      if (Pe(t, r.client) <= r.clock)
        return null;
      const { item: c } = mp(t, r);
      if (c instanceof pe && c.content instanceof Jn)
        l = c.content.type;
      else
        return null;
    } else
      throw gn();
    o >= 0 ? a = l._length : a = 0;
  }
  return Mwe(l, a, n.assoc);
}, Ly = (n, e) => n === e || n !== null && e !== null && n.tname === e.tname && hs(n.item, e.item) && hs(n.type, e.type) && n.assoc === e.assoc;
class Owe {
  constructor(e, t) {
    this.ds = e, this.sv = t;
  }
}
const Lwe = (n, e) => new Owe(n, e);
Lwe(sC(), /* @__PURE__ */ new Map());
const yo = (n, e) => e === void 0 ? !n.deleted : e.sv.has(n.id.client) && (e.sv.get(n.id.client) || 0) > n.id.clock && !Pl(e.ds, n.id), dp = (n, e) => {
  const t = bi(n.meta, dp, Lr), i = n.doc.store;
  t.has(e) || (e.sv.forEach((r, s) => {
    r < Pe(i, s) && Et(n, Y(s, r));
  }), qs(n, e.ds, (r) => {
  }), t.add(e));
};
class bC {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const Qh = (n) => {
  const e = /* @__PURE__ */ new Map();
  return n.clients.forEach((t, i) => {
    const r = t[t.length - 1];
    e.set(i, r.id.clock + r.length);
  }), e;
}, Pe = (n, e) => {
  const t = n.clients.get(e);
  if (t === void 0)
    return 0;
  const i = t[t.length - 1];
  return i.id.clock + i.length;
}, yC = (n, e) => {
  let t = n.clients.get(e.id.client);
  if (t === void 0)
    t = [], n.clients.set(e.id.client, t);
  else {
    const i = t[t.length - 1];
    if (i.id.clock + i.length !== e.id.clock)
      throw gn();
  }
  t.push(e);
}, zn = (n, e) => {
  let t = 0, i = n.length - 1, r = n[i], s = r.id.clock;
  if (s === e)
    return i;
  let o = ui(e / (s + r.length - 1) * i);
  for (; t <= i; ) {
    if (r = n[o], s = r.id.clock, s <= e) {
      if (e < s + r.length)
        return o;
      t = o + 1;
    } else
      i = o - 1;
    o = ui((t + i) / 2);
  }
  throw gn();
}, Rwe = (n, e) => {
  const t = n.clients.get(e.client);
  return t[zn(t, e.clock)];
}, hc = Rwe, pp = (n, e, t) => {
  const i = zn(e, t), r = e[i];
  return r.id.clock < t && r instanceof pe ? (e.splice(i + 1, 0, hh(n, r, t - r.id.clock)), i + 1) : i;
}, Et = (n, e) => {
  const t = n.doc.store.clients.get(e.client);
  return t[pp(n, t, e.clock)];
}, Ry = (n, e, t) => {
  const i = e.clients.get(t.client), r = zn(i, t.clock), s = i[r];
  return t.clock !== s.id.clock + s.length - 1 && s.constructor !== Wt && i.splice(r + 1, 0, hh(n, s, t.clock - s.id.clock + 1)), s;
}, Iwe = (n, e, t) => {
  const i = n.clients.get(e.id.client);
  i[zn(i, e.id.clock)] = t;
}, wC = (n, e, t, i, r) => {
  if (i === 0)
    return;
  const s = t + i;
  let o = pp(n, e, t), l;
  do
    l = e[o++], s < l.id.clock + l.length && pp(n, e, s), r(l);
  while (o < e.length && e[o].id.clock < s);
};
class Bwe {
  constructor(e, t, i) {
    this.doc = e, this.deleteSet = new so(), this.beforeState = Qh(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = t, this.meta = /* @__PURE__ */ new Map(), this.local = i, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const Iy = (n, e) => e.deleteSet.clients.size === 0 && !Hbe(e.afterState, (t, i) => e.beforeState.get(i) !== t) ? !1 : (nm(e.deleteSet), ywe(n, e), oo(n, e.deleteSet), !0), By = (n, e, t) => {
  const i = e._item;
  (i === null || i.id.clock < (n.beforeState.get(i.id.client) || 0) && !i.deleted) && bi(n.changed, e, Lr).add(t);
}, uc = (n, e) => {
  let t = n[e], i = n[e - 1], r = e;
  for (; r > 0; t = i, i = n[--r - 1]) {
    if (i.deleted === t.deleted && i.constructor === t.constructor && i.mergeWith(t)) {
      t instanceof pe && t.parentSub !== null && t.parent._map.get(t.parentSub) === t && t.parent._map.set(t.parentSub, i);
      continue;
    }
    break;
  }
  const s = e - r;
  return s && n.splice(e + 1 - s, s), s;
}, Nwe = (n, e, t) => {
  for (const [i, r] of n.clients.entries()) {
    const s = e.clients.get(i);
    for (let o = r.length - 1; o >= 0; o--) {
      const l = r[o], a = l.clock + l.len;
      for (let c = zn(s, l.clock), h = s[c]; c < s.length && h.id.clock < a; h = s[++c]) {
        const u = s[c];
        if (l.clock + l.len <= u.id.clock)
          break;
        u instanceof pe && u.deleted && !u.keep && t(u) && u.gc(e, !1);
      }
    }
  }
}, Pwe = (n, e) => {
  n.clients.forEach((t, i) => {
    const r = e.clients.get(i);
    for (let s = t.length - 1; s >= 0; s--) {
      const o = t[s], l = Yh(r.length - 1, 1 + zn(r, o.clock + o.len - 1));
      for (let a = l, c = r[a]; a > 0 && c.id.clock >= o.clock; c = r[a])
        a -= 1 + uc(r, a);
    }
  });
}, vC = (n, e) => {
  if (e < n.length) {
    const t = n[e], i = t.doc, r = i.store, s = t.deleteSet, o = t._mergeStructs;
    try {
      nm(s), t.afterState = Qh(t.doc.store), i.emit("beforeObserverCalls", [t, i]);
      const l = [];
      t.changed.forEach(
        (a, c) => l.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(t, a);
        })
      ), l.push(() => {
        t.changedParentTypes.forEach((a, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (a = a.filter(
            (h) => h.target._item === null || !h.target._item.deleted
          ), a.forEach((h) => {
            h.currentTarget = c, h._path = null;
          }), a.sort((h, u) => h.path.length - u.path.length), pC(c._dEH, a, t));
        });
      }), l.push(() => i.emit("afterTransaction", [t, i])), Kg(l, []), t._needFormattingCleanup && ive(t);
    } finally {
      i.gc && Nwe(s, r, i.gcFilter), Pwe(s, r), t.afterState.forEach((h, u) => {
        const f = t.beforeState.get(u) || 0;
        if (f !== h) {
          const d = r.clients.get(u), p = Qi(zn(d, f), 1);
          for (let g = d.length - 1; g >= p; )
            g -= 1 + uc(d, g);
        }
      });
      for (let h = o.length - 1; h >= 0; h--) {
        const { client: u, clock: f } = o[h].id, d = r.clients.get(u), p = zn(d, f);
        p + 1 < d.length && uc(d, p + 1) > 1 || p > 0 && uc(d, p);
      }
      if (!t.local && t.afterState.get(i.clientID) !== t.beforeState.get(i.clientID) && (cwe(iC, eC, "[yjs] ", tC, nC, "Changed the client-id because another client seems to be using it."), i.clientID = oC()), i.emit("afterTransactionCleanup", [t, i]), i._observers.has("update")) {
        const h = new Fl();
        Iy(h, t) && i.emit("update", [h.toUint8Array(), t.origin, i, t]);
      }
      if (i._observers.has("updateV2")) {
        const h = new Rr();
        Iy(h, t) && i.emit("updateV2", [h.toUint8Array(), t.origin, i, t]);
      }
      const { subdocsAdded: l, subdocsLoaded: a, subdocsRemoved: c } = t;
      (l.size > 0 || c.size > 0 || a.size > 0) && (l.forEach((h) => {
        h.clientID = i.clientID, h.collectionid == null && (h.collectionid = i.collectionid), i.subdocs.add(h);
      }), c.forEach((h) => i.subdocs.delete(h)), i.emit("subdocs", [{ loaded: a, added: l, removed: c }, i, t]), c.forEach((h) => h.destroy())), n.length <= e + 1 ? (i._transactionCleanups = [], i.emit("afterAllTransactions", [i, n])) : vC(n, e + 1);
    }
  }
}, de = (n, e, t = null, i = !0) => {
  const r = n._transactionCleanups;
  let s = !1, o = null;
  n._transaction === null && (s = !0, n._transaction = new Bwe(n, t, i), r.push(n._transaction), r.length === 1 && n.emit("beforeAllTransactions", [n]), n.emit("beforeTransaction", [n._transaction, n]));
  try {
    o = e(n._transaction);
  } finally {
    if (s) {
      const l = n._transaction === r[0];
      n._transaction = null, l && vC(r, 0);
    }
  }
  return o;
};
class Fwe {
  constructor(e, t) {
    this.insertions = t, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const Ny = (n, e, t) => {
  qs(n, t.deletions, (i) => {
    i instanceof pe && e.scope.some((r) => ih(r, i)) && dm(i, !1);
  });
}, Py = (n, e, t) => {
  let i = null, r = null;
  const s = n.doc, o = n.scope;
  if (de(s, (l) => {
    for (; e.length > 0 && i === null; ) {
      const a = s.store, c = e.pop(), h = /* @__PURE__ */ new Set(), u = [];
      let f = !1;
      qs(l, c.insertions, (d) => {
        if (d instanceof pe) {
          if (d.redone !== null) {
            let { item: p, diff: g } = mp(a, d.id);
            g > 0 && (p = Et(l, Y(p.id.client, p.id.clock + g))), d = p;
          }
          !d.deleted && o.some((p) => ih(p, d)) && u.push(d);
        }
      }), qs(l, c.deletions, (d) => {
        d instanceof pe && o.some((p) => ih(p, d)) && !Pl(c.insertions, d.id) && h.add(d);
      }), h.forEach((d) => {
        f = FC(l, d, h, c.insertions, n.ignoreRemoteMapChanges, n) !== null || f;
      });
      for (let d = u.length - 1; d >= 0; d--) {
        const p = u[d];
        n.deleteFilter(p) && (p.delete(l), f = !0);
      }
      i = f ? c : null;
    }
    l.changed.forEach((a, c) => {
      a.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), r = l;
  }, n), i != null) {
    const l = r.changedParentTypes;
    n.emit("stack-item-popped", [{ stackItem: i, type: t, changedParentTypes: l }, n]);
  }
  return i;
};
class sm extends Kh {
  constructor(e, {
    captureTimeout: t = 500,
    captureTransaction: i = (a) => !0,
    deleteFilter: r = () => !0,
    trackedOrigins: s = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: l = rp(e) ? e[0].doc : e.doc
  } = {}) {
    super(), this.scope = [], this.addToScope(e), this.deleteFilter = r, s.add(this), this.trackedOrigins = s, this.captureTransaction = i, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.doc = l, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = t, this.afterTransactionHandler = (a) => {
      if (!this.captureTransaction(a) || !this.scope.some((m) => a.changedParentTypes.has(m)) || !this.trackedOrigins.has(a.origin) && (!a.origin || !this.trackedOrigins.has(a.origin.constructor)))
        return;
      const c = this.undoing, h = this.redoing, u = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : h || this.clear(!1, !0);
      const f = new so();
      a.afterState.forEach((m, b) => {
        const y = a.beforeState.get(b) || 0, k = m - y;
        k > 0 && yl(f, b, y, k);
      });
      const d = Yi();
      let p = !1;
      if (this.lastChange > 0 && d - this.lastChange < this.captureTimeout && u.length > 0 && !c && !h) {
        const m = u[u.length - 1];
        m.deletions = hp([m.deletions, a.deleteSet]), m.insertions = hp([m.insertions, f]);
      } else
        u.push(new Fwe(a.deleteSet, f)), p = !0;
      !c && !h && (this.lastChange = d), qs(a, a.deleteSet, (m) => {
        m instanceof pe && this.scope.some((b) => ih(b, m)) && dm(m, !0);
      });
      const g = [{ stackItem: u[u.length - 1], origin: a.origin, type: c ? "redo" : "undo", changedParentTypes: a.changedParentTypes }, this];
      p ? this.emit("stack-item-added", g) : this.emit("stack-item-updated", g);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  addToScope(e) {
    e = rp(e) ? e : [e], e.forEach((t) => {
      this.scope.every((i) => i !== t) && this.scope.push(t);
    });
  }
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, t = !0) {
    (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((i) => {
      e && (this.undoStack.forEach((r) => Ny(i, this, r)), this.undoStack = []), t && (this.redoStack.forEach((r) => Ny(i, this, r)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: t }]);
    });
  }
  stopCapturing() {
    this.lastChange = 0;
  }
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = Py(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = Py(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  canUndo() {
    return this.undoStack.length > 0;
  }
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* $we(n) {
  const e = K(n.restDecoder);
  for (let t = 0; t < e; t++) {
    const i = K(n.restDecoder), r = n.readClient();
    let s = K(n.restDecoder);
    for (let o = 0; o < i; o++) {
      const l = n.readInfo();
      if (l === 10) {
        const a = K(n.restDecoder);
        yield new jt(Y(r, s), a), s += a;
      } else if ((Jh & l) !== 0) {
        const a = (l & (si | qt)) === 0, c = new pe(
          Y(r, s),
          null,
          (l & qt) === qt ? n.readLeftID() : null,
          null,
          (l & si) === si ? n.readRightID() : null,
          a ? n.readParentInfo() ? n.readString() : n.readLeftID() : null,
          a && (l & gl) === gl ? n.readString() : null,
          $C(n, l)
        );
        yield c, s += c.length;
      } else {
        const a = n.readLen();
        yield new Wt(Y(r, s), a), s += a;
      }
    }
  }
}
class om {
  constructor(e, t) {
    this.gen = $we(e), this.curr = null, this.done = !1, this.filterSkips = t, this.next();
  }
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === jt);
    return this.curr;
  }
}
class lm {
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const Hwe = (n) => rh(n, aC, Fl), qwe = (n, e) => {
  if (n.constructor === Wt) {
    const { client: t, clock: i } = n.id;
    return new Wt(Y(t, i + e), n.length - e);
  } else if (n.constructor === jt) {
    const { client: t, clock: i } = n.id;
    return new jt(Y(t, i + e), n.length - e);
  } else {
    const t = n, { client: i, clock: r } = t.id;
    return new pe(
      Y(i, r + e),
      null,
      Y(i, r + e - 1),
      null,
      t.rightOrigin,
      t.parent,
      t.parentSub,
      t.content.splice(e)
    );
  }
}, rh = (n, e = Vs, t = Rr) => {
  if (n.length === 1)
    return n[0];
  const i = n.map((h) => new e(er(h)));
  let r = i.map((h) => new om(h, !0)), s = null;
  const o = new t(), l = new lm(o);
  for (; r = r.filter((f) => f.curr !== null), r.sort(
    (f, d) => {
      if (f.curr.id.client === d.curr.id.client) {
        const p = f.curr.id.clock - d.curr.id.clock;
        return p === 0 ? f.curr.constructor === d.curr.constructor ? 0 : f.curr.constructor === jt ? 1 : -1 : p;
      } else
        return d.curr.id.client - f.curr.id.client;
    }
  ), r.length !== 0; ) {
    const h = r[0], u = h.curr.id.client;
    if (s !== null) {
      let f = h.curr, d = !1;
      for (; f !== null && f.id.clock + f.length <= s.struct.id.clock + s.struct.length && f.id.client >= s.struct.id.client; )
        f = h.next(), d = !0;
      if (f === null || f.id.client !== u || d && f.id.clock > s.struct.id.clock + s.struct.length)
        continue;
      if (u !== s.struct.id.client)
        Di(l, s.struct, s.offset), s = { struct: f, offset: 0 }, h.next();
      else if (s.struct.id.clock + s.struct.length < f.id.clock)
        if (s.struct.constructor === jt)
          s.struct.length = f.id.clock + f.length - s.struct.id.clock;
        else {
          Di(l, s.struct, s.offset);
          const p = f.id.clock - s.struct.id.clock - s.struct.length;
          s = { struct: new jt(Y(u, s.struct.id.clock + s.struct.length), p), offset: 0 };
        }
      else {
        const p = s.struct.id.clock + s.struct.length - f.id.clock;
        p > 0 && (s.struct.constructor === jt ? s.struct.length -= p : f = qwe(f, p)), s.struct.mergeWith(f) || (Di(l, s.struct, s.offset), s = { struct: f, offset: 0 }, h.next());
      }
    } else
      s = { struct: h.curr, offset: 0 }, h.next();
    for (let f = h.curr; f !== null && f.id.client === u && f.id.clock === s.struct.id.clock + s.struct.length && f.constructor !== jt; f = h.next())
      Di(l, s.struct, s.offset), s = { struct: f, offset: 0 };
  }
  s !== null && (Di(l, s.struct, s.offset), s = null), am(l);
  const a = i.map((h) => im(h)), c = hp(a);
  return oo(o, c), o.toUint8Array();
}, Vwe = (n, e, t = Vs, i = Rr) => {
  const r = fC(e), s = new i(), o = new lm(s), l = new t(er(n)), a = new om(l, !1);
  for (; a.curr; ) {
    const h = a.curr, u = h.id.client, f = r.get(u) || 0;
    if (a.curr.constructor === jt) {
      a.next();
      continue;
    }
    if (h.id.clock + h.length > f)
      for (Di(o, h, Qi(f - h.id.clock, 0)), a.next(); a.curr && a.curr.id.client === u; )
        Di(o, a.curr, 0), a.next();
    else
      for (; a.curr && a.curr.id.client === u && a.curr.id.clock + a.curr.length <= f; )
        a.next();
  }
  am(o);
  const c = im(l);
  return oo(s, c), s.toUint8Array();
}, xC = (n) => {
  n.written > 0 && (n.clientStructs.push({ written: n.written, restEncoder: Ee(n.encoder.restEncoder) }), n.encoder.restEncoder = at(), n.written = 0);
}, Di = (n, e, t) => {
  n.written > 0 && n.currClient !== e.id.client && xC(n), n.written === 0 && (n.currClient = e.id.client, n.encoder.writeClient(e.id.client), V(n.encoder.restEncoder, e.id.clock + t)), e.write(n.encoder, t), n.written++;
}, am = (n) => {
  xC(n);
  const e = n.encoder.restEncoder;
  V(e, n.clientStructs.length);
  for (let t = 0; t < n.clientStructs.length; t++) {
    const i = n.clientStructs[t];
    V(e, i.written), Xh(e, i.restEncoder);
  }
}, zwe = (n, e, t, i) => {
  const r = new t(er(n)), s = new om(r, !1), o = new i(), l = new lm(o);
  for (let c = s.curr; c !== null; c = s.next())
    Di(l, e(c), 0);
  am(l);
  const a = im(r);
  return oo(o, a), o.toUint8Array();
}, Uwe = (n) => zwe(n, aye, Vs, Fl), Fy = "You must not compute changes after the event-handler fired.";
class eu {
  constructor(e, t) {
    this.target = e, this.currentTarget = e, this.transaction = t, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  get path() {
    return this._path || (this._path = Wwe(this.currentTarget, this.target));
  }
  deletes(e) {
    return Pl(this.transaction.deleteSet, e.id);
  }
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Ki(Fy);
      const e = /* @__PURE__ */ new Map(), t = this.target;
      this.transaction.changed.get(t).forEach((r) => {
        if (r !== null) {
          const s = t._map.get(r);
          let o, l;
          if (this.adds(s)) {
            let a = s.left;
            for (; a !== null && this.adds(a); )
              a = a.left;
            if (this.deletes(s))
              if (a !== null && this.deletes(a))
                o = "delete", l = bf(a.content.getContent());
              else
                return;
            else
              a !== null && this.deletes(a) ? (o = "update", l = bf(a.content.getContent())) : (o = "add", l = void 0);
          } else if (this.deletes(s))
            o = "delete", l = bf(s.content.getContent());
          else
            return;
          e.set(r, { action: o, oldValue: l });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  get delta() {
    return this.changes.delta;
  }
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw Ki(Fy);
      const t = this.target, i = Lr(), r = Lr(), s = [];
      if (e = {
        added: i,
        deleted: r,
        delta: s,
        keys: this.keys
      }, this.transaction.changed.get(t).has(null)) {
        let l = null;
        const a = () => {
          l && s.push(l);
        };
        for (let c = t._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((l === null || l.delete === void 0) && (a(), l = { delete: 0 }), l.delete += c.length, r.add(c)) : this.adds(c) ? ((l === null || l.insert === void 0) && (a(), l = { insert: [] }), l.insert = l.insert.concat(c.content.getContent()), i.add(c)) : ((l === null || l.retain === void 0) && (a(), l = { retain: 0 }), l.retain += c.length);
        l !== null && l.retain === void 0 && a();
      }
      this._changes = e;
    }
    return e;
  }
}
const Wwe = (n, e) => {
  const t = [];
  for (; e._item !== null && e !== n; ) {
    if (e._item.parentSub !== null)
      t.unshift(e._item.parentSub);
    else {
      let i = 0, r = e._item.parent._start;
      for (; r !== e._item && r !== null; )
        r.deleted || i++, r = r.right;
      t.unshift(i);
    }
    e = e._item.parent;
  }
  return t;
}, kC = 80;
let cm = 0;
class jwe {
  constructor(e, t) {
    e.marker = !0, this.p = e, this.index = t, this.timestamp = cm++;
  }
}
const Gwe = (n) => {
  n.timestamp = cm++;
}, _C = (n, e, t) => {
  n.p.marker = !1, n.p = e, e.marker = !0, n.index = t, n.timestamp = cm++;
}, Kwe = (n, e, t) => {
  if (n.length >= kC) {
    const i = n.reduce((r, s) => r.timestamp < s.timestamp ? r : s);
    return _C(i, e, t), i;
  } else {
    const i = new jwe(e, t);
    return n.push(i), i;
  }
}, tu = (n, e) => {
  if (n._start === null || e === 0 || n._searchMarker === null)
    return null;
  const t = n._searchMarker.length === 0 ? null : n._searchMarker.reduce((s, o) => lc(e - s.index) < lc(e - o.index) ? s : o);
  let i = n._start, r = 0;
  for (t !== null && (i = t.p, r = t.index, Gwe(t)); i.right !== null && r < e; ) {
    if (!i.deleted && i.countable) {
      if (e < r + i.length)
        break;
      r += i.length;
    }
    i = i.right;
  }
  for (; i.left !== null && r > e; )
    i = i.left, !i.deleted && i.countable && (r -= i.length);
  for (; i.left !== null && i.left.id.client === i.id.client && i.left.id.clock + i.left.length === i.id.clock; )
    i = i.left, !i.deleted && i.countable && (r -= i.length);
  return t !== null && lc(t.index - r) < i.parent.length / kC ? (_C(t, i, r), t) : Kwe(n._searchMarker, i, r);
}, vl = (n, e, t) => {
  for (let i = n.length - 1; i >= 0; i--) {
    const r = n[i];
    if (t > 0) {
      let s = r.p;
      for (s.marker = !1; s && (s.deleted || !s.countable); )
        s = s.left, s && !s.deleted && s.countable && (r.index -= s.length);
      if (s === null || s.marker === !0) {
        n.splice(i, 1);
        continue;
      }
      r.p = s, s.marker = !0;
    }
    (e < r.index || t > 0 && e === r.index) && (r.index = Qi(e, r.index + t));
  }
}, nu = (n, e, t) => {
  const i = n, r = e.changedParentTypes;
  for (; bi(r, n, () => []).push(t), n._item !== null; )
    n = n._item.parent;
  pC(i._eH, t, e);
};
class st {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = Ey(), this._dEH = Ey(), this._searchMarker = null;
  }
  get parent() {
    return this._item ? this._item.parent : null;
  }
  _integrate(e, t) {
    this.doc = e, this._item = t;
  }
  _copy() {
    throw qn();
  }
  clone() {
    throw qn();
  }
  _write(e) {
  }
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  _callObserver(e, t) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  observe(e) {
    Ty(this._eH, e);
  }
  observeDeep(e) {
    Ty(this._dEH, e);
  }
  unobserve(e) {
    My(this._eH, e);
  }
  unobserveDeep(e) {
    My(this._dEH, e);
  }
  toJSON() {
  }
}
const SC = (n, e, t) => {
  e < 0 && (e = n._length + e), t < 0 && (t = n._length + t);
  let i = t - e;
  const r = [];
  let s = n._start;
  for (; s !== null && i > 0; ) {
    if (s.countable && !s.deleted) {
      const o = s.content.getContent();
      if (o.length <= e)
        e -= o.length;
      else {
        for (let l = e; l < o.length && i > 0; l++)
          r.push(o[l]), i--;
        e = 0;
      }
    }
    s = s.right;
  }
  return r;
}, CC = (n) => {
  const e = [];
  let t = n._start;
  for (; t !== null; ) {
    if (t.countable && !t.deleted) {
      const i = t.content.getContent();
      for (let r = 0; r < i.length; r++)
        e.push(i[r]);
    }
    t = t.right;
  }
  return e;
}, xl = (n, e) => {
  let t = 0, i = n._start;
  for (; i !== null; ) {
    if (i.countable && !i.deleted) {
      const r = i.content.getContent();
      for (let s = 0; s < r.length; s++)
        e(r[s], t++, n);
    }
    i = i.right;
  }
}, AC = (n, e) => {
  const t = [];
  return xl(n, (i, r) => {
    t.push(e(i, r, n));
  }), t;
}, Ywe = (n) => {
  let e = n._start, t = null, i = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (t === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        t = e.content.getContent(), i = 0, e = e.right;
      }
      const r = t[i++];
      return t.length <= i && (t = null), {
        done: !1,
        value: r
      };
    }
  };
}, DC = (n, e) => {
  const t = tu(n, e);
  let i = n._start;
  for (t !== null && (i = t.p, e -= t.index); i !== null; i = i.right)
    if (!i.deleted && i.countable) {
      if (e < i.length)
        return i.content.getContent()[e];
      e -= i.length;
    }
}, sh = (n, e, t, i) => {
  let r = t;
  const s = n.doc, o = s.clientID, l = s.store, a = t === null ? e._start : t.right;
  let c = [];
  const h = () => {
    c.length > 0 && (r = new pe(Y(o, Pe(l, o)), r, r && r.lastId, a, a && a.id, e, null, new Br(c)), r.integrate(n, 0), c = []);
  };
  i.forEach((u) => {
    if (u === null)
      c.push(u);
    else
      switch (u.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(u);
          break;
        default:
          switch (h(), u.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              r = new pe(Y(o, Pe(l, o)), r, r && r.lastId, a, a && a.id, e, null, new $l(new Uint8Array(u))), r.integrate(n, 0);
              break;
            case lo:
              r = new pe(Y(o, Pe(l, o)), r, r && r.lastId, a, a && a.id, e, null, new Hl(u)), r.integrate(n, 0);
              break;
            default:
              if (u instanceof st)
                r = new pe(Y(o, Pe(l, o)), r, r && r.lastId, a, a && a.id, e, null, new Jn(u)), r.integrate(n, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), h();
}, EC = Ki("Length exceeded!"), TC = (n, e, t, i) => {
  if (t > e._length)
    throw EC;
  if (t === 0)
    return e._searchMarker && vl(e._searchMarker, t, i.length), sh(n, e, null, i);
  const r = t, s = tu(e, t);
  let o = e._start;
  for (s !== null && (o = s.p, t -= s.index, t === 0 && (o = o.prev, t += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (t <= o.length) {
        t < o.length && Et(n, Y(o.id.client, o.id.clock + t));
        break;
      }
      t -= o.length;
    }
  return e._searchMarker && vl(e._searchMarker, r, i.length), sh(n, e, o, i);
}, Jwe = (n, e, t) => {
  let r = (e._searchMarker || []).reduce((s, o) => o.index > s.index ? o : s, { index: 0, p: e._start }).p;
  if (r)
    for (; r.right; )
      r = r.right;
  return sh(n, e, r, t);
}, MC = (n, e, t, i) => {
  if (i === 0)
    return;
  const r = t, s = i, o = tu(e, t);
  let l = e._start;
  for (o !== null && (l = o.p, t -= o.index); l !== null && t > 0; l = l.right)
    !l.deleted && l.countable && (t < l.length && Et(n, Y(l.id.client, l.id.clock + t)), t -= l.length);
  for (; i > 0 && l !== null; )
    l.deleted || (i < l.length && Et(n, Y(l.id.client, l.id.clock + i)), l.delete(n), i -= l.length), l = l.right;
  if (i > 0)
    throw EC;
  e._searchMarker && vl(e._searchMarker, r, -s + i);
}, oh = (n, e, t) => {
  const i = e._map.get(t);
  i !== void 0 && i.delete(n);
}, hm = (n, e, t, i) => {
  const r = e._map.get(t) || null, s = n.doc, o = s.clientID;
  let l;
  if (i == null)
    l = new Br([i]);
  else
    switch (i.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        l = new Br([i]);
        break;
      case Uint8Array:
        l = new $l(i);
        break;
      case lo:
        l = new Hl(i);
        break;
      default:
        if (i instanceof st)
          l = new Jn(i);
        else
          throw new Error("Unexpected content type");
    }
  new pe(Y(o, Pe(s.store, o)), r, r && r.lastId, null, null, e, t, l).integrate(n, 0);
}, um = (n, e) => {
  const t = n._map.get(e);
  return t !== void 0 && !t.deleted ? t.content.getContent()[t.length - 1] : void 0;
}, OC = (n) => {
  const e = {};
  return n._map.forEach((t, i) => {
    t.deleted || (e[i] = t.content.getContent()[t.length - 1]);
  }), e;
}, LC = (n, e) => {
  const t = n._map.get(e);
  return t !== void 0 && !t.deleted;
}, Ea = (n) => uwe(n.entries(), (e) => !e[1].deleted);
class Zwe extends eu {
  constructor(e, t) {
    super(e, t), this._transaction = t;
  }
}
class xs extends st {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  static from(e) {
    const t = new xs();
    return t.push(e), t;
  }
  _integrate(e, t) {
    super._integrate(e, t), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new xs();
  }
  clone() {
    const e = new xs();
    return e.insert(0, this.toArray().map(
      (t) => t instanceof st ? t.clone() : t
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  _callObserver(e, t) {
    super._callObserver(e, t), nu(this, e, new Zwe(this, e));
  }
  insert(e, t) {
    this.doc !== null ? de(this.doc, (i) => {
      TC(i, this, e, t);
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  push(e) {
    this.doc !== null ? de(this.doc, (t) => {
      Jwe(t, this, e);
    }) : this._prelimContent.push(...e);
  }
  unshift(e) {
    this.insert(0, e);
  }
  delete(e, t = 1) {
    this.doc !== null ? de(this.doc, (i) => {
      MC(i, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  get(e) {
    return DC(this, e);
  }
  toArray() {
    return CC(this);
  }
  slice(e = 0, t = this.length) {
    return SC(this, e, t);
  }
  toJSON() {
    return this.map((e) => e instanceof st ? e.toJSON() : e);
  }
  map(e) {
    return AC(this, e);
  }
  forEach(e) {
    xl(this, e);
  }
  [Symbol.iterator]() {
    return Ywe(this);
  }
  _write(e) {
    e.writeTypeRef(xve);
  }
}
const Xwe = (n) => new xs();
class Qwe extends eu {
  constructor(e, t, i) {
    super(e, t), this.keysChanged = i;
  }
}
class zs extends st {
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  _integrate(e, t) {
    super._integrate(e, t), this._prelimContent.forEach((i, r) => {
      this.set(r, i);
    }), this._prelimContent = null;
  }
  _copy() {
    return new zs();
  }
  clone() {
    const e = new zs();
    return this.forEach((t, i) => {
      e.set(i, t instanceof st ? t.clone() : t);
    }), e;
  }
  _callObserver(e, t) {
    nu(this, e, new Qwe(this, e, t));
  }
  toJSON() {
    const e = {};
    return this._map.forEach((t, i) => {
      if (!t.deleted) {
        const r = t.content.getContent()[t.length - 1];
        e[i] = r instanceof st ? r.toJSON() : r;
      }
    }), e;
  }
  get size() {
    return [...Ea(this._map)].length;
  }
  keys() {
    return _f(Ea(this._map), (e) => e[0]);
  }
  values() {
    return _f(Ea(this._map), (e) => e[1].content.getContent()[e[1].length - 1]);
  }
  entries() {
    return _f(Ea(this._map), (e) => [e[0], e[1].content.getContent()[e[1].length - 1]]);
  }
  forEach(e) {
    this._map.forEach((t, i) => {
      t.deleted || e(t.content.getContent()[t.length - 1], i, this);
    });
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  delete(e) {
    this.doc !== null ? de(this.doc, (t) => {
      oh(t, this, e);
    }) : this._prelimContent.delete(e);
  }
  set(e, t) {
    return this.doc !== null ? de(this.doc, (i) => {
      hm(i, this, e, t);
    }) : this._prelimContent.set(e, t), t;
  }
  get(e) {
    return um(this, e);
  }
  has(e) {
    return LC(this, e);
  }
  clear() {
    this.doc !== null ? de(this.doc, (e) => {
      this.forEach(function(t, i, r) {
        oh(e, r, i);
      });
    }) : this._prelimContent.clear();
  }
  _write(e) {
    e.writeTypeRef(kve);
  }
}
const eve = (n) => new zs(), Ri = (n, e) => n === e || typeof n == "object" && typeof e == "object" && n && e && lye(n, e);
class gp {
  constructor(e, t, i, r) {
    this.left = e, this.right = t, this.index = i, this.currentAttributes = r;
  }
  forward() {
    switch (this.right === null && gn(), this.right.content.constructor) {
      case Ge:
        this.right.deleted || ao(this.currentAttributes, this.right.content);
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const $y = (n, e, t) => {
  for (; e.right !== null && t > 0; ) {
    switch (e.right.content.constructor) {
      case Ge:
        e.right.deleted || ao(e.currentAttributes, e.right.content);
        break;
      default:
        e.right.deleted || (t < e.right.length && Et(n, Y(e.right.id.client, e.right.id.clock + t)), e.index += e.right.length, t -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Ta = (n, e, t) => {
  const i = /* @__PURE__ */ new Map(), r = tu(e, t);
  if (r) {
    const s = new gp(r.p.left, r.p, r.index, i);
    return $y(n, s, t - r.index);
  } else {
    const s = new gp(null, e._start, 0, i);
    return $y(n, s, t);
  }
}, RC = (n, e, t, i) => {
  for (; t.right !== null && (t.right.deleted === !0 || t.right.content.constructor === Ge && Ri(i.get(t.right.content.key), t.right.content.value)); )
    t.right.deleted || i.delete(t.right.content.key), t.forward();
  const r = n.doc, s = r.clientID;
  i.forEach((o, l) => {
    const a = t.left, c = t.right, h = new pe(Y(s, Pe(r.store, s)), a, a && a.lastId, c, c && c.id, e, null, new Ge(l, o));
    h.integrate(n, 0), t.right = h, t.forward();
  });
}, ao = (n, e) => {
  const { key: t, value: i } = e;
  i === null ? n.delete(t) : n.set(t, i);
}, IC = (n, e) => {
  for (; n.right !== null; ) {
    if (!(n.right.deleted || n.right.content.constructor === Ge && Ri(e[n.right.content.key] || null, n.right.content.value)))
      break;
    n.forward();
  }
}, BC = (n, e, t, i) => {
  const r = n.doc, s = r.clientID, o = /* @__PURE__ */ new Map();
  for (const l in i) {
    const a = i[l], c = t.currentAttributes.get(l) || null;
    if (!Ri(c, a)) {
      o.set(l, c);
      const { left: h, right: u } = t;
      t.right = new pe(Y(s, Pe(r.store, s)), h, h && h.lastId, u, u && u.id, e, null, new Ge(l, a)), t.right.integrate(n, 0), t.forward();
    }
  }
  return o;
}, Sf = (n, e, t, i, r) => {
  t.currentAttributes.forEach((f, d) => {
    r[d] === void 0 && (r[d] = null);
  });
  const s = n.doc, o = s.clientID;
  IC(t, r);
  const l = BC(n, e, t, r), a = i.constructor === String ? new Un(i) : i instanceof st ? new Jn(i) : new Vr(i);
  let { left: c, right: h, index: u } = t;
  e._searchMarker && vl(e._searchMarker, t.index, a.getLength()), h = new pe(Y(o, Pe(s.store, o)), c, c && c.lastId, h, h && h.id, e, null, a), h.integrate(n, 0), t.right = h, t.index = u, t.forward(), RC(n, e, t, l);
}, Hy = (n, e, t, i, r) => {
  const s = n.doc, o = s.clientID;
  IC(t, r);
  const l = BC(n, e, t, r);
  e:
    for (; t.right !== null && (i > 0 || l.size > 0 && (t.right.deleted || t.right.content.constructor === Ge)); ) {
      if (!t.right.deleted)
        switch (t.right.content.constructor) {
          case Ge: {
            const { key: a, value: c } = t.right.content, h = r[a];
            if (h !== void 0) {
              if (Ri(h, c))
                l.delete(a);
              else {
                if (i === 0)
                  break e;
                l.set(a, c);
              }
              t.right.delete(n);
            } else
              t.currentAttributes.set(a, c);
            break;
          }
          default:
            i < t.right.length && Et(n, Y(t.right.id.client, t.right.id.clock + i)), i -= t.right.length;
            break;
        }
      t.forward();
    }
  if (i > 0) {
    let a = "";
    for (; i > 0; i--)
      a += `
`;
    t.right = new pe(Y(o, Pe(s.store, o)), t.left, t.left && t.left.lastId, t.right, t.right && t.right.id, e, null, new Un(a)), t.right.integrate(n, 0), t.forward();
  }
  RC(n, e, t, l);
}, NC = (n, e, t, i, r) => {
  let s = e;
  const o = un();
  for (; s && (!s.countable || s.deleted); ) {
    if (!s.deleted && s.content.constructor === Ge) {
      const c = s.content;
      o.set(c.key, c);
    }
    s = s.right;
  }
  let l = 0, a = !1;
  for (; e !== s; ) {
    if (t === e && (a = !0), !e.deleted) {
      const c = e.content;
      switch (c.constructor) {
        case Ge: {
          const { key: h, value: u } = c, f = i.get(h) || null;
          (o.get(h) !== c || f === u) && (e.delete(n), l++, !a && (r.get(h) || null) === u && f !== u && (f === null ? r.delete(h) : r.set(h, f))), !a && !e.deleted && ao(r, c);
          break;
        }
      }
    }
    e = e.right;
  }
  return l;
}, tve = (n, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const t = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === Ge) {
      const i = e.content.key;
      t.has(i) ? e.delete(n) : t.add(i);
    }
    e = e.left;
  }
}, nve = (n) => {
  let e = 0;
  return de(n.doc, (t) => {
    let i = n._start, r = n._start, s = un();
    const o = ip(s);
    for (; r; ) {
      if (r.deleted === !1)
        switch (r.content.constructor) {
          case Ge:
            ao(o, r.content);
            break;
          default:
            e += NC(t, i, r, s, o), s = ip(o), i = r;
            break;
        }
      r = r.right;
    }
  }), e;
}, ive = (n) => {
  const e = /* @__PURE__ */ new Set(), t = n.doc;
  for (const [i, r] of n.afterState.entries()) {
    const s = n.beforeState.get(i) || 0;
    r !== s && wC(n, t.store.clients.get(i), s, r, (o) => {
      !o.deleted && o.content.constructor === Ge && o.constructor !== Wt && e.add(o.parent);
    });
  }
  de(t, (i) => {
    qs(n, n.deleteSet, (r) => {
      if (r instanceof Wt || !r.parent._hasFormatting || e.has(r.parent))
        return;
      const s = r.parent;
      r.content.constructor === Ge ? e.add(s) : tve(i, r);
    });
    for (const r of e)
      nve(r);
  });
}, qy = (n, e, t) => {
  const i = t, r = ip(e.currentAttributes), s = e.right;
  for (; t > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Jn:
        case Vr:
        case Un:
          t < e.right.length && Et(n, Y(e.right.id.client, e.right.id.clock + t)), t -= e.right.length, e.right.delete(n);
          break;
      }
    e.forward();
  }
  s && NC(n, s, e.right, r, e.currentAttributes);
  const o = (e.left || e.right).parent;
  return o._searchMarker && vl(o._searchMarker, e.index, -i + t), e;
};
class rve extends eu {
  constructor(e, t, i) {
    super(e, t), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), i.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.keysChanged.add(r);
    });
  }
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return this._changes;
  }
  get delta() {
    if (this._delta === null) {
      const e = this.target.doc, t = [];
      de(e, (i) => {
        const r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
        let o = this.target._start, l = null;
        const a = {};
        let c = "", h = 0, u = 0;
        const f = () => {
          if (l !== null) {
            let d = null;
            switch (l) {
              case "delete":
                u > 0 && (d = { delete: u }), u = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (d = { insert: c }, r.size > 0 && (d.attributes = {}, r.forEach((p, g) => {
                  p !== null && (d.attributes[g] = p);
                }))), c = "";
                break;
              case "retain":
                h > 0 && (d = { retain: h }, sye(a) || (d.attributes = tye({}, a))), h = 0;
                break;
            }
            d && t.push(d), l = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case Jn:
            case Vr:
              this.adds(o) ? this.deletes(o) || (f(), l = "insert", c = o.content.getContent()[0], f()) : this.deletes(o) ? (l !== "delete" && (f(), l = "delete"), u += 1) : o.deleted || (l !== "retain" && (f(), l = "retain"), h += 1);
              break;
            case Un:
              this.adds(o) ? this.deletes(o) || (l !== "insert" && (f(), l = "insert"), c += o.content.str) : this.deletes(o) ? (l !== "delete" && (f(), l = "delete"), u += o.length) : o.deleted || (l !== "retain" && (f(), l = "retain"), h += o.length);
              break;
            case Ge: {
              const { key: d, value: p } = o.content;
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const g = r.get(d) || null;
                  Ri(g, p) ? p !== null && o.delete(i) : (l === "retain" && f(), Ri(p, s.get(d) || null) ? delete a[d] : a[d] = p);
                }
              } else if (this.deletes(o)) {
                s.set(d, p);
                const g = r.get(d) || null;
                Ri(g, p) || (l === "retain" && f(), a[d] = g);
              } else if (!o.deleted) {
                s.set(d, p);
                const g = a[d];
                g !== void 0 && (Ri(g, p) ? g !== null && o.delete(i) : (l === "retain" && f(), p === null ? delete a[d] : a[d] = p));
              }
              o.deleted || (l === "insert" && f(), ao(r, o.content));
              break;
            }
          }
          o = o.right;
        }
        for (f(); t.length > 0; ) {
          const d = t[t.length - 1];
          if (d.retain !== void 0 && d.attributes === void 0)
            t.pop();
          else
            break;
        }
      }), this._delta = t;
    }
    return this._delta;
  }
}
class Us extends st {
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  get length() {
    return this._length;
  }
  _integrate(e, t) {
    super._integrate(e, t);
    try {
      this._pending.forEach((i) => i());
    } catch (i) {
      console.error(i);
    }
    this._pending = null;
  }
  _copy() {
    return new Us();
  }
  clone() {
    const e = new Us();
    return e.applyDelta(this.toDelta()), e;
  }
  _callObserver(e, t) {
    super._callObserver(e, t);
    const i = new rve(this, e, t);
    nu(this, e, i), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  toString() {
    let e = "", t = this._start;
    for (; t !== null; )
      !t.deleted && t.countable && t.content.constructor === Un && (e += t.content.str), t = t.right;
    return e;
  }
  toJSON() {
    return this.toString();
  }
  applyDelta(e, { sanitize: t = !0 } = {}) {
    this.doc !== null ? de(this.doc, (i) => {
      const r = new gp(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (o.insert !== void 0) {
          const l = !t && typeof o.insert == "string" && s === e.length - 1 && r.right === null && o.insert.slice(-1) === `
` ? o.insert.slice(0, -1) : o.insert;
          (typeof l != "string" || l.length > 0) && Sf(i, this, r, l, o.attributes || {});
        } else
          o.retain !== void 0 ? Hy(i, this, r, o.retain, o.attributes || {}) : o.delete !== void 0 && qy(i, r, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  toDelta(e, t, i) {
    const r = [], s = /* @__PURE__ */ new Map(), o = this.doc;
    let l = "", a = this._start;
    function c() {
      if (l.length > 0) {
        const u = {};
        let f = !1;
        s.forEach((p, g) => {
          f = !0, u[g] = p;
        });
        const d = { insert: l };
        f && (d.attributes = u), r.push(d), l = "";
      }
    }
    const h = () => {
      for (; a !== null; ) {
        if (yo(a, e) || t !== void 0 && yo(a, t))
          switch (a.content.constructor) {
            case Un: {
              const u = s.get("ychange");
              e !== void 0 && !yo(a, e) ? (u === void 0 || u.user !== a.id.client || u.type !== "removed") && (c(), s.set("ychange", i ? i("removed", a.id) : { type: "removed" })) : t !== void 0 && !yo(a, t) ? (u === void 0 || u.user !== a.id.client || u.type !== "added") && (c(), s.set("ychange", i ? i("added", a.id) : { type: "added" })) : u !== void 0 && (c(), s.delete("ychange")), l += a.content.str;
              break;
            }
            case Jn:
            case Vr: {
              c();
              const u = {
                insert: a.content.getContent()[0]
              };
              if (s.size > 0) {
                const f = {};
                u.attributes = f, s.forEach((d, p) => {
                  f[p] = d;
                });
              }
              r.push(u);
              break;
            }
            case Ge:
              yo(a, e) && (c(), ao(s, a.content));
              break;
          }
        a = a.right;
      }
      c();
    };
    return e || t ? de(o, (u) => {
      e && dp(u, e), t && dp(u, t), h();
    }, "cleanup") : h(), r;
  }
  insert(e, t, i) {
    if (t.length <= 0)
      return;
    const r = this.doc;
    r !== null ? de(r, (s) => {
      const o = Ta(s, this, e);
      i || (i = {}, o.currentAttributes.forEach((l, a) => {
        i[a] = l;
      })), Sf(s, this, o, t, i);
    }) : this._pending.push(() => this.insert(e, t, i));
  }
  insertEmbed(e, t, i = {}) {
    const r = this.doc;
    r !== null ? de(r, (s) => {
      const o = Ta(s, this, e);
      Sf(s, this, o, t, i);
    }) : this._pending.push(() => this.insertEmbed(e, t, i));
  }
  delete(e, t) {
    if (t === 0)
      return;
    const i = this.doc;
    i !== null ? de(i, (r) => {
      qy(r, Ta(r, this, e), t);
    }) : this._pending.push(() => this.delete(e, t));
  }
  format(e, t, i) {
    if (t === 0)
      return;
    const r = this.doc;
    r !== null ? de(r, (s) => {
      const o = Ta(s, this, e);
      o.right !== null && Hy(s, this, o, t, i);
    }) : this._pending.push(() => this.format(e, t, i));
  }
  removeAttribute(e) {
    this.doc !== null ? de(this.doc, (t) => {
      oh(t, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  setAttribute(e, t) {
    this.doc !== null ? de(this.doc, (i) => {
      hm(i, this, e, t);
    }) : this._pending.push(() => this.setAttribute(e, t));
  }
  getAttribute(e) {
    return um(this, e);
  }
  getAttributes() {
    return OC(this);
  }
  _write(e) {
    e.writeTypeRef(_ve);
  }
}
const sve = (n) => new Us();
class Cf {
  constructor(e, t = () => !0) {
    this._filter = t, this._root = e, this._currentNode = e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let e = this._currentNode, t = e && e.content && e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(t)))
      do
        if (t = e.content.type, !e.deleted && (t.constructor === kl || t.constructor === Ir) && t._start !== null)
          e = t._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = e.parent._item;
      while (e !== null && (e.deleted || !this._filter(e.content.type)));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: e.content.type, done: !1 });
  }
}
class Ir extends st {
  constructor() {
    super(), this._prelimContent = [];
  }
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  _integrate(e, t) {
    super._integrate(e, t), this.insert(0, this._prelimContent), this._prelimContent = null;
  }
  _copy() {
    return new Ir();
  }
  clone() {
    const e = new Ir();
    return e.insert(0, this.toArray().map((t) => t instanceof st ? t.clone() : t)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  createTreeWalker(e) {
    return new Cf(this, e);
  }
  querySelector(e) {
    e = e.toUpperCase();
    const i = new Cf(this, (r) => r.nodeName && r.nodeName.toUpperCase() === e).next();
    return i.done ? null : i.value;
  }
  querySelectorAll(e) {
    return e = e.toUpperCase(), Gi(new Cf(this, (t) => t.nodeName && t.nodeName.toUpperCase() === e));
  }
  _callObserver(e, t) {
    nu(this, e, new ave(this, t, e));
  }
  toString() {
    return AC(this, (e) => e.toString()).join("");
  }
  toJSON() {
    return this.toString();
  }
  toDOM(e = document, t = {}, i) {
    const r = e.createDocumentFragment();
    return i !== void 0 && i._createAssociation(r, this), xl(this, (s) => {
      r.insertBefore(s.toDOM(e, t, i), null);
    }), r;
  }
  insert(e, t) {
    this.doc !== null ? de(this.doc, (i) => {
      TC(i, this, e, t);
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  insertAfter(e, t) {
    if (this.doc !== null)
      de(this.doc, (i) => {
        const r = e && e instanceof st ? e._item : e;
        sh(i, this, r, t);
      });
    else {
      const i = this._prelimContent, r = e === null ? 0 : i.findIndex((s) => s === e) + 1;
      if (r === 0 && e !== null)
        throw Ki("Reference item not found");
      i.splice(r, 0, ...t);
    }
  }
  delete(e, t = 1) {
    this.doc !== null ? de(this.doc, (i) => {
      MC(i, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  toArray() {
    return CC(this);
  }
  push(e) {
    this.insert(this.length, e);
  }
  unshift(e) {
    this.insert(0, e);
  }
  get(e) {
    return DC(this, e);
  }
  slice(e = 0, t = this.length) {
    return SC(this, e, t);
  }
  forEach(e) {
    xl(this, e);
  }
  _write(e) {
    e.writeTypeRef(Cve);
  }
}
const ove = (n) => new Ir();
class kl extends Ir {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? e.content.type : null;
  }
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? e.content.type : null;
  }
  _integrate(e, t) {
    super._integrate(e, t), this._prelimAttrs.forEach((i, r) => {
      this.setAttribute(r, i);
    }), this._prelimAttrs = null;
  }
  _copy() {
    return new kl(this.nodeName);
  }
  clone() {
    const e = new kl(this.nodeName), t = this.getAttributes();
    return iye(t, (i, r) => {
      typeof i == "string" && e.setAttribute(r, i);
    }), e.insert(0, this.toArray().map((i) => i instanceof st ? i.clone() : i)), e;
  }
  toString() {
    const e = this.getAttributes(), t = [], i = [];
    for (const l in e)
      i.push(l);
    i.sort();
    const r = i.length;
    for (let l = 0; l < r; l++) {
      const a = i[l];
      t.push(a + '="' + e[a] + '"');
    }
    const s = this.nodeName.toLocaleLowerCase(), o = t.length > 0 ? " " + t.join(" ") : "";
    return `<${s}${o}>${super.toString()}</${s}>`;
  }
  removeAttribute(e) {
    this.doc !== null ? de(this.doc, (t) => {
      oh(t, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  setAttribute(e, t) {
    this.doc !== null ? de(this.doc, (i) => {
      hm(i, this, e, t);
    }) : this._prelimAttrs.set(e, t);
  }
  getAttribute(e) {
    return um(this, e);
  }
  hasAttribute(e) {
    return LC(this, e);
  }
  getAttributes() {
    return OC(this);
  }
  toDOM(e = document, t = {}, i) {
    const r = e.createElement(this.nodeName), s = this.getAttributes();
    for (const o in s) {
      const l = s[o];
      typeof l == "string" && r.setAttribute(o, l);
    }
    return xl(this, (o) => {
      r.appendChild(o.toDOM(e, t, i));
    }), i !== void 0 && i._createAssociation(r, this), r;
  }
  _write(e) {
    e.writeTypeRef(Sve), e.writeKey(this.nodeName);
  }
}
const lve = (n) => new kl(n.readKey());
class ave extends eu {
  constructor(e, t, i) {
    super(e, i), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), t.forEach((r) => {
      r === null ? this.childListChanged = !0 : this.attributesChanged.add(r);
    });
  }
}
class lh extends zs {
  constructor(e) {
    super(), this.hookName = e;
  }
  _copy() {
    return new lh(this.hookName);
  }
  clone() {
    const e = new lh(this.hookName);
    return this.forEach((t, i) => {
      e.set(i, t);
    }), e;
  }
  toDOM(e = document, t = {}, i) {
    const r = t[this.hookName];
    let s;
    return r !== void 0 ? s = r.createDom(this) : s = document.createElement(this.hookName), s.setAttribute("data-yjs-hook", this.hookName), i !== void 0 && i._createAssociation(s, this), s;
  }
  _write(e) {
    e.writeTypeRef(Ave), e.writeKey(this.hookName);
  }
}
const cve = (n) => new lh(n.readKey());
class ah extends Us {
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? e.content.type : null;
  }
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? e.content.type : null;
  }
  _copy() {
    return new ah();
  }
  clone() {
    const e = new ah();
    return e.applyDelta(this.toDelta()), e;
  }
  toDOM(e = document, t, i) {
    const r = e.createTextNode(this.toString());
    return i !== void 0 && i._createAssociation(r, this), r;
  }
  toString() {
    return this.toDelta().map((e) => {
      const t = [];
      for (const r in e.attributes) {
        const s = [];
        for (const o in e.attributes[r])
          s.push({ key: o, value: e.attributes[r][o] });
        s.sort((o, l) => o.key < l.key ? -1 : 1), t.push({ nodeName: r, attrs: s });
      }
      t.sort((r, s) => r.nodeName < s.nodeName ? -1 : 1);
      let i = "";
      for (let r = 0; r < t.length; r++) {
        const s = t[r];
        i += `<${s.nodeName}`;
        for (let o = 0; o < s.attrs.length; o++) {
          const l = s.attrs[o];
          i += ` ${l.key}="${l.value}"`;
        }
        i += ">";
      }
      i += e.insert;
      for (let r = t.length - 1; r >= 0; r--)
        i += `</${t[r].nodeName}>`;
      return i;
    }).join("");
  }
  toJSON() {
    return this.toString();
  }
  _write(e) {
    e.writeTypeRef(Dve);
  }
}
const hve = (n) => new ah();
class fm {
  constructor(e, t) {
    this.id = e, this.length = t;
  }
  get deleted() {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  write(e, t, i) {
    throw qn();
  }
  integrate(e, t) {
    throw qn();
  }
}
const uve = 0;
class Wt extends fm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  integrate(e, t) {
    t > 0 && (this.id.clock += t, this.length -= t), yC(e.doc.store, this);
  }
  write(e, t) {
    e.writeInfo(uve), e.writeLen(this.length - t);
  }
  getMissing(e, t) {
    return null;
  }
}
class $l {
  constructor(e) {
    this.content = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.content];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new $l(this.content);
  }
  splice(e) {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, t) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    e.writeBuf(this.content);
  }
  getRef() {
    return 3;
  }
}
const fve = (n) => new $l(n.readBuf());
class _l {
  constructor(e) {
    this.len = e;
  }
  getLength() {
    return this.len;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new _l(this.len);
  }
  splice(e) {
    const t = new _l(this.len - e);
    return this.len = e, t;
  }
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  integrate(e, t) {
    yl(e.deleteSet, t.id.client, t.id.clock, this.len), t.markDeleted();
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    e.writeLen(this.len - t);
  }
  getRef() {
    return 1;
  }
}
const dve = (n) => new _l(n.readLen()), PC = (n, e) => new lo({ guid: n, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class Hl {
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const t = {};
    this.opts = t, e.gc || (t.gc = !1), e.autoLoad && (t.autoLoad = !0), e.meta !== null && (t.meta = e.meta);
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.doc];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Hl(PC(this.doc.guid, this.opts));
  }
  splice(e) {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, t) {
    this.doc._item = t, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  gc(e) {
  }
  write(e, t) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  getRef() {
    return 9;
  }
}
const pve = (n) => new Hl(PC(n.readString(), n.readAny()));
class Vr {
  constructor(e) {
    this.embed = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.embed];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Vr(this.embed);
  }
  splice(e) {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, t) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    e.writeJSON(this.embed);
  }
  getRef() {
    return 5;
  }
}
const gve = (n) => new Vr(n.readJSON());
class Ge {
  constructor(e, t) {
    this.key = e, this.value = t;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [];
  }
  isCountable() {
    return !1;
  }
  copy() {
    return new Ge(this.key, this.value);
  }
  splice(e) {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, t) {
    const i = t.parent;
    i._searchMarker = null, i._hasFormatting = !0;
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  getRef() {
    return 6;
  }
}
const mve = (n) => new Ge(n.readKey(), n.readJSON());
class ch {
  constructor(e) {
    this.arr = e;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new ch(this.arr);
  }
  splice(e) {
    const t = new ch(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  integrate(e, t) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    const i = this.arr.length;
    e.writeLen(i - t);
    for (let r = t; r < i; r++) {
      const s = this.arr[r];
      e.writeString(s === void 0 ? "undefined" : JSON.stringify(s));
    }
  }
  getRef() {
    return 2;
  }
}
const bve = (n) => {
  const e = n.readLen(), t = [];
  for (let i = 0; i < e; i++) {
    const r = n.readString();
    r === "undefined" ? t.push(void 0) : t.push(JSON.parse(r));
  }
  return new ch(t);
};
class Br {
  constructor(e) {
    this.arr = e;
  }
  getLength() {
    return this.arr.length;
  }
  getContent() {
    return this.arr;
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Br(this.arr);
  }
  splice(e) {
    const t = new Br(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  integrate(e, t) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    const i = this.arr.length;
    e.writeLen(i - t);
    for (let r = t; r < i; r++) {
      const s = this.arr[r];
      e.writeAny(s);
    }
  }
  getRef() {
    return 8;
  }
}
const yve = (n) => {
  const e = n.readLen(), t = [];
  for (let i = 0; i < e; i++)
    t.push(n.readAny());
  return new Br(t);
};
class Un {
  constructor(e) {
    this.str = e;
  }
  getLength() {
    return this.str.length;
  }
  getContent() {
    return this.str.split("");
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Un(this.str);
  }
  splice(e) {
    const t = new Un(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const i = this.str.charCodeAt(e - 1);
    return i >= 55296 && i <= 56319 && (this.str = this.str.slice(0, e - 1) + "\uFFFD", t.str = "\uFFFD" + t.str.slice(1)), t;
  }
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  integrate(e, t) {
  }
  delete(e) {
  }
  gc(e) {
  }
  write(e, t) {
    e.writeString(t === 0 ? this.str : this.str.slice(t));
  }
  getRef() {
    return 4;
  }
}
const wve = (n) => new Un(n.readString()), vve = [
  Xwe,
  eve,
  sve,
  lve,
  ove,
  cve,
  hve
], xve = 0, kve = 1, _ve = 2, Sve = 3, Cve = 4, Ave = 5, Dve = 6;
class Jn {
  constructor(e) {
    this.type = e;
  }
  getLength() {
    return 1;
  }
  getContent() {
    return [this.type];
  }
  isCountable() {
    return !0;
  }
  copy() {
    return new Jn(this.type._copy());
  }
  splice(e) {
    throw qn();
  }
  mergeWith(e) {
    return !1;
  }
  integrate(e, t) {
    this.type._integrate(e.doc, t);
  }
  delete(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e), t = t.right;
    this.type._map.forEach((i) => {
      i.deleted ? i.id.clock < (e.beforeState.get(i.id.client) || 0) && e._mergeStructs.push(i) : i.delete(e);
    }), e.changed.delete(this.type);
  }
  gc(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.gc(e, !0), t = t.right;
    this.type._start = null, this.type._map.forEach((i) => {
      for (; i !== null; )
        i.gc(e, !0), i = i.left;
    }), this.type._map = /* @__PURE__ */ new Map();
  }
  write(e, t) {
    this.type._write(e);
  }
  getRef() {
    return 7;
  }
}
const Eve = (n) => new Jn(vve[n.readTypeRef()](n)), mp = (n, e) => {
  let t = e, i = 0, r;
  do
    i > 0 && (t = Y(t.client, t.clock + i)), r = hc(n, t), i = t.clock - r.id.clock, t = r.redone;
  while (t !== null && r instanceof pe);
  return {
    item: r,
    diff: i
  };
}, dm = (n, e) => {
  for (; n !== null && n.keep !== e; )
    n.keep = e, n = n.parent._item;
}, hh = (n, e, t) => {
  const { client: i, clock: r } = e.id, s = new pe(
    Y(i, r + t),
    e,
    Y(i, r + t - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(t)
  );
  return e.deleted && s.markDeleted(), e.keep && (s.keep = !0), e.redone !== null && (s.redone = Y(e.redone.client, e.redone.clock + t)), e.right = s, s.right !== null && (s.right.left = s), n._mergeStructs.push(s), s.parentSub !== null && s.right === null && s.parent._map.set(s.parentSub, s), e.length = t, s;
}, Vy = (n, e) => Vbe(n, (t) => Pl(t.deletions, e)), FC = (n, e, t, i, r, s) => {
  const o = n.doc, l = o.store, a = o.clientID, c = e.redone;
  if (c !== null)
    return Et(n, c);
  let h = e.parent._item, u = null, f;
  if (h !== null && h.deleted === !0) {
    if (h.redone === null && (!t.has(h) || FC(n, h, t, i, r, s) === null))
      return null;
    for (; h.redone !== null; )
      h = Et(n, h.redone);
  }
  const d = h === null ? e.parent : h.content.type;
  if (e.parentSub === null) {
    for (u = e.left, f = e; u !== null; ) {
      let b = u;
      for (; b !== null && b.parent._item !== h; )
        b = b.redone === null ? null : Et(n, b.redone);
      if (b !== null && b.parent._item === h) {
        u = b;
        break;
      }
      u = u.left;
    }
    for (; f !== null; ) {
      let b = f;
      for (; b !== null && b.parent._item !== h; )
        b = b.redone === null ? null : Et(n, b.redone);
      if (b !== null && b.parent._item === h) {
        f = b;
        break;
      }
      f = f.right;
    }
  } else if (f = null, e.right && !r) {
    for (u = e; u !== null && u.right !== null && (u.right.redone || Pl(i, u.right.id) || Vy(s.undoStack, u.right.id) || Vy(s.redoStack, u.right.id)); )
      for (u = u.right; u.redone; )
        u = Et(n, u.redone);
    if (u && u.right !== null)
      return null;
  } else
    u = d._map.get(e.parentSub) || null;
  const p = Pe(l, a), g = Y(a, p), m = new pe(
    g,
    u,
    u && u.lastId,
    f,
    f && f.id,
    d,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = g, dm(m, !0), m.integrate(n, 0), m;
};
class pe extends fm {
  constructor(e, t, i, r, s, o, l, a) {
    super(e, a.getLength()), this.origin = i, this.left = t, this.right = r, this.rightOrigin = s, this.parent = o, this.parentSub = l, this.redone = null, this.content = a, this.info = this.content.isCountable() ? vy : 0;
  }
  set marker(e) {
    (this.info & wf) > 0 !== e && (this.info ^= wf);
  }
  get marker() {
    return (this.info & wf) > 0;
  }
  get keep() {
    return (this.info & wy) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= wy);
  }
  get countable() {
    return (this.info & vy) > 0;
  }
  get deleted() {
    return (this.info & yf) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= yf);
  }
  markDeleted() {
    this.info |= yf;
  }
  getMissing(e, t) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Pe(t, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Pe(t, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === vs && this.id.client !== this.parent.client && this.parent.clock >= Pe(t, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = Ry(e, t, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = Et(e, this.rightOrigin), this.rightOrigin = this.right.id), (this.left && this.left.constructor === Wt || this.right && this.right.constructor === Wt) && (this.parent = null), !this.parent)
      this.left && this.left.constructor === pe && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === pe && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === vs) {
      const i = hc(t, this.parent);
      i.constructor === Wt ? this.parent = null : this.parent = i.content.type;
    }
    return null;
  }
  integrate(e, t) {
    if (t > 0 && (this.id.clock += t, this.left = Ry(e, e.doc.store, Y(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(t), this.length -= t), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let i = this.left, r;
        if (i !== null)
          r = i.right;
        else if (this.parentSub !== null)
          for (r = this.parent._map.get(this.parentSub) || null; r !== null && r.left !== null; )
            r = r.left;
        else
          r = this.parent._start;
        const s = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; r !== null && r !== this.right; ) {
          if (o.add(r), s.add(r), hs(this.origin, r.origin)) {
            if (r.id.client < this.id.client)
              i = r, s.clear();
            else if (hs(this.rightOrigin, r.rightOrigin))
              break;
          } else if (r.origin !== null && o.has(hc(e.doc.store, r.origin)))
            s.has(hc(e.doc.store, r.origin)) || (i = r, s.clear());
          else
            break;
          r = r.right;
        }
        this.left = i;
      }
      if (this.left !== null) {
        const i = this.left.right;
        this.right = i, this.left.right = this;
      } else {
        let i;
        if (this.parentSub !== null)
          for (i = this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = this.parent._start, this.parent._start = this;
        this.right = i;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), yC(e.doc.store, this), this.content.integrate(e, this), By(e, this.parent, this.parentSub), (this.parent._item !== null && this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new Wt(this.id, this.length).integrate(e, 0);
  }
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  get lastId() {
    return this.length === 1 ? this.id : Y(this.id.client, this.id.clock + this.length - 1);
  }
  mergeWith(e) {
    if (this.constructor === e.constructor && hs(e.origin, this.lastId) && this.right === e && hs(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const t = this.parent._searchMarker;
      return t && t.forEach((i) => {
        i.p === e && (i.p = this, !this.deleted && this.countable && (i.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  delete(e) {
    if (!this.deleted) {
      const t = this.parent;
      this.countable && this.parentSub === null && (t._length -= this.length), this.markDeleted(), yl(e.deleteSet, this.id.client, this.id.clock, this.length), By(e, t, this.parentSub), this.content.delete(e);
    }
  }
  gc(e, t) {
    if (!this.deleted)
      throw gn();
    this.content.gc(e), t ? Iwe(e, this, new Wt(this.id, this.length)) : this.content = new _l(this.length);
  }
  write(e, t) {
    const i = t > 0 ? Y(this.id.client, this.id.clock + t - 1) : this.origin, r = this.rightOrigin, s = this.parentSub, o = this.content.getRef() & Jh | (i === null ? 0 : qt) | (r === null ? 0 : si) | (s === null ? 0 : gl);
    if (e.writeInfo(o), i !== null && e.writeLeftID(i), r !== null && e.writeRightID(r), i === null && r === null) {
      const l = this.parent;
      if (l._item !== void 0) {
        const a = l._item;
        if (a === null) {
          const c = gC(l);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(a.id);
      } else
        l.constructor === String ? (e.writeParentInfo(!0), e.writeString(l)) : l.constructor === vs ? (e.writeParentInfo(!1), e.writeLeftID(l)) : gn();
      s !== null && e.writeString(s);
    }
    this.content.write(e, t);
  }
}
const $C = (n, e) => Tve[e & Jh](n), Tve = [
  () => {
    gn();
  },
  dve,
  bve,
  fve,
  wve,
  gve,
  mve,
  Eve,
  yve,
  pve,
  () => {
    gn();
  }
], Mve = 10;
class jt extends fm {
  get deleted() {
    return !0;
  }
  delete() {
  }
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  integrate(e, t) {
    gn();
  }
  write(e, t) {
    e.writeInfo(Mve), V(e.restEncoder, this.length - t);
  }
  getMissing(e, t) {
    return null;
  }
}
const HC = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}, qC = "__ $YJS$ __";
HC[qC] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
HC[qC] = !0;
class pm {
  constructor(e, t) {
    this.yanchor = e, this.yhead = t;
  }
  toJSON() {
    return {
      yanchor: Oy(this.yanchor),
      yhead: Oy(this.yhead)
    };
  }
  static fromJSON(e) {
    return new pm(wl(e.yanchor), wl(e.yhead));
  }
}
class Ove {
  constructor(e, t) {
    this.ytext = e, this.awareness = t, this.undoManager = new sm(e);
  }
  toYPos(e, t = 0) {
    return up(this.ytext, e, t);
  }
  fromYPos(e) {
    const t = fp(wl(e), this.ytext.doc);
    if (t == null || t.type !== this.ytext)
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    return {
      pos: t.index,
      assoc: t.assoc
    };
  }
  toYRange(e) {
    const t = e.assoc, i = this.toYPos(e.anchor, t), r = this.toYPos(e.head, t);
    return new pm(i, r);
  }
  fromYRange(e) {
    const t = this.fromYPos(e.yanchor), i = this.fromYPos(e.yhead);
    return t.pos === i.pos ? S.cursor(i.pos, i.assoc) : S.range(t.pos, i.pos);
  }
}
const iu = E.define({
  combine(n) {
    return n[n.length - 1];
  }
}), bp = nn.define();
class Lve {
  constructor(e) {
    this.view = e, this.conf = e.state.facet(iu), this._observer = (t, i) => {
      if (i.origin !== this.conf) {
        const r = t.delta, s = [];
        let o = 0;
        for (let l = 0; l < r.length; l++) {
          const a = r[l];
          a.insert != null ? s.push({ from: o, to: o, insert: a.insert }) : a.delete != null ? (s.push({ from: o, to: o + a.delete, insert: "" }), o += a.delete) : o += a.retain;
        }
        e.dispatch({ changes: s, annotations: [bp.of(this.conf)] });
      }
    }, this._ytext = this.conf.ytext, this._ytext.observe(this._observer);
  }
  update(e) {
    if (!e.docChanged || e.transactions.length > 0 && e.transactions[0].annotation(bp) === this.conf)
      return;
    const t = this.conf.ytext;
    t.doc.transact(() => {
      let i = 0;
      e.changes.iterChanges((r, s, o, l, a) => {
        const c = a.sliceString(0, a.length, `
`);
        r !== s && t.delete(r + i, s - r), c.length > 0 && t.insert(r + i, c), i += c.length - (s - r);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
}
const Rve = Re.fromClass(Lve), Ive = I.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
}), Bve = nn.define();
class Nve extends mi {
  constructor(e, t) {
    super(), this.color = e, this.name = t;
  }
  toDOM() {
    return kf("span", [It("class", "cm-ySelectionCaret"), It("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
      Aa("\u2060"),
      kf("div", [
        It("class", "cm-ySelectionCaretDot")
      ]),
      Aa("\u2060"),
      kf("div", [
        It("class", "cm-ySelectionInfo")
      ], [
        Aa(this.name)
      ]),
      Aa("\u2060")
    ]);
  }
  eq(e) {
    return e.color === this.color;
  }
  compare(e) {
    return e.color === this.color;
  }
  updateDOM() {
    return !1;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return !0;
  }
}
class Pve {
  constructor(e) {
    this.conf = e.state.facet(iu), this._listener = ({ added: t, updated: i, removed: r }, s, o) => {
      t.concat(i).concat(r).findIndex((a) => a !== this.conf.awareness.doc.clientID) >= 0 && e.dispatch({ annotations: [Bve.of([])] });
    }, this._awareness = this.conf.awareness, this._awareness.on("change", this._listener), this.decorations = W.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  update(e) {
    const t = this.conf.ytext, i = t.doc, r = this.conf.awareness, s = [], o = this.conf.awareness.getLocalState();
    if (o != null) {
      const l = e.view.hasFocus && e.view.dom.ownerDocument.hasFocus(), a = l ? e.state.selection.main : null, c = o.cursor == null ? null : wl(o.cursor.anchor), h = o.cursor == null ? null : wl(o.cursor.head);
      if (a != null) {
        const u = up(t, a.anchor), f = up(t, a.head);
        (o.cursor == null || !Ly(c, u) || !Ly(h, f)) && r.setLocalStateField("cursor", {
          anchor: u,
          head: f
        });
      } else
        o.cursor != null && l && r.setLocalStateField("cursor", null);
    }
    r.getStates().forEach((l, a) => {
      if (a === r.doc.clientID)
        return;
      const c = l.cursor;
      if (c == null || c.anchor == null || c.head == null)
        return;
      const h = fp(c.anchor, i), u = fp(c.head, i);
      if (h == null || u == null || h.type !== t || u.type !== t)
        return;
      const { color: f = "#30bced", name: d = "Anonymous" } = l.user || {}, p = l.user && l.user.colorLight || f + "33", g = Yh(h.index, u.index), m = Qi(h.index, u.index), b = e.view.state.doc.lineAt(g), y = e.view.state.doc.lineAt(m);
      if (b.number === y.number)
        s.push({
          from: g,
          to: m,
          value: U.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        });
      else {
        s.push({
          from: g,
          to: b.from + b.length,
          value: U.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        }), s.push({
          from: y.from,
          to: m,
          value: U.mark({
            attributes: { style: `background-color: ${p}` },
            class: "cm-ySelection"
          })
        });
        for (let k = b.number + 1; k < y.number; k++) {
          const w = e.view.state.doc.line(k).from;
          s.push({
            from: w,
            to: w,
            value: U.line({
              attributes: { style: `background-color: ${p}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      s.push({
        from: u.index,
        to: u.index,
        value: U.widget({
          side: u.index - h.index > 0 ? -1 : 1,
          block: !1,
          widget: new Nve(f, d)
        })
      });
    }), this.decorations = U.set(s, !0);
  }
}
const Fve = Re.fromClass(Pve, {
  decorations: (n) => n.decorations
}), $ve = () => {
  let n = !0;
  return (e, t) => {
    if (n) {
      n = !1;
      try {
        e();
      } finally {
        n = !0;
      }
    } else
      t !== void 0 && t();
  };
};
class Hve {
  constructor(e) {
    this.undoManager = e;
  }
  addTrackedOrigin(e) {
    this.undoManager.addTrackedOrigin(e);
  }
  removeTrackedOrigin(e) {
    this.undoManager.removeTrackedOrigin(e);
  }
  undo() {
    return this.undoManager.undo() != null;
  }
  redo() {
    return this.undoManager.redo() != null;
  }
}
const ru = E.define({
  combine(n) {
    return n[n.length - 1];
  }
});
class qve {
  constructor(e) {
    this.view = e, this.conf = e.state.facet(ru), this._undoManager = this.conf.undoManager, this.syncConf = e.state.facet(iu), this._beforeChangeSelection = null, this._mux = $ve(), this._onStackItemAdded = ({ stackItem: t, changedParentTypes: i }) => {
      i.has(this.syncConf.ytext) && this._beforeChangeSelection && !t.meta.has(this) && t.meta.set(this, this._beforeChangeSelection);
    }, this._onStackItemPopped = ({ stackItem: t }) => {
      const i = t.meta.get(this);
      if (i) {
        const r = this.syncConf.fromYRange(i);
        e.dispatch(e.state.update({ selection: r })), this._storeSelection();
      }
    }, this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    }, this._undoManager.on("stack-item-added", this._onStackItemAdded), this._undoManager.on("stack-item-popped", this._onStackItemPopped), this._undoManager.addTrackedOrigin(this.syncConf);
  }
  update(e) {
    e.selectionSet && (e.transactions.length === 0 || e.transactions[0].annotation(bp) !== this.syncConf) && this._storeSelection();
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded), this._undoManager.off("stack-item-popped", this._onStackItemPopped), this._undoManager.removeTrackedOrigin(this.syncConf);
  }
}
const Vve = Re.fromClass(qve), zve = ({ state: n, dispatch: e }) => n.facet(ru).undo() || !0, Uve = ({ state: n, dispatch: e }) => n.facet(ru).redo() || !0, Wve = (n, e, { undoManager: t = new sm(n) } = {}) => {
  const i = new Ove(n, e), r = [
    iu.of(i),
    Rve
  ];
  return e && r.push(
    Ive,
    Fve
  ), t !== !1 && r.push(
    ru.of(new Hve(t)),
    Vve,
    I.domEventHandlers({
      beforeinput(s, o) {
        return s.inputType === "historyUndo" ? zve(o) : s.inputType === "historyRedo" ? Uve(o) : !1;
      }
    })
  ), r;
}, Af = 3e4;
class VC extends Kh {
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = setInterval(() => {
      const t = Yi();
      this.getLocalState() !== null && Af / 2 <= t - this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const i = [];
      this.meta.forEach((r, s) => {
        s !== this.clientID && Af <= t - r.lastUpdated && this.states.has(s) && i.push(s);
      }), i.length > 0 && gm(this, i, "timeout");
    }, ui(Af / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  setLocalState(e) {
    const t = this.clientID, i = this.meta.get(t), r = i === void 0 ? 0 : i.clock + 1, s = this.states.get(t);
    e === null ? this.states.delete(t) : this.states.set(t, e), this.meta.set(t, {
      clock: r,
      lastUpdated: Yi()
    });
    const o = [], l = [], a = [], c = [];
    e === null ? c.push(t) : s == null ? e != null && o.push(t) : (l.push(t), Vo(s, e) || a.push(t)), (o.length > 0 || a.length > 0 || c.length > 0) && this.emit("change", [{ added: o, updated: a, removed: c }, "local"]), this.emit("update", [{ added: o, updated: l, removed: c }, "local"]);
  }
  setLocalStateField(e, t) {
    const i = this.getLocalState();
    i !== null && this.setLocalState({
      ...i,
      [e]: t
    });
  }
  getStates() {
    return this.states;
  }
}
const gm = (n, e, t) => {
  const i = [];
  for (let r = 0; r < e.length; r++) {
    const s = e[r];
    if (n.states.has(s)) {
      if (n.states.delete(s), s === n.clientID) {
        const o = n.meta.get(s);
        n.meta.set(s, {
          clock: o.clock + 1,
          lastUpdated: Yi()
        });
      }
      i.push(s);
    }
  }
  i.length > 0 && (n.emit("change", [{ added: [], updated: [], removed: i }, t]), n.emit("update", [{ added: [], updated: [], removed: i }, t]));
}, zo = (n, e, t = n.states) => {
  const i = e.length, r = at();
  V(r, i);
  for (let s = 0; s < i; s++) {
    const o = e[s], l = t.get(o) || null, a = n.meta.get(o).clock;
    V(r, o), V(r, a), kr(r, JSON.stringify(l));
  }
  return Ee(r);
}, jve = (n, e, t) => {
  const i = er(e), r = Yi(), s = [], o = [], l = [], a = [], c = K(i);
  for (let h = 0; h < c; h++) {
    const u = K(i);
    let f = K(i);
    const d = JSON.parse(Fi(i)), p = n.meta.get(u), g = n.states.get(u), m = p === void 0 ? 0 : p.clock;
    (m < f || m === f && d === null && n.states.has(u)) && (d === null ? u === n.clientID && n.getLocalState() != null ? f++ : n.states.delete(u) : n.states.set(u, d), n.meta.set(u, {
      clock: f,
      lastUpdated: r
    }), p === void 0 && d !== null ? s.push(u) : p !== void 0 && d === null ? a.push(u) : d !== null && (Vo(d, g) || l.push(u), o.push(u)));
  }
  (s.length > 0 || l.length > 0 || a.length > 0) && n.emit("change", [{
    added: s,
    updated: l,
    removed: a
  }, t]), (s.length > 0 || o.length > 0 || a.length > 0) && n.emit("update", [{
    added: s,
    updated: o,
    removed: a
  }, t]);
}, zC = /* @__PURE__ */ new Map();
class Gve {
  constructor(e) {
    this.room = e, this.onmessage = null, this._onChange = (t) => t.key === e && this.onmessage !== null && this.onmessage({ data: Oye(t.newValue || "") }), Qbe(this._onChange);
  }
  postMessage(e) {
    WS.setItem(this.room, Mye(Cye(e)));
  }
  close() {
    eye(this._onChange);
  }
}
const Kve = typeof BroadcastChannel > "u" ? Gve : BroadcastChannel, mm = (n) => bi(zC, n, () => {
  const e = Lr(), t = new Kve(n);
  return t.onmessage = (i) => e.forEach((r) => r(i.data, "broadcastchannel")), {
    bc: t,
    subs: e
  };
}), Yve = (n, e) => (mm(n).subs.add(e), e), Jve = (n, e) => {
  const t = mm(n), i = t.subs.delete(e);
  return i && t.subs.size === 0 && (t.bc.close(), zC.delete(n)), i;
}, rs = (n, e, t = null) => {
  const i = mm(n);
  i.bc.postMessage(e), i.subs.forEach((r) => r(e, t));
}, UC = 0, bm = 1, WC = 2, yp = (n, e) => {
  V(n, UC);
  const t = Dwe(e);
  Ie(n, t);
}, jC = (n, e, t) => {
  V(n, bm), Ie(n, _we(e, t));
}, Zve = (n, e, t) => jC(e, t, lt(n)), GC = (n, e, t) => {
  try {
    vwe(e, lt(n), t);
  } catch (i) {
    console.error("Caught error while handling a Yjs update", i);
  }
}, Xve = (n, e) => {
  V(n, WC), Ie(n, e);
}, Qve = GC, exe = (n, e, t, i) => {
  const r = K(n);
  switch (r) {
    case UC:
      Zve(n, e, t);
      break;
    case bm:
      GC(n, t, i);
      break;
    case WC:
      Qve(n, t, i);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return r;
}, txe = 0, nxe = (n, e, t) => {
  switch (K(n)) {
    case txe:
      t(e, Fi(n));
  }
}, ixe = (n) => rye(n, (e, t) => `${encodeURIComponent(t)}=${encodeURIComponent(e)}`).join("&"), pr = 0, KC = 3, ks = 1, rxe = 2, ql = [];
ql[pr] = (n, e, t, i, r) => {
  V(n, pr);
  const s = exe(
    e,
    n,
    t.doc,
    t
  );
  i && s === bm && !t.synced && (t.synced = !0);
};
ql[KC] = (n, e, t, i, r) => {
  V(n, ks), Ie(
    n,
    zo(
      t.awareness,
      Array.from(t.awareness.getStates().keys())
    )
  );
};
ql[ks] = (n, e, t, i, r) => {
  jve(
    t.awareness,
    lt(e),
    t
  );
};
ql[rxe] = (n, e, t, i, r) => {
  nxe(
    e,
    t.doc,
    (s, o) => sxe(t, o)
  );
};
const zy = 3e4, sxe = (n, e) => console.warn(`Permission denied to access ${n.url}.
${e}`), YC = (n, e, t) => {
  const i = er(e), r = at(), s = K(i), o = n.messageHandlers[s];
  return o ? o(r, i, n, t, s) : console.error("Unable to compute message"), r;
}, JC = (n) => {
  if (n.shouldConnect && n.ws === null) {
    const e = new n._WS(n.url);
    e.binaryType = "arraybuffer", n.ws = e, n.wsconnecting = !0, n.wsconnected = !1, n.synced = !1, e.onmessage = (t) => {
      n.wsLastMessageReceived = Yi();
      const i = YC(n, new Uint8Array(t.data), !0);
      Xg(i) > 1 && e.send(Ee(i));
    }, e.onerror = (t) => {
      n.emit("connection-error", [t, n]);
    }, e.onclose = (t) => {
      n.emit("connection-close", [t, n]), n.ws = null, n.wsconnecting = !1, n.wsconnected ? (n.wsconnected = !1, n.synced = !1, gm(
        n.awareness,
        Array.from(n.awareness.getStates().keys()).filter(
          (i) => i !== n.doc.clientID
        ),
        n
      ), n.emit("status", [{
        status: "disconnected"
      }])) : n.wsUnsuccessfulReconnects++, setTimeout(
        JC,
        Yh(
          zbe(2, n.wsUnsuccessfulReconnects) * 100,
          n.maxBackoffTime
        ),
        n
      );
    }, e.onopen = () => {
      n.wsLastMessageReceived = Yi(), n.wsconnecting = !1, n.wsconnected = !0, n.wsUnsuccessfulReconnects = 0, n.emit("status", [{
        status: "connected"
      }]);
      const t = at();
      if (V(t, pr), yp(t, n.doc), e.send(Ee(t)), n.awareness.getLocalState() !== null) {
        const i = at();
        V(i, ks), Ie(
          i,
          zo(n.awareness, [
            n.doc.clientID
          ])
        ), e.send(Ee(i));
      }
    }, n.emit("status", [{
      status: "connecting"
    }]);
  }
}, Df = (n, e) => {
  const t = n.ws;
  n.wsconnected && t && t.readyState === t.OPEN && t.send(e), n.bcconnected && rs(n.bcChannel, e, n);
};
class oxe extends Kh {
  constructor(e, t, i, {
    connect: r = !0,
    awareness: s = new VC(i),
    params: o = {},
    WebSocketPolyfill: l = WebSocket,
    resyncInterval: a = -1,
    maxBackoffTime: c = 2500,
    disableBc: h = !1
  } = {}) {
    for (super(); e[e.length - 1] === "/"; )
      e = e.slice(0, e.length - 1);
    const u = ixe(o);
    this.maxBackoffTime = c, this.bcChannel = e + "/" + t, this.url = e + "/" + t + (u.length === 0 ? "" : "?" + u), this.roomname = t, this.doc = i, this._WS = l, this.awareness = s, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = h, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = ql.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = r, this._resyncInterval = 0, a > 0 && (this._resyncInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        const f = at();
        V(f, pr), yp(f, i), this.ws.send(Ee(f));
      }
    }, a)), this._bcSubscriber = (f, d) => {
      if (d !== this) {
        const p = YC(this, new Uint8Array(f), !1);
        Xg(p) > 1 && rs(this.bcChannel, Ee(p), this);
      }
    }, this._updateHandler = (f, d) => {
      if (d !== this) {
        const p = at();
        V(p, pr), Xve(p, f), Df(this, Ee(p));
      }
    }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({ added: f, updated: d, removed: p }, g) => {
      const m = f.concat(d).concat(p), b = at();
      V(b, ks), Ie(
        b,
        zo(s, m)
      ), Df(this, Ee(b));
    }, this._unloadHandler = () => {
      gm(
        this.awareness,
        [i.clientID],
        "window unload"
      );
    }, typeof window < "u" ? window.addEventListener("unload", this._unloadHandler) : typeof process < "u" && process.on("exit", this._unloadHandler), s.on("update", this._awarenessUpdateHandler), this._checkInterval = setInterval(() => {
      this.wsconnected && zy < Yi() - this.wsLastMessageReceived && this.ws.close();
    }, zy / 10), r && this.connect();
  }
  get synced() {
    return this._synced;
  }
  set synced(e) {
    this._synced !== e && (this._synced = e, this.emit("synced", [e]), this.emit("sync", [e]));
  }
  destroy() {
    this._resyncInterval !== 0 && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), typeof window < "u" ? window.removeEventListener("unload", this._unloadHandler) : typeof process < "u" && process.off("exit", this._unloadHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy();
  }
  connectBc() {
    if (this.disableBc)
      return;
    this.bcconnected || (Yve(this.bcChannel, this._bcSubscriber), this.bcconnected = !0);
    const e = at();
    V(e, pr), yp(e, this.doc), rs(this.bcChannel, Ee(e), this);
    const t = at();
    V(t, pr), jC(t, this.doc), rs(this.bcChannel, Ee(t), this);
    const i = at();
    V(i, KC), rs(
      this.bcChannel,
      Ee(i),
      this
    );
    const r = at();
    V(r, ks), Ie(
      r,
      zo(this.awareness, [
        this.doc.clientID
      ])
    ), rs(
      this.bcChannel,
      Ee(r),
      this
    );
  }
  disconnectBc() {
    const e = at();
    V(e, ks), Ie(
      e,
      zo(this.awareness, [
        this.doc.clientID
      ], /* @__PURE__ */ new Map())
    ), Df(this, Ee(e)), this.bcconnected && (Jve(this.bcChannel, this._bcSubscriber), this.bcconnected = !1);
  }
  disconnect() {
    this.shouldConnect = !1, this.disconnectBc(), this.ws !== null && this.ws.close();
  }
  connect() {
    this.shouldConnect = !0, !this.wsconnected && this.ws === null && (JC(this), this.connectBc());
  }
}
function lxe(n) {
  if (!n.enabled)
    return {};
  const e = ni(() => new lo(), []), [t, i] = ht(!1), r = ni(() => {
    var a;
    const l = new oxe((a = n.wsUrl) != null ? a : "ws://localhost:4444", n.room, e, {
      connect: !0,
      params: {},
      WebSocketPolyfill: WebSocket,
      awareness: new VC(e),
      maxBackoffTime: 2500
    });
    return l.awareness.setLocalStateField("user", {
      name: n.username,
      color: n.color
    }), l.on("status", ({
      status: c
    }) => {
      c == "connected" && l.on("sync", (h) => {
        !h || (l.firstUser = !0, i(!0));
      });
    }), l;
  }, []), s = ni(() => e.getText("codemirror"), []), o = ni(() => new sm(s, {
    trackedOrigins: /* @__PURE__ */ new Set([r.doc.clientID, null]),
    ignoreRemoteMapChanges: !0
  }), []);
  return {
    provider: r,
    undoManager: o,
    ytext: s,
    ydoc: e,
    ready: t
  };
}
const wp = Ae.div.withConfig({
  displayName: "CodeMirror__CodeEditor",
  componentId: "sc-1q0hyc9-0"
})(["border-radius:var(--border-radius);background:var(--gray-200);font-family:monospace;font-size:0.94em;resize:none;border:0;padding:20px;min-height:500px;display:", ';flex:1;border:1px solid var(--gray-400);box-shadow:inset 0px 0px 4px rgba(0,0,0,0.15);@media print{display:none;}.cm-ySelectionInfo{opacity:1 !important;font-size:0.6rem;padding:0.25rem 0.5rem !important;border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:10px;font-family:"Lato" !important;font-weight:600 !important;}.cm-widgetBuffer{margin-bottom:0;}.cm-ySelectionCaretDot{display:none;}.cm-yLineSelection{margin:0 2px 0 6px !important;}.cm-editor{outline:0;}'], (n) => n.$shown ? "block" : "none"), axe = Ae.textarea.withConfig({
  displayName: "CodeMirror__HiddenTextArea",
  componentId: "sc-1q0hyc9-1"
})(["display:none;"]), cxe = (n) => {
  const {
    from: e
  } = n.state.selection.main, t = n.state.doc.lineAt(e);
  return {
    line: t.number - 1,
    ch: e - t.from
  };
}, hxe = (n, e) => {
  const {
    line: t,
    ch: i
  } = e, r = n.state.doc.line(t + 1).from + i;
  n.dispatch({
    selection: {
      anchor: r,
      head: r
    },
    scrollIntoView: !0
  });
}, uxe = ({
  text: n,
  setText: e,
  id: t,
  name: i,
  className: r,
  shown: s,
  syncText: o,
  setSyncText: l,
  collaboration: a
}) => {
  const c = fs(null), [h, u] = ht(!1), {
    provider: f,
    undoManager: d,
    ytext: p,
    ydoc: g,
    ready: m
  } = lxe(a);
  return Cr(() => {
    a.enabled && (d.on("stack-item-added", (x) => {
      x.stackItem.meta.set("cursor-location", cxe(c.current));
    }), d.on("stack-item-popped", (x) => {
      hxe(c.current, x.stackItem.meta.get("cursor-location"));
    }));
    const b = np.filter((x, v) => v != 3), y = [a.enabled ? b : np, ol.of([g1e]), I.lineWrapping, I.updateListener.of((x) => {
      x.docChanged && (localStorage.getItem("log") == "true" && console.log("doc changed"), e(w.state.doc.toString()));
    })];
    a.enabled && (y.push(Wve(p, f.awareness, {
      undoManager: d
    })), y.push(ol.of([{
      key: "Mod-z",
      run: () => d.undo(),
      preventDefault: !0
    }, {
      key: "Mod-y",
      run: () => d.redo(),
      preventDefault: !0
    }])));
    const k = J.create({
      doc: a.enabled ? p.toString() : n,
      extensions: y
    }), w = new I({
      state: k,
      parent: document.getElementById(t + "-editor")
    });
    return c.current = w, u(!0), () => {
      a.enabled && (f.disconnect(), g.destroy()), w.destroy();
    };
  }, []), Cr(() => {
    const b = document.querySelectorAll("#myst-css-namespace").length, y = a.enabled && p.toString().length == 0 && f.awareness.getStates().size == b && f.firstUser && m;
    p && p.toString().length != 0 && e(p.toString()), y ? (console.log("You are the first user in this document. Initiating..."), c.current.dispatch({
      changes: {
        from: 0,
        to: c.current.state.doc.length,
        insert: n
      }
    })) : o && (console.log("setting text"), c.current.dispatch({
      changes: {
        from: 0,
        to: c.current.state.doc.length,
        insert: n
      }
    }), l(!1));
  }, [o, m, h]), yt`
      <${wp} $shown="${s}" id="${t}-editor" class=${r}><//>
      <${axe} value=${n} name=${i} id=${t}><//>
  `;
};
console.log("CodeMirror component loaded");
const fxe = Ae.section`
  z-index: 2;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 10px;
  width: 450px;
  padding: 20px;
  right: 50%;
  transform: translate(50%, 0);
  top: 100%;
  position: absolute;
  background-color: var(--white);
  border: 1px solid var(--gray-600);
  border-radius: var(--border-radius);
`, dxe = Ae.h3`
  font-family: 'Lato', sans-serif;
  color: var(--gray-900);
`, pxe = Ae.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
`, Uy = Ae(Bh)`
  padding: 0 10px;
  margin-top: 0px;

  &:hover {
    background-color: ${(n) => n.$negative ? "var(--red-500)" : "var(--green-400)"} !important;
    border: 1px solid ${(n) => n.$negative ? "var(--red-500)" : "var(--green-400)"} !important;
  }`, gxe = ({
  changeDocumentTemplate: n,
  selectedTemplate: e,
  closeModal: t
}) => yt`
    <${fxe}>
        <${dxe}>Are you sure you want to change the current template?<//>
        <${pxe}>
            <${Uy} type="button" onClick=${() => n(e)}> Yes<//>
            <${Uy} $negative type="button" onClick=${t}>x Cancel<//>
        <//>
    <//>
  `;
console.log("Modal functional component loaded");
const mxe = Ae.div`
  position: absolute;
  ${(n) => n.$orientation == "left" && ds(["left:0;"])}
  transform: ${(n) => n.$orientation == "left" ? "translateX(-105%)" : "translate(-50%, 130%)"};
`, bxe = Ae.div`
  position: relative; 
  background: var(--green-400);
  color: #ffffff;
  font-family: 'Lato', sans-serif;
  text-align: left;
  padding: 10px 20px 10px 20px;
  border-radius: var(--border-radius);
  border: solid var(--green-400);
  border-width: 1px 1px 1px 1px;
  max-height: 40px;
  top: calc(100% + 11px);
  ${(n) => n.$orientation == "bottom" && ds(["left:50%;"])}
  transform: ${(n) => n.$orientation == "left" ? "none" : "translateX(-25%)"};

  &::before {
    content: '';
    position: absolute;
    ${(n) => n.$orientation == "left" ? ds(["right:0;top:50%;border-top:15px solid transparent;border-bottom:15px solid transparent;border-left:30px solid var(--green-400);"]) : ds(["left:50%;border-left:15px solid transparent;border-right:15px solid transparent;border-bottom:30px solid var(--green-400);"])}
    transform: ${(n) => n.$orientation == "left" ? "translate(50%, -50%)" : "translate(-50%, -100%)"};
  }
`, Wy = ({
  tooltipOrientation: n,
  errorMessage: e
}) => yt`
    <${mxe} $orientation=${n}>
      <${bxe} $orientation=${n}>
          ${e}
      <//>
    <//>`;
console.log("Tooltip component loaded");
const yxe = Ae.div`
  display: none;
  margin-left: 5px;
  font-family: 'Lato', sans-serif;
  text-transform: uppercase;
  font-size: 12px;
  align-items: center;
  justify-content: space-around;
  white-space: nowrap;
  border: 1px solid var(--gray-900);
  border-radius: var(--border-radius);
  color: var(--white);
  background-color: var(--gray-800);
  z-index: 20;
  width: 100%;
`, jy = Ae(Bh)`
  width: 100%!important;
  color: var(--white);
  border: 1px solid var(--gray-900)!important;
  padding: 0 10px 0 10px!important;
  margin-top: 0px;`, wxe = Ae.div`
  position: relative;
  display: inline-block;
  width: min-content;

  &:hover {
    div {
      display: inline-flex;
      flex-direction: column;
    }
  }
`, vxe = Ae.div`
  display: flex;
  flex-direction: row-reverse;
  border: 1px solid var(--gray-900);
  width: inherit;
`, xxe = Ae.div`
  position: absolute;
  display: flex;
  padding-top: 5px;
`, kxe = (n) => {
  const e = ["id", "templatetext"];
  for (const t in n) {
    for (let i of e)
      n[t][i] || (n[t].errorMessage = `Configuration of template ${t} is lacking '${i}'`);
    n[t].errorMessage && console.error(n[t].errorMessage);
  }
  return n;
}, _xe = ({
  setText: n,
  templatelist: e,
  setSyncText: t
}) => {
  const [i, r] = ht(""), [s, o] = ht({}), [l, a] = ht(null), [c, h] = ht(!1), [u, f] = ht(!1), [d, p] = ht({
    error: null,
    message: null
  }), g = (w) => w.ok ? w : Promise.reject(`Invalid HTTP response: ${w.status}`), m = (w) => {
    r(s[w].templatetext), n(s[w].templatetext), t(!0), h(!1);
  }, b = (w) => fetch(w).then(g).then((x) => x.json().catch((v) => {
    console.error(v), p({
      error: v,
      message: "Template configuration is not valid"
    });
  })).catch((x) => {
    console.warn(x), p({
      error: x,
      message: "Template configuration not found"
    });
  }), y = (w) => fetch(w).then(g).then((x) => x.text()).catch((x) => {
    throw console.error(x), new Error("Could not fetch the template");
  }), k = async (w) => {
    if (!w)
      return {};
    for (const x in w) {
      const v = w[x].templatetext;
      await y(v).then((C) => w[x].templatetext = C).catch((C) => {
        var B, R;
        return (R = (B = w[x]).errorMessage) != null ? R : B.errorMessage = C.message;
      });
    }
    return w;
  };
  return Cr(() => b(e).then(kxe).then(k).then(o), []), d.error ? yt`
        <${No} type="button" template=${i} onMouseEnter=${() => f(!0)} onMouseLeave=${() => f(!1)}>
          Templates
        <//>
        <${u && Wy} tooltipOrientation="bottom" errorMessage=${d.message}/>` : Object.keys(s).length == 0 ? yt`
        <${No} type="button" template=${i} onMouseEnter=${() => f(!0)} onMouseLeave=${() => f(!1)}>
          Templates
        <//>` : yt`
    ${c && yt`<${gxe} selectedTemplate=${l} closeModal=${() => {
    h(!1), a(!1);
  }} changeDocumentTemplate=${m}/>`}
    <${wxe}>
      <${No} type="button">Templates<//>
      <${xxe}>
        <${yxe}>
        ${Object.keys(s).map((w) => yt`
            ${s[w].errorMessage ? yt`
              <${vxe}>
                <${u === w && Wy} tooltipOrientation="left" errorMessage="${s[w].errorMessage}"/>
                  <${jy} type="button" onMouseEnter=${() => f(w)} onMouseLeave=${() => f(!1)}>${s[w].id}
                <//>
              <//>
            ` : yt`
              <${jy} type="button" 
              onClick=${() => {
    h(!0), a(w);
  }}>${s[w].id}
              <//>
            `}
          `)}      
        <//>
      <//>
    <//>
  `;
};
console.log("TemplateManager component loaded");
const Sxe = Ae.div.withConfig({
  displayName: "Preview",
  componentId: "sc-1gprrj9-0"
})(['background-color:white;padding:20px;min-height:500px;flex:1;border:1px solid var(--gray-400);border-left:1px solid var(--gray-600);box-shadow:inset 0px 0px 4px var(--gray-600);border-radius:var(--border-radius);font-family:"Lato",sans-serif;vertical-align:top;color:var(--gray-900);word-break:unset;', ` @media print{display:block !important;border:0px !important;box-shadow:none !important;border-radius:0px !important;word-break:unset !important;}p{margin-top:0px;line-height:1.5em;display:block;a{display:inline;}@media print{break-inside:avoid !important;text-align:justify !important;text-justify:inter-word !important;}}a{color:var(--blue-500);@media print{&::after{content:"(" attr(href) ")" !important;}}}h1,h2,h3,h4,h5,h6{font-weight:bold;line-height:1.5;margin:1em 0;}h1{font-size:1.8em;}h2{font-size:1.5em;}h3{font-size:1.25em;}h4{font-size:1.15em;}h5{font-size:1.1em;}h6{font-size:1em;}hr{height:1px;margin:16px 0;background-color:var(--gray-500);border:0 none;}code,pre{border-radius:var(--border-radius);background-color:var(--gray-200);}code{padding:0.2em 0.4em;font-family:"Source Code Pro";}pre{white-space:pre-wrap;padding:16px;}aside{border-radius:var(--border-radius);&.admonition{border:var(--border-2) solid var(--green-500);margin-bottom:1rem;.admonition{margin:0rem 1.4rem 0.9rem 1.4rem;}& > header,p{padding:10px;}& > p{margin-bottom:0;}& > header{color:var(--white);font-weight:bold;background:var(--green-500);}}&[class="admonition"]{.admonition{margin-top:0.9rem;}}&.note,&.important,&.tip,&.hint,&.directive-unhandled,&.warning{border:3px solid var(--blue-400);& > header{background-color:var(--blue-400);display:flex;&::before{padding-right:5px;display:flex;align-items:center;}}}&.warning{border:3px solid var(--orange-500);& > header{background-color:var(--orange-500);&::before{content:url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-exclamation-triangle' viewBox='0 0 16 16'%3E%3Cpath d='M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z' fill='white'%3E%3C/path%3E%3Cpath d='M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z' fill='white'%3E%3C/path%3E%3C/svg%3E%0A");}}}&.tip,&.hint{& > header::before{content:url("data:image/svg+xml,%3Csvg style='color: white' width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 0V2H8V0H7Z' fill='white'%3E%3C/path%3E%3Cpath d='M3.35355 3.64645L1.85355 2.14645L1.14645 2.85355L2.64645 4.35355L3.35355 3.64645Z' fill='white'%3E%3C/path%3E%3Cpath d='M12.3536 4.35355L13.8536 2.85355L13.1464 2.14645L11.6464 3.64645L12.3536 4.35355Z' fill='white'%3E%3C/path%3E%3Cpath d='M7.49998 3C5.52977 3 3.85938 4.44872 3.58075 6.39913L3.5707 6.46949C3.41148 7.58398 3.73042 8.64543 4.36009 9.45895C4.74345 9.95426 5 10.427 5 10.9013V12.5C5 12.7761 5.22386 13 5.5 13H9.5C9.77614 13 10 12.7761 10 12.5V10.9013C10 10.427 10.2565 9.95423 10.6399 9.45893C11.2696 8.64541 11.5885 7.58397 11.4293 6.4695L11.4192 6.39914C11.1406 4.44873 9.4702 3 7.49998 3Z' fill='white'%3E%3C/path%3E%3Cpath d='M0 8H2V7H0V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M13 8H15V7H13V8Z' fill='white'%3E%3C/path%3E%3Cpath d='M6 15H9V14H6V15Z' fill='white'%3E%3C/path%3E%3C/svg%3E");}}&.note > header::before{content:url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='currentColor' class='bi bi-pencil' viewBox='0 0 16 16'%3E%3Cpath d='M12.146.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1 0 .708l-10 10a.5.5 0 0 1-.168.11l-5 2a.5.5 0 0 1-.65-.65l2-5a.5.5 0 0 1 .11-.168l10-10zM11.207 2.5 13.5 4.793 14.793 3.5 12.5 1.207 11.207 2.5zm1.586 3L10.5 3.207 4 9.707V10h.5a.5.5 0 0 1 .5.5v.5h.5a.5.5 0 0 1 .5.5v.5h.293l6.5-6.5zm-9.761 5.175-.106.106-1.528 3.821 3.821-1.528.106-.106A.5.5 0 0 1 5 12.5V12h-.5a.5.5 0 0 1-.5-.5V11h-.5a.5.5 0 0 1-.468-.325z' fill='white'%3E%3C/path%3E%3C/svg%3E");}&.important > header::before{content:url("data:image/svg+xml,%3Csvg style='color: white' xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24'%3E%3Cpath d='M18 16v-5c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2zm-5 0h-2v-2h2v2zm0-4h-2V8h2v4zm-1 10c1.1 0 2-.9 2-2h-4c0 1.1.89 2 2 2z' fill='white'%3E%3C/path%3E%3C/svg%3E");}&.directive-unhandled,&.directive-error{margin-bottom:1em;& > header{padding:10px;color:var(--white);mark{background:transparent;font-weight:bold;color:inherit;}code{background:transparent;font-family:'Lato',sans-serif;font-weight:bold;padding:0;margin-left:.3em;}}pre{background-color:var(--white);margin:0;font-family:'Lato',sans-serif;}}&.directive-unhandled{border:3px solid var(--gray-700);& > header{background-color:var(--gray-700);}}&.directive-error{border:3px solid var(--red-500);& > header{background-color:var(--red-500);}}}sup,sub,numref{line-height:0;}abbr{letter-spacing:0.1em;font-weight:bold;}img{max-width:100%;height:auto;display:block;margin-left:auto;margin-right:auto;}li{margin-bottom:1em;}ul,ol{margin-bottom:2em;list-style:revert;padding-left:40px;padding-top:1em;}blockquote{border-left:5px solid var(--green-500);margin-left:0;margin-top:0;padding-left:0.75rem;}table{border-spacing:0;margin:20px 0 20px 0;}th,td{padding:20px;text-align:left;border-right:1px solid var(--gray-500);border-bottom:1px solid var(--gray-500);}th{background:var(--gray-900);border-top:1px solid var(--gray-500);color:var(--white);&:first-of-type{border-top-left-radius:var(--border-radius);border-left:1px solid var(--gray-500);}&:last-of-type{border-top-right-radius:var(--border-radius);}}td{&:first-of-type{border-left:1px solid var(--gray-500);}p:last-of-type{margin-bottom:0;}}tr{&:nth-child(2n + 2){background:var(--gray-100);}&:last-of-type{td{&:first-of-type{border-bottom-left-radius:var(--border-radius);}&:last-of-type{border-bottom-right-radius:var(--border-radius);}}}}`], (n) => !n.$shown && ds`
    display: none;
  `);
function uh(n) {
  let e;
  return n.nodeType == 11 ? e = n.getSelection ? n : n.ownerDocument : e = n, e.getSelection();
}
function vp(n, e) {
  return e ? n == e || n.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Cxe(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function fc(n, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return vp(n, e.anchorNode);
  } catch {
    return !1;
  }
}
function Sl(n) {
  return n.nodeType == 3 ? Nr(n, 0, n.nodeValue.length).getClientRects() : n.nodeType == 1 ? n.getClientRects() : [];
}
function fh(n, e, t, i) {
  return t ? Gy(n, e, t, i, -1) || Gy(n, e, t, i, 1) : !1;
}
function Cl(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}
function Gy(n, e, t, i, r) {
  for (; ; ) {
    if (n == t && e == i)
      return !0;
    if (e == (r < 0 ? 0 : fi(n))) {
      if (n.nodeName == "DIV")
        return !1;
      let s = n.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Cl(n) + (r < 0 ? 0 : 1), n = s;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (r < 0 ? -1 : 0)], n.nodeType == 1 && n.contentEditable == "false")
        return !1;
      e = r < 0 ? fi(n) : 0;
    } else
      return !1;
  }
}
function fi(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function ym(n, e) {
  let t = e ? n.left : n.right;
  return { left: t, right: t, top: n.top, bottom: n.bottom };
}
function Axe(n) {
  return {
    left: 0,
    right: n.innerWidth,
    top: 0,
    bottom: n.innerHeight
  };
}
function Dxe(n, e, t, i, r, s, o, l) {
  let a = n.ownerDocument, c = a.defaultView || window;
  for (let h = n, u = !1; h && !u; )
    if (h.nodeType == 1) {
      let f, d = h == a.body, p = 1, g = 1;
      if (d)
        f = Axe(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (u = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let y = h.getBoundingClientRect();
        p = y.width / h.offsetWidth, g = y.height / h.offsetHeight, f = {
          left: y.left,
          right: y.left + h.clientWidth * p,
          top: y.top,
          bottom: y.top + h.clientHeight * g
        };
      }
      let m = 0, b = 0;
      if (r == "nearest")
        e.top < f.top ? (b = -(f.top - e.top + o), t > 0 && e.bottom > f.bottom + b && (b = e.bottom - f.bottom + b + o)) : e.bottom > f.bottom && (b = e.bottom - f.bottom + o, t < 0 && e.top - b < f.top && (b = -(f.top + b - e.top + o)));
      else {
        let y = e.bottom - e.top, k = f.bottom - f.top;
        b = (r == "center" && y <= k ? e.top + y / 2 - k / 2 : r == "start" || r == "center" && t < 0 ? e.top - o : e.bottom - k + o) - f.top;
      }
      if (i == "nearest" ? e.left < f.left ? (m = -(f.left - e.left + s), t > 0 && e.right > f.right + m && (m = e.right - f.right + m + s)) : e.right > f.right && (m = e.right - f.right + s, t < 0 && e.left < f.left + m && (m = -(f.left + m - e.left + s))) : m = (i == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : i == "start" == l ? e.left - s : e.right - (f.right - f.left) + s) - f.left, m || b)
        if (d)
          c.scrollBy(m, b);
        else {
          let y = 0, k = 0;
          if (b) {
            let w = h.scrollTop;
            h.scrollTop += b / g, k = (h.scrollTop - w) * g;
          }
          if (m) {
            let w = h.scrollLeft;
            h.scrollLeft += m / p, y = (h.scrollLeft - w) * p;
          }
          e = {
            left: e.left - y,
            top: e.top - k,
            right: e.right - y,
            bottom: e.bottom - k
          }, y && Math.abs(y - m) < 1 && (i = "nearest"), k && Math.abs(k - b) < 1 && (r = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function Exe(n) {
  let e = n.ownerDocument;
  for (let t = n.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class Txe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? fi(t) : 0), i, Math.min(e.focusOffset, i ? fi(i) : 0));
  }
  set(e, t, i, r) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = r;
  }
}
let es = null;
function ZC(n) {
  if (n.setActive)
    return n.setActive();
  if (es)
    return n.focus(es);
  let e = [];
  for (let t = n; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (n.focus(es == null ? {
    get preventScroll() {
      return es = { preventScroll: !0 }, !0;
    }
  } : void 0), !es) {
    es = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], r = e[t++], s = e[t++];
      i.scrollTop != r && (i.scrollTop = r), i.scrollLeft != s && (i.scrollLeft = s);
    }
  }
}
let Ky;
function Nr(n, e, t = e) {
  let i = Ky || (Ky = document.createRange());
  return i.setEnd(n, t), i.setStart(n, e), i;
}
function _s(n, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, r = new KeyboardEvent("keydown", i);
  r.synthetic = !0, n.dispatchEvent(r);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, n.dispatchEvent(s), r.defaultPrevented || s.defaultPrevented;
}
function Mxe(n) {
  for (; n; ) {
    if (n && (n.nodeType == 9 || n.nodeType == 11 && n.host))
      return n;
    n = n.assignedSlot || n.parentNode;
  }
  return null;
}
function XC(n) {
  for (; n.attributes.length; )
    n.removeAttributeNode(n.attributes[0]);
}
function Oxe(n, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, fi(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let r = t.childNodes[i - 1];
      r.contentEditable == "false" ? i-- : (t = r, i = fi(t));
    } else {
      if (t == n)
        return !0;
      i = Cl(t), t = t.parentNode;
    }
}
function QC(n) {
  return n.scrollTop > Math.max(1, n.scrollHeight - n.clientHeight - 4);
}
class ut {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new ut(e.parentNode, Cl(e), t);
  }
  static after(e, t) {
    return new ut(e.parentNode, Cl(e) + 1, t);
  }
}
const wm = [];
class Se {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, r = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = r ? r.nextSibling : i.firstChild)) {
            let l = Se.get(s);
            (!l || !l.parent && l.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (s = r ? r.nextSibling : i.firstChild, t && !t.written && t.node == i && s != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; s && s != o.dom; )
            s = Yy(s);
        else
          i.insertBefore(o.dom, s);
        r = o.dom;
      }
      for (s = r ? r.nextSibling : i.firstChild, s && t && t.node == i && (t.written = !0); s; )
        s = Yy(s);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let r = fi(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        r == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? r = -1 : r = 1), e = s;
      }
      r < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Se.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let r = 0, s = 0; ; r++) {
      let o = this.children[r];
      if (o.dom == i)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let r = -1, s = -1, o = -1, l = -1;
    for (let a = 0, c = i, h = i; a < this.children.length; a++) {
      let u = this.children[a], f = c + u.length;
      if (c < e && f > t)
        return u.domBoundsAround(e, t, c);
      if (f >= e && r == -1 && (r = a, s = c), c > t && u.dom.parentNode == this.dom) {
        o = a, l = h;
        break;
      }
      h = f, c = f + u.breakAfter;
    }
    return {
      from: s,
      to: l < 0 ? i + this.length : l,
      startDOM: (r ? this.children[r - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = wm) {
    this.markDirty();
    for (let r = e; r < t; r++) {
      let s = this.children[r];
      s.parent == this && s.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let r = 0; r < i.length; r++)
      i[r].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new eA(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, r, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Se.prototype.breakAfter = 0;
function Yy(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class eA {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function tA(n, e, t, i, r, s, o, l, a) {
  let { children: c } = n, h = c.length ? c[e] : null, u = s.length ? s[s.length - 1] : null, f = u ? u.breakAfter : o;
  if (!(e == i && h && !o && !f && s.length < 2 && h.merge(t, r, s.length ? u : null, t == 0, l, a))) {
    if (i < c.length) {
      let d = c[i];
      d && (r < d.length || d.breakAfter && (u == null ? void 0 : u.breakAfter)) ? (e == i && (d = d.split(r), r = 0), !f && u && d.merge(0, r, u, !0, 0, a) ? s[s.length - 1] = d : ((r || d.children.length && !d.children[0].length) && d.merge(0, r, null, !1, 0, a), s.push(d))) : d != null && d.breakAfter && (u ? u.breakAfter = 1 : o = 1), i++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && s.length && h.merge(t, h.length, s[0], !1, l, 0) ? h.breakAfter = s.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, l, 0), e++)); e < i && s.length; )
      if (c[i - 1].become(s[s.length - 1]))
        i--, s.pop(), a = s.length ? 0 : l;
      else if (c[e].become(s[0]))
        e++, s.shift(), l = s.length ? 0 : a;
      else
        break;
    !s.length && e && i < c.length && !c[e - 1].breakAfter && c[i].merge(0, 0, c[e - 1], !1, l, a) && e--, (e < i || s.length) && n.replaceChildren(e, i, s);
  }
}
function nA(n, e, t, i, r, s) {
  let o = n.childCursor(), { i: l, off: a } = o.findPos(t, 1), { i: c, off: h } = o.findPos(e, -1), u = e - t;
  for (let f of i)
    u += f.length;
  n.length += u, tA(n, c, h, l, a, i, 0, r, s);
}
let $t = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, xp = typeof document < "u" ? document : { documentElement: { style: {} } };
const kp = /* @__PURE__ */ /Edge\/(\d+)/.exec($t.userAgent), iA = /* @__PURE__ */ /MSIE \d/.test($t.userAgent), _p = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec($t.userAgent), su = !!(iA || _p || kp), Jy = !su && /* @__PURE__ */ /gecko\/(\d+)/i.test($t.userAgent), Ef = !su && /* @__PURE__ */ /Chrome\/(\d+)/.exec($t.userAgent), Zy = "webkitFontSmoothing" in xp.documentElement.style, rA = !su && /* @__PURE__ */ /Apple Computer/.test($t.vendor), Xy = rA && (/* @__PURE__ */ /Mobile\/\w+/.test($t.userAgent) || $t.maxTouchPoints > 2);
var H = {
  mac: Xy || /* @__PURE__ */ /Mac/.test($t.platform),
  windows: /* @__PURE__ */ /Win/.test($t.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test($t.platform),
  ie: su,
  ie_version: iA ? xp.documentMode || 6 : _p ? +_p[1] : kp ? +kp[1] : 0,
  gecko: Jy,
  gecko_version: Jy ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec($t.userAgent) || [0, 0])[1] : 0,
  chrome: !!Ef,
  chrome_version: Ef ? +Ef[1] : 0,
  ios: Xy,
  android: /* @__PURE__ */ /Android\b/.test($t.userAgent),
  webkit: Zy,
  safari: rA,
  webkit_version: Zy ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: xp.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Lxe = 256;
class di extends Se {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof di) || this.length - (t - e) + i.length > Lxe || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new di(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new ut(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return Rxe(this.dom, e, t);
  }
}
class pi extends Se {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let r of t)
      r.setParent(this);
  }
  setAttrs(e) {
    if (XC(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof pi && i.mark.eq(this.mark)) || e && s <= 0 || t < this.length && o <= 0) ? !1 : (nA(this, e, t, i ? i.children : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, r = -1, s = 0;
    for (let l of this.children) {
      let a = i + l.length;
      a > e && t.push(i < e ? l.split(e - i) : l), r < 0 && i >= e && (r = s), i = a, s++;
    }
    let o = this.length - e;
    return this.length = e, r > -1 && (this.children.length = r, this.markDirty()), new pi(this.mark, t, o);
  }
  domAtPos(e) {
    return sA(this, e);
  }
  coordsAt(e, t) {
    return lA(this, e, t);
  }
}
function Rxe(n, e, t) {
  let i = n.nodeValue.length;
  e > i && (e = i);
  let r = e, s = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? H.chrome || H.gecko || (e ? (r--, o = 1) : s < i && (s++, o = -1)) : t < 0 ? r-- : s < i && s++;
  let l = Nr(n, r, s).getClientRects();
  if (!l.length)
    return null;
  let a = l[(o ? o < 0 : t >= 0) ? 0 : l.length - 1];
  return H.safari && !o && a.width == 0 && (a = Array.prototype.find.call(l, (c) => c.width) || a), o ? ym(a, o < 0) : a || null;
}
class gr extends Se {
  static create(e, t, i) {
    return new gr(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  split(e) {
    let t = gr.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof gr) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof gr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Z.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, r = this.posAtStart;
    return i ? i.slice(r, r + this.length) : Z.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? ut.before(this.dom) : ut.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let r = this.dom.getClientRects(), s = null;
    if (!r.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let l = o ? r.length - 1 : 0; s = r[l], !(e > 0 ? l == 0 : l == r.length - 1 || s.top < s.bottom); l += o ? -1 : 1)
      ;
    return ym(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Ws extends Se {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Ws && e.side == this.side;
  }
  split() {
    return new Ws(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? ut.before(this.dom) : ut.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Z.empty;
  }
  get isHidden() {
    return !0;
  }
}
di.prototype.children = gr.prototype.children = Ws.prototype.children = wm;
function sA(n, e) {
  let t = n.dom, { children: i } = n, r = 0;
  for (let s = 0; r < i.length; r++) {
    let o = i[r], l = s + o.length;
    if (!(l == s && o.getSide() <= 0)) {
      if (e > s && e < l && o.dom.parentNode == t)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = l;
    }
  }
  for (let s = r; s > 0; s--) {
    let o = i[s - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let s = r; s < i.length; s++) {
    let o = i[s];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new ut(t, 0);
}
function oA(n, e, t) {
  let i, { children: r } = n;
  t > 0 && e instanceof pi && r.length && (i = r[r.length - 1]) instanceof pi && i.mark.eq(e.mark) ? oA(i, e.children[0], t - 1) : (r.push(e), e.setParent(n)), n.length += e.length;
}
function lA(n, e, t) {
  let i = null, r = -1, s = null, o = -1;
  function l(c, h) {
    for (let u = 0, f = 0; u < c.children.length && f <= h; u++) {
      let d = c.children[u], p = f + d.length;
      p >= h && (d.children.length ? l(d, h - f) : (!s || s.isHidden && t > 0) && (p > h || f == p && d.getSide() > 0) ? (s = d, o = h - f) : (f < h || f == p && d.getSide() < 0 && !d.isHidden) && (i = d, r = h - f)), f = p;
    }
  }
  l(n, e);
  let a = (t < 0 ? i : s) || i || s;
  return a ? a.coordsAt(Math.max(0, a == i ? r : o), t) : Ixe(n);
}
function Ixe(n) {
  let e = n.dom.lastChild;
  if (!e)
    return n.dom.getBoundingClientRect();
  let t = Sl(e);
  return t[t.length - 1] || null;
}
function Sp(n, e) {
  for (let t in n)
    t == "class" && e.class ? e.class += " " + n.class : t == "style" && e.style ? e.style += ";" + n.style : e[t] = n[t];
  return e;
}
const Qy = /* @__PURE__ */ Object.create(null);
function vm(n, e, t) {
  if (n == e)
    return !0;
  n || (n = Qy), e || (e = Qy);
  let i = Object.keys(n), r = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != r.length - (t && r.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let s of i)
    if (s != t && (r.indexOf(s) == -1 || n[s] !== e[s]))
      return !1;
  return !0;
}
function Cp(n, e, t) {
  let i = !1;
  if (e)
    for (let r in e)
      t && r in t || (i = !0, r == "style" ? n.style.cssText = "" : n.removeAttribute(r));
  if (t)
    for (let r in t)
      e && e[r] == t[r] || (i = !0, r == "style" ? n.style.cssText = t[r] : n.setAttribute(r, t[r]));
  return i;
}
function Bxe(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < n.attributes.length; t++) {
    let i = n.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class We extends Se {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(e, t, i, r, s, o) {
    if (i) {
      if (!(i instanceof We))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return r && this.setDeco(i ? i.attrs : null), nA(this, e, t, i ? i.children : [], s, o), !0;
  }
  split(e) {
    let t = new We();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: r } = this.childPos(e);
    r && (t.append(this.children[i].split(r), 0), this.children[i].merge(r, this.children[i].length, null, !1, 0, 0), i++);
    for (let s = i; s < this.children.length; s++)
      t.append(this.children[s], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    !this.dom || (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    vm(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    oA(this, e, t);
  }
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = Sp(t, this.attrs || {})), i && (this.attrs = Sp({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return sA(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (XC(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Cp(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let r = this.dom.lastChild;
    for (; r && Se.get(r) instanceof pi; )
      r = r.lastChild;
    if (!r || !this.length || r.nodeName != "BR" && ((i = Se.get(r)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!H.ios || !this.children.some((s) => s instanceof di))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof di) || /[^ -~]/.test(i.text))
        return null;
      let r = Sl(i.dom);
      if (r.length != 1)
        return null;
      e += r[0].width, t = r[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = lA(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: r } = this.parent.view.viewState, s = i.bottom - i.top;
      if (Math.abs(s - r.lineHeight) < 2 && r.textHeight < s) {
        let o = (s - r.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, t) {
    for (let i = 0, r = 0; i < e.children.length; i++) {
      let s = e.children[i], o = r + s.length;
      if (o >= t) {
        if (s instanceof We)
          return s;
        if (o > t)
          break;
      }
      r = o + s.breakAfter;
    }
    return null;
  }
}
class $i extends Se {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.deco = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, r, s, o) {
    return i && (!(i instanceof $i) || !this.widget.compare(i.widget) || e > 0 && s <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? ut.before(this.dom) : ut.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new $i(this.widget, t, this.deco);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return wm;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Z.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof $i && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: t, endSide: i } = this.deco;
    return t == i ? !1 : e < 0 ? t < 0 : i > 0;
  }
}
class Vl {
  eq(e) {
    return !1;
  }
  updateDOM(e, t) {
    return !1;
  }
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(e) {
    return !0;
  }
  coordsAt(e, t, i) {
    return null;
  }
  get isHidden() {
    return !1;
  }
  destroy(e) {
  }
}
var fn = /* @__PURE__ */ function(n) {
  return n[n.Text = 0] = "Text", n[n.WidgetBefore = 1] = "WidgetBefore", n[n.WidgetAfter = 2] = "WidgetAfter", n[n.WidgetRange = 3] = "WidgetRange", n;
}(fn || (fn = {}));
class Fe extends ai {
  constructor(e, t, i, r) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = r;
  }
  get heightRelevant() {
    return !1;
  }
  static mark(e) {
    return new zl(e);
  }
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Ji(e, t, t, i, e.widget || null, !1);
  }
  static replace(e) {
    let t = !!e.block, i, r;
    if (e.isBlockGap)
      i = -5e8, r = 4e8;
    else {
      let { start: s, end: o } = aA(e, t);
      i = (s ? t ? -3e8 : -1 : 5e8) - 1, r = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Ji(e, i, r, t, e.widget || null, !0);
  }
  static line(e) {
    return new Ul(e);
  }
  static set(e, t = !1) {
    return W.of(e, t);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Fe.none = W.empty;
class zl extends Fe {
  constructor(e) {
    let { start: t, end: i } = aA(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof zl && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && vm(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
zl.prototype.point = !1;
class Ul extends Fe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Ul && this.spec.class == e.spec.class && vm(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Ul.prototype.mapMode = qe.TrackBefore;
Ul.prototype.point = !0;
class Ji extends Fe {
  constructor(e, t, i, r, s, o) {
    super(t, i, s, e), this.block = r, this.isReplace = o, this.mapMode = r ? t <= 0 ? qe.TrackBefore : qe.TrackAfter : qe.TrackDel;
  }
  get type() {
    return this.startSide != this.endSide ? fn.WidgetRange : this.startSide <= 0 ? fn.WidgetBefore : fn.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Ji && Nxe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Ji.prototype.point = !0;
function aA(n, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = n;
  return t == null && (t = n.inclusive), i == null && (i = n.inclusive), { start: t != null ? t : e, end: i != null ? i : e };
}
function Nxe(n, e) {
  return n == e || !!(n && e && n.compare(e));
}
function Ap(n, e, t, i = 0) {
  let r = t.length - 1;
  r >= 0 && t[r] + i >= n ? t[r] = Math.max(t[r], e) : t.push(n, e);
}
class Uo {
  constructor(e, t, i, r) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = r, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof $i && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new We()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ma(new Ws(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof $i) && this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let r = Math.min(this.text.length - this.textOff, e, 512);
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(Ma(new di(this.text.slice(this.textOff, this.textOff + r)), t), i), this.atCursorPos = !0, this.textOff += r, e -= r, i = 0;
    }
  }
  span(e, t, i, r) {
    this.buildText(t - e, i, r), this.pos = t, this.openStart < 0 && (this.openStart = r);
  }
  point(e, t, i, r, s, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Ji) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = t - e;
    if (i instanceof Ji)
      if (i.block)
        i.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new $i(i.widget || new ew("div"), l, i));
      else {
        let a = gr.create(i.widget || new ew("span"), l, l ? 0 : i.startSide), c = this.atCursorPos && !a.isEditable && s <= r.length && (e < t || i.startSide > 0), h = !a.isEditable && (e < t || s > r.length || i.startSide <= 0), u = this.getLine();
        this.pendingBuffer == 2 && !c && !a.isEditable && (this.pendingBuffer = 0), this.flushBuffer(r), c && (u.append(Ma(new Ws(1), r), s), s = r.length + Math.max(0, s - r.length)), u.append(Ma(a, r), s), this.atCursorPos = h, this.pendingBuffer = h ? e < t || s > r.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = r.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, t, i, r, s) {
    let o = new Uo(e, t, i, s);
    return o.openEnd = W.spans(r, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Ma(n, e) {
  for (let t of e)
    n = new pi(t, [n], n.length);
  return n;
}
class ew extends Vl {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const cA = /* @__PURE__ */ E.define(), hA = /* @__PURE__ */ E.define(), uA = /* @__PURE__ */ E.define(), fA = /* @__PURE__ */ E.define(), Dp = /* @__PURE__ */ E.define(), dA = /* @__PURE__ */ E.define(), pA = /* @__PURE__ */ E.define(), gA = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
}), Pxe = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
});
class Ss {
  constructor(e, t = "nearest", i = "nearest", r = 5, s = 5, o = !1) {
    this.range = e, this.y = t, this.x = i, this.yMargin = r, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new Ss(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new Ss(S.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Oa = /* @__PURE__ */ G.define({ map: (n, e) => n.map(e) });
function _r(n, e, t) {
  let i = n.facet(fA);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const ou = /* @__PURE__ */ E.define({ combine: (n) => n.length ? n[0] : !0 });
let Fxe = 0;
const Do = /* @__PURE__ */ E.define();
class Pr {
  constructor(e, t, i, r, s) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.domEventObservers = r, this.extension = s(this);
  }
  static define(e, t) {
    const { eventHandlers: i, eventObservers: r, provide: s, decorations: o } = t || {};
    return new Pr(Fxe++, e, i, r, (l) => {
      let a = [Do.of(l)];
      return o && a.push(Al.of((c) => {
        let h = c.plugin(l);
        return h ? o(h) : Fe.none;
      })), s && a.push(s(l)), a;
    });
  }
  static fromClass(e, t) {
    return Pr.define((i) => new e(i), t);
  }
}
class Tf {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (_r(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        _r(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        _r(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const mA = /* @__PURE__ */ E.define(), xm = /* @__PURE__ */ E.define(), Al = /* @__PURE__ */ E.define(), km = /* @__PURE__ */ E.define(), bA = /* @__PURE__ */ E.define();
function tw(n, e, t) {
  let i = n.state.facet(bA);
  if (!i.length)
    return i;
  let r = i.map((o) => o instanceof Function ? o(n) : o), s = [];
  return W.spans(r, e, t, {
    point() {
    },
    span(o, l, a, c) {
      let h = s;
      for (let u = a.length - 1; u >= 0; u--, c--) {
        let f = a[u].spec.bidiIsolate, d;
        if (f != null)
          if (c > 0 && h.length && (d = h[h.length - 1]).to == o && d.direction == f)
            d.to = l, h = d.inner;
          else {
            let p = { from: o, to: l, direction: f, inner: [] };
            h.push(p), h = p.inner;
          }
      }
    }
  }), s;
}
const yA = /* @__PURE__ */ E.define();
function wA(n) {
  let e = 0, t = 0, i = 0, r = 0;
  for (let s of n.state.facet(yA)) {
    let o = s(n);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (r = Math.max(r, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: r };
}
const Eo = /* @__PURE__ */ E.define();
class Jt {
  constructor(e, t, i, r) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = r;
  }
  join(e) {
    return new Jt(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let r = e[t - 1];
      if (!(r.fromA > i.toA)) {
        if (r.toA < i.fromA)
          break;
        i = i.join(r), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let r = 0, s = 0, o = 0, l = 0; ; r++) {
      let a = r == e.length ? null : e[r], c = o - l, h = a ? a.fromB : 1e9;
      for (; s < t.length && t[s] < h; ) {
        let u = t[s], f = t[s + 1], d = Math.max(l, u), p = Math.min(h, f);
        if (d <= p && new Jt(d + c, p + c, d, p).addToSet(i), f > h)
          break;
        s += 2;
      }
      if (!a)
        return i;
      new Jt(a.fromA, a.toA, a.fromB, a.toB).addToSet(i), o = a.toA, l = a.toB;
    }
  }
}
class dh {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Oe.empty(this.startState.doc.length);
    for (let s of i)
      this.changes = this.changes.compose(s.changes);
    let r = [];
    this.changes.iterChangedRanges((s, o, l, a) => r.push(new Jt(s, o, l, a))), this.changedRanges = r;
  }
  static create(e, t, i) {
    return new dh(e, t, i);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var dt = /* @__PURE__ */ function(n) {
  return n[n.LTR = 0] = "LTR", n[n.RTL = 1] = "RTL", n;
}(dt || (dt = {}));
const Dl = dt.LTR, vA = dt.RTL;
function xA(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    e.push(1 << +n[t]);
  return e;
}
const $xe = /* @__PURE__ */ xA("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Hxe = /* @__PURE__ */ xA("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ep = /* @__PURE__ */ Object.create(null), Cn = [];
for (let n of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ n.charCodeAt(0), t = /* @__PURE__ */ n.charCodeAt(1);
  Ep[e] = t, Ep[t] = -e;
}
function qxe(n) {
  return n <= 247 ? $xe[n] : 1424 <= n && n <= 1524 ? 2 : 1536 <= n && n <= 1785 ? Hxe[n - 1536] : 1774 <= n && n <= 2220 ? 4 : 8192 <= n && n <= 8203 ? 256 : 64336 <= n && n <= 65023 ? 4 : n == 8204 ? 256 : 1;
}
const Vxe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ii {
  get dir() {
    return this.level % 2 ? vA : Dl;
  }
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  static find(e, t, i, r) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let l = e[o];
      if (l.from <= t && l.to >= t) {
        if (l.level == i)
          return o;
        (s < 0 || (r != 0 ? r < 0 ? l.from < t : l.to > t : e[s].level > l.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function kA(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++) {
    let i = n[t], r = e[t];
    if (i.from != r.from || i.to != r.to || i.direction != r.direction || !kA(i.inner, r.inner))
      return !1;
  }
  return !0;
}
const fe = [];
function zxe(n, e, t, i, r) {
  for (let s = 0; s <= i.length; s++) {
    let o = s ? i[s - 1].to : e, l = s < i.length ? i[s].from : t, a = s ? 256 : r;
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = qxe(n.charCodeAt(c));
      f == 512 ? f = h : f == 8 && u == 4 && (f = 16), fe[c] = f == 4 ? 2 : f, f & 7 && (u = f), h = f;
    }
    for (let c = o, h = a, u = a; c < l; c++) {
      let f = fe[c];
      if (f == 128)
        c < l - 1 && h == fe[c + 1] && h & 24 ? f = fe[c] = h : fe[c] = 256;
      else if (f == 64) {
        let d = c + 1;
        for (; d < l && fe[d] == 64; )
          d++;
        let p = c && h == 8 || d < t && fe[d] == 8 ? u == 1 ? 1 : 8 : 256;
        for (let g = c; g < d; g++)
          fe[g] = p;
        c = d - 1;
      } else
        f == 8 && u == 1 && (fe[c] = 1);
      h = f, f & 7 && (u = f);
    }
  }
}
function Uxe(n, e, t, i, r) {
  let s = r == 1 ? 2 : 1;
  for (let o = 0, l = 0, a = 0; o <= i.length; o++) {
    let c = o ? i[o - 1].to : e, h = o < i.length ? i[o].from : t;
    for (let u = c, f, d, p; u < h; u++)
      if (d = Ep[f = n.charCodeAt(u)])
        if (d < 0) {
          for (let g = l - 3; g >= 0; g -= 3)
            if (Cn[g + 1] == -d) {
              let m = Cn[g + 2], b = m & 2 ? r : m & 4 ? m & 1 ? s : r : 0;
              b && (fe[u] = fe[Cn[g]] = b), l = g;
              break;
            }
        } else {
          if (Cn.length == 189)
            break;
          Cn[l++] = u, Cn[l++] = f, Cn[l++] = a;
        }
      else if ((p = fe[u]) == 2 || p == 1) {
        let g = p == r;
        a = g ? 0 : 1;
        for (let m = l - 3; m >= 0; m -= 3) {
          let b = Cn[m + 2];
          if (b & 2)
            break;
          if (g)
            Cn[m + 2] |= 2;
          else {
            if (b & 4)
              break;
            Cn[m + 2] |= 4;
          }
        }
      }
  }
}
function Wxe(n, e, t, i) {
  for (let r = 0, s = i; r <= t.length; r++) {
    let o = r ? t[r - 1].to : n, l = r < t.length ? t[r].from : e;
    for (let a = o; a < l; ) {
      let c = fe[a];
      if (c == 256) {
        let h = a + 1;
        for (; ; )
          if (h == l) {
            if (r == t.length)
              break;
            h = t[r++].to, l = r < t.length ? t[r].from : e;
          } else if (fe[h] == 256)
            h++;
          else
            break;
        let u = s == 1, f = (h < e ? fe[h] : i) == 1, d = u == f ? u ? 1 : 2 : i;
        for (let p = h, g = r, m = g ? t[g - 1].to : n; p > a; )
          p == m && (p = t[--g].from, m = g ? t[g - 1].to : n), fe[--p] = d;
        a = h;
      } else
        s = c, a++;
    }
  }
}
function Tp(n, e, t, i, r, s, o) {
  let l = i % 2 ? 2 : 1;
  if (i % 2 == r % 2)
    for (let a = e, c = 0; a < t; ) {
      let h = !0, u = !1;
      if (c == s.length || a < s[c].from) {
        let g = fe[a];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? i : i + 1, p = a;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (u)
              break e;
            let g = s[c];
            if (!h)
              for (let m = g.to, b = c + 1; ; ) {
                if (m == t)
                  break e;
                if (b < s.length && s[b].from == m)
                  m = s[b++].to;
                else {
                  if (fe[m] == l)
                    break e;
                  break;
                }
              }
            if (c++, f)
              f.push(g);
            else {
              g.from > a && o.push(new Ii(a, g.from, d));
              let m = g.direction == Dl != !(d % 2);
              Mp(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), a = g.to;
            }
            p = g.to;
          } else {
            if (p == t || (h ? fe[p] != l : fe[p] == l))
              break;
            p++;
          }
      f ? Tp(n, a, p, i + 1, r, f, o) : a < p && o.push(new Ii(a, p, d)), a = p;
    }
  else
    for (let a = t, c = s.length; a > e; ) {
      let h = !0, u = !1;
      if (!c || a > s[c - 1].to) {
        let g = fe[a - 1];
        g != l && (h = !1, u = g == 16);
      }
      let f = !h && l == 1 ? [] : null, d = h ? i : i + 1, p = a;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (u)
              break e;
            let g = s[--c];
            if (!h)
              for (let m = g.from, b = c; ; ) {
                if (m == e)
                  break e;
                if (b && s[b - 1].to == m)
                  m = s[--b].from;
                else {
                  if (fe[m - 1] == l)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < a && o.push(new Ii(g.to, a, d));
              let m = g.direction == Dl != !(d % 2);
              Mp(n, m ? i + 1 : i, r, g.inner, g.from, g.to, o), a = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (h ? fe[p - 1] != l : fe[p - 1] == l))
              break;
            p--;
          }
      f ? Tp(n, p, a, i + 1, r, f, o) : p < a && o.push(new Ii(p, a, d)), a = p;
    }
}
function Mp(n, e, t, i, r, s, o) {
  let l = e % 2 ? 2 : 1;
  zxe(n, r, s, i, l), Uxe(n, r, s, i, l), Wxe(r, s, i, l), Tp(n, r, s, e, t, i, o);
}
function jxe(n, e, t) {
  if (!n)
    return [new Ii(0, 0, e == vA ? 1 : 0)];
  if (e == Dl && !t.length && !Vxe.test(n))
    return _A(n.length);
  if (t.length)
    for (; n.length > fe.length; )
      fe[fe.length] = 256;
  let i = [], r = e == Dl ? 0 : 1;
  return Mp(n, r, r, t, 0, n.length, i), i;
}
function _A(n) {
  return [new Ii(0, n, 0)];
}
let SA = "";
function Gxe(n, e, t, i, r) {
  var s;
  let o = i.head - n.from, l = -1;
  if (o == 0) {
    if (!r || !n.length)
      return null;
    e[0].level != t && (o = e[0].side(!1, t), l = 0);
  } else if (o == n.length) {
    if (r)
      return null;
    let f = e[e.length - 1];
    f.level != t && (o = f.side(!0, t), l = e.length - 1);
  }
  l < 0 && (l = Ii.find(e, o, (s = i.bidiLevel) !== null && s !== void 0 ? s : -1, i.assoc));
  let a = e[l];
  o == a.side(r, t) && (a = e[l += r ? 1 : -1], o = a.side(!r, t));
  let c = r == (a.dir == t), h = Le(n.text, o, c);
  if (SA = n.text.slice(Math.min(o, h), Math.max(o, h)), h != a.side(r, t))
    return S.cursor(h + n.from, c ? -1 : 1, a.level);
  let u = l == (r ? e.length - 1 : 0) ? null : e[l + (r ? 1 : -1)];
  return !u && a.level != t ? S.cursor(r ? n.to : n.from, r ? -1 : 1, t) : u && u.level < a.level ? S.cursor(u.side(!r, t) + n.from, r ? 1 : -1, u.level) : S.cursor(h + n.from, r ? -1 : 1, a.level);
}
class nw extends Se {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new We()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Jt(0, 0, 0, e.state.doc.length)], 0, null);
  }
  update(e) {
    var t;
    let i = e.changedRanges;
    this.minWidth > 0 && i.length && (i.every(({ fromA: c, toA: h }) => h < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let r = -1;
    this.view.inputState.composing >= 0 && (!((t = this.domChanged) === null || t === void 0) && t.newSel ? r = this.domChanged.newSel.head : !eke(e.changes, this.hasComposition) && !e.selectionSet && (r = e.state.selection.main.head));
    let s = r > -1 ? Yxe(this.view, e.changes, r) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: h } = this.hasComposition;
      i = new Jt(c, h, e.changes.mapPos(c, -1), e.changes.mapPos(h, 1)).addToSet(i.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (H.ie || H.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, l = this.updateDeco(), a = Xxe(o, l, e.changes);
    return i = Jt.extendWithRanges(i, a), !(this.flags & 7) && i.length == 0 ? !1 : (this.updateInner(i, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: r } = this.view;
    r.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = H.chrome || H.ios ? { node: r.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || r.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach((o) => o.flags &= -9);
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof $i && o.widget instanceof iw && s.push(o.dom);
    r.updateGaps(s);
  }
  updateChildren(e, t, i) {
    let r = i ? i.range.addToSet(e.slice()) : e, s = this.childCursor(t);
    for (let o = r.length - 1; ; o--) {
      let l = o >= 0 ? r[o] : null;
      if (!l)
        break;
      let { fromA: a, toA: c, fromB: h, toB: u } = l, f, d, p, g;
      if (i && i.range.fromB < u && i.range.toB > h) {
        let w = Uo.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), x = Uo.build(this.view.state.doc, i.range.toB, u, this.decorations, this.dynamicDecorationMap);
        d = w.breakAtStart, p = w.openStart, g = x.openEnd;
        let v = this.compositionView(i);
        x.breakAtStart ? v.breakAfter = 1 : x.content.length && v.merge(v.length, v.length, x.content[0], !1, x.openStart, 0) && (v.breakAfter = x.content[0].breakAfter, x.content.shift()), w.content.length && v.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat(v).concat(x.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = Uo.build(this.view.state.doc, h, u, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: b } = s.findPos(c, 1), { i: y, off: k } = s.findPos(a, -1);
      tA(this, y, k, m, b, f, d, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new di(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: r } of e.marks)
      t = new pi(r, [t], t.length);
    let i = new We();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (s, o) => {
      o.flags |= 8 | (o.children.some((a) => a.flags & 7) ? 1 : 0), this.markedForComposition.add(o);
      let l = Se.get(s);
      l && l != o && (l.dom = null), o.setDOM(s);
    }, i = this.childPos(e.range.fromB, 1), r = this.children[i.i];
    t(e.line, r);
    for (let s = e.marks.length - 1; s >= -1; s--)
      i = r.childPos(i.off, 1), r = r.children[i.i], t(s >= 0 ? e.marks[s].node : e.text, r);
  }
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, r = i == this.dom, s = !r && fc(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(r || t || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let l = this.view.state.selection.main, a = this.moveToLine(this.domAtPos(l.anchor)), c = l.empty ? a : this.moveToLine(this.domAtPos(l.head));
    if (H.gecko && l.empty && !this.hasComposition && Kxe(a)) {
      let u = document.createTextNode("");
      this.view.observer.ignore(() => a.node.insertBefore(u, a.node.childNodes[a.offset] || null)), a = c = new ut(u, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || !fh(a.node, a.offset, h.anchorNode, h.anchorOffset) || !fh(c.node, c.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      H.android && H.chrome && this.dom.contains(h.focusNode) && Qxe(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let u = uh(this.view.root);
      if (u)
        if (l.empty) {
          if (H.gecko) {
            let f = Jxe(a.node, a.offset);
            if (f && f != 3) {
              let d = AA(a.node, a.offset, f == 1 ? 1 : -1);
              d && (a = new ut(d.node, d.offset));
            }
          }
          u.collapse(a.node, a.offset), l.bidiLevel != null && u.caretBidiLevel !== void 0 && (u.caretBidiLevel = l.bidiLevel);
        } else if (u.extend) {
          u.collapse(a.node, a.offset);
          try {
            u.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          l.anchor > l.head && ([a, c] = [c, a]), f.setEnd(c.node, c.offset), f.setStart(a.node, a.offset), u.removeAllRanges(), u.addRange(f);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(a, c)), this.impreciseAnchor = a.precise ? null : new ut(h.anchorNode, h.anchorOffset), this.impreciseHead = c.precise ? null : new ut(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = uh(e.root), { anchorNode: r, anchorOffset: s } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = We.find(this, t.head);
    if (!o)
      return;
    let l = o.posAtStart;
    if (t.head == l || t.head == l + o.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    i.collapse(h.node, h.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let u = e.observer.selectionRange;
    e.docView.posFromDOM(u.anchorNode, u.anchorOffset) != t.from && i.collapse(r, s);
  }
  moveToLine(e) {
    let t = this.dom, i;
    if (e.node != t)
      return e;
    for (let r = e.offset; !i && r < t.childNodes.length; r++) {
      let s = Se.get(t.childNodes[r]);
      s instanceof We && (i = s.domAtPos(0));
    }
    for (let r = e.offset - 1; !i && r >= 0; r--) {
      let s = Se.get(t.childNodes[r]);
      s instanceof We && (i = s.domAtPos(s.length));
    }
    return i ? new ut(i.node, i.offset, !0) : e;
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = Se.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let r = this.children[t];
      if (i < r.length || r instanceof We)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    let i = null, r = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let l = this.children[o], a = s - l.breakAfter, c = a - l.length;
      if (a < e)
        break;
      c <= e && (c < e || l.covers(-1)) && (a > e || l.covers(1)) && (!i || l instanceof We && !(i instanceof We && t >= 0)) && (i = l, r = c), s = c;
    }
    return i ? i.coordsAt(e - r, t) : null;
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), r = this.children[t];
    if (!(r instanceof We))
      return null;
    for (; r.children.length; ) {
      let { i: l, off: a } = r.childPos(i, 1);
      for (; ; l++) {
        if (l == r.children.length)
          return null;
        if ((r = r.children[l]).length)
          break;
      }
      i = a;
    }
    if (!(r instanceof di))
      return null;
    let s = Le(r.text, i);
    if (s == i)
      return null;
    let o = Nr(r.dom, i, s).getClientRects();
    for (let l = 0; l < o.length; l++) {
      let a = o[l];
      if (l == o.length - 1 || a.top < a.bottom && a.left < a.right)
        return a;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: r } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, a = this.view.textDirection == dt.LTR;
    for (let c = 0, h = 0; h < this.children.length; h++) {
      let u = this.children[h], f = c + u.length;
      if (f > r)
        break;
      if (c >= i) {
        let d = u.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = u.dom.lastChild, g = p ? Sl(p) : [];
          if (g.length) {
            let m = g[g.length - 1], b = a ? m.right - d.left : d.right - m.left;
            b > l && (l = b, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + u.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? dt.RTL : dt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof We) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, r;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Sl(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = s ? s.width / 27 : 7, r = s ? s.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: r };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new eA(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, r = 0; ; r++) {
      let s = r == t.viewports.length ? null : t.viewports[r], o = s ? s.from - 1 : this.length;
      if (o > i) {
        let l = (t.lineBlockAt(o).bottom - t.lineBlockAt(i).top) / this.view.scaleY;
        e.push(Fe.replace({
          widget: new iw(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!s)
        break;
      i = s.to + 1;
    }
    return Fe.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Al).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), r;
    if (!i)
      return;
    !t.empty && (r = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, r.left),
      top: Math.min(i.top, r.top),
      right: Math.max(i.right, r.right),
      bottom: Math.max(i.bottom, r.bottom)
    });
    let s = wA(this.view), o = {
      left: i.left - s.left,
      top: i.top - s.top,
      right: i.right + s.right,
      bottom: i.bottom + s.bottom
    }, { offsetWidth: l, offsetHeight: a } = this.view.scrollDOM;
    Dxe(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, l), -l), Math.max(Math.min(e.yMargin, a), -a), this.view.textDirection == dt.LTR);
  }
}
function Kxe(n) {
  return n.node.nodeType == 1 && n.node.firstChild && (n.offset == 0 || n.node.childNodes[n.offset - 1].contentEditable == "false") && (n.offset == n.node.childNodes.length || n.node.childNodes[n.offset].contentEditable == "false");
}
class iw extends Vl {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function CA(n, e) {
  let t = n.observer.selectionRange, i = t.focusNode && AA(t.focusNode, t.focusOffset, 0);
  if (!i)
    return null;
  let r = e - i.offset;
  return { from: r, to: r + i.node.nodeValue.length, node: i.node };
}
function Yxe(n, e, t) {
  let i = CA(n, t);
  if (!i)
    return null;
  let { node: r, from: s, to: o } = i, l = r.nodeValue;
  if (/[\n\r]/.test(l) || n.state.doc.sliceString(i.from, i.to) != l)
    return null;
  let a = e.invertedDesc, c = new Jt(a.mapPos(s), a.mapPos(o), s, o), h = [];
  for (let u = r.parentNode; ; u = u.parentNode) {
    let f = Se.get(u);
    if (f instanceof pi)
      h.push({ node: u, deco: f.mark });
    else {
      if (f instanceof We || u.nodeName == "DIV" && u.parentNode == n.contentDOM)
        return { range: c, text: r, marks: h, line: u };
      if (u != n.contentDOM)
        h.push({ node: u, deco: new zl({
          inclusive: !0,
          attributes: Bxe(u),
          tagName: u.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function AA(n, e, t) {
  if (t <= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: r };
      if (i.nodeType == 1 && r > 0)
        i = i.childNodes[r - 1], r = fi(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = n, r = e; ; ) {
      if (i.nodeType == 3)
        return { node: i, offset: r };
      if (i.nodeType == 1 && r < i.childNodes.length && t >= 0)
        i = i.childNodes[r], r = 0;
      else
        break;
    }
  return null;
}
function Jxe(n, e) {
  return n.nodeType != 1 ? 0 : (e && n.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < n.childNodes.length && n.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let Zxe = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    Ap(e, t, this.changes);
  }
  comparePoint(e, t) {
    Ap(e, t, this.changes);
  }
};
function Xxe(n, e, t) {
  let i = new Zxe();
  return W.compare(n, e, t, i), i.changes;
}
function Qxe(n, e) {
  for (let t = n; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function eke(n, e) {
  let t = !1;
  return e && n.iterChangedRanges((i, r) => {
    i < e.to && r > e.from && (t = !0);
  }), t;
}
function tke(n, e, t = 1) {
  let i = n.charCategorizer(e), r = n.doc.lineAt(e), s = e - r.from;
  if (r.length == 0)
    return S.cursor(e);
  s == 0 ? t = 1 : s == r.length && (t = -1);
  let o = s, l = s;
  t < 0 ? o = Le(r.text, s, !1) : l = Le(r.text, s);
  let a = i(r.text.slice(o, l));
  for (; o > 0; ) {
    let c = Le(r.text, o, !1);
    if (i(r.text.slice(c, o)) != a)
      break;
    o = c;
  }
  for (; l < r.length; ) {
    let c = Le(r.text, l);
    if (i(r.text.slice(l, c)) != a)
      break;
    l = c;
  }
  return S.range(o + r.from, l + r.from);
}
function nke(n, e) {
  return e.left > n ? e.left - n : Math.max(0, n - e.right);
}
function ike(n, e) {
  return e.top > n ? e.top - n : Math.max(0, n - e.bottom);
}
function Mf(n, e) {
  return n.top < e.bottom - 1 && n.bottom > e.top + 1;
}
function rw(n, e) {
  return e < n.top ? { top: e, left: n.left, right: n.right, bottom: n.bottom } : n;
}
function sw(n, e) {
  return e > n.bottom ? { top: n.top, left: n.left, right: n.right, bottom: e } : n;
}
function Op(n, e, t) {
  let i, r, s, o, l = !1, a, c, h, u;
  for (let p = n.firstChild; p; p = p.nextSibling) {
    let g = Sl(p);
    for (let m = 0; m < g.length; m++) {
      let b = g[m];
      r && Mf(r, b) && (b = rw(sw(b, r.bottom), r.top));
      let y = nke(e, b), k = ike(t, b);
      if (y == 0 && k == 0)
        return p.nodeType == 3 ? ow(p, e, t) : Op(p, e, t);
      if (!i || o > k || o == k && s > y) {
        i = p, r = b, s = y, o = k;
        let w = k ? t < b.top ? -1 : 1 : y ? e < b.left ? -1 : 1 : 0;
        l = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      y == 0 ? t > b.bottom && (!h || h.bottom < b.bottom) ? (a = p, h = b) : t < b.top && (!u || u.top > b.top) && (c = p, u = b) : h && Mf(h, b) ? h = sw(h, b.bottom) : u && Mf(u, b) && (u = rw(u, b.top));
    }
  }
  if (h && h.bottom >= t ? (i = a, r = h) : u && u.top <= t && (i = c, r = u), !i)
    return { node: n, offset: 0 };
  let f = Math.max(r.left, Math.min(r.right, e));
  if (i.nodeType == 3)
    return ow(i, f, t);
  if (l && i.contentEditable != "false")
    return Op(i, f, t);
  let d = Array.prototype.indexOf.call(n.childNodes, i) + (e >= (r.left + r.right) / 2 ? 1 : 0);
  return { node: n, offset: d };
}
function ow(n, e, t) {
  let i = n.nodeValue.length, r = -1, s = 1e9, o = 0;
  for (let l = 0; l < i; l++) {
    let a = Nr(n, l, l + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let h = a[c];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let u = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && u < s) {
        let f = e >= (h.left + h.right) / 2, d = f;
        if ((H.chrome || H.gecko) && Nr(n, l).getBoundingClientRect().left == h.right && (d = !f), u <= 0)
          return { node: n, offset: l + (d ? 1 : 0) };
        r = l + (d ? 1 : 0), s = u;
      }
    }
  }
  return { node: n, offset: r > -1 ? r : o > 0 ? n.nodeValue.length : 0 };
}
function DA(n, e, t, i = -1) {
  var r, s;
  let o = n.contentDOM.getBoundingClientRect(), l = o.top + n.viewState.paddingTop, a, { docHeight: c } = n.viewState, { x: h, y: u } = e, f = u - l;
  if (f < 0)
    return 0;
  if (f > c)
    return n.state.doc.length;
  for (let w = n.viewState.heightOracle.textHeight / 2, x = !1; a = n.elementAtHeight(f), a.type != fn.Text; )
    for (; f = i > 0 ? a.bottom + w : a.top - w, !(f >= 0 && f <= c); ) {
      if (x)
        return t ? null : 0;
      x = !0, i = -i;
    }
  u = l + f;
  let d = a.from;
  if (d < n.viewport.from)
    return n.viewport.from == 0 ? 0 : t ? null : lw(n, o, a, h, u);
  if (d > n.viewport.to)
    return n.viewport.to == n.state.doc.length ? n.state.doc.length : t ? null : lw(n, o, a, h, u);
  let p = n.dom.ownerDocument, g = n.root.elementFromPoint ? n.root : p, m = g.elementFromPoint(h, u);
  m && !n.contentDOM.contains(m) && (m = null), m || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), m = g.elementFromPoint(h, u), m && !n.contentDOM.contains(m) && (m = null));
  let b, y = -1;
  if (m && ((r = n.docView.nearest(m)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(h, u);
      w && ({ offsetNode: b, offset: y } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(h, u);
      w && ({ startContainer: b, startOffset: y } = w, (!n.contentDOM.contains(b) || H.safari && rke(b, y, h) || H.chrome && ske(b, y, h)) && (b = void 0));
    }
  }
  if (!b || !n.docView.dom.contains(b)) {
    let w = We.find(n.docView, d);
    if (!w)
      return f > a.top + a.height / 2 ? a.to : a.from;
    ({ node: b, offset: y } = Op(w.dom, h, u));
  }
  let k = n.docView.nearest(b);
  if (!k)
    return null;
  if (k.isWidget && ((s = k.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = k.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? k.posAtStart : k.posAtEnd;
  } else
    return k.localPosFromDOM(b, y) + k.posAtStart;
}
function lw(n, e, t, i, r) {
  let s = Math.round((i - e.left) * n.defaultCharacterWidth);
  if (n.lineWrapping && t.height > n.defaultLineHeight * 1.5) {
    let l = n.viewState.heightOracle.textHeight, a = Math.floor((r - t.top - (n.defaultLineHeight - l) * 0.5) / l);
    s += a * n.viewState.heightOracle.lineLength;
  }
  let o = n.state.sliceDoc(t.from, t.to);
  return t.from + Oc(o, s, n.state.tabSize);
}
function rke(n, e, t) {
  let i;
  if (n.nodeType != 3 || e != (i = n.nodeValue.length))
    return !1;
  for (let r = n.nextSibling; r; r = r.nextSibling)
    if (r.nodeType != 1 || r.nodeName != "BR")
      return !1;
  return Nr(n, i - 1, i).getBoundingClientRect().left > t;
}
function ske(n, e, t) {
  if (e != 0)
    return !1;
  for (let r = n; ; ) {
    let s = r.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != r)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    r = s;
  }
  let i = n.nodeType == 1 ? n.getBoundingClientRect() : Nr(n, 0, Math.max(n.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function oke(n, e) {
  let t = n.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == fn.Text))
        return i;
  }
  return t;
}
function lke(n, e, t, i) {
  let r = oke(n, e.head), s = !i || r.type != fn.Text || !(n.lineWrapping || r.widgetLineBreaks) ? null : n.coordsAtPos(e.assoc < 0 && e.head > r.from ? e.head - 1 : e.head);
  if (s) {
    let o = n.dom.getBoundingClientRect(), l = n.textDirectionAt(r.from), a = n.posAtCoords({
      x: t == (l == dt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (a != null)
      return S.cursor(a, t ? -1 : 1);
  }
  return S.cursor(t ? r.to : r.from, t ? -1 : 1);
}
function aw(n, e, t, i) {
  let r = n.state.doc.lineAt(e.head), s = n.bidiSpans(r), o = n.textDirectionAt(r.from);
  for (let l = e, a = null; ; ) {
    let c = Gxe(r, s, o, l, t), h = SA;
    if (!c) {
      if (r.number == (t ? n.state.doc.lines : 1))
        return l;
      h = `
`, r = n.state.doc.line(r.number + (t ? 1 : -1)), s = n.bidiSpans(r), c = S.cursor(t ? r.from : r.to);
    }
    if (a) {
      if (!a(h))
        return l;
    } else {
      if (!i)
        return c;
      a = i(h);
    }
    l = c;
  }
}
function ake(n, e, t) {
  let i = n.state.charCategorizer(e), r = i(t);
  return (s) => {
    let o = i(s);
    return r == Ce.Space && (r = o), r == o;
  };
}
function cke(n, e, t, i) {
  let r = e.head, s = t ? 1 : -1;
  if (r == (t ? n.state.doc.length : 0))
    return S.cursor(r, e.assoc);
  let o = e.goalColumn, l, a = n.contentDOM.getBoundingClientRect(), c = n.coordsAtPos(r, e.assoc || -1), h = n.documentTop;
  if (c)
    o == null && (o = c.left - a.left), l = s < 0 ? c.top : c.bottom;
  else {
    let d = n.viewState.lineBlockAt(r);
    o == null && (o = Math.min(a.right - a.left, n.defaultCharacterWidth * (r - d.from))), l = (s < 0 ? d.top : d.bottom) + h;
  }
  let u = a.left + o, f = i != null ? i : n.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (f + d) * s, g = DA(n, { x: u, y: p }, !1, s);
    if (p < a.top || p > a.bottom || (s < 0 ? g < r : g > r)) {
      let m = n.docView.coordsForChar(g), b = !m || p < m.top ? -1 : 1;
      return S.cursor(g, b, void 0, o);
    }
  }
}
function dc(n, e, t) {
  for (; ; ) {
    let i = 0;
    for (let r of n)
      r.between(e - 1, e + 1, (s, o, l) => {
        if (e > s && e < o) {
          let a = i || t || (e - s < o - e ? -1 : 1);
          e = a < 0 ? s : o, i = a;
        }
      });
    if (!i)
      return e;
  }
}
function Of(n, e, t) {
  let i = dc(n.state.facet(km).map((r) => r(n)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : S.cursor(i, i < t.from ? 1 : -1);
}
class hke {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, H.safari && e.contentDOM.addEventListener("input", () => null), H.gecko && Dke(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !wke(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, t) {
    let i = this.handlers[e];
    if (i) {
      for (let r of i.observers)
        r(this.view, t);
      for (let r of i.handlers) {
        if (t.defaultPrevented)
          break;
        if (r(this.view, t)) {
          t.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let t = uke(e), i = this.handlers, r = this.view.contentDOM;
    for (let s in t)
      if (s != "scroll") {
        let o = !t[s].handlers.length, l = i[s];
        l && o != !l.handlers.length && (r.removeEventListener(s, this.handleEvent), l = null), l || r.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in i)
      s != "scroll" && !t[s] && r.removeEventListener(s, this.handleEvent);
    this.handlers = t;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && dke.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), H.android && H.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let t;
    return H.ios && !e.synthetic && !e.altKey && !e.metaKey && ((t = EA.find((i) => i.keyCode == e.keyCode)) && !e.ctrlKey || fke.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = t || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, _s(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : H.safari && !H.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function cw(n, e) {
  return (t, i) => {
    try {
      return e.call(n, i, t);
    } catch (r) {
      _r(t.state, r);
    }
  };
}
function uke(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(i) {
    return e[i] || (e[i] = { observers: [], handlers: [] });
  }
  for (let i of n) {
    let r = i.spec;
    if (r && r.domEventHandlers)
      for (let s in r.domEventHandlers) {
        let o = r.domEventHandlers[s];
        o && t(s).handlers.push(cw(i.value, o));
      }
    if (r && r.domEventObservers)
      for (let s in r.domEventObservers) {
        let o = r.domEventObservers[s];
        o && t(s).observers.push(cw(i.value, o));
      }
  }
  for (let i in mn)
    t(i).handlers.push(mn[i]);
  for (let i in bn)
    t(i).observers.push(bn[i]);
  return e;
}
const EA = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], fke = "dthko", dke = [16, 17, 18, 20, 91, 92, 224, 225], La = 6;
function Ra(n) {
  return Math.max(0, n) * 0.7 + 8;
}
function pke(n, e) {
  return Math.max(Math.abs(n.clientX - e.clientX), Math.abs(n.clientY - e.clientY));
}
class gke {
  constructor(e, t, i, r) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = r, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = Exe(e.contentDOM), this.atoms = e.state.facet(km).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(J.allowMultipleSelections) && mke(e, t), this.dragging = yke(e, t) && LA(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && pke(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, r = 0, s = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = wA(this.view);
    e.clientX - o.left <= s.left + La ? i = -Ra(s.left - e.clientX) : e.clientX + o.right >= s.right - La && (i = Ra(e.clientX - s.right)), e.clientY - o.top <= s.top + La ? r = -Ra(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - La && (r = Ra(e.clientY - s.bottom)), this.setScrollSpeed(i, r);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let r = e.ranges[i], s = null;
      if (r.empty) {
        let o = dc(this.atoms, r.from, 0);
        o != r.from && (s = S.cursor(o, -1));
      } else {
        let o = dc(this.atoms, r.from, -1), l = dc(this.atoms, r.to, 1);
        (o != r.from || l != r.to) && (s = S.range(r.from == r.anchor ? o : l, r.from == r.head ? o : l));
      }
      s && (t || (t = e.ranges.slice()), t[i] = s);
    }
    return t ? S.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection) || i.main.assoc != t.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function mke(n, e) {
  let t = n.state.facet(cA);
  return t.length ? t[0](e) : H.mac ? e.metaKey : e.ctrlKey;
}
function bke(n, e) {
  let t = n.state.facet(hA);
  return t.length ? t[0](e) : H.mac ? !e.altKey : !e.ctrlKey;
}
function yke(n, e) {
  let { main: t } = n.state.selection;
  if (t.empty)
    return !1;
  let i = uh(n.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let r = i.getRangeAt(0).getClientRects();
  for (let s = 0; s < r.length; s++) {
    let o = r[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function wke(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != n.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = Se.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const mn = /* @__PURE__ */ Object.create(null), bn = /* @__PURE__ */ Object.create(null), TA = H.ie && H.ie_version < 15 || H.ios && H.webkit_version < 604;
function vke(n) {
  let e = n.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    n.focus(), t.remove(), MA(n, t.value);
  }, 50);
}
function MA(n, e) {
  let { state: t } = n, i, r = 1, s = t.toText(e), o = s.lines == t.selection.ranges.length;
  if (Lp != null && t.selection.ranges.every((a) => a.empty) && Lp == s.toString()) {
    let a = -1;
    i = t.changeByRange((c) => {
      let h = t.doc.lineAt(c.from);
      if (h.from == a)
        return { range: c };
      a = h.from;
      let u = t.toText((o ? s.line(r++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: u },
        range: S.cursor(c.from + u.length)
      };
    });
  } else
    o ? i = t.changeByRange((a) => {
      let c = s.line(r++);
      return {
        changes: { from: a.from, to: a.to, insert: c.text },
        range: S.cursor(a.from + c.length)
      };
    }) : i = t.replaceSelection(s);
  n.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
bn.scroll = (n) => {
  n.inputState.lastScrollTop = n.scrollDOM.scrollTop, n.inputState.lastScrollLeft = n.scrollDOM.scrollLeft;
};
mn.keydown = (n, e) => (n.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (n.inputState.lastEscPress = Date.now()), !1);
bn.touchstart = (n, e) => {
  n.inputState.lastTouchTime = Date.now(), n.inputState.setSelectionOrigin("select.pointer");
};
bn.touchmove = (n) => {
  n.inputState.setSelectionOrigin("select.pointer");
};
mn.mousedown = (n, e) => {
  if (n.observer.flush(), n.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let t = null;
  for (let i of n.state.facet(uA))
    if (t = i(n, e), t)
      break;
  if (!t && e.button == 0 && (t = _ke(n, e)), t) {
    let i = !n.hasFocus;
    n.inputState.startMouseSelection(new gke(n, e, t, i)), i && n.observer.ignore(() => ZC(n.contentDOM));
    let r = n.inputState.mouseSelection;
    if (r)
      return r.start(e), r.dragging === !1;
  }
  return !1;
};
function hw(n, e, t, i) {
  if (i == 1)
    return S.cursor(e, t);
  if (i == 2)
    return tke(n.state, e, t);
  {
    let r = We.find(n.docView, e), s = n.state.doc.lineAt(r ? r.posAtEnd : e), o = r ? r.posAtStart : s.from, l = r ? r.posAtEnd : s.to;
    return l < n.state.doc.length && l == s.to && l++, S.range(o, l);
  }
}
let OA = (n, e) => n >= e.top && n <= e.bottom, uw = (n, e, t) => OA(e, t) && n >= t.left && n <= t.right;
function xke(n, e, t, i) {
  let r = We.find(n.docView, e);
  if (!r)
    return 1;
  let s = e - r.posAtStart;
  if (s == 0)
    return 1;
  if (s == r.length)
    return -1;
  let o = r.coordsAt(s, -1);
  if (o && uw(t, i, o))
    return -1;
  let l = r.coordsAt(s, 1);
  return l && uw(t, i, l) ? 1 : o && OA(i, o) ? -1 : 1;
}
function fw(n, e) {
  let t = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: xke(n, t, e.clientX, e.clientY) };
}
const kke = H.ie && H.ie_version <= 11;
let dw = null, pw = 0, gw = 0;
function LA(n) {
  if (!kke)
    return n.detail;
  let e = dw, t = gw;
  return dw = n, gw = Date.now(), pw = !e || t > Date.now() - 400 && Math.abs(e.clientX - n.clientX) < 2 && Math.abs(e.clientY - n.clientY) < 2 ? (pw + 1) % 3 : 1;
}
function _ke(n, e) {
  let t = fw(n, e), i = LA(e), r = n.state.selection;
  return {
    update(s) {
      s.docChanged && (t.pos = s.changes.mapPos(t.pos), r = r.map(s.changes));
    },
    get(s, o, l) {
      let a = fw(n, s), c, h = hw(n, a.pos, a.bias, i);
      if (t.pos != a.pos && !o) {
        let u = hw(n, t.pos, t.bias, i), f = Math.min(u.from, h.from), d = Math.max(u.to, h.to);
        h = f < h.from ? S.range(f, d) : S.range(d, f);
      }
      return o ? r.replaceRange(r.main.extend(h.from, h.to)) : l && i == 1 && r.ranges.length > 1 && (c = Ske(r, a.pos)) ? c : l ? r.addRange(h) : S.create([h]);
    }
  };
}
function Ske(n, e) {
  for (let t = 0; t < n.ranges.length; t++) {
    let { from: i, to: r } = n.ranges[t];
    if (i <= e && r >= e)
      return S.create(n.ranges.slice(0, t).concat(n.ranges.slice(t + 1)), n.mainIndex == t ? 0 : n.mainIndex - (n.mainIndex > t ? 1 : 0));
  }
  return null;
}
mn.dragstart = (n, e) => {
  let { selection: { main: t } } = n.state;
  if (e.target.draggable) {
    let r = n.docView.nearest(e.target);
    if (r && r.isWidget) {
      let s = r.posAtStart, o = s + r.length;
      (s >= t.to || o <= t.from) && (t = S.range(s, o));
    }
  }
  let { inputState: i } = n;
  return i.mouseSelection && (i.mouseSelection.dragging = !0), i.draggedContent = t, e.dataTransfer && (e.dataTransfer.setData("Text", n.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
mn.dragend = (n) => (n.inputState.draggedContent = null, !1);
function mw(n, e, t, i) {
  if (!t)
    return;
  let r = n.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = n.inputState, o = i && s && bke(n, e) ? { from: s.from, to: s.to } : null, l = { from: r, insert: t }, a = n.state.changes(o ? [o, l] : l);
  n.focus(), n.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(r, -1), head: a.mapPos(r, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), n.inputState.draggedContent = null;
}
mn.drop = (n, e) => {
  if (!e.dataTransfer)
    return !1;
  if (n.state.readOnly)
    return !0;
  let t = e.dataTransfer.files;
  if (t && t.length) {
    let i = Array(t.length), r = 0, s = () => {
      ++r == t.length && mw(n, e, i.filter((o) => o != null).join(n.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let l = new FileReader();
      l.onerror = s, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result), s();
      }, l.readAsText(t[o]);
    }
    return !0;
  } else {
    let i = e.dataTransfer.getData("Text");
    if (i)
      return mw(n, e, i, !0), !0;
  }
  return !1;
};
mn.paste = (n, e) => {
  if (n.state.readOnly)
    return !0;
  n.observer.flush();
  let t = TA ? null : e.clipboardData;
  return t ? (MA(n, t.getData("text/plain") || t.getData("text/uri-text")), !0) : (vke(n), !1);
};
function Cke(n, e) {
  let t = n.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), n.focus();
  }, 50);
}
function Ake(n) {
  let e = [], t = [], i = !1;
  for (let r of n.selection.ranges)
    r.empty || (e.push(n.sliceDoc(r.from, r.to)), t.push(r));
  if (!e.length) {
    let r = -1;
    for (let { from: s } of n.selection.ranges) {
      let o = n.doc.lineAt(s);
      o.number > r && (e.push(o.text), t.push({ from: o.from, to: Math.min(n.doc.length, o.to + 1) })), r = o.number;
    }
    i = !0;
  }
  return { text: e.join(n.lineBreak), ranges: t, linewise: i };
}
let Lp = null;
mn.copy = mn.cut = (n, e) => {
  let { text: t, ranges: i, linewise: r } = Ake(n.state);
  if (!t && !r)
    return !1;
  Lp = r ? t : null, e.type == "cut" && !n.state.readOnly && n.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = TA ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", t), !0) : (Cke(n, t), !1);
};
const RA = /* @__PURE__ */ nn.define();
function IA(n, e) {
  let t = [];
  for (let i of n.facet(pA)) {
    let r = i(n, e);
    r && t.push(r);
  }
  return t ? n.update({ effects: t, annotations: RA.of(!0) }) : null;
}
function BA(n) {
  setTimeout(() => {
    let e = n.hasFocus;
    if (e != n.inputState.notifiedFocused) {
      let t = IA(n.state, e);
      t ? n.dispatch(t) : n.update([]);
    }
  }, 10);
}
bn.focus = (n) => {
  n.inputState.lastFocusTime = Date.now(), !n.scrollDOM.scrollTop && (n.inputState.lastScrollTop || n.inputState.lastScrollLeft) && (n.scrollDOM.scrollTop = n.inputState.lastScrollTop, n.scrollDOM.scrollLeft = n.inputState.lastScrollLeft), BA(n);
};
bn.blur = (n) => {
  n.observer.clearSelectionRange(), BA(n);
};
bn.compositionstart = bn.compositionupdate = (n) => {
  n.inputState.compositionFirstChange == null && (n.inputState.compositionFirstChange = !0), n.inputState.composing < 0 && (n.inputState.composing = 0);
};
bn.compositionend = (n) => {
  n.inputState.composing = -1, n.inputState.compositionEndedAt = Date.now(), n.inputState.compositionPendingKey = !0, n.inputState.compositionPendingChange = n.observer.pendingRecords().length > 0, n.inputState.compositionFirstChange = null, H.chrome && H.android ? n.observer.flushSoon() : n.inputState.compositionPendingChange ? Promise.resolve().then(() => n.observer.flush()) : setTimeout(() => {
    n.inputState.composing < 0 && n.docView.hasComposition && n.update([]);
  }, 50);
};
bn.contextmenu = (n) => {
  n.inputState.lastContextMenu = Date.now();
};
mn.beforeinput = (n, e) => {
  var t;
  let i;
  if (H.chrome && H.android && (i = EA.find((r) => r.inputType == e.inputType)) && (n.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let r = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > r + 10 && n.hasFocus && (n.contentDOM.blur(), n.focus());
    }, 100);
  }
  return !1;
};
const bw = /* @__PURE__ */ new Set();
function Dke(n) {
  bw.has(n) || (bw.add(n), n.addEventListener("copy", () => {
  }), n.addEventListener("cut", () => {
  }));
}
const yw = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Eke {
  constructor(e) {
    this.lineWrapping = e, this.doc = Z.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return yw.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i];
      r < 0 ? i++ : this.heightSamples[Math.floor(r * 10)] || (t = !0, this.heightSamples[Math.floor(r * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, r, s, o) {
    let l = yw.indexOf(e) > -1, a = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != l;
    if (this.lineWrapping = l, this.lineHeight = t, this.charWidth = i, this.textHeight = r, this.lineLength = s, a) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let h = o[c];
        h < 0 ? c++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return a;
  }
}
class Tke {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class On {
  constructor(e, t, i, r, s) {
    this.from = e, this.length = t, this.top = i, this.height = r, this._content = s;
  }
  get type() {
    return typeof this._content == "number" ? fn.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof Ji ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new On(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var ke = /* @__PURE__ */ function(n) {
  return n[n.ByPos = 0] = "ByPos", n[n.ByHeight = 1] = "ByHeight", n[n.ByPosNoHeight = 2] = "ByPosNoHeight", n;
}(ke || (ke = {}));
const pc = 1e-3;
class _t {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > pc && (e.heightChanged = !0), this.height = t);
  }
  replace(e, t, i) {
    return _t.of(i);
  }
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, r) {
    let s = this, o = i.doc;
    for (let l = r.length - 1; l >= 0; l--) {
      let { fromA: a, toA: c, fromB: h, toB: u } = r[l], f = s.lineAt(a, ke.ByPosNoHeight, i.setDoc(t), 0, 0), d = f.to >= c ? f : s.lineAt(c, ke.ByPosNoHeight, i, 0, 0);
      for (u += d.to - c, c = d.to; l > 0 && f.from <= r[l - 1].toA; )
        a = r[l - 1].fromA, h = r[l - 1].fromB, l--, a < f.from && (f = s.lineAt(a, ke.ByPosNoHeight, i, 0, 0));
      h += f.from - a, a = f.from;
      let p = _m.build(i.setDoc(o), e, h, u);
      s = s.replace(a, c, p);
    }
    return s.updateHeight(i, 0);
  }
  static empty() {
    return new Nt(0, 0);
  }
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, r = 0, s = 0;
    for (; ; )
      if (t == i)
        if (r > s * 2) {
          let l = e[t - 1];
          l.break ? e.splice(--t, 1, l.left, null, l.right) : e.splice(--t, 1, l.left, l.right), i += 1 + l.break, r -= l.size;
        } else if (s > r * 2) {
          let l = e[i];
          l.break ? e.splice(i, 1, l.left, null, l.right) : e.splice(i, 1, l.left, l.right), i += 2 + l.break, s -= l.size;
        } else
          break;
      else if (r < s) {
        let l = e[t++];
        l && (r += l.size);
      } else {
        let l = e[--i];
        l && (s += l.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new Mke(_t.of(e.slice(0, t)), o, _t.of(e.slice(i)));
  }
}
_t.prototype.size = 1;
class NA extends _t {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, r) {
    return new On(r, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, r, s) {
    return this.blockAt(0, i, r, s);
  }
  forEachLine(e, t, i, r, s, o) {
    e <= s + this.length && t >= s && o(this.blockAt(0, i, r, s));
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more && this.setHeight(e, r.heights[r.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Nt extends NA {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, r) {
    return new On(r, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let r = i[0];
    return i.length == 1 && (r instanceof Nt || r instanceof et && r.flags & 4) && Math.abs(this.length - r.length) < 10 ? (r instanceof et ? r = new Nt(r.length, this.height) : r.height = this.height, this.outdated || (r.outdated = !1), r) : _t.of(i);
  }
  updateHeight(e, t = 0, i = !1, r) {
    return r && r.from <= t && r.more ? this.setHeight(e, r.heights[r.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class et extends _t {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, r = e.doc.lineAt(t + this.length).number, s = r - i + 1, o, l = 0;
    if (e.lineWrapping) {
      let a = Math.min(this.height, e.lineHeight * s);
      o = a / s, this.length > s + 1 && (l = (this.height - a) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: i, lastLine: r, perLine: o, perChar: l };
  }
  blockAt(e, t, i, r) {
    let { firstLine: s, lastLine: o, perLine: l, perChar: a } = this.heightMetrics(t, r);
    if (t.lineWrapping) {
      let c = r + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), h = t.doc.lineAt(c), u = l + h.length * a, f = Math.max(i, e - u / 2);
      return new On(h.from, h.length, f, u, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - i) / l))), { from: h, length: u } = t.doc.line(s + c);
      return new On(h, u, i + l * c, l, 0);
    }
  }
  lineAt(e, t, i, r, s) {
    if (t == ke.ByHeight)
      return this.blockAt(e, i, r, s);
    if (t == ke.ByPosNoHeight) {
      let { from: d, to: p } = i.doc.lineAt(e);
      return new On(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: l, perChar: a } = this.heightMetrics(i, s), c = i.doc.lineAt(e), h = l + c.length * a, u = c.number - o, f = r + l * u + a * (c.from - s - u);
    return new On(c.from, c.length, Math.max(r, Math.min(f, r + this.height - h)), h, 0);
  }
  forEachLine(e, t, i, r, s, o) {
    e = Math.max(e, s), t = Math.min(t, s + this.length);
    let { firstLine: l, perLine: a, perChar: c } = this.heightMetrics(i, s);
    for (let h = e, u = r; h <= t; ) {
      let f = i.doc.lineAt(h);
      if (h == e) {
        let p = f.number - l;
        u += a * p + c * (e - s - p);
      }
      let d = a + c * f.length;
      o(new On(f.from, f.length, u, d, 0)), u += d, h = f.to + 1;
    }
  }
  replace(e, t, i) {
    let r = this.length - t;
    if (r > 0) {
      let s = i[i.length - 1];
      s instanceof et ? i[i.length - 1] = new et(s.length + r) : i.push(null, new et(r - 1));
    }
    if (e > 0) {
      let s = i[0];
      s instanceof et ? i[0] = new et(e + s.length) : i.unshift(new et(e - 1), null);
    }
    return _t.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new et(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new et(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, r) {
    let s = t + this.length;
    if (r && r.from <= t + this.length && r.more) {
      let o = [], l = Math.max(t, r.from), a = -1;
      for (r.from > t && o.push(new et(r.from - t - 1).updateHeight(e, t)); l <= s && r.more; ) {
        let h = e.doc.lineAt(l).length;
        o.length && o.push(null);
        let u = r.heights[r.index++];
        a == -1 ? a = u : Math.abs(u - a) >= pc && (a = -2);
        let f = new Nt(h, u);
        f.outdated = !1, o.push(f), l += h + 1;
      }
      l <= s && o.push(null, new et(s - l).updateHeight(e, l));
      let c = _t.of(o);
      return (a < 0 || Math.abs(c.height - this.height) >= pc || Math.abs(a - this.heightMetrics(e, t).perLine) >= pc) && (e.heightChanged = !0), c;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Mke extends _t {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, r) {
    let s = i + this.left.height;
    return e < s ? this.left.blockAt(e, t, i, r) : this.right.blockAt(e, t, s, r + this.left.length + this.break);
  }
  lineAt(e, t, i, r, s) {
    let o = r + this.left.height, l = s + this.left.length + this.break, a = t == ke.ByHeight ? e < o : e < l, c = a ? this.left.lineAt(e, t, i, r, s) : this.right.lineAt(e, t, i, o, l);
    if (this.break || (a ? c.to < l : c.from > l))
      return c;
    let h = t == ke.ByPosNoHeight ? ke.ByPosNoHeight : ke.ByPos;
    return a ? c.join(this.right.lineAt(l, h, i, o, l)) : this.left.lineAt(l, h, i, r, s).join(c);
  }
  forEachLine(e, t, i, r, s, o) {
    let l = r + this.left.height, a = s + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, i, r, s, o), t >= a && this.right.forEachLine(e, t, i, l, a, o);
    else {
      let c = this.lineAt(a, ke.ByPos, i, r, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, i, r, s, o), c.to >= e && c.from <= t && o(c), t > c.to && this.right.forEachLine(c.to + 1, t, i, l, a, o);
    }
  }
  replace(e, t, i) {
    let r = this.left.length + this.break;
    if (t < r)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - r, t - r, i));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let l of i)
      s.push(l);
    if (e > 0 && ww(s, o - 1), t < this.length) {
      let l = s.length;
      this.decomposeRight(t, s), ww(s, l);
    }
    return _t.of(s);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, r = i + this.break;
    if (e >= r)
      return this.right.decomposeRight(e - r, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < r && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? _t.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, r) {
    let { left: s, right: o } = this, l = t + s.length + this.break, a = null;
    return r && r.from <= t + s.length && r.more ? a = s = s.updateHeight(e, t, i, r) : s.updateHeight(e, t, i), r && r.from <= l + o.length && r.more ? a = o = o.updateHeight(e, l, i, r) : o.updateHeight(e, l, i), a ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function ww(n, e) {
  let t, i;
  n[e] == null && (t = n[e - 1]) instanceof et && (i = n[e + 1]) instanceof et && n.splice(e - 1, 3, new et(t.length + 1 + i.length));
}
const Oke = 5;
class _m {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), r = this.nodes[this.nodes.length - 1];
      r instanceof Nt ? r.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Nt(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let r = i.widget ? i.widget.estimatedHeight : 0, s = i.widget ? i.widget.lineBreaks : 0;
      r < 0 && (r = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new NA(o, r, i)) : (o || s || r >= Oke) && this.addLineDeco(r, s, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Nt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new et(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Nt)
      return e;
    let t = new Nt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine();
    let t = e.deco;
    t && t.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, t && t.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let r = this.ensureLine();
    r.length += i, r.collapsed += i, r.widgetHeight = Math.max(r.widgetHeight, e), r.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Nt) && !this.isCovered ? this.nodes.push(new Nt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let r of this.nodes)
      r instanceof Nt && r.updateHeight(this.oracle, i), i += r ? r.length : 1;
    return this.nodes;
  }
  static build(e, t, i, r) {
    let s = new _m(i, e);
    return W.spans(t, i, r, s, 0), s.finish(i);
  }
}
function Lke(n, e, t) {
  let i = new Rke();
  return W.compare(n, e, t, i, 0), i.changes;
}
class Rke {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, r) {
    (e < t || i && i.heightRelevant || r && r.heightRelevant) && Ap(e, t, this.changes, 5);
  }
}
function Ike(n, e) {
  let t = n.getBoundingClientRect(), i = n.ownerDocument, r = i.defaultView || window, s = Math.max(0, t.left), o = Math.min(r.innerWidth, t.right), l = Math.max(0, t.top), a = Math.min(r.innerHeight, t.bottom);
  for (let c = n.parentNode; c && c != i.body; )
    if (c.nodeType == 1) {
      let h = c, u = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && u.overflow != "visible") {
        let f = h.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), l = Math.max(l, f.top), a = c == n.parentNode ? f.bottom : Math.min(a, f.bottom);
      }
      c = u.position == "absolute" || u.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - t.left,
    right: Math.max(s, o) - t.left,
    top: l - (t.top + e),
    bottom: Math.max(l, a) - (t.top + e)
  };
}
function Bke(n, e) {
  let t = n.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class Lf {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let r = e[i], s = t[i];
      if (r.from != s.from || r.to != s.to || r.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, t) {
    return Fe.replace({
      widget: new Nke(this.size * (t ? e.scaleY : e.scaleX), t)
    }).range(this.from, this.to);
  }
}
class Nke extends Vl {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class vw {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = xw, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = dt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(xm).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Eke(t), this.stateDeco = e.facet(Al).filter((i) => typeof i != "function"), this.heightMap = _t.empty().applyChanges(this.stateDeco, Z.empty, this.heightOracle.setDoc(e.doc), [new Jt(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Fe.set(this.lineGaps.map((i) => i.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let r = i ? t.head : t.anchor;
      if (!e.some(({ from: s, to: o }) => r >= s && r <= o)) {
        let { from: s, to: o } = this.lineBlockAt(r);
        e.push(new Ia(s, o));
      }
    }
    this.viewports = e.sort((i, r) => i.from - r.from), this.scaler = this.heightMap.height <= 7e6 ? xw : new $ke(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : To(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Al).filter((h) => typeof h != "function");
    let r = e.changedRanges, s = Jt.extendWithRanges(r, Lke(i, this.stateDeco, e ? e.changes : Oe.empty(this.state.doc.length))), o = this.heightMap.height, l = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), l ? (this.scrollAnchorPos = e.changes.mapPos(l.from, -1), this.scrollAnchorHeight = l.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let a = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < a.from || t.range.head > a.to) || !this.viewportIsAppropriate(a)) && (a = this.getViewport(0, t));
    let c = !e.changes.empty || e.flags & 2 || a.from != this.viewport.from || a.to != this.viewport.to;
    this.viewport = a, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Pxe) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), r = this.heightOracle, s = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? dt.RTL : dt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), l = t.getBoundingClientRect(), a = o || this.mustMeasureContent || this.contentDOMHeight != l.height;
    this.contentDOMHeight = l.height, this.mustMeasureContent = !1;
    let c = 0, h = 0;
    if (l.width && l.height) {
      let w = l.width / t.offsetWidth, x = l.height / t.offsetHeight;
      (w > 0.995 && w < 1.005 || !isFinite(w) || Math.abs(l.width - t.offsetWidth) < 1) && (w = 1), (x > 0.995 && x < 1.005 || !isFinite(x) || Math.abs(l.height - t.offsetHeight) < 1) && (x = 1), (this.scaleX != w || this.scaleY != x) && (this.scaleX = w, this.scaleY = x, c |= 8, o = a = !0);
    }
    let u = (parseInt(i.paddingTop) || 0) * this.scaleY, f = (parseInt(i.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != u || this.paddingBottom != f) && (this.paddingTop = u, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (r.lineWrapping && (a = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let d = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != d && (this.scrollAnchorHeight = -1, this.scrollTop = d), this.scrolledToBottom = QC(e.scrollDOM);
    let p = (this.printing ? Bke : Ike)(t, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (a = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let y = l.width;
    if ((this.contentDOMWidth != y || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = l.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), a) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (r.mustRefreshForHeights(w) && (o = !0), o || r.lineWrapping && Math.abs(y - this.contentDOMWidth) > r.charWidth) {
        let { lineHeight: x, charWidth: v, textHeight: C } = e.docView.measureTextSize();
        o = x > 0 && r.refresh(s, x, v, C, y / v, w), o && (e.docView.minWidth = 0, c |= 8);
      }
      g > 0 && m > 0 ? h = Math.max(g, m) : g < 0 && m < 0 && (h = Math.min(g, m)), r.heightChanged = !1;
      for (let x of this.viewports) {
        let v = x.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(x);
        this.heightMap = (o ? _t.empty().applyChanges(this.stateDeco, Z.empty, this.heightOracle, [new Jt(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(r, 0, o, new Tke(x.from, v));
      }
      r.heightChanged && (c |= 2);
    }
    let k = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return k && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (c & 2 || k) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), r = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: l } = this, a = new Ia(r.lineAt(o - i * 1e3, ke.ByHeight, s, 0, 0).from, r.lineAt(l + (1 - i) * 1e3, ke.ByHeight, s, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), u = r.lineAt(c, ke.ByPos, s, 0, 0), f;
        t.y == "center" ? f = (u.top + u.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? f = u.top : f = u.bottom - h, a = new Ia(r.lineAt(f - 1e3 / 2, ke.ByHeight, s, 0, 0).from, r.lineAt(f + h + 1e3 / 2, ke.ByHeight, s, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), r = t.mapPos(e.to, 1);
    return new Ia(this.heightMap.lineAt(i, ke.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(r, ke.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: r } = this.heightMap.lineAt(e, ke.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(t, ke.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (e == 0 || r <= o - Math.max(10, Math.min(-i, 250))) && (t == this.state.doc.length || s >= l + Math.max(10, Math.min(i, 250))) && r > o - 2 * 1e3 && s < l + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let r of e)
      t.touchesRange(r.from, r.to) || i.push(new Lf(t.mapPos(r.from), t.mapPos(r.to), r.size));
    return i;
  }
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, r = i ? 1e4 : 2e3, s = r >> 1, o = r << 1;
    if (this.defaultTextDirection != dt.LTR && !i)
      return [];
    let l = [], a = (c, h, u, f) => {
      if (h - c < s)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let m of p)
        if (m > c && m < h) {
          a(c, m - 10, u, f), a(m + 10, h, u, f);
          return;
        }
      let g = Fke(e, (m) => m.from >= u.from && m.to <= u.to && Math.abs(m.from - c) < s && Math.abs(m.to - h) < s && !p.some((b) => m.from < b && m.to > b));
      if (!g) {
        if (h < u.to && t && i && t.visibleRanges.some((m) => m.from <= h && m.to >= h)) {
          let m = t.moveToLineBoundary(S.cursor(h), !1, !0).head;
          m > c && (h = m);
        }
        g = new Lf(c, h, this.gapSize(u, c, h, f));
      }
      l.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let h = Pke(c.from, c.to, this.stateDeco);
      if (h.total < o)
        continue;
      let u = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (i) {
        let p = r / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (u != null) {
          let b = Na(h, u), y = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          g = b - y, m = b + y;
        } else
          g = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        f = Ba(h, g), d = Ba(h, m);
      } else {
        let p = h.total * this.heightOracle.charWidth, g = r * this.heightOracle.charWidth, m, b;
        if (u != null) {
          let y = Na(h, u), k = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = y - k, b = y + k;
        } else
          m = (this.pixelViewport.left - g) / p, b = (this.pixelViewport.right + g) / p;
        f = Ba(h, m), d = Ba(h, b);
      }
      f > c.from && a(c.from, f, c, h), d < c.to && a(d, c.to, c, h);
    }
    return l;
  }
  gapSize(e, t, i, r) {
    let s = Na(r, i) - Na(r, t);
    return this.heightOracle.lineWrapping ? e.height * s : r.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Lf.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Fe.set(e.map((t) => t.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    W.spans(e, this.viewport.from, this.viewport.to, {
      span(r, s) {
        t.push({ from: r, to: s });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((r, s) => r.from != t[s].from || r.to != t[s].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || To(this.heightMap.lineAt(e, ke.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return To(this.heightMap.lineAt(this.scaler.fromDOM(e), ke.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return To(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Ia {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function Pke(n, e, t) {
  let i = [], r = n, s = 0;
  return W.spans(t, n, e, {
    span() {
    },
    point(o, l) {
      o > r && (i.push({ from: r, to: o }), s += o - r), r = l;
    }
  }, 20), r < e && (i.push({ from: r, to: e }), s += e - r), { total: s, ranges: i };
}
function Ba({ total: n, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(n * t);
  for (let r = 0; ; r++) {
    let { from: s, to: o } = e[r], l = o - s;
    if (i <= l)
      return s + i;
    i -= l;
  }
}
function Na(n, e) {
  let t = 0;
  for (let { from: i, to: r } of n.ranges) {
    if (e <= r) {
      t += e - i;
      break;
    }
    t += r - i;
  }
  return t / n.total;
}
function Fke(n, e) {
  for (let t of n)
    if (e(t))
      return t;
}
const xw = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class $ke {
  constructor(e, t, i) {
    let r = 0, s = 0, o = 0;
    this.viewports = i.map(({ from: l, to: a }) => {
      let c = t.lineAt(l, ke.ByPos, e, 0, 0).top, h = t.lineAt(a, ke.ByPos, e, 0, 0).bottom;
      return r += h - c, { from: l, to: a, top: c, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - r) / (t.height - r);
    for (let l of this.viewports)
      l.domTop = o + (l.top - s) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), s = l.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.top)
        return r + (e - i) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      i = s.bottom, r = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, r = 0; ; t++) {
      let s = t < this.viewports.length ? this.viewports[t] : null;
      if (!s || e < s.domTop)
        return i + (e - r) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      i = s.bottom, r = s.domBottom;
    }
  }
}
function To(n, e) {
  if (e.scale == 1)
    return n;
  let t = e.toDOM(n.top), i = e.toDOM(n.bottom);
  return new On(n.from, n.length, t, i - t, Array.isArray(n._content) ? n._content.map((r) => To(r, e)) : n._content);
}
const Pa = /* @__PURE__ */ E.define({ combine: (n) => n.join(" ") }), Rp = /* @__PURE__ */ E.define({ combine: (n) => n.indexOf(!0) > -1 }), Ip = /* @__PURE__ */ Ct.newName(), PA = /* @__PURE__ */ Ct.newName(), FA = /* @__PURE__ */ Ct.newName(), $A = { "&light": "." + PA, "&dark": "." + FA };
function Bp(n, e, t) {
  return new Ct(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (r) => {
        if (r == "&")
          return n;
        if (!t || !t[r])
          throw new RangeError(`Unsupported selector: ${r}`);
        return t[r];
      }) : n + " " + i;
    }
  });
}
const Hke = /* @__PURE__ */ Bp("." + Ip, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, $A), Mo = "\uFFFF";
class qke {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(J.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Mo;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let r = e; ; ) {
      this.findPointBefore(i, r);
      let s = this.text.length;
      this.readNode(r);
      let o = r.nextSibling;
      if (o == t)
        break;
      let l = Se.get(r), a = Se.get(o);
      (l && a ? l.breakAfter : (l ? l.breakAfter : kw(r)) || kw(o) && (r.nodeName != "BR" || r.cmIgnore) && this.text.length > s) && this.lineBreak(), r = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, r = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, l;
      if (this.lineSeparator ? (s = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (l = r.exec(t)) && (s = l.index, o = l[0].length), this.append(t.slice(i, s < 0 ? t.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= o - 1);
      i = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Se.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let r = i.iter(); !r.next().done; )
        r.lineBreak ? this.lineBreak() : this.append(r.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + (Vke(e, i.node, i.offset) ? t : 0));
  }
}
function Vke(n, e, t) {
  for (; ; ) {
    if (!e || t < fi(e))
      return !1;
    if (e == n)
      return !0;
    t = Cl(e) + 1, e = e.parentNode;
  }
}
function kw(n) {
  return n.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(n.nodeName);
}
class _w {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class zke {
  constructor(e, t, i, r) {
    this.typeOver = r, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let l = s || o ? [] : jke(e), a = new qke(l, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = Gke(l, this.bounds.from);
    } else {
      let l = e.observer.selectionRange, a = s && s.node == l.focusNode && s.offset == l.focusOffset || !vp(e.contentDOM, l.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(l.focusNode, l.focusOffset), c = o && o.node == l.anchorNode && o.offset == l.anchorOffset || !vp(e.contentDOM, l.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(l.anchorNode, l.anchorOffset);
      this.newSel = S.single(c, a);
    }
  }
}
function HA(n, e) {
  let t, { newSel: i } = e, r = n.state.selection.main, s = n.inputState.lastKeyTime > Date.now() - 100 ? n.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: l } = e.bounds, a = r.from, c = null;
    (s === 8 || H.android && e.text.length < l - o) && (a = r.to, c = "end");
    let h = Wke(n.state.doc.sliceString(o, l, Mo), e.text, a - o, c);
    h && (H.chrome && s == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Mo + Mo && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: Z.of(e.text.slice(h.from, h.toB).split(Mo))
    });
  } else
    i && (!n.hasFocus && n.state.facet(ou) || i.main.eq(r)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !r.empty && i && i.main.empty ? t = { from: r.from, to: r.to, insert: n.state.doc.slice(r.from, r.to) } : t && t.from >= r.from && t.to <= r.to && (t.from != r.from || t.to != r.to) && r.to - r.from - (t.to - t.from) <= 4 ? t = {
    from: r.from,
    to: r.to,
    insert: n.state.doc.slice(r.from, t.from).append(t.insert).append(n.state.doc.slice(t.to, r.to))
  } : (H.mac || H.android) && t && t.from == t.to && t.from == r.head - 1 && /^\. ?$/.test(t.insert.toString()) && n.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: Z.of([" "]) }) : H.chrome && t && t.from == t.to && t.from == r.head && t.insert.toString() == `
 ` && n.lineWrapping && (i && (i = S.single(i.main.anchor - 1, i.main.head - 1)), t = { from: r.from, to: r.to, insert: Z.of([" "]) }), t) {
    if (H.ios && n.inputState.flushIOSKey() || H.android && (t.from == r.from && t.to == r.to && t.insert.length == 1 && t.insert.lines == 2 && _s(n.contentDOM, "Enter", 13) || (t.from == r.from - 1 && t.to == r.to && t.insert.length == 0 || s == 8 && t.insert.length < t.to - t.from && t.to > r.head) && _s(n.contentDOM, "Backspace", 8) || t.from == r.from && t.to == r.to + 1 && t.insert.length == 0 && _s(n.contentDOM, "Delete", 46)))
      return !0;
    let o = t.insert.toString();
    n.inputState.composing >= 0 && n.inputState.composing++;
    let l, a = () => l || (l = Uke(n, t, i));
    return n.state.facet(dA).some((c) => c(n, t.from, t.to, o, a)) || n.dispatch(a()), !0;
  } else if (i && !i.main.eq(r)) {
    let o = !1, l = "select";
    return n.inputState.lastSelectionTime > Date.now() - 50 && (n.inputState.lastSelectionOrigin == "select" && (o = !0), l = n.inputState.lastSelectionOrigin), n.dispatch({ selection: i, scrollIntoView: o, userEvent: l }), !0;
  } else
    return !1;
}
function Uke(n, e, t) {
  let i, r = n.state, s = r.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!t || t.main.empty && t.main.from == e.from + e.insert.length) && n.inputState.composing < 0) {
    let l = s.from < e.from ? r.sliceDoc(s.from, e.from) : "", a = s.to > e.to ? r.sliceDoc(e.to, s.to) : "";
    i = r.replaceSelection(n.state.toText(l + e.insert.sliceString(0, void 0, n.state.lineBreak) + a));
  } else {
    let l = r.changes(e), a = t && t.main.to <= l.newLength ? t.main : void 0;
    if (r.selection.ranges.length > 1 && n.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = n.state.sliceDoc(e.from, e.to), h, u = t && CA(n, t.main.head);
      if (u) {
        let p = e.insert.length - (e.to - e.from);
        h = { from: u.from, to: u.to - p };
      } else
        h = n.state.doc.lineAt(s.head);
      let f = s.to - e.to, d = s.to - s.from;
      i = r.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: l, range: a || p.map(l) };
        let g = p.to - f, m = g - c.length;
        if (p.to - p.from != d || n.state.sliceDoc(m, g) != c || p.to >= h.from && p.from <= h.to)
          return { range: p };
        let b = r.changes({ from: m, to: g, insert: e.insert }), y = p.to - s.to;
        return {
          changes: b,
          range: a ? S.range(Math.max(0, a.anchor + y), Math.max(0, a.head + y)) : p.map(b)
        };
      });
    } else
      i = {
        changes: l,
        selection: a && r.selection.replaceRange(a)
      };
  }
  let o = "input.type";
  return (n.composing || n.inputState.compositionPendingChange && n.inputState.compositionEndedAt > Date.now() - 50) && (n.inputState.compositionPendingChange = !1, o += ".compose", n.inputState.compositionFirstChange && (o += ".start", n.inputState.compositionFirstChange = !1)), r.update(i, { userEvent: o, scrollIntoView: !0 });
}
function Wke(n, e, t, i) {
  let r = Math.min(n.length, e.length), s = 0;
  for (; s < r && n.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == r && n.length == e.length)
    return null;
  let o = n.length, l = e.length;
  for (; o > 0 && l > 0 && n.charCodeAt(o - 1) == e.charCodeAt(l - 1); )
    o--, l--;
  if (i == "end") {
    let a = Math.max(0, s - Math.min(o, l));
    t -= o + a - s;
  }
  if (o < s && n.length < e.length) {
    let a = t <= s && t >= o ? s - t : 0;
    s -= a, l = s + (l - o), o = s;
  } else if (l < s) {
    let a = t <= s && t >= l ? s - t : 0;
    s -= a, o = s + (o - l), l = s;
  }
  return { from: s, toA: o, toB: l };
}
function jke(n) {
  let e = [];
  if (n.root.activeElement != n.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: r, focusOffset: s } = n.observer.selectionRange;
  return t && (e.push(new _w(t, i)), (r != t || s != i) && e.push(new _w(r, s))), e;
}
function Gke(n, e) {
  if (n.length == 0)
    return null;
  let t = n[0].pos, i = n.length == 2 ? n[1].pos : t;
  return t > -1 && i > -1 ? S.single(t + e, i + e) : null;
}
const Kke = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Rf = H.ie && H.ie_version <= 11;
class Yke {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new Txe(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (H.ie && H.ie_version <= 11 || H.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Rf && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, r = this.selectionRange;
    if (i.state.facet(ou) ? i.root.activeElement != this.dom : !fc(i.dom, r))
      return;
    let s = r.anchorNode && i.docView.nearest(r.anchorNode);
    if (s && s.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (H.ie && H.ie_version <= 11 || H.android && H.chrome) && !i.state.selection.main.empty && r.focusNode && fh(r.focusNode, r.focusOffset, r.anchorNode, r.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = H.safari && e.root.nodeType == 11 && Cxe(this.dom.ownerDocument) == this.dom && Jke(this.view) || uh(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = fc(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Oxe(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Kke), Rf && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    !this.active || (this.active = !1, this.observer.disconnect(), Rf && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let r = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && _s(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(r);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, r = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      !o || (o.typeOver && (r = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: r };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), r = this.selectionChanged && fc(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new zke(this.view, e, t, i);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return this.view.requestMeasure(), !1;
    let i = this.view.state, r = HA(this.view, t);
    return this.view.state == i && this.view.update([]), r;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = Sw(t, e.previousSibling || e.target.previousSibling, -1), r = Sw(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: r ? t.posBefore(r) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect();
    for (let r of this.scrollTargets)
      r.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Sw(n, e, t) {
  for (; e; ) {
    let i = Se.get(e);
    if (i && i.parent == n)
      return i;
    let r = e.parentNode;
    e = r != n.dom ? r : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function Jke(n) {
  let e = null;
  function t(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (n.contentDOM.addEventListener("beforeinput", t, !0), n.dom.ownerDocument.execCommand("indent"), n.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, r = e.startOffset, s = e.endContainer, o = e.endOffset, l = n.docView.domAtPos(n.state.selection.main.anchor);
  return fh(l.node, l.offset, s, o) && ([i, r, s, o] = [s, o, i, r]), { anchorNode: i, anchorOffset: r, focusNode: s, focusOffset: o };
}
class ne {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM);
    let { dispatch: t } = e;
    this.dispatchTransactions = e.dispatchTransactions || t && ((i) => i.forEach((r) => t(r, this))) || ((i) => this.update(i)), this.dispatch = this.dispatch.bind(this), this._root = e.root || Mxe(e.parent) || document, this.viewState = new vw(e.state || J.create(e)), e.scrollTo && e.scrollTo.is(Oa) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Do).map((i) => new Tf(i));
    for (let i of this.plugins)
      i.update(this);
    this.observer = new Yke(this), this.inputState = new hke(this), this.inputState.ensureHandlers(this.plugins), this.docView = new nw(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Ve ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(t, this);
  }
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, r, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, l = 0, a = null;
    e.some((f) => f.annotation(RA)) ? (this.inputState.notifiedFocused = o, l = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, a = IA(s, o), a || (l = 1));
    let c = this.observer.delayedAndroidKey, h = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (h = null)) : this.observer.clear(), s.facet(J.phrases) != this.state.facet(J.phrases))
      return this.setState(s);
    r = dh.create(this, s, e), r.flags |= l;
    let u = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (u && (u = u.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          u = new Ss(d.empty ? d : S.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(Oa) && (u = d.value.clip(this.state));
      }
      this.viewState.update(r, u), this.bidiCache = ph.update(this.bidiCache, r.changes), r.empty || (this.updatePlugins(r), this.inputState.update(r)), t = this.docView.update(r), this.state.facet(Eo) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (r.startState.facet(Pa) != r.state.facet(Pa) && (this.viewState.mustMeasureContent = !0), (t || i || u || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !r.empty)
      for (let f of this.state.facet(Dp))
        try {
          f(r);
        } catch (d) {
          _r(this.state, d, "update listener");
        }
    (a || h) && Promise.resolve().then(() => {
      a && this.state == a.startState && this.dispatch(a), h && !HA(this, h) && c.force && _s(this.contentDOM, c.key, c.keyCode);
    });
  }
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new vw(e), this.plugins = e.facet(Do).map((i) => new Tf(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new nw(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Do), i = e.state.facet(Do);
    if (t != i) {
      let r = [];
      for (let s of i) {
        let o = t.indexOf(s);
        if (o < 0)
          r.push(new Tf(s));
        else {
          let l = this.plugins[o];
          l.mustUpdate = e, r.push(l);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = r, this.pluginMap.clear();
    } else
      for (let r of this.plugins)
        r.mustUpdate = e;
    for (let r = 0; r < this.plugins.length; r++)
      this.plugins[r].update(this);
    t != i && this.inputState.ensureHandlers(this.plugins);
  }
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, r = i.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(r - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let l = 0; ; l++) {
        if (o < 0)
          if (QC(i))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(r);
            s = d.from, o = d.top;
          }
        this.updateState = 1;
        let a = this.viewState.measure(this);
        if (!a && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        a & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let h = c.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return _r(this.state, p), Cw;
          }
        }), u = dh.create(this, this.state, []), f = !1;
        u.flags |= a, t ? t.flags |= a : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), f = this.docView.update(u));
        for (let d = 0; d < c.length; d++)
          if (h[d] != Cw)
            try {
              let p = c[d];
              p.write && p.write(h[d], this);
            } catch (p) {
              _r(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !u.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                r = r + p, i.scrollTop = r / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let l of this.state.facet(Dp))
        l(t);
  }
  get themeClasses() {
    return Ip + " " + (this.state.facet(Rp) ? FA : PA) + " " + this.state.facet(Pa);
  }
  updateAttrs() {
    let e = Aw(this, mA, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(ou) ? "true" : "false",
      class: "cm-content",
      style: `${H.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Aw(this, xm, t);
    let i = this.observer.ignore(() => {
      let r = Cp(this.contentDOM, this.contentAttrs, t), s = Cp(this.dom, this.editorAttrs, e);
      return r || s;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let r of i.effects)
        if (r.is(ne.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = r.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Eo);
    let e = this.state.facet(ne.cspNonce);
    Ct.mount(this.root, this.styleModules.concat(Hke).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(e, t, i) {
    return Of(this, e, aw(this, e, t, i));
  }
  moveByGroup(e, t) {
    return Of(this, e, aw(this, e, t, (i) => ake(this, e.head, i)));
  }
  moveToLineBoundary(e, t, i = !0) {
    return lke(this, e, t, i);
  }
  moveVertically(e, t, i) {
    return Of(this, e, cke(this, e, t, i));
  }
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), DA(this, e, t);
  }
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let r = this.state.doc.lineAt(e), s = this.bidiSpans(r), o = s[Ii.find(s, e - r.from, -1, t)];
    return ym(i, o.dir == dt.LTR == t > 0);
  }
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(e) {
    return !this.state.facet(gA) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(e) {
    if (e.length > Zke)
      return _A(e.length);
    let t = this.textDirectionAt(e.from), i;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == t && (s.fresh || kA(s.isolates, i = tw(this, e.from, e.to))))
        return s.order;
    i || (i = tw(this, e.from, e.to));
    let r = jxe(e.text, t, i);
    return this.bidiCache.push(new ph(e.from, e.to, t, i, !0, r)), r;
  }
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || H.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      ZC(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  static scrollIntoView(e, t = {}) {
    return Oa.of(new Ss(typeof e == "number" ? S.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: t } = this.scrollDOM, i = this.viewState.scrollAnchorAt(e);
    return Oa.of(new Ss(S.cursor(i.from), "start", "start", i.top - e, t, !0));
  }
  static domEventHandlers(e) {
    return Pr.define(() => ({}), { eventHandlers: e });
  }
  static domEventObservers(e) {
    return Pr.define(() => ({}), { eventObservers: e });
  }
  static theme(e, t) {
    let i = Ct.newName(), r = [Pa.of(i), Eo.of(Bp(`.${i}`, e))];
    return t && t.dark && r.push(Rp.of(!0)), r;
  }
  static baseTheme(e) {
    return gi.lowest(Eo.of(Bp("." + Ip, e, $A)));
  }
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), r = i && Se.get(i) || Se.get(e);
    return ((t = r == null ? void 0 : r.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
ne.styleModule = Eo;
ne.inputHandler = dA;
ne.focusChangeEffect = pA;
ne.perLineTextDirection = gA;
ne.exceptionSink = fA;
ne.updateListener = Dp;
ne.editable = ou;
ne.mouseSelectionStyle = uA;
ne.dragMovesSelection = hA;
ne.clickAddsSelectionRange = cA;
ne.decorations = Al;
ne.atomicRanges = km;
ne.bidiIsolatedRanges = bA;
ne.scrollMargins = yA;
ne.darkTheme = Rp;
ne.cspNonce = /* @__PURE__ */ E.define({ combine: (n) => n.length ? n[0] : "" });
ne.contentAttributes = xm;
ne.editorAttributes = mA;
ne.lineWrapping = /* @__PURE__ */ ne.contentAttributes.of({ class: "cm-lineWrapping" });
ne.announce = /* @__PURE__ */ G.define();
const Zke = 4096, Cw = {};
class ph {
  constructor(e, t, i, r, s, o) {
    this.from = e, this.to = t, this.dir = i, this.isolates = r, this.fresh = s, this.order = o;
  }
  static update(e, t) {
    if (t.empty && !e.some((s) => s.fresh))
      return e;
    let i = [], r = e.length ? e[e.length - 1].dir : dt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == r && !t.touchesRange(o.from, o.to) && i.push(new ph(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return i;
  }
}
function Aw(n, e, t) {
  for (let i = n.state.facet(e), r = i.length - 1; r >= 0; r--) {
    let s = i[r], o = typeof s == "function" ? s(n) : s;
    o && Sp(o, t);
  }
  return t;
}
const Xke = !H.ios, Qke = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Xke && (Qke[".cm-line"].caretColor = "transparent !important");
class Fr extends ai {
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  eq(e) {
    return !1;
  }
  destroy(e) {
  }
}
Fr.prototype.elementClass = "";
Fr.prototype.toDOM = void 0;
Fr.prototype.mapMode = qe.TrackBefore;
Fr.prototype.startSide = Fr.prototype.endSide = -1;
Fr.prototype.point = !0;
const If = /* @__PURE__ */ E.define(), e_e = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => W.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, gc = /* @__PURE__ */ E.define();
function t_e(n) {
  return [n_e(), gc.of(Object.assign(Object.assign({}, e_e), n))];
}
const Np = /* @__PURE__ */ E.define({
  combine: (n) => n.some((e) => e)
});
function n_e(n) {
  let e = [
    i_e
  ];
  return n && n.fixed === !1 && e.push(Np.of(!0)), e;
}
const i_e = /* @__PURE__ */ Pr.fromClass(class {
  constructor(n) {
    this.view = n, this.prevViewport = n.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = n.state.facet(gc).map((e) => new Ew(n, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !n.state.facet(Np), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), n.scrollDOM.insertBefore(this.dom, n.contentDOM);
  }
  update(n) {
    if (this.updateGutters(n)) {
      let e = this.prevViewport, t = n.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    n.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Np) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = n.view.viewport;
  }
  syncGutters(n) {
    let e = this.dom.nextSibling;
    n && this.dom.remove();
    let t = W.iter(this.view.state.facet(If), this.view.viewport.from), i = [], r = this.gutters.map((s) => new r_e(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(s.type)) {
        let o = !0;
        for (let l of s.type)
          if (l.type == fn.Text && o) {
            Pp(t, i, l.from);
            for (let a of r)
              a.line(this.view, l, i);
            o = !1;
          } else if (l.widget)
            for (let a of r)
              a.widget(this.view, l);
      } else if (s.type == fn.Text) {
        Pp(t, i, s.from);
        for (let o of r)
          o.line(this.view, s, i);
      } else if (s.widget)
        for (let o of r)
          o.widget(this.view, s);
    for (let s of r)
      s.finish();
    n && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(n) {
    let e = n.startState.facet(gc), t = n.state.facet(gc), i = n.docChanged || n.heightChanged || n.viewportChanged || !W.eq(n.startState.facet(If), n.state.facet(If), n.view.viewport.from, n.view.viewport.to);
    if (e == t)
      for (let r of this.gutters)
        r.update(n) && (i = !0);
    else {
      i = !0;
      let r = [];
      for (let s of t) {
        let o = e.indexOf(s);
        o < 0 ? r.push(new Ew(this.view, s)) : (this.gutters[o].update(n), r.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), r.indexOf(s) < 0 && s.destroy();
      for (let s of r)
        this.dom.appendChild(s.dom);
      this.gutters = r;
    }
    return i;
  }
  destroy() {
    for (let n of this.gutters)
      n.destroy();
    this.dom.remove();
  }
}, {
  provide: (n) => ne.scrollMargins.of((e) => {
    let t = e.plugin(n);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == dt.LTR ? { left: t.dom.offsetWidth * e.scaleX } : { right: t.dom.offsetWidth * e.scaleX };
  })
});
function Dw(n) {
  return Array.isArray(n) ? n : [n];
}
function Pp(n, e, t) {
  for (; n.value && n.from <= t; )
    n.from == t && e.push(n.value), n.next();
}
class r_e {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = W.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: r } = this, s = (t.top - this.height) / e.scaleY, o = t.height / e.scaleY;
    if (this.i == r.elements.length) {
      let l = new qA(e, o, s, i);
      r.elements.push(l), r.dom.appendChild(l.dom);
    } else
      r.elements[this.i].update(e, o, s, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let r = [];
    Pp(this.cursor, r, t.from), i.length && (r = r.concat(i));
    let s = this.gutter.config.lineMarker(e, t, r);
    s && r.unshift(s);
    let o = this.gutter;
    r.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, r);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Ew {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (r) => {
        let s = r.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let a = s.getBoundingClientRect();
          o = (a.top + a.bottom) / 2;
        } else
          o = r.clientY;
        let l = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, l, r) && r.preventDefault();
      });
    this.markers = Dw(t.markers(e)), t.initialSpacer && (this.spacer = new qA(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = Dw(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let r = this.config.updateSpacer(this.spacer.markers[0], e);
      r != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [r]);
    }
    let i = e.view.viewport;
    return !W.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class qA {
  constructor(e, t, i, r) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, r);
  }
  update(e, t, i, r) {
    this.height != t && (this.height = t, this.dom.style.height = t + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), s_e(this.markers, r) || this.setMarkers(e, r);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", r = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let l = o, a = s < t.length ? t[s++] : null, c = !1;
      if (a) {
        let h = a.elementClass;
        h && (i += " " + h);
        for (let u = o; u < this.markers.length; u++)
          if (this.markers[u].compare(a)) {
            l = u, c = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(r);
          let u = r.nextSibling;
          r.remove(), r = u;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? r = r.nextSibling : this.dom.insertBefore(a.toDOM(e), r)), c && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function s_e(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].compare(e[t]))
      return !1;
  return !0;
}
class Ne {
  constructor(e, t, i, r) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = r;
  }
  offset(e, t) {
    return new Ne(this.fromA + e, this.toA + e, this.fromB + t, this.toB + t);
  }
}
function $r(n, e, t, i, r, s) {
  if (n == i)
    return [];
  let o = Sm(n, e, t, i, r, s), l = Cm(n, e + o, t, i, r + o, s);
  e += o, t -= l, r += o, s -= l;
  let a = t - e, c = s - r;
  if (!a || !c)
    return [new Ne(e, t, r, s)];
  if (a > c) {
    let u = n.slice(e, t).indexOf(i.slice(r, s));
    if (u > -1)
      return [
        new Ne(e, e + u, r, r),
        new Ne(e + u + c, t, s, s)
      ];
  } else if (c > a) {
    let u = i.slice(r, s).indexOf(n.slice(e, t));
    if (u > -1)
      return [
        new Ne(e, e, r, r + u),
        new Ne(t, t, r + u + a, s)
      ];
  }
  if (a == 1 || c == 1)
    return [new Ne(e, t, r, s)];
  let h = UA(n, e, t, i, r, s);
  if (h) {
    let [u, f, d] = h;
    return $r(n, e, u, i, r, f).concat($r(n, u + d, t, i, f + d, s));
  }
  return o_e(n, e, t, i, r, s);
}
let Oo = 1e9;
function o_e(n, e, t, i, r, s) {
  let o = t - e, l = s - r;
  if (Oo < 1e9 && Math.min(o, l) > Oo * 16)
    return Math.min(o, l) > Oo * 64 ? [new Ne(e, t, r, s)] : Tw(n, e, t, i, r, s);
  let a = Math.ceil((o + l) / 2);
  Bf.reset(a), Nf.reset(a);
  let c = (d, p) => n.charCodeAt(e + d) == i.charCodeAt(r + p), h = (d, p) => n.charCodeAt(t - d - 1) == i.charCodeAt(s - p - 1), u = (o - l) % 2 != 0 ? Nf : null, f = u ? null : Bf;
  for (let d = 0; d < a; d++) {
    if (d > Oo)
      return Tw(n, e, t, i, r, s);
    let p = Bf.advance(d, o, l, a, u, !1, c) || Nf.advance(d, o, l, a, f, !0, h);
    if (p)
      return l_e(n, e, t, e + p[0], i, r, s, r + p[1]);
  }
  return [new Ne(e, t, r, s)];
}
class VA {
  constructor() {
    this.vec = [];
  }
  reset(e) {
    this.len = e << 1;
    for (let t = 0; t < this.len; t++)
      this.vec[t] = -1;
    this.vec[e + 1] = 0, this.start = this.end = 0;
  }
  advance(e, t, i, r, s, o, l) {
    for (let a = -e + this.start; a <= e - this.end; a += 2) {
      let c = r + a, h = a == -e || a != e && this.vec[c - 1] < this.vec[c + 1] ? this.vec[c + 1] : this.vec[c - 1] + 1, u = h - a;
      for (; h < t && u < i && l(h, u); )
        h++, u++;
      if (this.vec[c] = h, h > t)
        this.end += 2;
      else if (u > i)
        this.start += 2;
      else if (s) {
        let f = r + (t - i) - a;
        if (f >= 0 && f < this.len && s.vec[f] != -1)
          if (o) {
            let d = s.vec[f];
            if (d >= t - h)
              return [d, r + d - f];
          } else {
            let d = t - s.vec[f];
            if (h >= d)
              return [h, u];
          }
      }
    }
    return null;
  }
}
const Bf = /* @__PURE__ */ new VA(), Nf = /* @__PURE__ */ new VA();
function l_e(n, e, t, i, r, s, o, l) {
  let a = !1;
  return !js(n, i) && ++i == t && (a = !0), !js(r, l) && ++l == o && (a = !0), a ? [new Ne(e, t, s, o)] : $r(n, e, i, r, s, l).concat($r(n, i, t, r, l, o));
}
function zA(n, e) {
  let t = 1, i = Math.min(n, e);
  for (; t < i; )
    t = t << 1;
  return t;
}
function Sm(n, e, t, i, r, s) {
  if (e == t || e == s || n.charCodeAt(e) != i.charCodeAt(r))
    return 0;
  let o = zA(t - e, s - r);
  for (let l = e, a = r; ; ) {
    let c = l + o, h = a + o;
    if (c > t || h > s || n.slice(l, c) != i.slice(a, h)) {
      if (o == 1)
        return l - e - (js(n, l) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == t || h == s)
        return c - e;
      l = c, a = h;
    }
  }
}
function Cm(n, e, t, i, r, s) {
  if (e == t || r == s || n.charCodeAt(t - 1) != i.charCodeAt(s - 1))
    return 0;
  let o = zA(t - e, s - r);
  for (let l = t, a = s; ; ) {
    let c = l - o, h = a - o;
    if (c < e || h < r || n.slice(c, l) != i.slice(h, a)) {
      if (o == 1)
        return t - l - (js(n, l) ? 0 : 1);
      o = o >> 1;
    } else {
      if (c == e || h == r)
        return t - c;
      l = c, a = h;
    }
  }
}
function Fp(n, e, t, i, r, s, o, l) {
  let a = i.slice(r, s), c = null;
  for (; ; ) {
    if (c || o < l)
      return c;
    for (let h = e + o; ; ) {
      js(n, h) || h++;
      let u = h + o;
      if (js(n, u) || (u += u == h + 1 ? 1 : -1), u >= t)
        break;
      let f = n.slice(h, u), d = -1;
      for (; (d = a.indexOf(f, d + 1)) != -1; ) {
        let p = Sm(n, u, t, i, r + d + f.length, s), g = Cm(n, e, h, i, r, r + d), m = f.length + p + g;
        (!c || c[2] < m) && (c = [h - g, r + d - g, m]);
      }
      h = u;
    }
    if (l < 0)
      return c;
    o = o >> 1;
  }
}
function UA(n, e, t, i, r, s) {
  let o = t - e, l = s - r;
  if (o < l) {
    let a = UA(i, r, s, n, e, t);
    return a && [a[1], a[0], a[2]];
  }
  return o < 4 || l * 2 < o ? null : Fp(n, e, t, i, r, s, Math.floor(o / 4), -1);
}
function Tw(n, e, t, i, r, s) {
  let o = t - e, l = s - r, a;
  if (o < l) {
    let f = Fp(i, r, s, n, e, t, Math.floor(o / 6), 50);
    a = f && [f[1], f[0], f[2]];
  } else
    a = Fp(n, e, t, i, r, s, Math.floor(l / 6), 50);
  if (!a)
    return [new Ne(e, t, r, s)];
  let [c, h, u] = a;
  return $r(n, e, c, i, r, h).concat($r(n, c + u, t, i, h + u, s));
}
function WA(n, e) {
  for (let t = 1; t < n.length; t++) {
    let i = n[t - 1], r = n[t];
    i.toA > r.fromA - e && i.toB > r.fromB - e && (n[t - 1] = new Ne(i.fromA, r.toA, i.fromB, r.toB), n.splice(t--, 1));
  }
}
function a_e(n, e, t) {
  for (; ; ) {
    WA(t, 1);
    let i = !1;
    for (let r = 0; r < t.length; r++) {
      let s = t[r], o, l;
      (o = Sm(n, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = t[r] = new Ne(s.fromA + o, s.toA, s.fromB + o, s.toB)), (l = Cm(n, s.fromA, s.toA, e, s.fromB, s.toB)) && (s = t[r] = new Ne(s.fromA, s.toA - l, s.fromB, s.toB - l));
      let a = s.toA - s.fromA, c = s.toB - s.fromB;
      if (a && c)
        continue;
      let h = s.fromA - (r ? t[r - 1].toA : 0), u = (r < t.length - 1 ? t[r + 1].fromA : n.length) - s.toA;
      if (!h || !u)
        continue;
      let f = a ? n.slice(s.fromA, s.toA) : e.slice(s.fromB, s.toB);
      h <= f.length && n.slice(s.fromA - h, s.fromA) == f.slice(f.length - h) ? (t[r] = new Ne(s.fromA - h, s.toA - h, s.fromB - h, s.toB - h), i = !0) : u <= f.length && n.slice(s.toA, s.toA + u) == f.slice(0, u) && (t[r] = new Ne(s.fromA + u, s.toA + u, s.fromB + u, s.toB + u), i = !0);
    }
    if (!i)
      break;
  }
  return t;
}
function c_e(n, e, t) {
  for (let i = 0, r = 0; r < n.length; r++) {
    let s = n[r], o = s.toA - s.fromA, l = s.toB - s.fromB;
    if (o && l || o > 3 || l > 3) {
      let a = r == n.length - 1 ? e.length : n[r + 1].fromA, c = s.fromA - i, h = a - s.toA, u = Ow(e, s.fromA, Math.min(c, 5)), f = Mw(e, s.toA, Math.min(h, 5)), d = s.fromA - u, p = f - s.toA;
      if (!o || !l) {
        let g = Math.max(o, l), [m, b, y] = o ? [e, s.fromA, s.toA] : [t, s.fromB, s.toB], k, w;
        d && p ? (g > d && e.slice(u, s.fromA) == m.slice(y - d, y) ? (s = n[r] = new Ne(u, u + o, s.fromB - d, s.toB - d), u = s.fromA, f = Mw(e, s.toA, Math.min(a - s.toA, 5))) : g > p && e.slice(s.toA, f) == m.slice(b, b + p) && (s = n[r] = new Ne(f - o, f, s.fromB + p, s.toB + p), f = s.toA, u = Ow(e, s.fromA, Math.min(s.fromA - i, 5))), d = s.fromA - u, p = f - s.toA) : !d && !p && (w = s.fromA - (k = h_e(e, s.fromA, c))) && e.slice(k, s.fromA) == m.slice(y - w, y) && (s = n[r] = new Ne(k, k + o, s.fromB - w, s.toB - w));
      }
      (d || p) && (s = n[r] = new Ne(s.fromA - d, s.toA + p, s.fromB - d, s.toB + p)), i = s.toA;
    }
  }
  return WA(n, 3), n;
}
let Sr;
try {
  Sr = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}]", "u");
} catch {
}
function jA(n) {
  return n > 48 && n < 58 || n > 64 && n < 91 || n > 96 && n < 123;
}
function GA(n, e) {
  if (e == n.length)
    return 0;
  let t = n.charCodeAt(e);
  return t < 192 ? jA(t) ? 1 : 0 : Sr ? !YA(t) || e == n.length - 1 ? Sr.test(String.fromCharCode(t)) ? 1 : 0 : Sr.test(n.slice(e, e + 2)) ? 2 : 0 : 0;
}
function KA(n, e) {
  if (!e)
    return 0;
  let t = n.charCodeAt(e - 1);
  return t < 192 ? jA(t) ? 1 : 0 : Sr ? !JA(t) || e == 1 ? Sr.test(String.fromCharCode(t)) ? 1 : 0 : Sr.test(n.slice(e - 2, e)) ? 2 : 0 : 0;
}
function Mw(n, e, t) {
  if (e == n.length || !KA(n, e))
    return e;
  for (let i = e, r = e + t; ; ) {
    let s = GA(n, i);
    if (!s)
      return i;
    if (i += s, i > r)
      return e;
  }
}
function Ow(n, e, t) {
  if (!e || !GA(n, e))
    return e;
  for (let i = e, r = e - t; ; ) {
    let s = KA(n, i);
    if (!s)
      return i;
    if (i -= s, i < r)
      return e;
  }
}
function h_e(n, e, t) {
  for (let i = e, r = e - t; ; ) {
    let s = i ? n.charCodeAt(i - 1) : 10;
    if (s == 10)
      return i;
    if (i--, i < r || s != 32 && s != 9)
      return e;
  }
}
const YA = (n) => n >= 55296 && n <= 56319, JA = (n) => n >= 56320 && n <= 57343;
function js(n, e) {
  return !e || e == n.length || !YA(n.charCodeAt(e - 1)) || !JA(n.charCodeAt(e));
}
function u_e(n, e, t) {
  var i;
  return Oo = ((i = t == null ? void 0 : t.scanLimit) !== null && i !== void 0 ? i : 1e9) >> 1, a_e(n, e, $r(n, 0, n.length, e, 0, e.length));
}
function ZA(n, e, t) {
  return c_e(u_e(n, e, t), n, e);
}
const Ln = /* @__PURE__ */ E.define({
  combine: (n) => n[0]
}), $p = /* @__PURE__ */ G.define(), Gs = /* @__PURE__ */ Ue.define({
  create(n) {
    return null;
  },
  update(n, e) {
    for (let t of e.effects)
      t.is($p) && (n = t.value);
    return n;
  }
}), XA = { scanLimit: 500 };
class Cs {
  constructor(e, t, i, r, s) {
    this.changes = e, this.fromA = t, this.toA = i, this.fromB = r, this.toB = s;
  }
  offset(e, t) {
    return e || t ? new Cs(this.changes, this.fromA + e, this.toA + e, this.fromB + t, this.toB + t) : this;
  }
  get endA() {
    return Math.max(this.fromA, this.toA - 1);
  }
  get endB() {
    return Math.max(this.fromB, this.toB - 1);
  }
  static build(e, t) {
    return QA(ZA(e.toString(), t.toString(), XA), e, t, 0, 0);
  }
  static updateA(e, t, i, r) {
    return Nw(Bw(e, r, !0, i.length), e, t, i);
  }
  static updateB(e, t, i, r) {
    return Nw(Bw(e, r, !1, t.length), e, t, i);
  }
}
function Lw(n, e, t, i) {
  let r = t.lineAt(n), s = i.lineAt(e);
  return r.to == n && s.to == e && n < t.length && e < i.length ? [n + 1, e + 1] : [r.from, s.from];
}
function Rw(n, e, t, i) {
  let r = t.lineAt(n), s = i.lineAt(e);
  return r.from == n && s.from == e ? [n, e] : [r.to + 1, s.to + 1];
}
function QA(n, e, t, i, r) {
  let s = [];
  for (let o = 0; o < n.length; o++) {
    let l = n[o], [a, c] = Lw(l.fromA + i, l.fromB + r, e, t), [h, u] = Rw(l.toA + i, l.toB + r, e, t), f = [l.offset(-a + i, -c + r)];
    for (; o < n.length - 1; ) {
      let d = n[o + 1], [p, g] = Lw(d.fromA + i, d.fromB + r, e, t);
      if (p > h + 1 && g > u + 1)
        break;
      f.push(d.offset(-a + i, -c + r)), [h, u] = Rw(d.toA + i, d.toB + r, e, t), o++;
    }
    s.push(new Cs(f, a, Math.max(a, h), c, Math.max(c, u)));
  }
  return s;
}
const Fa = 1e3;
function Iw(n, e, t, i) {
  let r = 0, s = n.length;
  for (; ; ) {
    if (r == s) {
      let h = 0, u = 0;
      r && ({ toA: h, toB: u } = n[r - 1]);
      let f = e - (t ? h : u);
      return [h + f, u + f];
    }
    let o = r + s >> 1, l = n[o], [a, c] = t ? [l.fromA, l.toA] : [l.fromB, l.toB];
    if (a > e)
      s = o;
    else if (c <= e)
      r = o + 1;
    else
      return i ? [l.fromA, l.fromB] : [l.toA, l.toB];
  }
}
function Bw(n, e, t, i) {
  let r = [];
  return e.iterChangedRanges((s, o, l, a) => {
    let c = 0, h = t ? e.length : i, u = 0, f = t ? i : e.length;
    s > Fa && ([c, u] = Iw(n, s - Fa, t, !0)), o < e.length - Fa && ([h, f] = Iw(n, o + Fa, t, !1));
    let d = a - l - (o - s), p, [g, m] = t ? [d, 0] : [0, d];
    r.length && (p = r[r.length - 1]).toA >= c ? r[r.length - 1] = {
      fromA: p.fromA,
      fromB: p.fromB,
      toA: h,
      toB: f,
      diffA: p.diffA + g,
      diffB: p.diffB + m
    } : r.push({ fromA: c, toA: h, fromB: u, toB: f, diffA: g, diffB: m });
  }), r;
}
function Nw(n, e, t, i) {
  if (!n.length)
    return e;
  let r = 0, s = 0, o = 0, l = [];
  for (let a of n) {
    let c = a.fromA + s, h = a.toA + s + a.diffA, u = a.fromB + o, f = a.toB + o + a.diffB;
    for (; r < e.length; ) {
      let d = e[r];
      if (d.toA + s <= c && d.toB + o <= u)
        l.push(d.offset(s, o));
      else if (d.fromA + s > h)
        break;
      r++;
    }
    for (let d of QA(ZA(t.sliceString(c, h), i.sliceString(u, f), XA), t, i, c, u))
      l.push(d);
    s += a.diffA, o += a.diffB;
  }
  for (; r < e.length; )
    l.push(e[r++].offset(s, o));
  return l;
}
const e2 = /* @__PURE__ */ Pr.fromClass(class {
  constructor(n) {
    ({ deco: this.deco, gutter: this.gutter } = $w(n));
  }
  update(n) {
    (n.docChanged || n.viewportChanged || f_e(n.startState, n.state) || d_e(n.startState, n.state)) && ({ deco: this.deco, gutter: this.gutter } = $w(n.view));
  }
}, {
  decorations: (n) => n.deco
}), $a = /* @__PURE__ */ gi.low(/* @__PURE__ */ t_e({
  class: "cm-changeGutter",
  markers: (n) => {
    var e;
    return ((e = n.plugin(e2)) === null || e === void 0 ? void 0 : e.gutter) || W.empty;
  }
}));
function f_e(n, e) {
  return n.field(Gs, !1) != e.field(Gs, !1);
}
function d_e(n, e) {
  return n.facet(Ln) != e.facet(Ln);
}
const Pw = /* @__PURE__ */ Fe.line({ class: "cm-changedLine" }), p_e = /* @__PURE__ */ Fe.mark({ class: "cm-changedText" }), g_e = /* @__PURE__ */ Fe.mark({ tagName: "ins" }), m_e = /* @__PURE__ */ Fe.mark({ tagName: "del" }), Fw = /* @__PURE__ */ new class extends Fr {
  constructor() {
    super(...arguments), this.elementClass = "cm-changedLineGutter";
  }
}();
function b_e(n, e, t, i, r, s) {
  let o = t ? n.fromA : n.fromB, l = t ? n.toA : n.toB, a = 0;
  if (o != l) {
    r.add(o, o, Pw), r.add(o, l, t ? m_e : g_e), s && s.add(o, o, Fw);
    for (let c = e.iterRange(o, l - 1), h = o; !c.next().done; ) {
      if (c.lineBreak) {
        h++, r.add(h, h, Pw), s && s.add(h, h, Fw);
        continue;
      }
      let u = h + c.value.length;
      if (i)
        for (; a < n.changes.length; ) {
          let f = n.changes[a], d = o + (t ? f.fromA : f.fromB), p = o + (t ? f.toA : f.toB), g = Math.max(h, d), m = Math.min(u, p);
          if (g < m && r.add(g, m, p_e), p < u)
            a++;
          else
            break;
        }
      h = u;
    }
  }
}
function $w(n) {
  let e = n.state.field(Gs), { side: t, highlightChanges: i, markGutter: r } = n.state.facet(Ln), s = t == "a", o = new Vt(), l = r ? new Vt() : null, { from: a, to: c } = n.viewport;
  for (let h of e) {
    if ((s ? h.fromA : h.fromB) >= c)
      break;
    (s ? h.toA : h.toB) > a && b_e(h, n.state.doc, s, i, o, l);
  }
  return { deco: o.finish(), gutter: l && l.finish() };
}
class Ha extends Vl {
  constructor(e) {
    super(), this.height = e;
  }
  eq(e) {
    return this.height == e.height;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-mergeSpacer", e.style.height = this.height + "px", e;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
const gh = /* @__PURE__ */ G.define({
  map: (n, e) => n.map(e)
}), Lo = /* @__PURE__ */ Ue.define({
  create: () => Fe.none,
  update: (n, e) => {
    for (let t of e.effects)
      if (t.is(gh))
        return t.value;
    return n.map(e.changes);
  },
  provide: (n) => ne.decorations.from(n)
}), qa = 0.01;
function y_e(n, e, t) {
  let i = new Vt(), r = new Vt(), s = n.state.field(Lo).iter(), o = e.state.field(Lo).iter(), l = 0, a = 0, c = 0, h = 0;
  for (let p = 0; ; p++) {
    let g = p < t.length ? t[p] : null;
    if (l < (g ? g.fromA : n.state.doc.length)) {
      let m = n.lineBlockAt(l).top + c, b = e.lineBlockAt(a).top + h, y = m - b;
      y < -qa ? (c -= y, i.add(l, l, Fe.widget({
        widget: new Ha(-y),
        block: !0,
        side: -1
      }))) : y > qa && (h += y, r.add(a, a, Fe.widget({
        widget: new Ha(y),
        block: !0,
        side: -1
      })));
    }
    if (!g)
      break;
    for (l = g.toA, a = g.toB; s.value && s.from < l; )
      c -= s.value.spec.widget.height, s.next();
    for (; o.value && o.from < a; )
      h -= o.value.spec.widget.height, o.next();
  }
  for (; s.value; )
    c -= s.value.spec.widget.height, s.next();
  for (; o.value; )
    h -= o.value.spec.widget.height, o.next();
  let u = n.contentHeight + c - (e.contentHeight + h);
  u < qa ? i.add(n.state.doc.length, n.state.doc.length, Fe.widget({
    widget: new Ha(-u),
    block: !0,
    side: 1
  })) : u > qa && r.add(e.state.doc.length, e.state.doc.length, Fe.widget({
    widget: new Ha(u),
    block: !0,
    side: 1
  }));
  let f = i.finish(), d = r.finish();
  W.eq([f], [n.state.field(Lo)]) || n.dispatch({ effects: gh.of(f) }), W.eq([d], [e.state.field(Lo)]) || e.dispatch({ effects: gh.of(d) });
}
const Hp = /* @__PURE__ */ G.define({
  map: (n, e) => e.mapPos(n)
});
class w_e extends Vl {
  constructor(e) {
    super(), this.lines = e;
  }
  eq(e) {
    return this.lines == e.lines;
  }
  toDOM(e) {
    let t = document.createElement("div");
    return t.className = "cm-collapsedLines", t.textContent = "\u299A " + e.state.phrase("$ unchanged lines", this.lines) + " \u299A", t.addEventListener("click", (i) => {
      let r = e.posAtDOM(i.target);
      e.dispatch({ effects: Hp.of(r) });
      let { side: s, sibling: o } = e.state.facet(Ln);
      o && o().dispatch({ effects: Hp.of(v_e(r, e.state.field(Gs), s == "a")) });
    }), t;
  }
  ignoreEvent(e) {
    return e instanceof MouseEvent;
  }
  get estimatedHeight() {
    return 27;
  }
}
function v_e(n, e, t) {
  let i = 0, r = 0;
  for (let s = 0; ; s++) {
    let o = s < e.length ? e[s] : null;
    if (!o || (t ? o.fromA : o.fromB) >= n)
      return r + (n - i);
    [i, r] = t ? [o.toA, o.toB] : [o.toB, o.toA];
  }
}
const x_e = /* @__PURE__ */ Ue.define({
  create(n) {
    return Fe.none;
  },
  update(n, e) {
    n = n.map(e.changes);
    for (let t of e.effects)
      t.is(Hp) && (n = n.update({ filter: (i) => i != t.value }));
    return n;
  },
  provide: (n) => ne.decorations.from(n)
});
function Hw({ margin: n = 3, minSize: e = 4 }) {
  return x_e.init((t) => k_e(t, n, e));
}
function k_e(n, e, t) {
  let i = new Vt(), r = n.facet(Ln).side == "a", s = n.field(Gs), o = 1;
  for (let l = 0; ; l++) {
    let a = l < s.length ? s[l] : null, c = l ? o + e : 1, h = a ? n.doc.lineAt(r ? a.fromA : a.fromB).number - 1 - e : n.doc.lines, u = h - c + 1;
    if (u >= t && i.add(n.doc.line(c).from, n.doc.line(h).to, Fe.replace({
      widget: new w_e(u),
      block: !0
    })), !a)
      break;
    o = n.doc.lineAt(Math.min(n.doc.length, r ? a.toA : a.toB)).number;
  }
  return i.finish();
}
const __e = /* @__PURE__ */ ne.styleModule.of(/* @__PURE__ */ new Ct({
  ".cm-mergeView": {
    overflowY: "auto"
  },
  ".cm-mergeViewEditors": {
    display: "flex",
    alignItems: "stretch"
  },
  ".cm-mergeViewEditor": {
    flexGrow: 1,
    flexBasis: 0,
    overflow: "hidden"
  },
  ".cm-merge-revert": {
    width: "1.6em",
    flexGrow: 0,
    flexShrink: 0,
    position: "relative"
  },
  ".cm-merge-revert button": {
    position: "absolute",
    display: "block",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "center",
    background: "none",
    border: "none",
    font: "inherit",
    cursor: "pointer"
  }
})), S_e = /* @__PURE__ */ ne.baseTheme({
  "& .cm-scroller, &": {
    height: "auto !important",
    overflowY: "visible !important"
  },
  "&.cm-merge-a .cm-changedLine, .cm-deletedChunk": {
    backgroundColor: "rgba(160, 128, 100, .08)"
  },
  "&.cm-merge-b .cm-changedLine": {
    backgroundColor: "rgba(100, 160, 128, .08)"
  },
  "&light.cm-merge-a .cm-changedText, &light .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ee443366, #ee443366) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-a .cm-changedText, &dark .cm-deletedChunk .cm-deletedText": {
    background: "linear-gradient(#ffaa9966, #ffaa9966) bottom/100% 2px no-repeat"
  },
  "&light.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#22bb2266, #22bb2266) bottom/100% 2px no-repeat"
  },
  "&dark.cm-merge-b .cm-changedText": {
    background: "linear-gradient(#88ff8866, #88ff8866) bottom/100% 2px no-repeat"
  },
  "del, ins": {
    textDecoration: "none"
  },
  ".cm-deletedChunk": {
    paddingLeft: "6px",
    "& .cm-chunkButtons": {
      position: "absolute",
      insetInlineEnd: "5px"
    },
    "& button": {
      border: "none",
      cursor: "pointer",
      color: "white",
      margin: "0 2px",
      borderRadius: "3px",
      "&[name=accept]": { background: "#2a2" },
      "&[name=reject]": { background: "#d43" }
    }
  },
  ".cm-collapsedLines": {
    padding: "5px 5px 5px 10px",
    cursor: "pointer"
  },
  "&light .cm-collapsedLines": {
    color: "#444",
    background: "linear-gradient(to bottom, transparent 0, #f3f3f3 30%, #f3f3f3 70%, transparent 100%)"
  },
  "&dark .cm-collapsedLines": {
    color: "#ddd",
    background: "linear-gradient(to bottom, transparent 0, #222 30%, #222 70%, transparent 100%)"
  },
  ".cm-changeGutter": { width: "3px", paddingLeft: "1px" },
  "&light.cm-merge-a .cm-changedLineGutter, &light .cm-deletedLineGutter": { background: "#e43" },
  "&dark.cm-merge-a .cm-changedLineGutter, &dark .cm-deletedLineGutter": { background: "#fa9" },
  "&light.cm-merge-b .cm-changedLineGutter": { background: "#2b2" },
  "&dark.cm-merge-b .cm-changedLineGutter": { background: "#8f8" }
}), qw = /* @__PURE__ */ new to(), Va = /* @__PURE__ */ new to();
class C_e {
  constructor(e) {
    this.revertDOM = null, this.revertToA = !1, this.revertToLeft = !1, this.measuring = -1;
    let t = [
      gi.low(e2),
      S_e,
      __e,
      Lo,
      ne.updateListener.of((u) => {
        this.measuring < 0 && (u.heightChanged || u.viewportChanged) && !u.transactions.some((f) => f.effects.some((d) => d.is(gh))) && this.measure();
      })
    ], i = [Ln.of({
      side: "a",
      sibling: () => this.b,
      highlightChanges: e.highlightChanges !== !1,
      markGutter: e.gutter !== !1
    })];
    e.gutter !== !1 && i.push($a);
    let r = J.create({
      doc: e.a.doc,
      selection: e.a.selection,
      extensions: [
        e.a.extensions || [],
        ne.editorAttributes.of({ class: "cm-merge-a" }),
        Va.of(i),
        t
      ]
    }), s = [Ln.of({
      side: "b",
      sibling: () => this.a,
      highlightChanges: e.highlightChanges !== !1,
      markGutter: e.gutter !== !1
    })];
    e.gutter !== !1 && s.push($a);
    let o = J.create({
      doc: e.b.doc,
      selection: e.b.selection,
      extensions: [
        e.b.extensions || [],
        ne.editorAttributes.of({ class: "cm-merge-b" }),
        Va.of(s),
        t
      ]
    });
    this.chunks = Cs.build(r.doc, o.doc);
    let l = [
      Gs.init(() => this.chunks),
      qw.of(e.collapseUnchanged ? Hw(e.collapseUnchanged) : [])
    ];
    r = r.update({ effects: G.appendConfig.of(l) }).state, o = o.update({ effects: G.appendConfig.of(l) }).state, this.dom = document.createElement("div"), this.dom.className = "cm-mergeView", this.editorDOM = this.dom.appendChild(document.createElement("div")), this.editorDOM.className = "cm-mergeViewEditors";
    let a = e.orientation || "a-b", c = document.createElement("div");
    c.className = "cm-mergeViewEditor";
    let h = document.createElement("div");
    h.className = "cm-mergeViewEditor", this.editorDOM.appendChild(a == "a-b" ? c : h), this.editorDOM.appendChild(a == "a-b" ? h : c), this.a = new ne({
      state: r,
      parent: c,
      root: e.root,
      dispatchTransactions: (u) => this.dispatch(u, this.a)
    }), this.b = new ne({
      state: o,
      parent: h,
      root: e.root,
      dispatchTransactions: (u) => this.dispatch(u, this.b)
    }), this.setupRevertControls(!!e.revertControls, e.revertControls == "b-to-a", e.renderRevertControl), e.parent && e.parent.appendChild(this.dom), this.scheduleMeasure();
  }
  dispatch(e, t) {
    if (e.some((i) => i.docChanged)) {
      let i = e[e.length - 1], r = e.reduce((o, l) => o.compose(l.changes), Oe.empty(e[0].startState.doc.length));
      this.chunks = t == this.a ? Cs.updateA(this.chunks, i.newDoc, this.b.state.doc, r) : Cs.updateB(this.chunks, this.a.state.doc, i.newDoc, r), t.update([...e, i.state.update({ effects: $p.of(this.chunks) })]);
      let s = t == this.a ? this.b : this.a;
      s.update([s.state.update({ effects: $p.of(this.chunks) })]), this.scheduleMeasure();
    } else
      t.update(e);
  }
  reconfigure(e) {
    if ("orientation" in e) {
      let s = e.orientation != "b-a";
      if (s != (this.editorDOM.firstChild == this.a.dom.parentNode)) {
        let o = this.a.dom.parentNode, l = this.b.dom.parentNode;
        o.remove(), l.remove(), this.editorDOM.insertBefore(s ? o : l, this.editorDOM.firstChild), this.editorDOM.appendChild(s ? l : o), this.revertToLeft = !this.revertToLeft, this.revertDOM && (this.revertDOM.textContent = "");
      }
    }
    if ("revertControls" in e || "renderRevertControl" in e) {
      let s = !!this.revertDOM, o = this.revertToA, l = this.renderRevert;
      "revertControls" in e && (s = !!e.revertControls, o = e.revertControls == "b-to-a"), "renderRevertControl" in e && (l = e.renderRevertControl), this.setupRevertControls(s, o, l);
    }
    let t = "highlightChanges" in e, i = "gutter" in e, r = "collapseUnchanged" in e;
    if (t || i || r) {
      let s = [], o = [];
      if (t || i) {
        let l = this.a.state.facet(Ln), a = i ? e.gutter !== !1 : l.markGutter, c = t ? e.highlightChanges !== !1 : l.highlightChanges;
        s.push(Va.reconfigure([
          Ln.of({ side: "a", sibling: () => this.b, highlightChanges: c, markGutter: a }),
          a ? $a : []
        ])), o.push(Va.reconfigure([
          Ln.of({ side: "b", sibling: () => this.a, highlightChanges: c, markGutter: a }),
          a ? $a : []
        ]));
      }
      if (r) {
        let l = qw.reconfigure(e.collapseUnchanged ? Hw(e.collapseUnchanged) : []);
        s.push(l), o.push(l);
      }
      this.a.dispatch({ effects: s }), this.b.dispatch({ effects: o });
    }
    this.scheduleMeasure();
  }
  setupRevertControls(e, t, i) {
    this.revertToA = t, this.revertToLeft = this.revertToA == (this.editorDOM.firstChild == this.a.dom.parentNode), this.renderRevert = i, !e && this.revertDOM ? (this.revertDOM.remove(), this.revertDOM = null) : e && !this.revertDOM ? (this.revertDOM = this.editorDOM.insertBefore(document.createElement("div"), this.editorDOM.firstChild.nextSibling), this.revertDOM.addEventListener("mousedown", (r) => this.revertClicked(r)), this.revertDOM.className = "cm-merge-revert") : this.revertDOM && (this.revertDOM.textContent = "");
  }
  scheduleMeasure() {
    if (this.measuring < 0) {
      let e = this.dom.ownerDocument.defaultView || window;
      this.measuring = e.requestAnimationFrame(() => {
        this.measuring = -1, this.measure();
      });
    }
  }
  measure() {
    y_e(this.a, this.b, this.chunks), this.revertDOM && this.updateRevertButtons();
  }
  updateRevertButtons() {
    let e = this.revertDOM, t = e.firstChild, i = this.a.viewport, r = this.b.viewport;
    for (let s = 0; s < this.chunks.length; s++) {
      let o = this.chunks[s];
      if (o.fromA > i.to || o.fromB > r.to)
        break;
      if (o.fromA < i.from || o.fromB < r.from)
        continue;
      let l = this.a.lineBlockAt(o.fromA).top + "px";
      for (; t && +t.dataset.chunk < s; )
        t = Vw(t);
      t && t.dataset.chunk == String(s) ? (t.style.top != l && (t.style.top = l), t = t.nextSibling) : e.insertBefore(this.renderRevertButton(l, s), t);
    }
    for (; t; )
      t = Vw(t);
  }
  renderRevertButton(e, t) {
    let i;
    if (this.renderRevert)
      i = this.renderRevert();
    else {
      i = document.createElement("button");
      let r = this.a.state.phrase("Revert this chunk");
      i.setAttribute("aria-label", r), i.setAttribute("title", r), i.textContent = this.revertToLeft ? "\u21DC" : "\u21DD";
    }
    return i.style.top = e, i.setAttribute("data-chunk", String(t)), i;
  }
  revertClicked(e) {
    let t = e.target, i;
    for (; t && t.parentNode != this.revertDOM; )
      t = t.parentNode;
    if (t && (i = this.chunks[t.dataset.chunk])) {
      let [r, s, o, l, a, c] = this.revertToA ? [this.b, this.a, i.fromB, i.toB, i.fromA, i.toA] : [this.a, this.b, i.fromA, i.toA, i.fromB, i.toB], h = r.state.sliceDoc(o, Math.max(o, l - 1));
      o != l && c <= s.state.doc.length && (h += r.state.lineBreak), s.dispatch({
        changes: { from: a, to: Math.min(s.state.doc.length, c), insert: h },
        userEvent: "revert"
      }), e.preventDefault();
    }
  }
  destroy() {
    this.a.destroy(), this.b.destroy(), this.measuring > -1 && (this.dom.ownerDocument.defaultView || window).cancelAnimationFrame(this.measuring), this.dom.remove();
  }
}
function Vw(n) {
  let e = n.nextSibling;
  return n.remove(), e;
}
const A_e = ({
  old: n,
  current: e
}) => {
  let t = [np, I.editable.of(!1), J.readOnly.of(!0)];
  return new C_e({
    a: {
      doc: n,
      extensions: t
    },
    b: {
      doc: e,
      extensions: t
    },
    orientation: "b-a"
  });
}, D_e = ({
  oldText: n,
  text: e
}) => {
  let t = fs(null), i = fs(null), r = fs(null);
  return Cr(() => {
    if (r.current)
      return !1;
    r.current = A_e({
      old: n,
      current: e
    }), t.current.appendChild(r.current.b.dom), i.current.appendChild(r.current.a.dom);
  }, []), yt`
  <div style="display:flex; width: 100%">
    <${wp} ref=${t} $shown=${!0}/>
    <${wp} ref=${i} $shown=${!0}/>
  </div>`;
}, E_e = Ae.div`
  display: flex;
  flex-flow: row wrap;
  width: 100%;
`, T_e = Ae.div`
  z-index: 10;
  position: sticky;
  top: 0;
  display: ${(n) => n.$shown ? "flex" : "none"};
  width: 100%;
  height: 60px;
  background-color: var(--gray-900);
  border-bottom: 1px solid var(--gray-600);

  @media print {
    display: none;
  }
`, M_e = Ae.div`
  width: 100%;
  display: flex;
  justify-content: flex-start;
  align-items: center;
  margin-left: 5px;
`, O_e = Ae(No)`
  pointer-events: none; 
  background-color: green; 
  border: none;
  width: fit-content;
`, L_e = Ae.div`
  width: 100%;
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-right: 15px;
`, R_e = Ae.div`
  border-left: 1px solid var(--gray-800);
  height: 40px;
  margin-right: 10px;
  margin-left: 10px;
`, I_e = Ae.div`
  padding: 20px;
  display: flex;
  flex-flow: row wrap;
  width: 100%;
`, B_e = [{
  label: "Source",
  img: "data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 30 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M22 14.3344V15.6663L17 18.1331V16.7394L20.525 15L17 13.2562V11.8669L22 14.3344ZM12 16.7394L8.475 15L12 13.2562V11.8669L7 14.3344V15.6663L12 18.1331V16.7394ZM16.4044 10H15.1056L12.5988 20H13.8944L16.4044 10V10Z' fill='%23FFFFFF'/%3E%3C/svg%3E"
}, {
  label: "Preview",
  img: "data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 30 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M12.7232 13.5185L13.0717 13.6453C13.364 13.7516 13.6059 13.4674 13.5201 13.2249L13.394 12.8684C13.1324 13.0434 12.905 13.264 12.7232 13.5185ZM5.3783 14.1143L6.20344 14.6793L5.36684 15.2271L5 14.6669L5.3783 14.1143ZM23.4976 14.6793C23.4976 14.6793 20.4337 20 14.8613 20C9.68749 20 6.20344 14.6793 6.20344 14.6793C6.20344 14.6793 9.40718 10 14.8613 10C20.4056 10 23.4976 14.6793 23.4976 14.6793ZM23.4976 14.6793C24.3642 15.1783 24.364 15.1787 24.3638 15.179L24.3633 15.1799L24.3621 15.182L24.3588 15.1875L24.3489 15.2044C24.3407 15.2182 24.3295 15.2369 24.3153 15.2603C24.2867 15.3069 24.246 15.3722 24.1933 15.4533C24.0878 15.6154 23.9336 15.8417 23.7316 16.1109C23.3288 16.6477 22.7301 17.3626 21.9419 18.0794C20.3721 19.5072 17.9836 21 14.8613 21C11.9278 21 9.5357 19.4963 7.93308 18.0917C7.12296 17.3817 6.48766 16.6739 6.05421 16.1433C5.83691 15.8773 5.66881 15.6539 5.55335 15.4945C5.49559 15.4147 5.45088 15.3508 5.41968 15.3054C5.40407 15.2827 5.39183 15.2646 5.38301 15.2514L5.37234 15.2355L5.36894 15.2303L5.36773 15.2285L5.36724 15.2277C5.36703 15.2274 5.36684 15.2271 6.20344 14.6793C5.3783 14.1143 5.37853 14.114 5.37878 14.1137L5.37933 14.1129L5.38065 14.1109L5.38421 14.1058L5.39489 14.0905C5.40361 14.0781 5.41551 14.0614 5.43057 14.0406C5.46067 13.9989 5.50343 13.941 5.55862 13.8692C5.66894 13.7255 5.82936 13.5255 6.03813 13.288C6.45474 12.814 7.06911 12.1846 7.86767 11.5546C9.45985 10.2984 11.8369 9 14.8613 9C17.9286 9 20.3014 10.2965 21.8823 11.558C22.6741 12.1898 23.2783 12.8211 23.6867 13.2969C23.8913 13.5353 24.048 13.7361 24.1557 13.8806C24.2095 13.9528 24.2513 14.0111 24.2806 14.0531C24.2954 14.0741 24.307 14.091 24.3155 14.1036L24.326 14.1192L24.3296 14.1244L24.3309 14.1264L24.3314 14.1273C24.3317 14.1276 24.3319 14.128 23.4976 14.6793ZM23.4976 14.6793L24.3319 14.128L24.6724 14.6432L24.3642 15.1783L23.4976 14.6793ZM15.5108 12.959C16.3818 13.2357 17.0123 14.0453 17.0123 15C17.0123 16.1836 16.0445 17.1429 14.8505 17.1429C13.8785 17.1429 13.0565 16.5071 12.7844 15.6322C12.7222 15.4324 12.6888 15.2201 12.6888 15C12.6888 14.8579 12.7032 14.7193 12.7298 14.585C12.8702 14.6361 13.0104 14.6627 13.147 14.6678C13.8935 14.6961 14.535 14.0861 14.541 13.3486C14.5422 13.2 14.5176 13.0462 14.4628 12.8914C14.5882 12.87 14.7179 12.8571 14.8505 12.8571C15.0808 12.8571 15.3027 12.8929 15.5108 12.959ZM11.2476 15C11.2476 16.9729 12.861 18.5714 14.8505 18.5714C16.8408 18.5714 18.4535 16.9729 18.4535 15C18.4535 13.0279 16.8408 11.4286 14.8505 11.4286C12.861 11.4286 11.2476 13.0279 11.2476 15Z' fill='%23FFFFFF'/%3E%3C/svg%3E%0A"
}, {
  label: "Both",
  img: "data:image/svg+xml,%3Csvg width='22' height='17' viewBox='0 0 22 17' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M2.66667 0.666667H10.5338V15.5109H2.66667C1.5621 15.5109 0.666667 14.6154 0.666667 13.5109V2.66667C0.666667 1.5621 1.5621 0.666667 2.66667 0.666667Z' stroke='white' stroke-width='1.33333'/%3E%3Cpath d='M10.8001 0.666667H18.6673C19.7718 0.666667 20.6673 1.5621 20.6673 2.66667V13.5109C20.6673 14.6154 19.7718 15.5109 18.6673 15.5109H10.8001V0.666667Z' stroke='white' stroke-width='1.33333'/%3E%3C/svg%3E%0A"
}, {
  label: "Diff",
  img: "data:image/svg+xml,%3Csvg width='22' height='17' viewBox='-2 0 20 15' fill='white' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M4.207 15.061L1 11.854v-.707L4.207 7.94l.707.707-2.353 2.354H15v1H2.56l2.354 2.353-.707.707zm7.586-7L15 4.854v-.707L11.793.94l-.707.707L13.439 4H1v1h12.44l-2.354 2.354.707.707z' stroke='white' stroke-width='0.3'/%3E%3C/svg%3E%0A"
}], N_e = [{
  label: "Copy HTML",
  img: "data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 -3 25 30' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M9 2h7v4h4v10h-3v1h4V4.6L17.4 1H8v5h1zm8 0h.31L20 4.69V5h-3zM5 19h7v1H5zm-2 4h13V10.6L12.4 7H3zm9-15h.31L15 10.69V11h-3zM4 8h7v4h4v10H4zm1 5h9v1H5zm4 3h5v1H5v-1z' fill='%23FFFFFF'/%3E%3C/svg%3E"
}], P_e = (n) => {
  const e = (t, i, r) => {
    t.type == "rule" && (t.props[0] = t.props[0].split(",").map((s) => `${n} ${s}`).join(","));
  };
  return Object.defineProperty(e, "name", {
    value: `scope-${n}`
  }), e;
};
function F_e(n) {
  function e(t) {
    t.clipboardData.setData("text/html", n), t.clipboardData.setData("text/plain", n), t.preventDefault();
  }
  document.addEventListener("copy", e), document.execCommand("copy"), document.removeEventListener("copy", e);
}
const z_e = ({
  name: n = "myst_editor_textarea",
  id: e = "myst_editor_textarea",
  initialMode: t = "Both",
  initialText: i = "",
  printCallback: r = window.print,
  topbar: s = !0,
  templatelist: o,
  collaboration: l = {}
}) => {
  const [a, c] = ht(t), [h, u] = ht(i), [f, d] = ht(null), [p, g] = ht(!1), m = (k) => cL.sanitize(ude({
    breaks: !0,
    linkify: !0
  }).use(IO).render(k)), b = (k, w) => {
    d(k), setTimeout(() => d(null), w * 1e3);
  }, y = () => {
    F_e(m(h)), b("copied!", 2);
  };
  return yt`
  <div id="myst-css-namespace">
    <${lE} stylisPlugins=${[P_e("#myst-css-namespace")]}>
      <${E_e}>
        <${T_e} $shown=${s}>
          <${M_e}> 
            <${R1} buttons=${N_e} highlightActive=${!1} clickCallback=${() => y()}/>
            ${f && yt`<${O_e}> ${f} <//>`}
          <//>
          <${L_e}>
            <${No} type="button" onClick=${(k) => r(k)}>Export as PDF<//>
            <${_xe} templatelist=${o} setText=${u} setSyncText=${g}/>
            <${R_e} />
            <${R1} buttons=${B_e} clickedId=${2} clickCallback=${(k) => c(k)}/>
          <//>
        <//>
        <${I_e}>
          <${uxe} text=${h} setText=${u} syncText=${p} setSyncText=${g} name=${n} id=${e} shown=${a === "Both" || a === "Source"} collaboration=${l}/>
          <${Sxe} $shown=${a === "Both" || a === "Preview"} dangerouslySetInnerHTML=${{
    __html: m(h)
  }}/>
          <${a == "Diff" && D_e} oldText=${i} text=${h}/>
        <//>
      <//>
    <//>
  </div>`;
};
export {
  z_e as default,
  yt as html,
  jo as render
};
